(******************************************************************************
 *                                  PasRISCV                                  *
 ******************************************************************************
 *                        Version 2025-06-23-17-44-0000                       *
 ******************************************************************************
 *                                zlib license                                *
 *============================================================================*
 *                                                                            *
 * Copyright (C) 2024-2025, Benjamin Rosseaux (benjamin@rosseaux.de)          *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 *                                                                            *
 *****************************************************************************)
unit PasRISCV;
{$ifdef fpc}
 {$mode delphi}
 {$ifdef cpui386}
  {$define cpu386}
 {$endif}
 {$ifdef cpu386}
  {$asmmode intel}
 {$endif}
 {$ifdef cpuamd64}
  {$asmmode intel}
 {$endif}
 {$ifdef FPC_LITTLE_ENDIAN}
  {$define LITTLE_ENDIAN}
 {$else}
  {$ifdef FPC_BIG_ENDIAN}
   {$define BIG_ENDIAN}
  {$endif}
 {$endif}
 {-$pic off}
 {$ifdef fpc_has_internal_sar}
  {$define HasSAR}
 {$endif}
 {$ifdef FPC_HAS_TYPE_EXTENDED}
  {$define HAS_TYPE_EXTENDED}
 {$else}
  {$undef HAS_TYPE_EXTENDED}
 {$endif}
 {$ifdef FPC_HAS_TYPE_DOUBLE}
  {$define HAS_TYPE_DOUBLE}
 {$else}
  {$undef HAS_TYPE_DOUBLE}
 {$endif}
 {$ifdef FPC_HAS_TYPE_SINGLE}
  {$define HAS_TYPE_SINGLE}
 {$else}
  {$undef HAS_TYPE_SINGLE}
 {$endif}
 {$define CAN_INLINE}
 {$define HAS_ADVANCED_RECORDS}
{$else}
 {$realcompatibility off}
 {$localsymbols on}
 {$define LITTLE_ENDIAN}
 {$ifndef cpu64}
  {$define cpu32}
 {$endif}
 {$define HAS_TYPE_EXTENDED}
 {$define HAS_TYPE_DOUBLE}
 {$define HAS_TYPE_SINGLE}
 {$undef CAN_INLINE}
 {$undef HAS_ADVANCED_RECORDS}
 {$ifndef BCB}
  {$ifdef ver120}
   {$define Delphi4or5}
  {$endif}
  {$ifdef ver130}
   {$define Delphi4or5}
  {$endif}
  {$ifdef ver140}
   {$define Delphi6}
  {$endif}
  {$ifdef ver150}
   {$define Delphi7}
  {$endif}
  {$ifdef ver170}
   {$define Delphi2005}
  {$endif}
 {$else}
  {$ifdef ver120}
   {$define Delphi4or5}
   {$define BCB4}
  {$endif}
  {$ifdef ver130}
   {$define Delphi4or5}
  {$endif}
 {$endif}
 {$ifdef conditionalexpressions}
  {$if CompilerVersion>=24.0}
   {$legacyifend on}
  {$ifend}
  {$if CompilerVersion>=14.0}
   {$if CompilerVersion=14.0}
    {$define Delphi6}
   {$ifend}
   {$define Delphi6AndUp}
  {$ifend}
  {$if CompilerVersion>=15.0}
   {$if CompilerVersion=15.0}
    {$define Delphi7}
   {$ifend}
   {$define Delphi7AndUp}
  {$ifend}
  {$if CompilerVersion>=17.0}
   {$if CompilerVersion=17.0}
    {$define Delphi2005}
   {$ifend}
   {$define Delphi2005AndUp}
  {$ifend}
  {$if CompilerVersion>=18.0}
   {$if CompilerVersion=18.0}
    {$define BDS2006}
    {$define Delphi2006}
   {$ifend}
   {$define Delphi2006AndUp}
   {$define CAN_INLINE}
   {$define HAS_ADVANCED_RECORDS}
  {$ifend}
  {$if CompilerVersion>=18.5}
   {$if CompilerVersion=18.5}
    {$define Delphi2007}
   {$ifend}
   {$define Delphi2007AndUp}
  {$ifend}
  {$if CompilerVersion=19.0}
   {$define Delphi2007Net}
  {$ifend}
  {$if CompilerVersion>=20.0}
   {$if CompilerVersion=20.0}
    {$define Delphi2009}
   {$ifend}
   {$define Delphi2009AndUp}
  {$ifend}
  {$if CompilerVersion>=21.0}
   {$if CompilerVersion=21.0}
    {$define Delphi2010}
   {$ifend}
   {$define Delphi2010AndUp}
  {$ifend}
  {$if CompilerVersion>=22.0}
   {$if CompilerVersion=22.0}
    {$define DelphiXE}
   {$ifend}
   {$define DelphiXEAndUp}
  {$ifend}
  {$if CompilerVersion>=23.0}
   {$if CompilerVersion=23.0}
    {$define DelphiXE2}
   {$ifend}
   {$define DelphiXE2AndUp}
  {$ifend}
  {$if CompilerVersion>=24.0}
   {$legacyifend on}
   {$if CompilerVersion=24.0}
    {$define DelphiXE3}
   {$ifend}
   {$define DelphiXE3AndUp}
  {$ifend}
  {$if CompilerVersion>=25.0}
   {$if CompilerVersion=25.0}
    {$define DelphiXE4}
   {$ifend}
   {$define DelphiXE4AndUp}
  {$ifend}
  {$if CompilerVersion>=26.0}
   {$if CompilerVersion=26.0}
    {$define DelphiXE5}
   {$ifend}
   {$define DelphiXE5AndUp}
  {$ifend}
  {$if CompilerVersion>=27.0}
   {$if CompilerVersion=27.0}
    {$define DelphiXE6}
   {$ifend}
   {$define DelphiXE6AndUp}
  {$ifend}
  {$if CompilerVersion>=28.0}
   {$if CompilerVersion=28.0}
    {$define DelphiXE7}
   {$ifend}
   {$define DelphiXE7AndUp}
  {$ifend}
  {$if CompilerVersion>=29.0}
   {$if CompilerVersion=29.0}
    {$define DelphiXE8}
   {$ifend}
   {$define DelphiXE8AndUp}
  {$ifend}
  {$if CompilerVersion>=30.0}
   {$if CompilerVersion=30.0}
    {$define Delphi10Seattle}
   {$ifend}
   {$define Delphi10SeattleAndUp}
  {$ifend}
  {$if CompilerVersion>=31.0}
   {$if CompilerVersion=31.0}
    {$define Delphi10Berlin}
   {$ifend}
   {$define Delphi10BerlinAndUp}
  {$ifend}
 {$endif}
 {$ifndef Delphi4or5}
  {$ifndef BCB}
   {$define Delphi6AndUp}
  {$endif}
   {$ifndef Delphi6}
    {$define BCB6OrDelphi7AndUp}
    {$ifndef BCB}
     {$define Delphi7AndUp}
    {$endif}
    {$ifndef BCB}
     {$ifndef Delphi7}
      {$ifndef Delphi2005}
       {$define BDS2006AndUp}
      {$endif}
     {$endif}
    {$endif}
   {$endif}
 {$endif}
 {$ifdef Delphi6AndUp}
  {$warn symbol_platform off}
  {$warn symbol_deprecated off}
 {$endif}
{$endif}
{$if defined(Win32) or defined(Win64)}
 {$define Windows}
{$ifend}
{$rangechecks off}
{$extendedsyntax on}
{$writeableconst on}
{$hints off}
{$booleval off}
{$typedaddress off}
{$stackframes off}
{$varstringchecks on}
{$typeinfo on}
{$overflowchecks off}
{$longstrings on}
{$openstrings on}
{$ifndef HAS_TYPE_SINGLE}
 {$error No single floating point precision}
{$endif}
{$ifndef HAS_TYPE_DOUBLE}
 {$error No double floating point precision}
{$endif}
{$scopedenums on}
{$ifndef fpc}
 {$ifdef conditionalexpressions}
  {$if CompilerVersion>=24.0}
   {$legacyifend on}
  {$ifend}
 {$endif}
{$endif}

{$undef ExplicitEnforceZeroRegister}
{$define UseExtraShAmt}
{$define CombinedDirectAccessTLBCache}
{$define UseSpecializedRegisterLoadStores}
{$undef Use16BitSplittedInstructionFetches}
{$undef PreferDirectMemoryAccess}
{$undef FrameBufferDeviceDirtyMarking}

{-$define PasRISCVDebugVirtIO9P}

{$if defined(fpc) and (defined(cpux86_64) or defined(cpuamd64))}
 {$optimization level3}
{$ifend}

(*{$ifdef fpc}
 {$codealign jump=16}
 {$codealign loop=16}
 {$codealign proc=16}
{$endif}//*)

{$define NewPCI}

{$define NVMELevelTriggeredPCIEInterrupts}

//{$define PasRISCVCPUFileDumpDebug}

interface

uses {$if defined(Posix) and not defined(fpc)}
      // Delphi: Linux, Android, Darwin (MacOS, iOS)
      Posix.Base,
      Posix.NetDB,
      Posix.NetIf,
      Posix.NetinetIn,
      Posix.NetinetIp6,
      Posix.NetinetTCP,
      Posix.NetinetUDP,
      Posix.StrOpts,
      Posix.SysSelect,
      Posix.SysSocket,
      Posix.SysTime,
      Posix.SysTimes,
      Posix.SysTypes,
      Posix.SysWait,
      Posix.Termios,
      Posix.Errno,
      Posix.Fcntl,
      Posix.Unistd,
      Posix.Time,
      System.Net.Socket,
      {$ifdef Linux}
       Linuxapi.KernelIoctl,
      {$endif}
      {$if defined(Android) and defined(RNL_DEBUG)}
       Androidapi.Log,
      {$ifend}
     {$elseif defined(fpc) and defined(Unix)}
      // FreePascal: Unix, Linux, Android, Darwin (MacOS, iOS)
      ctypes,
      BaseUnix,
      Unix,
      UnixType,
      Sockets,
      {$if not defined(Darwin)}
       cnetdb,
      {$ifend}
      {$if defined(PasRISCVUseRealConsole)}
       termio,
      {$ifend}
      {$if defined(linux) or defined(android)}
       linux,
      {$ifend}
     {$elseif defined(Windows)}
      // Delphi and FreePascal: Win32, Win64
      Windows,
      MMSystem,
      {$ifdef fpc}
       jwaIpTypes,
       JwaIpHlpApi,
      {$else}
       Winapi.IpTypes,
       Winapi.IpHlpApi,
      {$endif}
      {$if defined(PasRISCVUseRealConsole)}
       CRT,
      {$ifend}
     {$ifend}
     SysUtils,
     Classes,
     Math,
     DateUtils,
{$if defined(fpc)}
     // FreePascal
{$if defined(Linux) or defined(Android)}
     zlib,
{$ifend}
{$else}
     // Delphi
     System.ZLIB,
{$ifend}
     SyncObjs,
     PasMP,
     RNL;

type PPPasRISCVInt8=^PPasRISCVInt8;
     PPasRISCVInt8=^TPasRISCVInt8;
     TPasRISCVInt8={$ifdef fpc}Int8{$else}shortint{$endif};

     TPasRISCVInt8Array=array[0..65535] of TPasRISCVInt8;
     PPasRISCVInt8Array=^TPasRISCVInt8Array;

     PPPasRISCVUInt8=^PPasRISCVUInt8;
     PPasRISCVUInt8=^TPasRISCVUInt8;
     TPasRISCVUInt8={$ifdef fpc}UInt8{$else}byte{$endif};

     PPPasRISCVUInt8Array=^PPasRISCVUInt8Array;
     PPasRISCVUInt8Array=^TPasRISCVUInt8Array;
     TPasRISCVUInt8Array=array[0..65535] of TPasRISCVUInt8;

     TPasRISCVUInt8DynamicArray=array of TPasRISCVUInt8;

     PPPasRISCVInt16=^PPasRISCVInt16;
     PPasRISCVInt16=^TPasRISCVInt16;
     TPasRISCVInt16={$ifdef fpc}Int16{$else}smallint{$endif};

     TPasRISCVInt16Array=array[0..65535] of TPasRISCVInt16;
     PPasRISCVInt16Array=^TPasRISCVInt16Array;

     PPPasRISCVUInt16=^PPasRISCVUInt16;
     PPasRISCVUInt16=^TPasRISCVUInt16;
     TPasRISCVUInt16={$ifdef fpc}UInt16{$else}word{$endif};

     TPasRISCVUInt16Array=array[0..65535] of TPasRISCVUInt16;
     PPasRISCVUInt16Array=^TPasRISCVUInt16Array;

     PPPasRISCVInt32=^PPasRISCVInt32;
     PPasRISCVInt32=^TPasRISCVInt32;
     TPasRISCVInt32={$ifdef fpc}Int32{$else}longint{$endif};

     TPasRISCVInt32Array=array[0..65535] of TPasRISCVInt32;
     PPasRISCVInt32Array=^TPasRISCVInt32Array;

     PPPasRISCVUInt32=^PPasRISCVUInt32;
     PPasRISCVUInt32=^TPasRISCVUInt32;
     TPasRISCVUInt32={$ifdef fpc}UInt32{$else}longword{$endif};

     PPPasRISCVUInt32rray=^PPasRISCVUInt32Array;
     PPasRISCVUInt32Array=^TPasRISCVUInt32Array;
     TPasRISCVUInt32Array=array[0..65535] of TPasRISCVUInt32;

     TPasRISCVUInt32DynamicArray=array of TPasRISCVUInt32;

     PPPasRISCVInt64=^PPasRISCVInt64;
     PPasRISCVInt64=^TPasRISCVInt64;
     TPasRISCVInt64=Int64;

     TPasRISCVInt64Array=array[0..65535] of TPasRISCVInt64;
     PPasRISCVInt64Array=^TPasRISCVInt64Array;

     PPPasRISCVUInt64=^PPasRISCVUInt64;
     PPasRISCVUInt64=^TPasRISCVUInt64;
     TPasRISCVUInt64=UInt64;

     TPasRISCVUInt64Array=array[0..65535] of TPasRISCVUInt64;
     PPasRISCVUInt64Array=^TPasRISCVUInt64Array;

     PPPasRISCVChar=^PAnsiChar;
     PPasRISCVChar=PAnsiChar;
     TPasRISCVChar=AnsiChar;

     PPPasRISCVRawByteChar=^PAnsiChar;
     PPasRISCVRawByteChar=PAnsiChar;
     TPasRISCVRawByteChar=AnsiChar;

     PPPasRISCVUTF16Char=^PWideChar;
     PPasRISCVUTF16Char=PWideChar;
     TPasRISCVUTF16Char=WideChar;

     PPPasRISCVPointer=^PPasRISCVPointer;
     PPasRISCVPointer=^TPasRISCVPointer;
     TPasRISCVPointer=Pointer;

     PPPasRISCVPointers=^PPasRISCVPointers;
     PPasRISCVPointers=^TPasRISCVPointers;
     TPasRISCVPointers=array[0..65535] of TPasRISCVPointer;

     PPPasRISCVVoid=^PPasRISCVVoid;
     PPasRISCVVoid=TPasRISCVPointer;

     PPPasRISCVFloat=^PPasRISCVFloat;
     PPasRISCVFloat=^TPasRISCVFloat;
     TPasRISCVFloat=Single;

     TPasRISCVFloats=array of TPasRISCVFloat;

     TPasRISCVFloatDynamicArray=array of TPasRISCVFloat;

     TPasRISCVFloatArray=array[0..65535] of TPasRISCVFloat;
     PPasRISCVFloatArray=^TPasRISCVFloatArray;

     PPPasRISCVDouble=^PPasRISCVDouble;
     PPasRISCVDouble=^TPasRISCVDouble;
     TPasRISCVDouble=Double;

     TPasRISCVDoubleArray=array[0..65535] of TPasRISCVDouble;
     PPasRISCVDoubleArray=^TPasRISCVDoubleArray;

     PPPasRISCVPtrUInt=^PPasRISCVPtrUInt;
     PPPasRISCVPtrInt=^PPasRISCVPtrInt;
     PPasRISCVPtrUInt=^TPasRISCVPtrUInt;
     PPasRISCVPtrInt=^TPasRISCVPtrInt;
{$ifdef fpc}
     TPasRISCVPtrUInt=PtrUInt;
     TPasRISCVPtrInt=PtrInt;
 {$undef OldDelphi}
{$else}
 {$ifdef conditionalexpressions}
  {$if CompilerVersion>=23.0}
   {$undef OldDelphi}
     TPasRISCVPtrUInt=NativeUInt;
     TPasRISCVPtrInt=NativeInt;
  {$else}
   {$define OldDelphi}
  {$ifend}
 {$else}
  {$define OldDelphi}
 {$endif}
{$endif}
{$ifdef OldDelphi}
{$ifdef cpu64}
     TPasRISCVPtrUInt=uint64;
     TPasRISCVPtrInt=int64;
{$else}
     TPasRISCVPtrUInt=longword;
     TPasRISCVPtrInt=longint;
{$endif}
{$endif}

     PPPasRISCVSizeUInt=^PPasRISCVSizeUInt;
     PPasRISCVSizeUInt=^TPasRISCVSizeUInt;
     TPasRISCVSizeUInt=TPasRISCVPtrUInt;

     PPPasRISCVSizeInt=^PPasRISCVSizeInt;
     PPasRISCVSizeInt=^TPasRISCVSizeInt;
     TPasRISCVSizeInt=TPasRISCVPtrInt;

     PPPasRISCVNativeUInt=^PPasRISCVNativeUInt;
     PPasRISCVNativeUInt=^TPasRISCVNativeUInt;
     TPasRISCVNativeUInt=TPasRISCVPtrUInt;

     PPPasRISCVNativeInt=^PPasRISCVNativeInt;
     PPasRISCVNativeInt=^TPasRISCVNativeInt;
     TPasRISCVNativeInt=TPasRISCVPtrInt;

     PPPasRISCVSize=^PPasRISCVSizeUInt;
     PPasRISCVSize=^TPasRISCVSizeUInt;
     TPasRISCVSize=TPasRISCVPtrUInt;

     PPPasRISCVPtrDiff=^PPasRISCVPtrDiff;
     PPasRISCVPtrDiff=^TPasRISCVPtrDiff;
     TPasRISCVPtrDiff=TPasRISCVPtrInt;

     PPPasRISCVRawByteString=^PPasRISCVRawByteString;
     PPasRISCVRawByteString=^TPasRISCVRawByteString;
     TPasRISCVRawByteString={$if declared(RawByteString)}RawByteString{$else}AnsiString{$ifend};

     PPPasRISCVUTF8String=^PPasRISCVUTF8String;
     PPasRISCVUTF8String=^TPasRISCVUTF8String;
     TPasRISCVUTF8String={$if declared(UTF8String)}UTF8String{$else}AnsiString{$ifend};

     PPPasRISCVUTF16String=^PPasRISCVUTF16String;
     PPasRISCVUTF16String=^TPasRISCVUTF16String;
     TPasRISCVUTF16String={$if declared(UnicodeString)}UnicodeString{$else}WideString{$ifend};

     TPasRISCVFPType=
      (
       Infinite,
       QuietNaN,
       SignalingNaN,
       Normal,
       Subnormal,
       Zero
      );

     EPasRISCV=class(Exception);

     { TPasRISCVDynamicQueue<T> }
     TPasRISCVDynamicQueue<T>=record
      public
       type TQueueItems=array of T;
      public
       Items:TQueueItems;
       Head:TPasRISCVSizeInt;
       Tail:TPasRISCVSizeInt;
       Count:TPasRISCVSizeInt;
       Size:TPasRISCVSizeInt;
       procedure Initialize;
       procedure Finalize;
       procedure GrowResize(const aSize:TPasRISCVSizeInt);
       procedure Clear;
       function IsEmpty:boolean;
       procedure EnqueueAtFront(const aItem:T);
       procedure Enqueue(const aItem:T);
       function Dequeue(out aItem:T):boolean; overload;
       function Dequeue:boolean; overload;
       function Peek(out aItem:T):boolean;
     end;

     { TPasRISCVThreadSafeDynamicQueue<T> }
     TPasRISCVThreadSafeDynamicQueue<T>=class
      public
       type TQueueItems=array of T;
      private
       fLock:TPasMPSlimReaderWriterLock;
       fItems:TQueueItems;
       fHead:TPasRISCVSizeInt;
       fTail:TPasRISCVSizeInt;
       fCount:TPasRISCVSizeInt;
       fSize:TPasRISCVSizeInt;
      public
       constructor Create; reintroduce;
       destructor Destroy; override;
       procedure GrowResize(const aSize:TPasRISCVSizeInt);
       procedure Clear;
       function IsEmpty:boolean;
       procedure EnqueueAtFront(const aItem:T);
       procedure Enqueue(const aItem:T);
       function Dequeue(out aItem:T):boolean; overload;
       function Dequeue:boolean; overload;
       function TryDequeue(out aItem:T):boolean; overload;
       function TryDequeue:boolean; overload;
       function Peek(out aItem:T):boolean;
     end;

     TPasRISCVHashMapEntityIndices=array of TPasRISCVInt32;

     TPasRISCVHashMapUInt128=array[0..1] of TPasRISCVUInt64;

     { TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue> }
     TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>=class
      public
       type TEntity=record
             public
              const Empty=0;
                    Deleted=1;
                    Used=2;
             public
              State:TPasRISCVUInt32;
              Key:TPasRISCVHashMapKey;
              Value:TPasRISCVHashMapValue;
            end;
            PEntity=^TEntity;
            TEntities=array of TEntity;
      private
       type TEntityEnumerator=record
             private
              fHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>;
              fIndex:TPasRISCVSizeInt;
              function GetCurrent:TEntity; inline;
             public
              constructor Create(const aHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
              function MoveNext:boolean; inline;
              property Current:TEntity read GetCurrent;
            end;
            TKeyEnumerator=record
             private
              fHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>;
              fIndex:TPasRISCVSizeInt;
              function GetCurrent:TPasRISCVHashMapKey; inline;
             public
              constructor Create(const aHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
              function MoveNext:boolean; inline;
              property Current:TPasRISCVHashMapKey read GetCurrent;
            end;
            TPasRISCVHashMapValueEnumerator=record
             private
              fHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>;
              fIndex:TPasRISCVSizeInt;
              function GetCurrent:TPasRISCVHashMapValue; inline;
             public
              constructor Create(const aHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
              function MoveNext:boolean; inline;
              property Current:TPasRISCVHashMapValue read GetCurrent;
            end;
            TEntitiesObject=class
             private
              fOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>;
             public
              constructor Create(const aOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
              function GetEnumerator:TEntityEnumerator;
            end;
            TKeysObject=class
             private
              fOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>;
             public
              constructor Create(const aOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
              function GetEnumerator:TKeyEnumerator;
            end;
            TValuesObject=class
             private
              fOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>;
              function GetValue(const aKey:TPasRISCVHashMapKey):TPasRISCVHashMapValue; inline;
              procedure SetValue(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue); inline;
             public
              constructor Create(const aOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
              function GetEnumerator:TPasRISCVHashMapValueEnumerator;
              property Values[const Key:TPasRISCVHashMapKey]:TPasRISCVHashMapValue read GetValue write SetValue; default;
            end;
      private
       fSize:TPasRISCVSizeUInt;
       fLogSize:TPasRISCVSizeUInt;
       fCountNonEmptyEntites:TPasRISCVSizeUInt;
       fCountDeletedEntites:TPasRISCVSizeUInt;
       fEntities:TEntities;
       fDefaultValue:TPasRISCVHashMapValue;
       fCanShrink:boolean;
       fEntitiesObject:TEntitiesObject;
       fKeysObject:TKeysObject;
       fValuesObject:TValuesObject;
       function HashData(const aData:TPasRISCVPointer;const aDataLength:TPasRISCVUInt32):TPasRISCVUInt32;
       function HashKey(const aKey:TPasRISCVHashMapKey):TPasRISCVUInt32;
       function CompareKey(const aKeyA,aKeyB:TPasRISCVHashMapKey):boolean;
       function FindEntity(const aKey:TPasRISCVHashMapKey):PEntity;
       function FindEntityForAdd(const aKey:TPasRISCVHashMapKey):PEntity;
       procedure Resize;
      protected
       function GetValue(const aKey:TPasRISCVHashMapKey):TPasRISCVHashMapValue;
       procedure SetValue(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue);
      public
       constructor Create(const aDefaultValue:TPasRISCVHashMapValue);
       destructor Destroy; override;
       procedure Clear(const aCanFree:Boolean=true);
       function Add(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue):PEntity;
       function Get(const aKey:TPasRISCVHashMapKey;const aCreateIfNotExist:boolean=false):PEntity;
       function TryGet(const aKey:TPasRISCVHashMapKey;out aValue:TPasRISCVHashMapValue):boolean;
       function ExistKey(const aKey:TPasRISCVHashMapKey):boolean;
       function Delete(const aKey:TPasRISCVHashMapKey):boolean;
       property EntityValues[const Key:TPasRISCVHashMapKey]:TPasRISCVHashMapValue read GetValue write SetValue; default;
       property Entities:TEntitiesObject read fEntitiesObject;
       property Keys:TKeysObject read fKeysObject;
       property Values:TValuesObject read fValuesObject;
       property CanShrink:boolean read fCanShrink write fCanShrink;
     end;

{$ifdef ExtraStringHashMap}
     { TPasRISCVStringHashMap<TPasRISCVHashMapValue> }
     TPasRISCVStringHashMap<TPasRISCVHashMapValue>=class
      private
       type TPasRISCVHashMapKey=RawByteString;
            TEntity=record
             public
              const Empty=0;
                    Deleted=1;
                    Used=2;
             public
              State:TPasRISCVUInt32;
              Key:TPasRISCVHashMapKey;
              Value:TPasRISCVHashMapValue;
            end;
            PEntity=^TEntity;
            TEntities=array of TEntity;
      private
       type TEntityEnumerator=record
             private
              fHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>;
              fIndex:TPasRISCVSizeInt;
              function GetCurrent:TEntity; inline;
             public
              constructor Create(const aHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
              function MoveNext:boolean; inline;
              property Current:TEntity read GetCurrent;
            end;
            TKeyEnumerator=record
             private
              fHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>;
              fIndex:TPasRISCVSizeInt;
              function GetCurrent:TPasRISCVHashMapKey; inline;
             public
              constructor Create(const aHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
              function MoveNext:boolean; inline;
              property Current:TPasRISCVHashMapKey read GetCurrent;
            end;
            TPasRISCVHashMapValueEnumerator=record
             private
              fHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>;
              fIndex:TPasRISCVSizeInt;
              function GetCurrent:TPasRISCVHashMapValue; inline;
             public
              constructor Create(const aHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
              function MoveNext:boolean; inline;
              property Current:TPasRISCVHashMapValue read GetCurrent;
            end;
            TEntitiesObject=class
             private
              fOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>;
             public
              constructor Create(const aOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
              function GetEnumerator:TEntityEnumerator;
            end;
            TKeysObject=class
             private
              fOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>;
             public
              constructor Create(const aOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
              function GetEnumerator:TKeyEnumerator;
            end;
            TValuesObject=class
             private
              fOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>;
              function GetValue(const aKey:TPasRISCVHashMapKey):TPasRISCVHashMapValue; inline;
              procedure SetValue(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue); inline;
             public
              constructor Create(const aOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
              function GetEnumerator:TPasRISCVHashMapValueEnumerator;
              property Values[const Key:TPasRISCVHashMapKey]:TPasRISCVHashMapValue read GetValue write SetValue; default;
            end;
      private
       fSize:TPasRISCVSizeUInt;
       fLogSize:TPasRISCVSizeUInt;
       fCountNonEmptyEntites:TPasRISCVSizeUInt;
       fCountDeletedEntites:TPasRISCVSizeUInt;
       fEntities:TEntities;
       fDefaultValue:TPasRISCVHashMapValue;
       fCanShrink:boolean;
       fEntitiesObject:TEntitiesObject;
       fKeysObject:TKeysObject;
       fValuesObject:TValuesObject;
       function HashKey(const aKey:TPasRISCVHashMapKey):TPasRISCVUInt32;
       function FindEntity(const aKey:TPasRISCVHashMapKey):PEntity;
       function FindEntityForAdd(const aKey:TPasRISCVHashMapKey):PEntity;
       procedure Resize;
      protected
       function GetValue(const aKey:TPasRISCVHashMapKey):TPasRISCVHashMapValue;
       procedure SetValue(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue);
      public
       constructor Create(const aDefaultValue:TPasRISCVHashMapValue);
       destructor Destroy; override;
       procedure Clear(const aCanFree:Boolean=true);
       function Add(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue):PEntity;
       function Get(const aKey:TPasRISCVHashMapKey;const aCreateIfNotExist:boolean=false):PEntity;
       function TryGet(const aKey:TPasRISCVHashMapKey;out aValue:TPasRISCVHashMapValue):boolean;
       function ExistKey(const aKey:TPasRISCVHashMapKey):boolean;
       function Delete(const aKey:TPasRISCVHashMapKey):boolean;
       property EntityValues[const Key:TPasRISCVHashMapKey]:TPasRISCVHashMapValue read GetValue write SetValue; default;
       property Entities:TEntitiesObject read fEntitiesObject;
       property Keys:TKeysObject read fKeysObject;
       property Values:TValuesObject read fValuesObject;
       property CanShrink:boolean read fCanShrink write fCanShrink;
     end;
{$else}
     TPasRISCVStringHashMap<TPasRISCVHashMapValue>=class(TPasRISCVHashMap<RawByteString,TPasRISCVHashMapValue>);
{$endif}

     { TPasRISCVFileMappedStream }
     TPasRISCVFileMappedStream=class(TStream)
      public
       const DefaultViewSize=64 shl 20; // 64MB
      private
       fFileHandle:{$ifdef unix}TPasRISCVInt32{$else}hFile{$endif};
{$ifndef unix}
       fMapHandle:{$ifdef unix}Pointer{$else}THandle{$endif};
{$endif}
       fAllocationGranularity:TPasRISCVInt64;
       fMemory:Pointer;
       fReadOnly:Boolean;
       fCurrentViewOffset:TPasRISCVInt64;
       fCurrentViewSize:TPasRISCVInt64;
       fViewSize:TPasRISCVInt64;
       fViewMask:TPasRISCVInt64;
       fPosition:TPasRISCVInt64;
       fSize:TPasRISCVInt64;
       fFileName:String;
{$ifdef unix}
       FTemporary:Boolean;
{$endif}
       procedure CreateMapView;
       procedure UpdateMapView;
       procedure CloseMapView;
      protected
       procedure SetSize(aNewSize:TPasRISCVInt32); overload; override;
       procedure SetSize(const aNewSize:TPasRISCVInt64); overload; override;
      public
       constructor Create(const aFileName:String;aMode:TPasRISCVUInt16;const aMappingWholeFile:Boolean);
       destructor Destroy; override;
       procedure Clear;
       function Flush:Boolean;
       function Read(var aBuffer;aCount:TPasRISCVInt32):TPasRISCVInt32; override;
       function Write(const aBuffer;aCount:TPasRISCVInt32):TPasRISCVInt32; override;
       function Seek(const aOffset:TPasRISCVInt64;aOrigin:TSeekOrigin):TPasRISCVInt64; override;
       property Memory:Pointer read fMemory;
       property MemoryViewOffset:TPasRISCVInt64 read fCurrentViewOffset;
       property MemoryViewSize:TPasRISCVInt64 read fCurrentViewSize;
       property ReadOnly:Boolean read fReadOnly;
     end;

     TPasRISCVAudioWAVFormat=class
      public
       type TWaveSignature=array[1..4] of ansichar;
            TWaveFileHeader=packed record
             Signature:TWaveSignature;
             Size:TPasRISCVUInt32;
             WAVESignature:TWaveSignature;
            end;
            PWaveFileHeader=^TWaveFileHeader;
            TWaveFormatHeader=packed record
             FormatTag:TPasRISCVUInt16;
             Channels:TPasRISCVUInt16;
             SamplesPerSecond:TPasRISCVUInt32;
             AvgBytesPerSecond:TPasRISCVUInt32;
             SampleSize:TPasRISCVUInt16;
             BitsPerSample:TPasRISCVUInt16;
            end;
            PWaveFormatHeader=^TWaveFormatHeader;
            TWaveChunkHeader=packed record
             Signature:TWaveSignature;
             Size:TPasRISCVUInt32;
            end;
            PWaveChunkHeader=^TWaveChunkHeader;
       const RIFFSignature:TWaveSignature=('R','I','F','F');
             WAVESignature:TWaveSignature=('W','A','V','E');
             FMTSignature:TWaveSignature=('f','m','t',' ');
             DATASignature:TWaveSignature=('d','a','t','a');
     end;

     { TPasRISCVAudioWAVStreamDump }
     TPasRISCVAudioWAVStreamDump=class
      private
       fStream:TStream;
       fDoFreeStream:boolean;
       fSampleRate:TPasRISCVInt32;
       fChannels:TPasRISCVInt32;
       fBitsPerSample:TPasRISCVInt32;
       fDataOffset:TPasRISCVInt64;
       fDataSize:TPasRISCVInt64;
       fFileHeaderOffset:TPasRISCVInt64;
       fFormatChunkHeaderOffset:TPasRISCVInt64;
       fDataChunkHeaderOffset:TPasRISCVInt64;
       fWaveFileHeader:TPasRISCVAudioWAVFormat.TWaveFileHeader;
       fWaveFormatChunkHeader:TPasRISCVAudioWAVFormat.TWaveChunkHeader;
       fWaveFormatHeader:TPasRISCVAudioWAVFormat.TWaveFormatHeader;
       fWaveDataChunkHeader:TPasRISCVAudioWAVFormat.TWaveChunkHeader;
       fBufferFloats:TPasRISCVFloatDynamicArray;
      public
       constructor Create(const aSampleRate:TPasRISCVInt32;const aStream:TStream;const aDoFreeStream:boolean=true);
       destructor Destroy; override;
       procedure Flush;
       procedure Dump(const aData:TPasRISCVPointer;const aDataSize:TPasRISCVSizeInt;const aFloat:Boolean);
     end;

     { TPasRISCV9PFileSystem }
     TPasRISCV9PFileSystem=class
      public
       const // FSQID type
             P9_QTDIR=$80;
             P9_QTAPP=$40;
             P9_QTEXCL=$20;
             P9_QTMOUNT=$10;
             P9_QTAUTH=$08;
             P9_QTTMP=$04;
             P9_QTSYMLINK=$02;
             P9_QTLINK=$01;
             P9_QTFILE=$00;

             // Mode Bits
             P9_S_IXOTH=$0001;
             P9_S_IWOTH=$0002;
             P9_S_IROTH=$0004;
             P9_S_IRWXO=$0007;
             P9_S_IXGRP=$0008;
             P9_S_IWGRP=$0010;
             P9_S_IRGRP=$0020;
             P9_S_IRWXG=$0038;
             P9_S_IXUSR=$0040;
             P9_S_IWUSR=$0080;
             P9_S_IRUSR=$0100;
             P9_S_IRWXU=$01c0;
             P9_S_IRWXUGO=$01ff;
             P9_S_IXOGU=P9_S_IXOTH or P9_S_IXGRP or P9_S_IXUSR;
             P9_S_IWOGU=P9_S_IWOTH or P9_S_IWGRP or P9_S_IWUSR;
             P9_S_IROGU=P9_S_IROTH or P9_S_IRGRP or P9_S_IRUSR;
             P9_S_ISVTX=$0200;
             P9_S_ISGID=$0400;
             P9_S_ISUID=$0800;
             P9_S_IFMT=$f000;
             P9_S_IFIFO=$1000;
             P9_S_IFCHR=$2000;
             P9_S_IFDIR=$4000;
             P9_S_IFBLK=$6000;
             P9_S_IFREG=$8000;
             P9_S_IFLNK=$a000;
             P9_S_IFSOCK=$c000;

             // Flags for open/create
             P9_O_RDONLY=$00000000;
             P9_O_WRONLY=$00000001;
             P9_O_RDWR=$00000002;
             P9_O_NOACCESS=$00000003;
             P9_O_CREAT=$00000040;
             P9_O_EXCL=$00000080;
             P9_O_NOCTTY=$00000100;
             P9_O_TRUNC=$00000200;
             P9_O_APPEND=$00000400;
             P9_O_NONBLOCK=$00000800;
             P9_O_DSYNC=$00001000;
             P9_O_FASYNC=$00002000;
             P9_O_DIRECT=$00004000;
             P9_O_LARGEFILE=$00008000;
             P9_O_DIRECTORY=$00010000;
             P9_O_NOFOLLOW=$00020000;
             P9_O_NOATIME=$00040000;
             P9_O_CLOEXEC=$00080000;
             P9_O_SYNC=$00100000;

             // SetAttr flags
             P9_SETATTR_MODE=$00000001;
             P9_SETATTR_UID=$00000002;
             P9_SETATTR_GID=$00000004;
             P9_SETATTR_SIZE=$00000008;
             P9_SETATTR_ATIME=$00000010;
             P9_SETATTR_MTIME=$00000020;
             P9_SETATTR_CTIME=$00000040;
             P9_SETATTR_ATIME_SET=$00000080;
             P9_SETATTR_MTIME_SET=$00000100;

             // Error codes
             P9_EPERM=1;
             P9_ENOENT=2;
             P9_EIO=5;
             P9_EEXIST=17;
             P9_ENOTDIR=20;
             P9_EINVAL=22;
             P9_ENOSPC=28;
             P9_ENOTEMPTY=39;
             P9_EPROTO=71;
             P9_ENOTSUP=524;

             // Lock types
             P9_LOCK_TYPE_RDLCK=0;
             P9_LOCK_TYPE_WRLCK=1;
             P9_LOCK_TYPE_UNLCK=2;

             // Lock flags
             P9_LOCK_FLAGS_BLOCK=1;
             P9_LOCK_FLAGS_RECLAIM=2;

             // Lock codes
             P9_LOCK_SUCCESS=0;
             P9_LOCK_BLOCKED=1;
             P9_LOCK_ERROR=2;
             P9_LOCK_GRACE=3;

             // FSCMD name
             FSCMD_NAME:PAnsiChar='.fscmd';
       type TFSQID=packed record
             Type_:TPasRISCVUInt8;
             Version:TPasRISCVUInt32;
             Path:TPasRISCVUInt64;
            end;
            PFSQID=^TFSQID;
            TFSQIDArray=array[0..65535] of TFSQID;
            PFSQIDArray=^TFSQIDArray;
            TFSStatFS=packed record
             BSize:TPasRISCVUInt32;
             Blocks:TPasRISCVUInt64;
             BFree:TPasRISCVUInt64;
             BAvail:TPasRISCVUInt64;
             Files:TPasRISCVUInt64;
             FFree:TPasRISCVUInt64;
            end;
            PFSStatFS=^TFSStatFS;
            TFSStat=packed record
             QID:TFSQID;
             Mode:TPasRISCVUInt32;
             UID:TPasRISCVUInt32;
             GID:TPasRISCVUInt32;
             NLink:TPasRISCVUInt64;
             RDev:TPasRISCVUInt64;
             Size:TPasRISCVUInt64;
             BlkSize:TPasRISCVUInt64;
             Blocks:TPasRISCVUInt64;
             ATimeSec:TPasRISCVUInt64;
             ATimeNSec:TPasRISCVUInt32;
             MTimeSec:TPasRISCVUInt64;
             MTimeNSec:TPasRISCVUInt32;
             CTimeSec:TPasRISCVUInt64;
             CTimeNSec:TPasRISCVUInt32;
            end;
            PFSStat=^TFSStat;
            TFSLock=packed record
             Type_:TPasRISCVUInt8;
             Flags:TPasRISCVUInt16;
             Start:TPasRISCVUInt64;
             Length:TPasRISCVUInt64;
             ProcID:TPasRISCVUInt32;
             ClientID:PPasRISCVUInt32;
            end;
            PFSLock=^TFSLock;
            TFSFile=class;
            TFSFile=class
             private
              fUID:TPasRISCVUInt32;
              fPath:TPasRISCVRawByteString;
              fIsOpened:TPasMPBool32;
              fIsDirectory:TPasMPBool32;
              fStream:TStream;
{$if defined(fpc) and defined(Unix)}
              fFile:cint;
              fDirectory:PDIR;
{$elseif defined(Windows)}
              fFileHandle:THandle;
              fDirectoryHandle:THandle;
              fIsOverlapped:TPasMPBool32;
{$ifend}
            end;
            TOnOpenCompletion=procedure(const aFileSystem:TPasRISCV9PFileSystem;const aQID:TPasRISCV9PFileSystem.PFSQID;const aError:TPasRISCVUInt32;const aOpaque:Pointer) of object;
      private
       fRootPath:TPasRISCVRawByteString;
      public
       constructor Create; virtual;
       destructor Destroy; override;
       procedure Delete(const aFile:TPasRISCV9PFileSystem.TFSFile); virtual;
       procedure StatFS(out aStatFS:TPasRISCV9PFileSystem.TFSStatFS); virtual;
       function Attach(out aFile:TPasRISCV9PFileSystem.TFSFile;const aQID:TPasRISCV9PFileSystem.PFSQID;const aUID:TPasRISCVUInt32;const aUName,aAName:TPasRISCVRawByteString):TPasRISCVInt32; virtual;
       function Walk(out aFiles:TPasRISCV9PFileSystem.TFSFile;const aQIDs:TPasRISCV9PFileSystem.PFSQIDArray;const aFile:TPasRISCV9PFileSystem.TFSFile;const aCount:TPasRISCVSizeInt;const aNames:array of TPasRISCVRawByteString):TPasRISCVInt32; virtual;
       function MkDir(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32; virtual;
       function Open(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aFlags:TPasRISCVUInt32;const aOnOpenCompletion:TPasRISCV9PFileSystem.TOnOpenCompletion;const aOpaque:Pointer):TPasRISCVInt32; virtual;
       function Create_(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aFlags:TPasRISCVUInt32;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32; virtual;
       function ReadDir(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; virtual;
       function Read(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; virtual;
       function Write(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; virtual;
       procedure Close(const aFile:TPasRISCV9PFileSystem.TFSFile); virtual;
       function Stat(const aFile:TPasRISCV9PFileSystem.TFSFile;out aStat:TPasRISCV9PFileSystem.TFSStat):TPasRISCVInt32; virtual;
       function SetAttr(const aFile:TPasRISCV9PFileSystem.TFSFile;const aMask,aMode,aUID,aGID:TPasRISCVUInt32;const aSize,aATimeSec,aATimeNSec,aMTimeSec,aMTimeNSec,aCTimeSec,aCTimeNSec:TPasRISCVUInt64):TPasRISCVInt32; virtual;
       function Link(const aDestFile,aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32; virtual;
       function SymLink(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName,aTarget:TPasRISCVRawByteString;const aGID:TPasRISCVUInt32):TPasRISCVInt32; virtual;
       function MkNod(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aMajor,aMinor,aGID:TPasRISCVUInt32):TPasRISCVInt32; virtual;
       function ReadLink(const aBuffer:Pointer;const aSize:TPasRISCVInt64;const aFile:TPasRISCV9PFileSystem.TFSFile):TPasRISCVInt64; virtual;
       function RenameAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aNewFile:TPasRISCV9PFileSystem.TFSFile;const aNewName:TPasRISCVRawByteString):TPasRISCVInt32; virtual;
       function UnlinkAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32; virtual;
       function Lock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32; virtual;
       function GetLock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32; virtual;
      public
       property RootPath:TPasRISCVRawByteString read fRootPath write fRootPath;
     end;

{$if defined(fpc) and defined(Unix)}
     { TPasRISCV9PFileSystemPOSIX }
     TPasRISCV9PFileSystemPOSIX=class(TPasRISCV9PFileSystem)
      public
       const DT_UNKNOWN=0;
             DT_FIFO=1;
             DT_CHR=2;
             DT_DIR=4;
             DT_BLK=6;
             DT_REG=8;
             DT_LNK=10;
             DT_SOCK=12;
             DT_WHT=14;
             UTIME_NOW=TPasRISCVUInt32((TPasRISCVUInt32(1) shl 30)-1);
             UTIME_OMIT=TPasRISCVUInt32((TPasRISCVUInt32(1) shl 30)-2);
      private
       function POSIXErrorCodeToP9ErrorCode(const aErrorCode:TPasRISCVInt32):TPasRISCVInt32;
       function P9OpenFlagsToPOSIXOpenFlags(const aFlags:TPasRISCVUInt32):TPasRISCVUInt32;
       procedure StatToQID(const aQID:TPasRISCV9PFileSystem.PFSQID;const aStat:PStat);
       function ComposePath(const aPath,aName:TPasRISCVRawByteString):TPasRISCVRawByteString;
       function CreateFileObject(const aPath:TPasRISCVRawByteString;const aUID:TPasRISCVUInt32):TPasRISCV9PFileSystem.TFSFile;
      public
       constructor Create(const aRootPath:TPasRISCVRawByteString); reintroduce;
       destructor Destroy; override;
       procedure Delete(const aFile:TPasRISCV9PFileSystem.TFSFile); override;
       procedure StatFS(out aStatFS:TPasRISCV9PFileSystem.TFSStatFS); override;
       function Attach(out aFile:TPasRISCV9PFileSystem.TFSFile;const aQID:TPasRISCV9PFileSystem.PFSQID;const aUID:TPasRISCVUInt32;const aUName,aAName:TPasRISCVRawByteString):TPasRISCVInt32; override;
       function Walk(out aFiles:TPasRISCV9PFileSystem.TFSFile;const aQIDs:TPasRISCV9PFileSystem.PFSQIDArray;const aFile:TPasRISCV9PFileSystem.TFSFile;const aCount:TPasRISCVSizeInt;const aNames:array of TPasRISCVRawByteString):TPasRISCVInt32; override;
       function MkDir(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32; override;
       function Open(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aFlags:TPasRISCVUInt32;const aOnOpenCompletion:TPasRISCV9PFileSystem.TOnOpenCompletion;const aOpaque:Pointer):TPasRISCVInt32; override;
       function Create_(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aFlags:TPasRISCVUInt32;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32; override;
       function ReadDir(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; override;
       function Read(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; override;
       function Write(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; override;
       procedure Close(const aFile:TPasRISCV9PFileSystem.TFSFile); override;
       function Stat(const aFile:TPasRISCV9PFileSystem.TFSFile;out aStat:TPasRISCV9PFileSystem.TFSStat):TPasRISCVInt32; override;
       function SetAttr(const aFile:TPasRISCV9PFileSystem.TFSFile;const aMask,aMode,aUID,aGID:TPasRISCVUInt32;const aSize,aATimeSec,aATimeNSec,aMTimeSec,aMTimeNSec,aCTimeSec,aCTimeNSec:TPasRISCVUInt64):TPasRISCVInt32; override;
       function Link(const aDestFile,aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32; override;
       function SymLink(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName,aTarget:TPasRISCVRawByteString;const aGID:TPasRISCVUInt32):TPasRISCVInt32; override;
       function MkNod(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aMajor,aMinor,aGID:TPasRISCVUInt32):TPasRISCVInt32; override;
       function ReadLink(const aBuffer:Pointer;const aSize:TPasRISCVInt64;const aFile:TPasRISCV9PFileSystem.TFSFile):TPasRISCVInt64; override;
       function RenameAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aNewFile:TPasRISCV9PFileSystem.TFSFile;const aNewName:TPasRISCVRawByteString):TPasRISCVInt32; override;
       function UnlinkAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32; override;
       function Lock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32; override;
       function GetLock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32; override;
     end;
{$ifend}

{$if defined(Windows)}
     { TPasRISCV9PFileSystemWindows }
     TPasRISCV9PFileSystemWindows=class(TPasRISCV9PFileSystem)
      public
      private
       function FileTimeToUnixTime(const aFileTime:TFileTime):TPasRISCVUInt64;
       function UnixTimeToFileTime(const aUnixTime:TPasRISCVUInt64):TFileTime;
       function Win32FileAttributesToP9Mode(const aFileAttributes:DWORD):TPasRISCVUInt32;
       function Win32ErrorCodeToP9ErrorCode(const aErrorCode:DWORD):TPasRISCVInt32;
       function P9OpenFlagsToWin32OpenFlags(const aFlags:TPasRISCVUInt32):DWORD;
       procedure StatToQID(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFileInfo:BY_HANDLE_FILE_INFORMATION);
       function ComposePath(const aPath,aName:TPasRISCVRawByteString):TPasRISCVRawByteString;
       function CreateFileObject(const aPath:TPasRISCVRawByteString;const aUID:TPasRISCVUInt32):TPasRISCV9PFileSystem.TFSFile;
      public
       constructor Create(const aRootPath:TPasRISCVRawByteString); reintroduce;
       destructor Destroy; override;
       procedure Delete(const aFile:TPasRISCV9PFileSystem.TFSFile); override;
       procedure StatFS(out aStatFS:TPasRISCV9PFileSystem.TFSStatFS); override;
       function Attach(out aFile:TPasRISCV9PFileSystem.TFSFile;const aQID:TPasRISCV9PFileSystem.PFSQID;const aUID:TPasRISCVUInt32;const aUName,aAName:TPasRISCVRawByteString):TPasRISCVInt32; override;
       function Walk(out aFiles:TPasRISCV9PFileSystem.TFSFile;const aQIDs:TPasRISCV9PFileSystem.PFSQIDArray;const aFile:TPasRISCV9PFileSystem.TFSFile;const aCount:TPasRISCVSizeInt;const aNames:array of TPasRISCVRawByteString):TPasRISCVInt32; override;
       function MkDir(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32; override;
       function Open(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aFlags:TPasRISCVUInt32;const aOnOpenCompletion:TPasRISCV9PFileSystem.TOnOpenCompletion;const aOpaque:Pointer):TPasRISCVInt32; override;
       function Create_(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aFlags:TPasRISCVUInt32;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32; override;
       function ReadDir(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; override;
       function Read(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; override;
       function Write(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; override;
       procedure Close(const aFile:TPasRISCV9PFileSystem.TFSFile); override;
       function Stat(const aFile:TPasRISCV9PFileSystem.TFSFile;out aStat:TPasRISCV9PFileSystem.TFSStat):TPasRISCVInt32; override;
       function SetAttr(const aFile:TPasRISCV9PFileSystem.TFSFile;const aMask,aMode,aUID,aGID:TPasRISCVUInt32;const aSize,aATimeSec,aATimeNSec,aMTimeSec,aMTimeNSec,aCTimeSec,aCTimeNSec:TPasRISCVUInt64):TPasRISCVInt32; override;
       function Link(const aDestFile,aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32; override;
       function SymLink(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName,aTarget:TPasRISCVRawByteString;const aGID:TPasRISCVUInt32):TPasRISCVInt32; override;
       function MkNod(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aMajor,aMinor,aGID:TPasRISCVUInt32):TPasRISCVInt32; override;
       function ReadLink(const aBuffer:Pointer;const aSize:TPasRISCVInt64;const aFile:TPasRISCV9PFileSystem.TFSFile):TPasRISCVInt64; override;
       function RenameAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aNewFile:TPasRISCV9PFileSystem.TFSFile;const aNewName:TPasRISCVRawByteString):TPasRISCVInt32; override;
       function UnlinkAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32; override;
       function Lock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32; override;
       function GetLock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32; override;
     end;
{$ifend}

     TPasRISCV9PFileSystemNative={$if defined(fpc) and defined(Unix)}TPasRISCV9PFileSystemPOSIX{$elseif defined(Windows)}TPasRISCV9PFileSystemWindows{$else}TPasRISCV9PFileSystem{$ifend};

     { TPasRISCV9PFileSystemMemory }

     { TPasRISCVEthernetDevice }
     TPasRISCVEthernetDevice=class
      public
       type TMACAddress=array[0..5] of TPasRISCVUInt8;
            PMACAddress=^TMACAddress;
            TOnCanWritePacket=function():Boolean of object;
            TOnWritePacket=procedure(const aBuffer:Pointer;const aBufferSize:TPasRISCVSizeInt) of object;
            TOnSetCarrier=procedure(const aCarrierStatus:Boolean) of object;
      private
       fMACAddress:TMACAddress;
       fOnCanWritePacket:TOnCanWritePacket;
       fOnWritePacket:TOnWritePacket;
       fOnSetCarrier:TOnSetCarrier;
      public
       constructor Create; reintroduce;
       destructor Destroy; override;
       procedure GenerateMACAddress;
       procedure Shutdown; virtual;
       procedure WritePacket(const aBuffer:Pointer;const aBufferSize:TPasRISCVSizeInt); virtual;
      public
       property MACAddress:TMACAddress read fMACAddress write fMACAddress;
       property OnCanWritePacket:TOnCanWritePacket read fOnCanWritePacket write fOnCanWritePacket;
       property OnWritePacket:TOnWritePacket read fOnWritePacket write fOnWritePacket;
       property OnSetCarrier:TOnSetCarrier read fOnSetCarrier write fOnSetCarrier;
     end;

{$if defined(fpc) and defined(unix)}
     { TPasRISCVEthernetDeviceTUN }
     TPasRISCVEthernetDeviceTUN=class(TPasRISCVEthernetDevice)
      public
       const TUNSETIFF=$400454ca;
             IFF_TUN=$0001;
             IFF_TAP=$0002;
             IFF_NAPI=$0010;
             IFF_NAPI_FRAGS=$0020;
             IFF_NO_CARRIER=$0040;
             IFF_NO_PI=$1000;
             IFF_ONE_QUEUE=$2000;
             IFF_VNET_HDR=$4000;
             IFF_TUN_EXCL=$8000;
             IFF_MULTI_QUEUE=$0100;
             IFF_ATTACH_QUEUE=$0200;
             IFF_DETACH_QUEUE=$0400;
             IFF_PERSIST=$0800;
             IFF_NOFILTER=$1000;
       type Tifmap=record
             mem_start:TPasRISCVUInt32;
             mem_end:TPasRISCVUInt32;
             base_addr:TPasRISCVUInt16;
             irq:TPasRISCVUInt8;
             dma:TPasRISCVUInt8;
             port:TPasRISCVUInt8;
            end;
            Pifmap=^Tifmap;
            Tifreq=record
             ifr_ifrn:record
              case TPasRISCVInt32 of
               0:(ifr_name:array[0..15] of TPasRISCVRawByteChar);
             end;
             ifr_ifru:record
              case TPasRISCVInt32 of
               0:(ifru_addr:sockaddr);
               1:(ifru_dstaddr:sockaddr);
               2:(ifru_broadaddr:sockaddr);
               3:(ifru_netmask:sockaddr);
               4:(ifru_hwaddr:sockaddr);
               5:(ifru_flags:TPasRISCVInt16);
               6:(ifru_ivalue:TPasRISCVInt32);
               7:(ifru_mtu:TPasRISCVInt32);
               8:(ifru_map:Tifmap);
               9:(ifru_slave:array[0..15] of TPasRISCVRawByteChar);
               10:(ifru_newname:array[0..15] of TPasRISCVRawByteChar);
               11:(ifru_data:PPasRISCVRawByteChar);
             end;
            end;
            Pifreq=^Tifreq;
            TNetworkThread=class(TPasMPThread)
             private
              fEthernetDevice:TPasRISCVEthernetDeviceTUN;
              fEvent:TPasMPEvent;
             protected
              procedure Execute; override;
             public
              constructor Create(const aEthernetDevice:TPasRISCVEthernetDeviceTUN);
              destructor Destroy; override;
              procedure Shutdown;
            end;
      private
       fTunFD:TPasRISCVInt32;
       fSelectedFilled:TPasMPBool32;
       fThread:TNetworkThread;
       fRFDS:TFDSet;
       fWFDS:TFDSet;
       fEFDS:TFDSet;
       fBuffer:array[0..65535] of TPasRISCVUInt8;
       procedure ThreadProc;
      public
       constructor Create; reintroduce;
       destructor Destroy; override;
       procedure Shutdown; override;
       function Open(const aInterfaceName:TPasRISCVRawByteString):Boolean;
       procedure WritePacket(const aBuffer:Pointer;const aBufferSize:TPasRISCVSizeInt); override;
     end;
{$ifend}

     { TPasRISCV }
     TPasRISCV=class
      public
       const PAGE_SIZE=4096;
             PAGE_MASK=4095;
             PAGE_SHIFT=12;
             PAGE_ADDRESS_MASK=TPasRISCVUInt64($fffffffffffff000);
             RUNSTATE_POWEROFF=TPasRISCVUInt32(1) shl 16;
             RUNSTATE_RUNNING=TPasRISCVUInt32(1) shl 17;
             RUNSTATE_REBOOT=TPasRISCVUInt32(1) shl 18;
             RUNSTATE_SINGLESTEP=TPasRISCVUInt32(1) shl 19;
             RUNSTATE_PAUSING=TPasRISCVUInt32(1) shl 20;
             RUNSTATE_PAUSED=TPasRISCVUInt32(1) shl 21;
             RUNSTATE_FLUSHTLB=TPasRISCVUInt32(1) shl 22;
             RUNSTATE_GLOBAL_MASK=TPasRISCVUInt32($ffff0000);
             RUNSTATE_HARTS_MASK=TPasRISCVUInt32($0000ffff);
             RUNSTATE_HART_SHIFT=0;
             CLOCK_FREQUENCY=1000000;
             FE_ALL_EXCEPT=$3f;
             FE_INVALID=$01;
             FE_DENORM=$02;
             FE_DIVBYZERO=$04;
             FE_OVERFLOW=$08;
             FE_UNDERFLOW=$10;
             FE_INEXACT=$20;
             KERNEL_OFFSET=$200000;
             POLL_RX=1 shl 0;
             POLL_TX=1 shl 1;
             SerialChars:array[0..35] of TPasRISCVChar=
              (
               '0','1','2','3','4','5','6','7','8','9',
               'A','B','C','D','E','F','G','H','I','J',
               'K','L','M','N','O','P','Q','R','S','T',
               'U','V','W','X','Y','Z'
              );
       type THART=class;
            THARTs=array of THART;
            TBus=class;
            { TPCG32 }
            TPCG32=record
             private
              const DefaultState=TPasRISCVUInt64($853c49e6748fea9b);
                    DefaultStream=TPasRISCVUInt64($da3e39cb94b95bdb);
                    Mult=TPasRISCVUInt64($5851f42d4c957f2d);
             private
              fState:TPasRISCVUInt64;
              fIncrement:TPasRISCVUInt64;
             public
              procedure Init(const aSeed:TPasRISCVUInt64=0);
              function Get32:TPasRISCVUInt32;
              function GetUnbiasedBounded(const aRange:TPasRISCVUInt32):TPasRISCVUInt32;
            end;
            TFSQID=packed record
             Type_:TPasRISCVUInt8;
             Version:TPasRISCVUInt32;
             Path:TPasRISCVUInt64;
            end;
            PFSQID=^TFSQID;
            { TEVDEV }
            TEVDEV=class
             public
              const KEY_RESERVED=0;
                    KEY_ESC=1;
                    KEY_1=2;
                    KEY_2=3;
                    KEY_3=4;
                    KEY_4=5;
                    KEY_5=6;
                    KEY_6=7;
                    KEY_7=8;
                    KEY_8=9;
                    KEY_9=10;
                    KEY_0=11;
                    KEY_MINUS=12;
                    KEY_EQUAL=13;
                    KEY_BACKSPACE=14;
                    KEY_TAB=15;
                    KEY_Q=16;
                    KEY_W=17;
                    KEY_E=18;
                    KEY_R=19;
                    KEY_T=20;
                    KEY_Y=21;
                    KEY_U=22;
                    KEY_I=23;
                    KEY_O=24;
                    KEY_P=25;
                    KEY_LEFTBRACE=26;
                    KEY_RIGHTBRACE=27;
                    KEY_ENTER=28;
                    KEY_LEFTCTRL=29;
                    KEY_A=30;
                    KEY_S=31;
                    KEY_D=32;
                    KEY_F=33;
                    KEY_G=34;
                    KEY_H=35;
                    KEY_J=36;
                    KEY_K=37;
                    KEY_L=38;
                    KEY_SEMICOLON=39;
                    KEY_APOSTROPHE=40;
                    KEY_GRAVE=41;
                    KEY_LEFTSHIFT=42;
                    KEY_BACKSLASH=43;
                    KEY_Z=44;
                    KEY_X=45;
                    KEY_C=46;
                    KEY_V=47;
                    KEY_B=48;
                    KEY_N=49;
                    KEY_M=50;
                    KEY_COMMA=51;
                    KEY_DOT=52;
                    KEY_SLASH=53;
                    KEY_RIGHTSHIFT=54;
                    KEY_KPASTERISK=55;
                    KEY_LEFTALT=56;
                    KEY_SPACE=57;
                    KEY_CAPSLOCK=58;
                    KEY_F1=59;
                    KEY_F2=60;
                    KEY_F3=61;
                    KEY_F4=62;
                    KEY_F5=63;
                    KEY_F6=64;
                    KEY_F7=65;
                    KEY_F8=66;
                    KEY_F9=67;
                    KEY_F10=68;
                    KEY_NUMLOCK=69;
                    KEY_SCROLLLOCK=70;
                    KEY_KP7=71;
                    KEY_KP8=72;
                    KEY_KP9=73;
                    KEY_KPMINUS=74;
                    KEY_KP4=75;
                    KEY_KP5=76;
                    KEY_KP6=77;
                    KEY_KPPLUS=78;
                    KEY_KP1=79;
                    KEY_KP2=80;
                    KEY_KP3=81;
                    KEY_KP0=82;
                    KEY_KPDOT=83;

                    KEY_ZENKAKUHANKAKU=85;
                    KEY_102ND=86;
                    KEY_F11=87;
                    KEY_F12=88;
                    KEY_RO=89;
                    KEY_KATAKANA=90;
                    KEY_HIRAGANA=91;
                    KEY_HENKAN=92;
                    KEY_KATAKANAHIRAGANA=93;
                    KEY_MUHENKAN=94;
                    KEY_KPJPCOMMA=95;
                    KEY_KPENTER=96;
                    KEY_RIGHTCTRL=97;
                    KEY_KPSLASH=98;
                    KEY_SYSRQ=99;
                    KEY_RIGHTALT=100;
                    KEY_LINEFEED=101;
                    KEY_HOME=102;
                    KEY_UP=103;
                    KEY_PAGEUP=104;
                    KEY_LEFT=105;
                    KEY_RIGHT=106;
                    KEY_END=107;
                    KEY_DOWN=108;
                    KEY_PAGEDOWN=109;
                    KEY_INSERT=110;
                    KEY_DELETE=111;
                    KEY_MACRO=112;
                    KEY_MUTE=113;
                    KEY_VOLUMEDOWN=114;
                    KEY_VOLUMEUP=115;
                    KEY_POWER=116; // SC System Power Down
                    KEY_KPEQUAL=117;
                    KEY_KPPLUSMINUS=118;
                    KEY_PAUSE=119;
                    KEY_SCALE=120; // AL Compiz Scale (Expose)
                    KEY_KPCOMMA=121;
                    KEY_HANGEUL=122;
                    KEY_HANGUEL=KEY_HANGEUL;
                    KEY_HANJA=123;
                    KEY_YEN=124;
                    KEY_LEFTMETA=125;
                    KEY_RIGHTMETA=126;
                    KEY_COMPOSE=127;
                    KEY_STOP=128; // AC Stop
                    KEY_AGAIN=129;
                    KEY_PROPS=130; // AC Properties
                    KEY_UNDO=131;  // AC Undo
                    KEY_FRONT=132;
                    KEY_COPY=133;  // AC Copy
                    KEY_OPEN=134;  // AC Open
                    KEY_PASTE=135; // AC Paste
                    KEY_FIND=136; // AC Search
                    KEY_CUT=137;   // AC Cut
                    KEY_HELP=138;  // AL Integrated Help Center
                    KEY_MENU=139;  // Menu (show menu)
                    KEY_CALC=140;  // AL Calculator
                    KEY_SETUP=141;
                    KEY_SLEEP=142;  // SC System Sleep
                    KEY_WAKEUP=143; // System Wake Up
                    KEY_FILE=144;   // AL Local Machine Browser
                    KEY_SENDFILE=145;
                    KEY_DELETEFILE=146;
                    KEY_XFER=147;
                    KEY_PROG1=148;
                    KEY_PROG2=149;
                    KEY_WWW=150; // AL Internet Browser
                    KEY_MSDOS=151;
                    KEY_COFFEE=152; // AL Terminal Lock/Screensaver
                    KEY_SCREENLOCK=KEY_COFFEE;
                    KEY_ROTATE_DISPLAY=153; // Display orientation for e.g. tablets
                    KEY_DIRECTION=KEY_ROTATE_DISPLAY;
                    KEY_CYCLEWINDOWS=154;
                    KEY_MAIL=155;
                    KEY_BOOKMARKS=156; // AC Bookmarks
                    KEY_COMPUTER=157;
                    KEY_BACK=158;    // AC Back
                    KEY_FORWARD=159; // AC Forward
                    KEY_CLOSECD=160;
                    KEY_EJECTCD=161;
                    KEY_EJECTCLOSECD=162;
                    KEY_NEXTSONG=163;
                    KEY_PLAYPAUSE=164;
                    KEY_PREVIOUSSONG=165;
                    KEY_STOPCD=166;
                    KEY_RECORD=167;
                    KEY_REWIND=168;
                    KEY_PHONE=169; // Media Select Telephone
                    KEY_ISO=170;
                    KEY_CONFIG=171;   // AL Consumer Control Configuration
                    KEY_HOMEPAGE=172; // AC Home
                    KEY_REFRESH=173;  // AC Refresh
                    KEY_EXIT=174;     // AC Exit
                    KEY_MOVE=175;
                    KEY_EDIT=176;
                    KEY_SCROLLUP=177;
                    KEY_SCROLLDOWN=178;
                    KEY_KPLEFTPAREN=179;
                    KEY_KPRIGHTPAREN=180;
                    KEY_NEW=181;  // AC New
                    KEY_REDO=182; // AC Redo/Repeat
                    KEY_F13=183;
                    KEY_F14=184;
                    KEY_F15=185;
                    KEY_F16=186;
                    KEY_F17=187;
                    KEY_F18=188;
                    KEY_F19=189;
                    KEY_F20=190;
                    KEY_F21=191;
                    KEY_F22=192;
                    KEY_F23=193;
                    KEY_F24=194;
                    KEY_PLAYCD=200;
                    KEY_PAUSECD=201;
                    KEY_PROG3=202;
                    KEY_PROG4=203;
                    KEY_ALL_APPLICATIONS=204; // AC Desktop Show All Applications
                    KEY_DASHBOARD=KEY_ALL_APPLICATIONS;
                    KEY_SUSPEND=205;
                    KEY_CLOSE=206; // AC Close
                    KEY_PLAY=207;
                    KEY_FASTFORWARD=208;
                    KEY_BASSBOOST=209;
                    KEY_PRINT=210; // AC Print
                    KEY_HP=211;
                    KEY_CAMERA=212;
                    KEY_SOUND=213;
                    KEY_QUESTION=214;
                    KEY_EMAIL=215;
                    KEY_CHAT=216;
                    KEY_SEARCH=217;
                    KEY_CONNECT=218;
                    KEY_FINANCE=219; // AL Checkbook/Finance
                    KEY_SPORT=220;
                    KEY_SHOP=221;
                    KEY_ALTERASE=222;
                    KEY_CANCEL=223; // AC Cancel
                    KEY_BRIGHTNESSDOWN=224;
                    KEY_BRIGHTNESSUP=225;
                    KEY_MEDIA=226;
                    KEY_SWITCHVIDEOMODE =227; // Cycle between available video outputs (Monitor/LCD/TV-out/etc)
                    KEY_KBDILLUMTOGGLE=228;
                    KEY_KBDILLUMDOWN=229;
                    KEY_KBDILLUMUP=230;
                    KEY_SEND=231;        // AC Send
                    KEY_REPLY=232;       // AC Reply
                    KEY_FORWARDMAIL=233; // AC Forward Msg
                    KEY_SAVE=234;        // AC Save
                    KEY_DOCUMENTS=235;
                    KEY_BATTERY=236;
                    KEY_BLUETOOTH=237;
                    KEY_WLAN=238;
                    KEY_UWB=239;
                    KEY_UNKNOWN=240;
                    KEY_VIDEO_NEXT=241;       // drive next video source
                    KEY_VIDEO_PREV=242;       // drive previous video source
                    KEY_BRIGHTNESS_CYCLE=243; // brightness up, after max is min
                    KEY_BRIGHTNESS_AUTO=244; // Set Auto Brightness: manual
                    KEY_BRIGHTNESS_ZERO=KEY_BRIGHTNESS_AUTO;
                    KEY_DISPLAY_OFF=245; // display device to off state
                    KEY_WWAN=246; // Wireless WAN (LTE, UMTS, GSM, etc.)
                    KEY_WIMAX=KEY_WWAN;
                    KEY_RFKILL=247; // Key that controls all radios
                    KEY_MICMUTE=248; // Mute / unmute the microphone
            end;
            { THID }
            THID=class
             public
              const BTN_NONE=$0;
                    BTN_LEFT=$1;
                    BTN_RIGHT=$2;
                    BTN_MIDDLE=$4;
                    SCROLL_UP=-1;
                    SCROLL_DOWN=1;
                    KEY_NONE=$00;
                    KEY_ERR_ROLLOVER=$01;
                    KEY_ERR_POSTFAIL=$02;
                    KEY_ERR_UNDEFINED=$03;
                    KEY_A=$04;
                    KEY_B=$05;
                    KEY_C=$06;
                    KEY_D=$07;
                    KEY_E=$08;
                    KEY_F=$09;
                    KEY_G=$0a;
                    KEY_H=$0b;
                    KEY_I=$0c;
                    KEY_J=$0d;
                    KEY_K=$0e;
                    KEY_L=$0f;
                    KEY_M=$10;
                    KEY_N=$11;
                    KEY_O=$12;
                    KEY_P=$13;
                    KEY_Q=$14;
                    KEY_R=$15;
                    KEY_S=$16;
                    KEY_T=$17;
                    KEY_U=$18;
                    KEY_V=$19;
                    KEY_W=$1a;
                    KEY_X=$1b;
                    KEY_Y=$1c;
                    KEY_Z=$1d;
                    KEY_1=$1e;
                    KEY_2=$1f;
                    KEY_3=$20;
                    KEY_4=$21;
                    KEY_5=$22;
                    KEY_6=$23;
                    KEY_7=$24;
                    KEY_8=$25;
                    KEY_9=$26;
                    KEY_0=$27;
                    KEY_RETURN=$28;
                    KEY_ESCAPE=$29;
                    KEY_BACKSPACE=$2a;
                    KEY_TAB=$2b;
                    KEY_SPACE=$2c;
                    KEY_MINUS=$2d;
                    KEY_EQUAL=$2e;
                    KEY_LEFTBRACE=$2f;
                    KEY_RIGHTBRACE=$30;
                    KEY_BACKSLASH=$31;
                    KEY_HASHTILDE=$32;
                    KEY_SEMICOLON=$33;
                    KEY_APOSTROPHE=$34;
                    KEY_GRAVE=$35;
                    KEY_COMMA=$36;
                    KEY_DOT=$37;
                    KEY_SLASH=$38;
                    KEY_CAPSLOCK=$39;
                    KEY_F1=$3a;
                    KEY_F2=$3b;
                    KEY_F3=$3c;
                    KEY_F4=$3d;
                    KEY_F5=$3e;
                    KEY_F6=$3f;
                    KEY_F7=$40;
                    KEY_F8=$41;
                    KEY_F9=$42;
                    KEY_F10=$43;
                    KEY_F11=$44;
                    KEY_F12=$45;
                    KEY_SYSRQ=$46;
                    KEY_SCROLLLOCK=$47;
                    KEY_PAUSE=$48;
                    KEY_INSERT=$49;
                    KEY_HOME=$4a;
                    KEY_PAGEUP=$4b;
                    KEY_DELETE=$4c;
                    KEY_END=$4d;
                    KEY_PAGEDOWN=$4e;
                    KEY_RIGHT=$4f;
                    KEY_LEFT=$50;
                    KEY_DOWN=$51;
                    KEY_UP=$52;
                    KEY_NUMLOCK=$53;
                    KEY_KPSLASH=$54;
                    KEY_KPASTERISK=$55;
                    KEY_KPMINUS=$56;
                    KEY_KPPLUS=$57;
                    KEY_KPENTER=$58;
                    KEY_KP1=$59;
                    KEY_KP2=$5a;
                    KEY_KP3=$5b;
                    KEY_KP4=$5c;
                    KEY_KP5=$5d;
                    KEY_KP6=$5e;
                    KEY_KP7=$5f;
                    KEY_KP8=$60;
                    KEY_KP9=$61;
                    KEY_KP0=$62;
                    KEY_KPDOT=$63;
                    KEY_102ND=$64;
                    KEY_COMPOSE=$65;
                    KEY_POWER=$66;
                    KEY_KPEQUAL=$67;
                    KEY_F13=$68;
                    KEY_F14=$69;
                    KEY_F15=$6a;
                    KEY_F16=$6b;
                    KEY_F17=$6c;
                    KEY_F18=$6d;
                    KEY_F19=$6e;
                    KEY_F20=$6f;
                    KEY_F21=$70;
                    KEY_F22=$71;
                    KEY_F23=$72;
                    KEY_F24=$73;
                    KEY_OPEN=$74;
                    KEY_HELP=$75;
                    KEY_MENU=$76;
                    KEY_FRONT=$77;
                    KEY_STOP=$78;
                    KEY_AGAIN=$79;
                    KEY_UNDO=$7a;
                    KEY_CUT=$7b;
                    KEY_COPY=$7c;
                    KEY_PASTE=$7d;
                    KEY_FIND=$7e;
                    KEY_MUTE=$7f;
                    KEY_VOLUMEUP=$80;
                    KEY_VOLUMEDOWN=$81;
                    KEY_KPCOMMA=$85;
                    KEY_RO=$87;
                    KEY_KATAKANAHIRAGANA=$88;
                    KEY_YEN=$89;
                    KEY_HENKAN=$8a;
                    KEY_MUHENKAN=$8b;
                    KEY_KPJPCOMMA=$8c;
                    KEY_HANGEUL=$90;
                    KEY_HANJA=$91;
                    KEY_KATAKANA=$92;
                    KEY_HIRAGANA=$93;
                    KEY_ZENKAKUHANKAKU=$94;
                    KEY_KPLEFTPAREN=$b6;
                    KEY_KPRIGHTPAREN=$b7;
                    KEY_LEFTCTRL=$e0;
                    KEY_LEFTSHIFT=$e1;
                    KEY_LEFTALT=$e2;
                    KEY_LEFTMETA=$e3;
                    KEY_RIGHTCTRL=$e4;
                    KEY_RIGHTSHIFT=$e5;
                    KEY_RIGHTALT=$e6;
                    KEY_RIGHTMETA=$e7;
                    KEY_MEDIA_PLAYPAUSE=$e8;
                    KEY_MEDIA_STOPCD=$e9;
                    KEY_MEDIA_PREVIOUSSONG=$ea;
                    KEY_MEDIA_NEXTSONG=$eb;
                    KEY_MEDIA_EJECTCD=$ec;
                    KEY_MEDIA_VOLUMEUP=$ed;
                    KEY_MEDIA_VOLUMEDOWN=$ee;
                    KEY_MEDIA_MUTE=$ef;
                    KEY_MEDIA_WWW=$f0;
                    KEY_MEDIA_BACK=$f1;
                    KEY_MEDIA_FORWARD=$f2;
                    KEY_MEDIA_STOP=$f3;
                    KEY_MEDIA_FIND=$f4;
                    KEY_MEDIA_SCROLLUP=$f5;
                    KEY_MEDIA_SCROLLDOWN=$f6;
                    KEY_MEDIA_EDIT=$f7;
                    KEY_MEDIA_SLEEP=$f8;
                    KEY_MEDIA_COFFEE=$f9;
                    KEY_MEDIA_REFRESH=$fa;
                    KEY_MEDIA_CALC=$fb;
            end;
            TAIARegFileMode=
             (
              Machine,
              Supervisor
             );
            { TTimer }
            TTimer=record
             public
              fBeginTime:TPasRISCVUInt64;
              fFrequency:TPasRISCVUInt64;
             public
              procedure Rebase(const aTime:TPasRISCVUInt64);
              procedure Initialize(const aFrequency:TPasRISCVUInt64);
              function Get:TPasRISCVUInt64;
              property Frequency:TPasRISCVUInt64 read fFrequency;
            end;
            PTimer=^TTimer;
            { TTimeCmp }
            TTimeCmp=record
             public
              fTimeCmp:TPasMPUInt64;
              fTimer:PTimer;
             public
              procedure Initialize(const aTimer:PTimer);
              function GetTimeCmp:TPasMPUInt64;
              procedure SetTimeCmp(aTimeCmp:TPasMPUInt64);
              function Pending:Boolean;
              function Delay:TPasMPUInt64;
              function DelayNS:TPasMPUInt64;
            end;
            { TThreadTimer }
            TThreadTimer=class(TPasMPThread)
             public
              type TThreadTimerEvent=procedure of object;
             private
              fInterval:TPasRISCVUInt64;
              fEvent:TPasMPEvent;
              fOnTimer:TThreadTimerEvent;
             protected
              procedure Execute; override;
             public
              constructor Create(const aOnTimer:TThreadTimerEvent); reintroduce;
              destructor Destroy; override;
              procedure Shutdown;
              procedure SetInterval(const aInterval:TPasRISCVUInt64);
            end;
            TVirtIODevice=class;
            TNVMeDevice=class;
            TVirtIOBlockDeviceCommand=record
             RequestType:TPasRISCVUInt32;
             SectorIndex:TPasRISCVUInt64;
             Count:TPasRISCVUInt64;
             WriteSize:TPasRISCVUInt64;
             QueueIndex:TPasRISCVUInt64;
             DescriptorIndex:TPasRISCVUInt64;
            end;
            PVirtIOBlockDeviceCommand=^TVirtIOBlockDeviceCommand;
            TNVMeDeviceCommand=record
             SubmissionQueueID:TPasRISCVUInt64;
             SubmissionQueueHead:TPasRISCVUInt64;
            end;
            PNVMeDeviceCommand=^TNVMeDeviceCommand;
            TNVMeDeviceCommandDynamicArray=array of TNVMeDeviceCommand;
            TJobQueueItem=record
             public
              type TJobType=
                    (
                     VirtIODeviceQueue,
                     NVMeDeviceQueue,
                     NVMeDeviceCommand
                    );
             public
              fObject:TObject;
              case fJobType:TJobType of
               TJobType.VirtIODeviceQueue:(
                fVirtIODeviceQueue:TPasRISCVUInt32;
                fVirtIODeviceAvailableIndex:TPasRISCVInt32;
               );
               TJobType.NVMeDeviceQueue:(
                fNVMeDeviceQueue:TPasRISCVUInt32;
                fNVMeDeviceQueueValue:TPasRISCVUInt32;
               );
               TJobType.NVMeDeviceCommand:(
                fNVMeDeviceCommand:TNVMeDeviceCommand;
               );
            end;
            PJobQueueItem=^TJobQueueItem;
            TJobQueue=TPasRISCVThreadSafeDynamicQueue<TJobQueueItem>;
            TJobManager=class;
            TJobWorkerThread=class(TPasMPThread)
             private
              fJobManager:TJobManager;
             protected
              procedure Execute; override;
             public
              constructor Create(const aJobManager:TJobManager); reintroduce;
              destructor Destroy; override;
            end;
            TJobWorkerThreads=array of TJobWorkerThread;
            TJobManager=class
             private
              fQueue:TJobQueue;
              fWorkerThreads:TJobWorkerThreads;
              fCountWorkerThreads:TPasRISCVSizeInt;
              fSequence:TPasMPUInt64;
              fSleepingOnIdle:TPasMPBool32;
              fSleepingJobWorkerThreads:TPasMPInt32;
              fWakeUpCounter:TPasMPInt32;
              fWakeUpConditionVariableLock:TPasMPConditionVariableLock;
              fWakeUpConditionVariable:TPasMPConditionVariable;
             public
              constructor Create(const aCountWorkerThreads:TPasRISCVSizeInt); reintroduce;
              destructor Destroy; override;
              procedure Shutdown;
              procedure WaitForWakeUp;
              procedure WakeUpAllWorkerThreads;
              function EnqueueVirtIODeviceQueue(const aVirtIODevice:TVirtIODevice;const aVirtIODeviceQueue:TPasRISCVUInt32;const aVirtIODeviceAvailableIndex:TPasRISCVInt32):Boolean;
              function EnqueueNVMeDeviceQueue(const aNVMeDevice:TNVMeDevice;const aNVMeDeviceQueue,aNVMeDeviceQueueValue:TPasRISCVUInt32):Boolean;
              function EnqueueNVMeDeviceCommand(const aNVMeDevice:TNVMeDevice;const aNVMeDeviceCommand:TNVMeDeviceCommand):Boolean;
              function EnqueueNVMeDeviceCommands(const aNVMeDevice:TNVMeDevice;const aNVMeDeviceCommands:TNVMeDeviceCommandDynamicArray;const aCount:TPasRISCVSizeInt):Boolean;
            end;
            { TFDT }
            TFDT=class
             public
              const FDT_MAGIC=TPasRISCVUInt32($d00dfeed);
                    FDT_VERSION=TPasRISCVUInt32(17);
                    FDT_COMP_VERSION=TPasRISCVUInt32(16);
                    FDT_BEGIN_NODE=1;
                    FDT_END_NODE=2;
                    FDT_PROP=3;
                    FDT_NOP=4;
                    FDT_END=9;
                    FDT_HDR_SIZE=40;
                    FDT_RSV_SIZE=16;
              type TFDTSizeDescriptor=record
                    StructSize:TPasRISCVUInt32;
                    StringsSize:TPasRISCVUInt32;
                   end;
                   { TFDTProperty }
                   TFDTProperty=class
                    private
                     fName:TPasRISCVRawByteString;
                     fData:TPasRISCVUInt8DynamicArray;
                     fLen:TPasRISCVUInt32;
                    public
                     constructor Create;
                     destructor Destroy; override;
                    public
                     property Name:TPasRISCVRawByteString read fName write fName;
                     property Data:TPasRISCVUInt8DynamicArray read fData write fData;
                     property Len:TPasRISCVUInt32 read fLen write fLen;
                   end;
                   TFDTProperties=array of TFDTProperty;
                   { TFDTNode }
                   TFDTNode=class;
                   TFDTNodes=array of TFDTNode;
                   TFDTNode=class
                    private
                     fFDT:TFDT;
                     fName:TPasRISCVRawByteString;
                     fParent:TFDTNode;
                     fProperties:TFDTProperties;
                     fCountProperties:TPasRISCVSizeInt;
                     fNodes:TFDTNodes;
                     fCountNodes:TPasRISCVSizeInt;
                     fPHandle:TPasRISCVUInt32;
                    public
                     constructor Create(const aFDT:TFDT;const aName:TPasRISCVRawByteString); overload;
                     constructor Create(const aFDT:TFDT;const aName:TPasRISCVRawByteString;const aAddress:TPasRISCVUInt64); overload;
                     destructor Destroy; override;
                     procedure AddChild(const aNode:TFDTNode);
                     function FindNode(const aName:TPasRISCVRawByteString):TFDTNode; overload;
                     function FindNode(const aName:TPasRISCVRawByteString;const aAddress:TPasRISCVUInt64):TFDTNode; overload;
                     function FindNodeAny(const aName:TPasRISCVRawByteString):TFDTNode;
                     function GetNewPHandle:TPasRISCVUInt32;
                     function GetPHandle:TPasRISCVUInt32;
                     function AddProperty(const aName:TPasRISCVRawByteString;const aData;const aSize:TPasRISCVUInt32):TPasRISCV.TFDT.TFDTProperty;
                     function AddPropertyU32(const aName:TPasRISCVRawByteString;const aValue:TPasRISCVUInt32):TFDTProperty;
                     function AddPropertyU64(const aName:TPasRISCVRawByteString;const aValue:TPasRISCVUInt64):TFDTProperty;
                     function AddPropertyCells(const aName:TPasRISCVRawByteString;const aCells:PPasRISCVUInt32;const aCountCells:TPasRISCVSizeInt):TFDTProperty;
                     function AddPropertyString(const aName,aValue:TPasRISCVRawByteString):TFDTProperty;
                     function AddPropertyReg(const aName:TPasRISCVRawByteString;const aBegin,aSize:TPasRISCVUInt64):TFDTProperty;
                     function DeleteProperty(const aName:TPasRISCVRawByteString):Boolean;
                     function FindProperty(const aName:TPasRISCVRawByteString):TFDTProperty;
                     procedure GetTreeSize(var aSize:TFDTSizeDescriptor);
                     procedure SerializeToStream(const aFDT:TFDT);
                    public
                     property Name:TPasRISCVRawByteString read fName write fName;
                     property Parent:TFDTNode read fParent write fParent;
                     property Properties:TFDTProperties read fProperties write fProperties;
                     property Nodes:TFDTNodes read fNodes write fNodes;
                     property PHandle:TPasRISCVUInt32 read fPHandle write fPHandle;
                   end;
             private
              fRoot:TFDTNode;
              fMemoryStream:TMemoryStream;
              fBufferSize:TPasRISCVUInt32;
              fStructOffset:TPasRISCVUInt32;
              fStringsBegin:TPasRISCVUInt32;
              fStringsOffset:TPasRISCVUInt32;
              fReservedOffset:TPasRISCVUInt32;
              fPHandleCounter:TPasRISCVUInt32;
              procedure WriteBigEndian32(const aValue:TPasRISCVUInt32);
             public
              constructor Create; reintroduce;
              destructor Destroy; override;
              class function NameWithAddr(const aName:TPasRISCVRawByteString;const aAddress:TPasRISCVUInt64):TPasRISCVRawByteString; static;
              class function IsIllegalPHandle(const aPHandle:TPasRISCVUInt32):Boolean; static;
              function GetTreeSize:TFDTSizeDescriptor;
              procedure SerializeToStream(const aStream:TStream);
             public
              property Root:TFDTNode read fRoot;
            end;
            TBusDevice=class;
            TBusDeviceArray=array of TBusDevice;
            { TBusDevice }
            TBusDevice=class
             private
              fMachine:TPasRISCV;
              fBase:TPasRISCVUInt64;
              fSize:TPasRISCVUInt64;
              fPHandle:TPasRISCVUInt32;
              fUnalignedAccessSupport:Boolean;
              fMinOpSize:TPasRISCVUInt64;
              fMaxOpSize:TPasRISCVUInt64;
              fSubBusDevices:TBusDeviceArray;
              fCountSubBusDevices:TPasRISCVUInt64;
              procedure SetBase(const aValue:TPasRISCVUInt64);
              procedure SetSize(const aValue:TPasRISCVUInt64); virtual;
              procedure SetEnd(const aValue:TPasRISCVUInt64);
             public
              constructor Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64); reintroduce; virtual;
              destructor Destroy; override;
              procedure AddSubBusDevice(const aSubBusDevice:TBusDevice);
              function FindSubBusDevice(const aAddress:TPasRISCVUInt64):TPasRISCV.TBusDevice;
              procedure Reset; virtual;
              function GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer; virtual;
              function GetGlobalDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; virtual;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); virtual;
              procedure Step; virtual;
             public
              property Machine:TPasRISCV read fMachine;
              property Base:TPasRISCVUInt64 read fBase write SetBase;
              property Size:TPasRISCVUInt64 read fSize write SetSize;
              property PHandle:TPasRISCVUInt32 read fPHandle;
              property UnalignedAccessSupport:Boolean read fUnalignedAccessSupport write fUnalignedAccessSupport;
              property MinOpSize:TPasRISCVUInt64 read fMinOpSize write fMinOpSize;
              property MaxOpSize:TPasRISCVUInt64 read fMaxOpSize write fMaxOpSize;
            end;
            { TInterrupts }
            TInterrupts=class
             public
              const CountIRQs=1024;
                    NoIRQ=TPasRISCVUInt32($ffffffff);
              type TIRQBitmap=array[0..(CountIRQs+$1f) shr 5] of TPasRISCVUInt32;
             private
              fMachine:TPasRISCV;
              fIRQAllocationBitmap:TIRQBitmap;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function AllocateIRQ:TPasRISCVUInt32;
              function AcquireIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
              function ReleaseIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
              function SendIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
              function RaiseIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
              function LowerIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
            end;
            { TACLINTDevice }
            TACLINTDevice=class(TBusDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($2000000);
                    DefaultSize=TPasRISCVUInt64($10000);
                    MSIPAddress=0;
                    MTimeCmpAddress=$4000;
                    MTimeCmpAddressSize=$8000;
                    MTimeAddress=$bff8;
                    SSIPAddress=$c000;
              type { TCLINTMTimerSubDevice } // for own MMIO sub-region with other minimum and maximum operation sizes, so it calls just the parent class methods for Load and Store
                   TCLINTMTimerSubDevice=class(TBusDevice)
                    private
                     fACLINTDevice:TACLINTDevice;
                    public
                     constructor Create(const aACLINTDevice:TACLINTDevice); reintroduce;
                     destructor Destroy; override;
                     function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
                     procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
                   end;
             private
              fCLINTMTimerSubDevice:TCLINTMTimerSubDevice;
              fStartTime:TPasRISCVUInt64;
              function GetTime:TPasRISCVUInt64;
              function GetCachedTime(var aTime:TPasRISCVUInt64):TPasRISCVUInt64;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TIMSICDevice }
            TIMSICDevice=class(TBusDevice)
             public
              const DefaultBaseAddressMachine=TPasRISCVUInt64($24000000);
                    DefaultBaseAddressSupervisor=TPasRISCVUInt64($28000000);
                    DefaultSizePerHART=TPasRISCVUInt64($4000);
             private
              fAIARegFileMode:TAIARegFileMode;
             public
              constructor Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64;const aAIARegFileMode:TPasRISCV.TAIARegFileMode); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TINTCDevice }
            TINTCDevice=class(TBusDevice)
             public
              function SendIRQ(const aIRQ:TPasRISCVUInt32):Boolean; virtual; abstract;
              function RaiseIRQ(const aIRQ:TPasRISCVUInt32):Boolean; virtual; abstract;
              function LowerIRQ(const aIRQ:TPasRISCVUInt32):Boolean; virtual; abstract;
            end; 
            { TAPLICDevice }
            TAPLICDevice=class(TINTCDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($0cfffffc);
                    DefaultSize=TPasRISCVUInt64($0);
                    DefaultDomainBaseAddressMachine=TPasRISCVUInt64($0c000000);
                    DefaultDomainBaseAddressSupervisor=TPasRISCVUInt64($0d000000);
                    DefaultDomainSize=TPasRISCVUInt64($4000);
                    APLIC_REGION_SIZE=$4000;
                    APLIC_REG_DOMAINCFG=$0000;
                    APLIC_REG_SOURCECFG_1=$0004;
                    APLIC_REG_SOURCECFG_1023=$0ffc;
                    APLIC_REG_MMSIADDRCFG=$1bc0;
                    APLIC_REG_MMSIADDRCFGH=$1bc4;
                    APLIC_REG_SMSIADDRCFG=$1bc8;
                    APLIC_REG_SMSIADDRCFGH=$1bcc;
                    APLIC_REG_SETIP_0=$1c00;
                    APLIC_REG_SETIP_31=$1c7c;
                    APLIC_REG_SETIPNUM=$1cdc;
                    APLIC_REG_IN_CLRIP_0=$1d00;
                    APLIC_REG_IN_CLRIP_31=$1d7c;
                    APLIC_REG_CLRIPNUM=$1ddc;
                    APLIC_REG_SETIE_0=$1e00;
                    APLIC_REG_SETIE_31=$1e7c;
                    APLIC_REG_SETIENUM=$1edc;
                    APLIC_REG_CLRIE_0=$1f00;
                    APLIC_REG_CLRIE_31=$1f7c;
                    APLIC_REG_CLRIENUM=$1fdc;
                    APLIC_REG_SETIPNUM_LE=$2000;
                    APLIC_REG_SETIPNUM_BE=$2004;
                    APLIC_REG_GENMSI=$3000;
                    APLIC_REG_TARGET_1=$3004; 
                    APLIC_REG_TARGET_1023=$3ffc;
                    APLIC_DOMAINCFG_BE=1;
                    APLIC_DOMAINCFG_DM=4;
                    APLIC_DOMAINCFG_IE=256;
                    APLIC_DOMAINCFG=$80000004;
                    APLIC_SOURCECFG_DELEGATE=$400;
                    APLIC_SOURCECFG_INACTIVE=$0;
                    APLIC_SOURCECFG_DETACHED=$1;
                    APLIC_SOURCECFG_EDGE_RISE=$4;
                    APLIC_SOURCECFG_EDGE_FALL=$5;
                    APLIC_SOURCECFG_LVL_HIGH=$6;
                    APLIC_SOURCECFG_LVL_LOW=$7;
                    APLIC_SOURCECFG_MASK=$7;
                    APLIC_MSIADDRCFGH_L=TPasRISCVUInt32($80000000);
                    APLIC_SRC_LIMIT=64;
                    APLIC_SRC_REGS=APLIC_SRC_LIMIT shr 5; 
              type TDomainDevice=class(TBusDevice)
                    private
                     fAPLICDevice:TAPLICDevice;
                     fAIARegFileMode:TPasRISCV.TAIARegFileMode;
                     fDelegationInvert:TPasRISCVUInt32;
                     fRootDomain:Boolean;
                     function ValidBits(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
                     function ValidSrc(const aSrc:TPasRISCVUInt64):Boolean;
                     function UngatedSrc(const aSrc:TPasRISCVUInt64):Boolean;
                     function ReadIP(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
                     function ReadIN(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
                     function ReadIE(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
                     procedure SetIPNum(const aSrc:TPasRISCVUInt64);
                     procedure SetIP(const aReg:TPasRISCVUInt64;const aBits:TPasRISCVUInt32);
                     procedure ClearIP(const aReg:TPasRISCVUInt64;const aBits:TPasRISCVUInt32);
                     procedure ClearIPNum(const aSrc:TPasRISCVUInt64);
                     procedure SetIE(const aReg:TPasRISCVUInt64;const aBits:TPasRISCVUInt32);
                     procedure SetIENum(const aSrc:TPasRISCVUInt64);
                     procedure ClearIE(const aReg:TPasRISCVUInt64;const aBits:TPasRISCVUInt32);
                     procedure ClearIENum(const aSrc:TPasRISCVUInt64);              
                    public
                     constructor Create(const aAPLICDevice:TAPLICDevice;const aBase,aSize:TPasRISCVUInt64;const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aRootDomain:Boolean); reintroduce;
                     destructor Destroy; override;
                     procedure Reset; override;
                     function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
                     procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
                   end;
                   TDomainDevices=array[TPasRISCV.TAIARegFileMode] of TDomainDevice;
                   TDomainCfg=array[TPasRISCV.TAIARegFileMode] of TPasRISCVUInt32;
                   TRegisters=array[0..APLIC_SRC_REGS-1] of TPasRISCVUInt32;
                   TSources=array[0..APLIC_SRC_LIMIT-1] of TPasRISCVUInt32;
             private
              fDomainDevices:TDomainDevices;
              fDomainCfg:TDomainCfg;
              fDelegated:TRegisters;
              fRaised:TRegisters;
              fInvert:TRegisters;
              fPending:TRegisters;
              fEnabled:TRegisters;
              fSource:TSources;
              fTarget:TSources;
              procedure GenerateMSI(const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aTarget:TPasRISCVUInt32);
              function RectifiedBits(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
              function RectifiedSrc(const aSrc:TPasRISCVUInt64):Boolean;
              function DetachedSrc(const aSrc:TPasRISCVUInt64):Boolean;
              procedure NotifyInterrupt(const aSrc:TPasRISCVUInt64);
              procedure EdgeInterrupt(const aSrc:TPasRISCVUInt64);
              procedure UpdateInterrupt(const aSrc:TPasRISCVUInt64);
             public 
              function SendIRQ(const aIRQ:TPasRISCVUInt32):Boolean; override;
              function RaiseIRQ(const aIRQ:TPasRISCVUInt32):Boolean; override;
              function LowerIRQ(const aIRQ:TPasRISCVUInt32):Boolean; override;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TPLICDevice }
            TPLICDevice=class(TINTCDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($0c000000);
                    DefaultSize=TPasRISCVUInt64($208000);
                    SourcePriorityAddress=0;
                    SourcePriorityEndAddress=$fff;
                    PendingAddress=$1000;
                    PendingEndAddress=$107f;
                    EnableAddress=$2000;
                    EnableEndAddress=$1f1fff;
                    ThresholdClaimAddress=$200000;
                    ThresholdClaimEndAddress=$3ffffff;
                    ContextOffset=$1000;
                    ContentMask=$fff;
                    ContentShift=12;
                    PriorityMask=1023;
                    CTXFLAG_THRESHOLD=0;
                    CTXFLAG_COMPLETE=1;
                    PLIC_SOURCE_MAX=1024;
                    PLIC_SRC_REG_COUNT=(PLIC_SOURCE_MAX+$1f) shr 5;
                    PLIC_CONTEXT_MAX=15872;
             private
              fAllocationIRQCounter:TPasRISCVUInt32;
              fCountContexts:TPasRISCVUInt32;
              fPriority:array[0..PLIC_SOURCE_MAX-1] of TPasRISCVUInt32;
              fPending:array[0..PLIC_SRC_REG_COUNT-1] of TPasRISCVUInt32;
              fRaised:array[0..PLIC_SRC_REG_COUNT-1] of TPasRISCVUInt32;
              fEnable:array[0..PLIC_CONTEXT_MAX-1] of array[0..PLIC_SRC_REG_COUNT-1] of TPasRISCVUInt32;
              fThreshold:array[0..PLIC_CONTEXT_MAX-1] of TPasRISCVUInt32;
              function IsIRQPending(const aIRQ:TPasRISCVUInt32):Boolean;
              function IsIRQEnabled(const aContext,aIRQ:TPasRISCVUInt32):Boolean;
              function NotifyContextIRQ(const aContext,aIRQ:TPasRISCVUInt32):Boolean;
              function NotifyIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
              procedure UpdateIRQ(const aIRQ:TPasRISCVUInt32);
              procedure UpdateContextIRQRegister(const aContext,aRegister:TPasRISCVUInt32);
              function UpdateContext(const aContext:TPasRISCVUInt32;const aClaim:Boolean):TPasRISCVUInt32;
              procedure FullUpdate;
              procedure SetIRQPriority(const aIRQ,aPriority:TPasRISCVUInt32);
              procedure SetEnableBits(const aContext,aRegister,aEnable:TPasRISCVUInt32);
              procedure SetContextThreshold(const aContext,aThreshold:TPasRISCVUInt32);
              function ClaimIRQ(const aContext:TPasRISCVUInt32):TPasRISCVUInt32;
              procedure CompleteIRQ(const aContext,aIRQ:TPasRISCVUInt32);
              function AllocateIRQ:TPasRISCVUInt32;
             public
              function SendIRQ(const aIRQ:TPasRISCVUInt32):Boolean; override;
              function RaiseIRQ(const aIRQ:TPasRISCVUInt32):Boolean; override;
              function LowerIRQ(const aIRQ:TPasRISCVUInt32):Boolean; override;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TSYSCONDevice }
            TSYSCONDevice=class(TBusDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($11100000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    PowerOffValue=TPasRISCVUInt64($5555);
                    RebootValue=TPasRISCVUInt64($7777);
             private
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TMemoryDevice }
            TMemoryDevice=class(TBusDevice)
             public
             private
              fData:Pointer;
              fOwnData:Boolean;
              procedure SetSize(const aValue:TPasRISCVUInt64); override;
             public
              constructor Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64;const aData:Pointer=nil;const aOwnData:Boolean=false); reintroduce;
              destructor Destroy; override;
              function GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
              procedure LoadFromStream(const aStream:TStream);
              procedure LoadFromFile(const aFileName:TPasRISCVUTF8String);
              procedure SaveToStream(const aStream:TStream);
              procedure SaveToFile(const aFileName:TPasRISCVUTF8String);
             public
              property Data:Pointer read fData write fData;
              property OwnData:Boolean read fOwnData write fOwnData;
            end;
            TPCIBusDevice=class;
            TPCIDevice=class;
            TPCIFunc=class;
            { TPCIMemoryDevice }
            TPCIMemoryDevice=class(TMemoryDevice)
             public
              type TOnLoad=function(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64 of object;
                   TOnStore=procedure(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64) of object;
             private
              fPCIBusDevice:TPCIBusDevice;
              fPCIDevice:TPCIDevice;
              fPCIFunc:TPCIFunc;
              fOnLoad:TOnLoad;
              fOnStore:TOnStore;
             public
              constructor Create(const aMachine:TPasRISCV;const aPCIDevice:TPCIDevice;const aPCIFunc:TPCIFunc;const aBase,aSize:TPasRISCVUInt64;const aOnLoad:TOnLoad;const aOnStore:TOnStore); reintroduce;
              destructor Destroy; override;
              function GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
             public
              property PCIBusDevice:TPCIBusDevice read fPCIBusDevice;
              property PCIDevice:TPCIDevice read fPCIDevice;
              property PCIFunc:TPCIFunc read fPCIFunc;
              property OnLoad:TOnLoad read fOnLoad write fOnLoad;
              property OnStore:TOnStore read fOnStore write fOnStore;
            end;
            TPCI=class
             public
              const PCI_REG_DEV_VEN_ID=$0;
                    PCI_REG_STATUS_CMD=$4;
                    PCI_REG_CLASS_REV=$8;
                    PCI_REG_BIST_HDR_LATENCY_CACHE=$c;
                    PCI_REG_BAR0=$10;
                    PCI_REG_BAR1=$14;
                    PCI_REG_BAR2=$18;
                    PCI_REG_BAR3=$1c;
                    PCI_REG_BAR4=$20;
                    PCI_REG_BAR5=$24;
                    PCI_REG_SSID_SVID=$2c;
                    PCI_REG_EXPANSION_ROM=$30;
                    PCI_REG_CAP_PTR=$34;
                    PCI_REG_IRQ_PIN_LINE=$3c;
                    PCI_CMD_IO_SPACE=$1;  // Accessible through IO ports
                    PCI_CMD_MEM_SPACE=$2;  // Accessible through MMIO
                    PCI_CMD_BUS_MASTER=$4;  // DMA
                    PCI_CMD_MWI_ENABLE=$10; // Memory Write and Invalidate
                    PCI_CMD_INTX_DISABLE=$400;
                    PCI_STATUS_INTX=$8;
{$ifdef NewPCI}
                    PCI_CMD_DEFAULT=PCI_CMD_IO_SPACE or PCI_CMD_MEM_SPACE or PCI_CMD_BUS_MASTER;// $17;
                    PCI_CMD_MASK=PCI_CMD_IO_SPACE or PCI_CMD_MEM_SPACE or PCI_CMD_BUS_MASTER or PCI_CMD_INTX_DISABLE;
                    PCI_STATUS_CAP=$10;
                    PCI_HEADER_PCI_PCI=$1;
                    PCI_HEADER_MULTIFUNC=$80;
                    PCI_BAR_IO_SPACE=$1;
                    PCI_BAR_64_BIT=$4;
                    PCI_BAR_PREFETCH=$8;
                    PCI_EXPANSION_ROM_ENABLED=$1;
                    PCI_CAP_LIST_OFF=$80;
                    PCI_MSI_CAP_OFF=$c0;
                    PCIE_CAP_PORT_ENDPOINT=$0;
                    PCIE_CAP_ROOT_PORT=$4;
                    PCIE_CAP_UPSTREAM_SWITCH=$5;
                    PCIE_CAP_DOWNSTREAM_SWITCH=$6;
                    PCIE_CAP_INTEGRATED_ENDPOINT=$9;
{$else}
                    PCI_CMD_DEFAULT=$17;
{$endif}
                    PCI_BUS_IRQS=4;
                    PCI_BUS_DEVS=32;
                    PCI_DEV_FUNCS=8;
                    PCI_FUNC_BARS=6;
                    PCI_IRQ_PIN_INTA=1;
                    PCI_IRQ_PIN_INTB=2;
                    PCI_IRQ_PIN_INTC=3;
                    PCI_IRQ_PIN_INTD=4;
                    PCI_BAR_ADDR_64=TPasRISCVUInt64($64646464);
                    PCI_BASE_DEFAULT_MMIO=TPasRISCVUInt64($30000000);
                    PCI_IO_DEFAULT_ADDR=TPasRISCVUInt64($03000000);
                    PCI_IO_DEFAULT_SIZE=TPasRISCVUInt64($00010000);
                    PCI_MEM32_DEFAULT_MMIO=TPasRISCVUInt64($40000000);
                    PCI_MEM32_DEFAULT_SIZE=TPasRISCVUInt64($40000000);
                    PCI_MEM64_DEFAULT_MMIO=TPasRISCVUInt64($4000000000);
                    PCI_MEM64_DEFAULT_SIZE=TPasRISCVUInt64($4000000000);
                    PCI_IRQs:array[0..PCI_BUS_IRQS-1] of TPasRISCVUInt32=($01,$02,$03,$04);
                    PCIExpressCapabilities:array[0..25] of TPasRISCVUInt32=
                     (
                      $0102c010, // [80] PCI Express (v2) Endpoint, IntMsgNum 0
                      $00008002, // DevCap: MaxPayload 512 bytes, RBE+
                      $00002050, // DevCtl: RlxdOrd+
                      $01800d02, // LnkCap: Speed 5GT/s, Width x16
                      $01020003, // LnkSta: Speed 5GT/s, Width x16
                      $00020060,
                      $00200028,
                      $00000000,
                      $00000000,
                      $00000000,
                      $00000000,
                      $00000002,
                      $00000000,
                      $00000000,
                      $00000000,
                      $00000000,
                      $0003d001, // [c0] Power Management version 3
                      $00000008, // NoSoftRst+
                      $00000000,
                      $00000000,
                      $01800005, // [d0] MSI: Enable- Count=1/1 Maskable+ 64bit+
                      $00000000, // Message Address Low
                      $00000000, // Message Address High
                      $00000000, // Message Data
                      $00000000, // Mask
                      $00000000  // Pending
                     );
            end;
            TPCIBARRegion=record
             fAddress:TPasRISCVUInt64;
             fSize:TPasRISCVUInt16;
             fOnLoad:TPCIMemoryDevice.TOnLoad;
             fOnStore:TPCIMemoryDevice.TOnStore;
            end;
            PPCIBARRegion=^TPCIBARRegion;
            TPCIBARRegions=array[0..TPCI.PCI_FUNC_BARS-1] of TPCIBARRegion;
            TPCIBarMemoryDevices=array[0..TPCI.PCI_FUNC_BARS-1] of TPCIMemoryDevice;
            TPCIFuncDescriptor=record
             fVendorID:TPasRISCVUInt16;
             fDeviceID:TPasRISCVUInt16;
             fClassCode:TPasRISCVUInt16;
             fProgIF:TPasRISCVUInt8;
             fRevisionID:TPasRISCVUInt8;
             fIRQPin:TPasRISCVUInt8;
             fBARRegions:TPCIBARRegions;
            end;
            PPCIFuncDescriptor=^TPCIFuncDescriptor;
            TPCIDevDescriptor=record
             fFunc:array[0..TPCI.PCI_DEV_FUNCS-1] of TPCIFuncDescriptor;
            end;
            PPCIDevDescriptor=^TPCIDevDescriptor;
            { TPCIFunc }
            TPCIFunc=class
             public
              fBus:TPCIBusDevice;
              fDevice:TPCIDevice;
              fStatus:TPasRISCVUInt32;
              fCommand:TPasRISCVUInt32;
              fIRQLine:TPasRISCVUInt32;
              fVendorID:TPasRISCVUInt16;
              fDeviceID:TPasRISCVUInt16;
              fClassCode:TPasRISCVUInt16;
              fProgIF:TPasRISCVUInt8;
              fRevisionID:TPasRISCVUInt8;
              fBridgeIO:TPasRISCVUInt32;
              fBridgeMem:TPasRISCVUInt32;
              fIRQPin:TPasRISCVUInt8;
              fBARMemoryDevices:TPCIBarMemoryDevices;
              fExpansionROM:TPCIMemoryDevice;
             public
              constructor Create(const aBus:TPCIBusDevice;const aDevice:TPCIDevice;const aFuncDesc:TPCIFuncDescriptor);
              destructor Destroy; override;
              function IsUpperHalf(const aBarID:TPasRISCVSizeUInt):Boolean;
              function Is64Bit(const aBarID:TPasRISCVSizeUInt):Boolean;
              function GetEffectiveBar(const aBarID:TPasRISCVSizeUInt):TPCIMemoryDevice;
              function GetBARAddress(const aBARSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure SendIRQ(const aMSIID:TPasRISCVUInt32;const aRaiseIRQ:Boolean);
              procedure RaiseIRQ(const aMSIID:TPasRISCVUInt32);
              procedure LowerIRQ; overload;
              procedure LowerIRQ(const aMSIID:TPasRISCVUInt32); overload;
            end;
            TPCIHostBridgeDevice=class;
            { TPCIBusDevice }
            TPCIBusDevice=class(TBusDevice)
             public
              const BusShift=20; // 20 for ECAM (PCIe), 16 for legacy PCI regular CAM
             private
              fIRQs:array[0..TPCI.PCI_BUS_IRQS-1] of TPasRISCVUInt32;
              fDevices:array[0..TPCI.PCI_BUS_DEVS-1] of TPCIDevice;
              fCountDevices:TPasRISCVUInt32;
              fIOAddr:TPasRISCVUInt64;
              fIOSize:TPasRISCVUInt64;
              fMemAddr:TPasRISCVUInt64;
              fMemSize:TPasRISCVUInt64;
              fBusID:TPasRISCVUInt8;
              fHostBridgeDevice:TPCIHostBridgeDevice;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              function GetFunc(const aBus,aDev,aFunc:TPasRISCVUInt32):TPCIFunc;
              class function GetIRQID(const aDeviceID,aIRQPin:TPasRISCVUInt32):TPasRISCVUInt32; static;
              class function PCIFuncIRQPinID(const aFunc:TPCIFunc):TPasRISCVUInt32; static;
              procedure AddBusDevice(const aDevice:TPCIDevice);
              procedure RemoveBusDevice(const aDevice:TPCIDevice);
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TPCIDevice }
            TPCIDevice=class
             public
             private
              fBus:TPCIBusDevice;
              fDeviceID:TPasRISCVUInt16;
              fFuncs:array[0..TPCI.PCI_DEV_FUNCS-1] of TPCIFunc;
             public
              constructor Create(const aBus:TPCIBusDevice); reintroduce;
              destructor Destroy; override;
              procedure Reset; virtual;
              procedure SendIRQ(const aFuncID,aMSIID:TPasRISCVUInt32);
              procedure RaiseIRQ(const aFuncID,aMSIID:TPasRISCVUInt32);
              procedure LowerIRQ(const aFuncID:TPasRISCVUInt32);
              function GetGlobalDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
            end;
            { TPCIHostBridgeDevice }
            TPCIHostBridgeDevice=class(TPCIDevice)
             public
             private
             public
              constructor Create(const aBus:TPCIBusDevice); reintroduce;
              destructor Destroy; override;
            end;
            { TNVMeDevice }
            TNVMeDevice=class(TPCIDevice)
             public
              const Dummy=0;
{                   SSD_VendorID=$1f31; // Nextorage
                    SSD_DeviceID=$4512; // Nextorage NE1N NVMe SSD //}
                    SSD_VendorID=$144d; // Samsung Electronics Co Ltd
                    SSD_DeviceID=$a809; // NVM Express SSD Controller 980 //}
                    NVME_REG_CAP1=$0;   // Controller Capabilities
                    NVME_REG_CAP2=$4;
                    NVME_REG_VS=$8;   // Version
                    NVME_REG_INTMS=$c;   // Interrupt Mask Set
                    NVME_REG_INTMC=$10;  // Interrupt Mask Clear
                    NVME_REG_CC=$14;  // Controller Configuration
                    NVME_REG_CSTS=$1c;  // Controller Status
                    NVME_REG_AQA=$24;  // Admin Queue Attributes
                    NVME_REG_ASQ1=$28;  // Admin Submission Queue Base Address
                    NVME_REG_ASQ2=$2c;
                    NVME_REG_ACQ1=$30;  // Admin Completion Queue Base Address
                    NVME_REG_ACQ2=$34;
                    NVME_MQES=$ffff; // Maximum Queue Entries Supported: 65536
                    NVME_CQR=$1;   // Contiguous Queues Required
                    NVME_TO=$A;   // Timeout: 5s
                    NVME_DSTRD=$0;   // Doorbell Stride (0 means 2-bit shift)
                    NVME_CSS=$1;   // Command Sets Supported (NVM Command Set)
                    NVME_MPMAX=$0;   // Max page size: 4K
                    NVME_IOQES=$46;  // IO Queue Entry Sizes (16b:64b)
                    NVME_LBAS=$9;   // LBA Block Size Shift (512b blocks)
                    NVME_MAX_QUEUES=$10;  // Max Queues: 16 (Admin + IO, Submission & Completion)
                    NVME_FEAT_NQES=TPasRISCVUInt32(TPasRISCVUInt32(NVME_MAX_QUEUES-1) or TPasRISCVUInt32(TPasRISCVUInt32(NVME_MAX_QUEUES-1) shl 16));
                    NVME_PAGE_SIZE=TPasRISCVUInt64($1000);
                    NVME_PAGE_MASK=TPasRISCVUInt64($fff);
                    NVME_PRP2_END=TPasRISCVUInt64($ff8);
                    NVME_NQUEUES=(NVME_MAX_QUEUES+1) shl 1;
                    NVME_CAP1_MQES=TPasRISCVUInt32($0000ffff); // NVME_MQES or (NVME_CQR shl 16) or (NVME_TO shl 24);
                    NVME_CAP1_CQR0=TPasRISCVUInt32($00010000);
                    NVME_CAP1_TO=TPasRISCVUInt32($ff000000);
                    NVME_CAP2_DSTRD=TPasRISCVUInt32($00000000);
                    NVME_CAP2_CSS=TPasRISCVUInt32($00000020);// NVME_DSTRD or (NVME_CSS shl 5) or (NVME_MPMAX shl 20);
                    NVME_VERSION=TPasRISCVUInt32($00010400);
                    NVME_CC_EN=TPasRISCVUInt32($00000001);
                    NVME_CC_SHN=TPasRISCVUInt32($0000c000);
                    NVME_CC_IOQES=TPasRISCVUInt32($00460000);
                    NVME_CSTS_RDY=TPasRISCVUInt32($00000001);
                    NVME_CSTS_SHST=TPasRISCVUInt32($00000008);
                    ADMIN_SUBMISSION_QUEUE=$0;   // Admin Submission Queue
                    ADMIN_COMPLETION_QUEUE=$1;   // Admin Completion Queue
                    ADMIN_DELETE_IO_SQ=$0;   // Delete IO Submission Queue
                    ADMIN_CREATE_IO_SQ=$1;   // Create IO Submission Queue
                    ADMIN_DELETE_IO_CQ=$4;   // Delete IO Completion Queue
                    ADMIN_CREATE_IO_CQ=$5;   // Create IO Completion Queue
                    ADMIN_IDENTIFY=$6;   // Identify
                    ADMIN_ABORT=$8;   // Abort Command
                    ADMIN_SET_FEATURES=$9;   // Set Features
                    ADMIN_GET_FEATURES=$A;   // Get Features
                    CQ_FLAGS_PC=$1; // Physically Contiguous
                    CQ_FLAGS_IEN=$2; // Interrupts Enabled
                    IDENT_NS=$0;   // Identify Namespace
                    IDENT_CTRL=$1;   // Identify Controller
                    IDENT_NSLS=$2;   // Identify Namespace List
                    IDENT_NIDS=$3;   // Identify Namespace Descriptors
                    FEAT_ARBITRATION=$1; // Arbitration
                    FEAT_POWER_MGMT=$2; // Power Management
                    FEAT_TEMP_THRESH=$4; // Temperature Threshold
                    FEAT_ERROR_RECOV=$5; // Error Recovery
                    FEAT_VOLATILE_WC=$6; // Volatile Write Cache
                    FEAT_NUM_QUEUES=$7; // Number of Queues
                    FEAT_IRQ_COALESC=$8; // Interrupt Coalescing
                    FEAT_IRQ_VECTOR=$9; // Interrupt Vector Configuration
                    FEAT_WR_ATOMIC=$a; // Write Atomicity Normal
                    FEAT_ASYNC_EVENT=$b; // Asynchronous Event Configuration
                    NVM_FLUSH=$0;
                    NVM_WRITE=$1;
                    NVM_READ=$2;
                    NVM_WRITEZ=$8;   // Write Zeroes
                    NVM_DTSM=$9;   // Dataset Management
                    SC_SUCCESS=$00;   // Successful Completion
                    SC_BAD_OPCODE=$01;   // Invalid Command Opcode
                    SC_BAD_FIELD=$02;   // Invalid Field in Command
                    SC_DATA_ERR=$04;   // Data Transfer Error
                    SC_ABORT=$07;   // Command Abort Requested
                    SC_SQ_DELETED=$08; // Command Aborted due to SQ Deletion
                    SC_FEAT_NSAVE=$0d; // Feature Identifier Not Saveable
                    SC_FEAT_NCHG=$0e; // Feature Identifier Not Changeable
                    SC_LBA_RANGE=$80; // LBA Out of Range
                    CS_CQ_INVALID=$00; // Invalid Completion Queue
                    CS_ID_INVALID=$01; // Invalid Queue ID
                    CS_SIZE_INVALID=$02;  // Invalid Queue size
              type TNVMeQueue=record
                    public
                     AddressLow:TPasRISCVUInt32;
                     AddressHigh:TPasRISCVUInt32;
                     Size:TPasRISCVUInt32;
                     Head:TPasRISCVUInt32;
                     Tail:TPasRISCVUInt32;
                     CompletionQueueID:TPasRISCVUInt32;
                     IRQ:TPasRISCVUInt32;
                     class function GetNext(var aHeadOrTail:TPasRISCVUInt32;const aSize:TPasRISCVUInt32):TPasRISCVUInt32; static;
                     function GetAddress:TPasRISCVUInt64;
                     procedure RaiseIRQ(const aNVMEDevice:TNVMEDevice);
                     procedure LowerIRQ(const aNVMEDevice:TNVMEDevice);
                     procedure Setup(const aNVMEDevice:TNVMEDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt32);
                   end;
                   PNVMeQueue=^TNVMeQueue;
                   TNVMePRPCtx=record
                    PRP1:TPasRISCVUInt64;
                    PRP2:TPasRISCVUInt64;
                    PRP2DMA:Pointer;
                    PRP2Offset:TPasRISCVUInt64;
                    Size:TPasRISCVUInt64;
                    Current:TPasRISCVUInt64;
                   end;
                   PNVMePRPCtx=^TNVMePRPCtx;
                   TNVMeCommand=record
                    Ptr:Pointer;
                    PRP:TNVMePRPCtx;
                    CmdID:TPasRISCVUInt32;
                    SqHeadID:TPasRISCVUInt32;
                    CompletionQueueID:TPasRISCVUInt32;
                    CommandSpecificStatus:TPasRISCVUInt32;
                   end;
                   PNVMeCommand=^TNVMeCommand;
             private
              fThreads:TPasRISCVUInt32;
              fConf:TPasRISCVUInt32;
              fIRQMask:TPasRISCVUInt32;
              fSerial:array[0..11] of TPasRISCVRawByteChar;
              fQueues:array[0..NVME_NQUEUES-1] of TNVMeQueue;
              fStreamLock:TPasMPSlimReaderWriterLock;
              fStream:TStream;
             public
              constructor Create(const aBus:TPCIBusDevice); reintroduce;
              destructor Destroy; override;
              procedure ResetDevice;
              procedure CompleteCommand(const aCommand:PNVMeCommand;const aStatusField:TPasRISCVUInt32); overload;
              procedure CompleteCommand(const aCommand:PNVMeCommand;const aStatusField,aCommandSpecificStatus:TPasRISCVUInt32); overload;
              function ProcessPRPChunk(const aCommand:PNVMeCommand):TPasRISCVUInt64;
              function GetPRPChunk(const aCommand:PNVMeCommand;out aSize:TPasRISCVUInt64):Pointer;
              function WritePRP(const aCommand:PNVMeCommand;const aData:Pointer;const aSize:TPasRISCVUInt64):Boolean;
              procedure Identify(const aCommand:PNVMeCommand);
              procedure CreateIOSubmissionQueue(const aCommand:PNVMeCommand);
              procedure CreateIOCompletionQueue(const aCommand:PNVMeCommand);
              procedure DeleteIOQueue(const aCommand:PNVMeCommand;const aIsCompletionQueue:Boolean);
              procedure AdminCommand(const aCommand:PNVMeCommand);
              procedure IOCommand(const aCommand:PNVMeCommand);
              procedure ProcessCommand(const aCommand:TNVMeDeviceCommand);
              procedure ProcessQueue(const aSubmissionQueueID:TPasRISCVUInt32;const aValue:TPasRISCVUInt16;const aLocking:Boolean);
              procedure Doorbell(const aQueueID:TPasRISCVUInt32;const aValue:TPasRISCVUInt16);
              function OnLoad(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure OnStore(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
              procedure AttachStream(const aStream:TStream);
              procedure LoadFromStream(const aStream:TStream);
              procedure LoadFromFile(const aFileName:TPasRISCVUTF8String);
              procedure SaveToStream(const aStream:TStream);
              procedure SaveToFile(const aFileName:TPasRISCVUTF8String);
            end;
            { TVirtIODevice }
            TVirtIODevice=class(TBusDevice)
             public
              const VRING_DESC_F_NEXT=1;
                    VRING_DESC_F_WRITE=2;
                    VRING_DESC_F_INDIRECT=4;
                    MAXIMUM_COUNT_QUEUES=8;
                    MAXIMUM_QUEUE_SIZE=1024;
                    MAX_CONFIG_SPACE_SIZE=256;
                    VIRTIO_PAGE_SIZE=4096;
                    VIRTIO_MMIO_MAGIC_VALUE=$000;
                    VIRTIO_MMIO_VERSION=$004;
                    VIRTIO_MMIO_DEVICE_ID=$008;
                    VIRTIO_MMIO_VENDOR_ID=$00c;
                    VIRTIO_MMIO_DEVICE_FEATURES=$010;
                    VIRTIO_MMIO_DEVICE_FEATURES_SEL=$014;
                    VIRTIO_MMIO_DRIVER_FEATURES=$020;
                    VIRTIO_MMIO_DRIVER_FEATURES_SEL=$024;
                    VIRTIO_MMIO_GUEST_PAGE_SIZE=$028;
                    VIRTIO_MMIO_QUEUE_SEL=$030;
                    VIRTIO_MMIO_QUEUE_NUM_MAX=$034;
                    VIRTIO_MMIO_QUEUE_NUM=$038;
                    VIRTIO_MMIO_QUEUE_ALIGN=$03c;
                    VIRTIO_MMIO_QUEUE_PFN=$040;
                    VIRTIO_MMIO_QUEUE_READY=$044;
                    VIRTIO_MMIO_QUEUE_NOTIFY=$050;
                    VIRTIO_MMIO_INTERRUPT_STATUS=$060;
                    VIRTIO_MMIO_INTERRUPT_ACK=$064;
                    VIRTIO_MMIO_STATUS=$070;
                    VIRTIO_MMIO_QUEUE_DESC_LOW=$080;
                    VIRTIO_MMIO_QUEUE_DESC_HIGH=$084;
                    VIRTIO_MMIO_QUEUE_AVAIL_LOW=$090;
                    VIRTIO_MMIO_QUEUE_AVAIL_HIGH=$094;
                    VIRTIO_MMIO_QUEUE_USED_LOW=$0a0;
                    VIRTIO_MMIO_QUEUE_USED_HIGH=$0a4;
                    VIRTIO_MMIO_CONFIG_GENERATION=$0fc;
                    VIRTIO_MMIO_CONFIG=$100;
                    VIRTIO_PCI_DEVICE_FEATURE_SEL=$000;
                    VIRTIO_PCI_DEVICE_FEATURE=$004;
                    VIRTIO_PCI_DRIVER_FEATURE_SEL=$008;
                    VIRTIO_PCI_DRIVER_FEATURE=$00c;
                    VIRTIO_PCI_MSIX_CONFIG=$010;
                    VIRTIO_PCI_NUM_QUEUES=$012;
                    VIRTIO_PCI_DEVICE_STATUS=$014;
                    VIRTIO_PCI_CONFIG_GENERATION=$015;
                    VIRTIO_PCI_QUEUE_SEL=$016;
                    VIRTIO_PCI_QUEUE_SIZE=$018;
                    VIRTIO_PCI_QUEUE_MSIX_VECTOR=$01a;
                    VIRTIO_PCI_QUEUE_ENABLE=$01c;
                    VIRTIO_PCI_QUEUE_NOTIFY_OFF=$01e;
                    VIRTIO_PCI_QUEUE_DESC_LOW=$020;
                    VIRTIO_PCI_QUEUE_DESC_HIGH=$024;
                    VIRTIO_PCI_QUEUE_AVAIL_LOW=$028;
                    VIRTIO_PCI_QUEUE_AVAIL_HIGH=$02c;
                    VIRTIO_PCI_QUEUE_USED_LOW=$030;
                    VIRTIO_PCI_QUEUE_USED_HIGH=$034;
                    VIRTIO_PCI_CFG_OFFSET=$0000;
                    VIRTIO_PCI_ISR_OFFSET=$1000;
                    VIRTIO_PCI_CONFIG_OFFSET=$2000;
                    VIRTIO_PCI_NOTIFY_OFFSET=$3000;
                    VIRTIO_PCI_CAP_LEN=16;
                    VIRTIO_CONFIG_S_ACKNOWLEDGE=1;
                    VIRTIO_CONFIG_S_DRIVER=2;
                    VIRTIO_CONFIG_S_DRIVER_OK=4;
                    VIRTIO_CONFIG_S_FEATURES_OK=8;
                    VIRTIO_CONFIG_S_FAILED=128;
                    VIRTIO_TRANSPORT_F_START=28;
                    VIRTIO_TRANSPORT_F_END=32;
                    VIRTQ_AVAIL_F_NO_INTERRUPT=1;
                    VIRTQ_USED_F_NO_NOTIFY=1;
                    VIRTIO_F_NOTIFY_ON_EMPTY=TPasRISCVUInt64(1) shl 24;
                    VIRTIO_F_INDIRECT_DESC=TPasRISCVUInt64(1) shl 28;
                    VIRTIO_F_EVENT_IDX=TPasRISCVUInt64(1) shl 29;
                    VIRTIO_F_VERSION_1=TPasRISCVUInt64(1) shl 32;
                    VIRTIO_F_ACCESS_PLATFORM=TPasRISCVUInt64(1) shl 33;
                    VIRTIO_F_RING_PACKED=TPasRISCVUInt64(1) shl 34;
                    VIRTIO_F_IN_ORDER=TPasRISCVUInt64(1) shl 35;
                    VIRTIO_F_ORDER_PLATFORM=TPasRISCVUInt64(1) shl 36;
                    VIRTIO_F_SR_IOV=TPasRISCVUInt64(1) shl 37;
                    VIRTIO_F_NOTIFICATION_DATA=TPasRISCVUInt64(1) shl 38;
                    VIRTIO_F_NOTIF_CONFIG_DATA=TPasRISCVUInt64(1) shl 39;
                    VIRTIO_F_RING_RESET=TPasRISCVUInt64(1) shl 40;
                    VIRTIO_F_ADMIN_VQ=TPasRISCVUInt64(1) shl 41;
                    VIRTIO_STATUS_ACKNOWLEDGE=TPasRISCVUInt32(1) shl 0;
                    VIRTIO_STATUS_DRIVER=TPasRISCVUInt32(1) shl 1;
                    VIRTIO_STATUS_DRIVER_OK=TPasRISCVUInt32(1) shl 2;
                    VIRTIO_STATUS_FEATURES_OK=TPasRISCVUInt32(1) shl 3;
                    VIRTIO_STATUS_DEVICE_NEEDS_RESET=TPasRISCVUInt32(1) shl 6;
                    VIRTIO_STATUS_FAILED=TPasRISCVUInt32(1) shl 7;
                    VIRTIO_INT_STATUS_USED_BUFFER=TPasRISCVUInt32(1) shl 0;
                    VIRTIO_INT_STATUS_CONFIG_CHANGE=TPasRISCVUInt32(1) shl 1;
              type TKind=
                    (
                     MMIO,
                     PCI
                    );
                   PKind=^TKind;
                   TQueueDescriptor=record
                    public
                     DescriptorIndex:TPasRISCVUInt32;
                     Offset:TPasRISCVUInt32;
                     Size:TPasRISCVUInt32;
                     Padding:TPasRISCVUInt32;
                   end;
                   PQueueDescriptor=^TQueueDescriptor;
                   TQueueDescriptors=array of TQueueDescriptor;
                   TQueue=record
                    public
                     Ready:TPasMPBool32;
                     Lock:TPasMPInt32;
                     Size:TPasRISCVUInt32;
                     UsedRingEvent:TPasMPBool32;
                     ShadowAvailableIndex:TPasRISCVUInt16;
                     ShadowUsedIndex:TPasRISCVUInt16;
                     DescriptorAddress:TPasRISCVUInt64;
                     AvailableAddress:TPasRISCVUInt64;
                     UsedAddress:TPasRISCVUInt64;
                     ManualRecv:TPasMPBool32;
                     Asynchronous:TPasMPBool32;
                     ReadDescriptors:TQueueDescriptors;
                     WriteDescriptors:TQueueDescriptors;
                     CountReadDescriptors:TPasRISCVSizeInt;
                     CountWriteDescriptors:TPasRISCVSizeInt;
                   end;
                   PQueue=^TQueue;
                   TQueues=array[0..MAXIMUM_COUNT_QUEUES-1] of TQueue;
                   PQueues=^TQueues;
                   TVirtIODescriptor=packed record
                    Address:TPasRISCVUInt64;
                    Len:TPasRISCVUInt32;
                    Flags:TPasRISCVUInt16;
                    Next:TPasRISCVUInt16;
                   end;
                   PVirtIODescriptor=^TVirtIODescriptor;
                   TConfigSpace=array[0..MAX_CONFIG_SPACE_SIZE-1] of TPasRISCVUInt8;
             private
              fKind:TKind;
              fUseQueueDescriptorCaching:Boolean;
              fIRQ:TPasRISCVUInt32;
              fIntStatus:TPasMPUInt32;
              fStatus:TPasRISCVUInt32;
              fDeviceFeatures:TPasRISCVUInt64;
              fDriverFeatures:TPasRISCVUInt64;
              fActiveFeatures:TPasRISCVUInt64;
              fDeviceFeaturesSelected:TPasRISCVUInt64;
              fDriverFeaturesSelected:TPasRISCVUInt64;
              fSelectedQueue:TPasRISCVUInt32;
              fQueues:TQueues;
              fDeviceID:TPasRISCVUInt32;
              fVendorID:TPasRISCVUInt32;
              fConfigSpaceSize:TPasRISCVUInt32;
              fConfigSpace:TConfigSpace;
              fDriverOK:Boolean;
             public
              constructor Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64;const aKind:TVirtIODevice.TKind); reintroduce;
              destructor Destroy; override;
              procedure DeviceReset; virtual;
              procedure DeviceDriverOK; virtual;
              procedure DeviceConfigWrite; virtual;
              procedure DeviceInitialize; virtual;
              function DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean; virtual;
              function Read8(const aPhysicalAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt8):Boolean;
              function Write8(const aPhysicalAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt8):Boolean;
              function Read16(const aPhysicalAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt16):Boolean;
              function Write16(const aPhysicalAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt16):Boolean;
              function Read32(const aPhysicalAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt32):Boolean;
              function Write32(const aPhysicalAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt32):Boolean;
              function Read64(const aPhysicalAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt64):Boolean;
              function Write64(const aPhysicalAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64):Boolean;
              function CopyMemoryFromRAM(const aBuf:Pointer;const aPhysicalAddress:TPasRISCVUInt64;const aCount:TPasRISCVUInt64):Boolean;
              function CopyMemoryToRAM(const aPhysicalAddress:TPasRISCVUInt64;const aBuf:Pointer;const aCount:TPasRISCVUInt64):Boolean;
              function GetDescriptor(const aDescriptor:PVirtIODescriptor;const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64):Boolean;
              function CopyMemoryFromToQueue(const aBuf:Pointer;const aQueueIndex,aDescriptorIndex,aOffset,aCount:TPasRISCVUInt64;const aToQueue:Boolean):Boolean;
              function CopyMemoryFromQueue(const aBuf:Pointer;const aQueueIndex,aDescriptorIndex,aOffset,aCount:TPasRISCVUInt64):Boolean;
              function CopyMemoryToQueue(const aQueueIndex,aDescriptorIndex,aOffset:TPasRISCVUInt64;const aBuf:Pointer;const aCount:TPasRISCVUInt64):Boolean;
              function ConsumeDescriptor(const aQueueIndex,aDescriptorIndex,aDescriptorLength:TPasRISCVUInt64):Boolean;
              function UsedRingSync(const aQueueIndex:TPasRISCVUInt64):Boolean;
              function GetDescriptors(out aReadSize,aWriteSize:TPasRISCVUInt64;const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64):Boolean;
              function AdvanceShadowAvailableIndex(const aQueueIndex:TPasRISCVUInt64):Boolean;
              procedure ProcessQueue(const aQueueIndex:TPasRISCVUInt64;const aAvailableIndex:TPasRISCVInt64);
              procedure QueueNotify(const aQueueIndex:TPasRISCVUInt64);
              procedure UpdateIRQ;
              procedure SetIRQ(const aValue:TPasRISCVUInt32);
              procedure NotifyQueueUsed;
              procedure NotifyDeviceNeedsReset;
              procedure NotifyConfigChange;
              function ConfigRead(const aOffset:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure ConfigWrite(const aOffset:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
              procedure SetStatus(const aStatus:TPasRISCVUInt32);
              function MMIORead(const aOffset:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure MMIOWrite(const aOffset:TPasRISCVUInt64;const aValue:TPasRISCVUInt32;const aSize:TPasRISCVUInt64);
              function PCIRead(const aOffset:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure PCIWrite(const aOffset:TPasRISCVUInt64;const aValue:TPasRISCVUInt32;const aSize:TPasRISCVUInt64);
              procedure Reset; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TVirtIOBlockDevice }
            TVirtIOBlockDevice=class(TVirtIODevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10050000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    DefaultIRQ=TPasRISCVUInt64($10);
                    DeviceID=$02;
                    Vendor=TPasRISCVUInt32($554d4551);
                    VIRTIO_BLK_F_BARRIER=TPasRISCVUInt64(1) shl 0; // Does host support barriers?
                    VIRTIO_BLK_F_SIZE_MAX=TPasRISCVUInt64(1) shl 1; // Indicates maximum segment size
                    VIRTIO_BLK_F_SEG_MAX=TPasRISCVUInt64(1) shl 2; // Indicates maximum # of segments
                    VIRTIO_BLK_F_GEOMETRY=TPasRISCVUInt64(1) shl 4; // Legacy geometry available
                    VIRTIO_BLK_F_RO=TPasRISCVUInt64(1) shl 5; // Disk is read-only
                    VIRTIO_BLK_F_BLK_SIZE=TPasRISCVUInt64(1) shl 6;  // Block size of disk is available
                    VIRTIO_BLK_F_SCSI=TPasRISCVUInt64(1) shl 7; // Supports scsi command passthru
                    VIRTIO_BLK_F_WCE=TPasRISCVUInt64(1) shl 9; // Writeback mode enabled after reset
                    VIRTIO_BLK_F_TOPOLOGY=TPasRISCVUInt64(1) shl 10; // Topology information is available
                    VIRTIO_BLK_F_CONFIG_WCE=TPasRISCVUInt64(1) shl 11; // Writeback mode available in config
                    VIRTIO_BLK_F_MQ=TPasRISCVUInt64(1) shl 12; // Device supports multiqueue
                    VIRTIO_BLK_F_DISCARD=TPasRISCVUInt64(1) shl 13;
                    VIRTIO_BLK_F_WRITE_ZEROES=TPasRISCVUInt64(1) shl 14;
                    VIRTIO_BLK_F_LIFETIME=TPasRISCVUInt64(1) shl 15;
                    VIRTIO_BLK_F_SECURE_ERASE=TPasRISCVUInt64(1) shl 16;
                    VIRTIO_BLK_F_ZONED=TPasRISCVUInt64(1) shl 17;
                    VIRTIO_BLK_F_FLUSH=VIRTIO_BLK_F_WCE;
                    VIRTIO_BLK_T_IN=0;
                    VIRTIO_BLK_T_OUT=1;
                    VIRTIO_BLK_T_SCSI=2;
                    VIRTIO_BLK_T_FLUSH=4;
                    VIRTIO_BLK_T_FLUSH_OUT=5;
                    VIRTIO_BLK_T_GET_ID=8;
                    VIRTIO_BLK_T_GET_LIFETIME=10;
                    VIRTIO_BLK_T_DISCARD=11;
                    VIRTIO_BLK_T_WRITE_ZEROES=13;
                    VIRTIO_BLK_T_SECURE_ERASE=14;
                    VIRTIO_BLK_S_OK=0;
                    VIRTIO_BLK_S_IOERR=1;
                    VIRTIO_BLK_S_UNSUPP=2;
                    SECTOR_SIZE=512;
              type TVirtIOBlkGeometry=packed record
                    Cylinders:TPasRISCVUInt16;
                    Heads:TPasRISCVUInt8;
                    Sectors:TPasRISCVUInt8;
                   end;
                   PVirtIOBlkGeometry=^TVirtIOBlkGeometry;
                   TVirtIOBlkTopology=packed record
                    PhysicalBlockExp:TPasRISCVUInt8;
                    AlignmentOffset:TPasRISCVUInt8;
                    MinIOSize:TPasRISCVUInt16;
                    OptIOSize:TPasRISCVUInt32;
                   end;
                   PVirtIOBlkTopology=^TVirtIOBlkTopology;
                   TVirtIOBlkZonedCharacteristics=packed record
                    ZoneSectors:TPasRISCVUInt32;
                    MaxOpenZones:TPasRISCVUInt32;
                    MaxActiveZones:TPasRISCVUInt32;
                    MaxAppendSectors:TPasRISCVUInt32;
                    WriteGranularity:TPasRISCVUInt32;
                    Model:TPasRISCVUInt8;
                   end;
                   PVirtIOBlkZonedCharacteristics=^TVirtIOBlkZonedCharacteristics;
                   TVirtIOBlkConfig=packed record
                    Capacity:TPasRISCVUInt64;
                    SizeMax:TPasRISCVUInt32;
                    SegMax:TPasRISCVUInt32;
                    Geometry:TVirtIOBlkGeometry;
                    BlkSize:TPasRISCVUInt32;
                    Topology:TVirtIOBlkTopology;
                    Writeback:TPasRISCVUInt8;
                    Unused0:TPasRISCVUInt8;
                    NumQueues:TPasRISCVUInt16;
                    MaxDiscardSectors:TPasRISCVUInt32;
                    MaxDiscardSeg:TPasRISCVUInt32;
                    DiscardSectorAlignment:TPasRISCVUInt32;
                    MaxWriteZeroesSectors:TPasRISCVUInt32;
                    MaxWriteZeroesSeg:TPasRISCVUInt32;
                    WriteZeroesMayUnmap:TPasRISCVUInt8;
                    Unused1:array[0..2] of TPasRISCVUInt8;
                    MaxSecureEraseSectors:TPasRISCVUInt32;
                    MaxSecureEraseSeg:TPasRISCVUInt32;
                    SecureEraseSectorAlignment:TPasRISCVUInt32;
                    Zoned:TVirtIOBlkZonedCharacteristics;
                   end;
                   PVirtIOBlkConfig=^TVirtIOBlkConfig;
                   TVirtIOBlkDiscardWriteZeroes=packed record
                    Sector:TPasRISCVUInt64;
                    CountSectors:TPasRISCVUInt32;
                    Flags:TPasRISCVUInt32;
                   end;
                   PVirtIOBlkDiscardWriteZeroes=^TVirtIOBlkDiscardWriteZeroes;
                   TBlockRequestHeader=packed record
                    Type_:TPasRISCVUInt32;
                    IOPrio:TPasRISCVUInt32;
                    SectorIndex:TPasRISCVUInt64;
                   end;
                   PBlockRequestHeader=^TBlockRequestHeader;
             private
              fStreamLock:TPasMPSlimReaderWriterLock;
              fStream:TStream;
              fCountSectors:TPasRISCVUInt64;
              fConfig:TVirtIOBlkConfig;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure DeviceReset; override;
              procedure DeviceConfigWrite; override;
              function ImageRead(const aSectorIndex:TPasRISCVUInt64;const aBuf:Pointer;const aCount:TPasRISCVUInt64):Boolean;
              function ImageWrite(const aSectorIndex:TPasRISCVUInt64;const aBuf:Pointer;const aCount:TPasRISCVUInt64):Boolean;
              function DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean; override;
              procedure AttachStream(const aStream:TStream);
              procedure LoadFromStream(const aStream:TStream);
              procedure LoadFromFile(const aFileName:TPasRISCVUTF8String);
              procedure SaveToStream(const aStream:TStream);
              procedure SaveToFile(const aFileName:TPasRISCVUTF8String);
            end;
            { TVirtIOInputDevice }
            TVirtIOInputDevice=class(TVirtIODevice)
             public
              const DefaultSize=TPasRISCVUInt64($1000);
                    VIRTIO_INPUT_CFG_UNSET=$00;
                    VIRTIO_INPUT_CFG_ID_NAME=$01;
                    VIRTIO_INPUT_CFG_ID_SERIAL=$02;
                    VIRTIO_INPUT_CFG_ID_DEVIDS=$03;
                    VIRTIO_INPUT_CFG_PROP_BITS=$10;
                    VIRTIO_INPUT_CFG_EV_BITS=$11;
                    VIRTIO_INPUT_CFG_ABS_INFO=$12;
                    VIRTIO_INPUT_EV_SYN=$00;
                    VIRTIO_INPUT_EV_KEY=$01;
                    VIRTIO_INPUT_EV_REL=$02;
                    VIRTIO_INPUT_EV_ABS=$03;
                    VIRTIO_INPUT_EV_REP=$14;
                    VIRTIO_INPUT_ABS_SCALE=32768;
                    BTN_LEFT=$110;
                    BTN_RIGHT=$111;
                    BTN_MIDDLE=$112;
                    BTN_GEAR_DOWN=$150;
                    BTN_GEAR_UP=$151;
                    REL_X=$00;
                    REL_Y=$01;
                    REL_Z=$02;
                    REL_WHEEL=$08;
                    ABS_X=$00;
                    ABS_Y=$01;
                    ABS_Z=$02;
                    ButtonList:array[0..2] of TPasRISCVUInt16=(BTN_LEFT,BTN_RIGHT,BTN_MIDDLE);
                    Vendor=$ffff;
                    DeviceID=$12;
              type TInputKind=
                    (
                     Keyboard,
                     Mouse,
                     Tablet
                    );
                   TKind=TInputKind;
                   PKind=^TKind;
             private
              fKind:TKind;
              fButtonState:TPasRISCVUInt32;
             public
              constructor Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64;const aKind:TVirtIOInputDevice.TKind); reintroduce;
              destructor Destroy; override;
              function HandleKeyboard(const aKeyCode:TPasRISCVUInt16;const aDown:Boolean):Boolean;
              function HandleMouse(const aDX,aDY,aDZ:TPasRISCVInt32;const aButtons:TPasRISCVUInt32):Boolean;
              procedure DeviceReset; override;
              function DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean; override;
              function QueueEvent(const aType,aCode:TPasRISCVUInt16;const aValue:TPasRISCVUInt32):Boolean;
              procedure DeviceConfigWrite; override;
            end;
            TVirtIOInputKeyboardDevice=class(TVirtIOInputDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10051000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    DefaultIRQ=TPasRISCVUInt64($11);
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              procedure DeviceInitialize; override;
            end;
            TVirtIOInputMouseDevice=class(TVirtIOInputDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10052000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    DefaultIRQ=TPasRISCVUInt64($12);
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              procedure DeviceInitialize; override;
            end;
            { TVirtIOSoundDevice }
            TVirtIOSoundDevice=class(TVirtIODevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10054000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    DefaultIRQ=TPasRISCVUInt64($14);
                    DeviceID=25;
                    VIRTIO_SOUND_VM_VERSION=1;
                    VIRTIO_SOUND_JACK_DEFAULT=0;
                    VIRTIO_SOUND_STREAM_DEFAULT=2;
                    VIRTIO_SOUND_CHMAP_DEFAULT=0;
                    VIRTIO_SOUND_HDA_FN_NID=0;
                    VIRTIO_SND_VQ_CONTROL=0;
                    VIRTIO_SND_VQ_EVENT=1;
                    VIRTIO_SND_VQ_TX=2;
                    VIRTIO_SND_VQ_RX=3;
                    VIRTIO_SND_VQ_MAX=4;
                    VIRTIO_SND_D_OUTPUT=0;
                    VIRTIO_SND_D_INPUT=1;
                    VIRTIO_SND_R_JACK_INFO=1;
                    VIRTIO_SND_R_JACK_REMAP=2;
                    VIRTIO_SND_R_PCM_INFO=$100;
                    VIRTIO_SND_R_PCM_SET_PARAMS=$101;
                    VIRTIO_SND_R_PCM_PREPARE=$102;
                    VIRTIO_SND_R_PCM_RELEASE=$103;
                    VIRTIO_SND_R_PCM_START=$104;
                    VIRTIO_SND_R_PCM_STOP=$105;
                    VIRTIO_SND_R_CHMAP_INFO=$200;
                    VIRTIO_SND_EVT_JACK_CONNECTED=$1000;
                    VIRTIO_SND_EVT_JACK_DISCONNECTED=$1001;
                    VIRTIO_SND_EVT_PCM_PERIOD_ELAPSED=$1100;
                    VIRTIO_SND_EVT_PCM_XRUN=$1101;
                    VIRTIO_SND_S_OK=$8000;
                    VIRTIO_SND_S_BAD_MSG=$8001;
                    VIRTIO_SND_S_NOT_SUPP=$8002;
                    VIRTIO_SND_S_IO_ERR=$8003;
                    VIRTIO_SND_PCM_F_SHMEM_HOST=0;
                    VIRTIO_SND_PCM_F_SHMEM_GUEST=1;
                    VIRTIO_SND_PCM_F_MSG_POLLING=2;
                    VIRTIO_SND_PCM_F_EVT_SHMEM_PERIODS=3;
                    VIRTIO_SND_PCM_F_EVT_XRUNS=4;
                    VIRTIO_SND_JACK_F_REMAP=0;
                    VIRTIO_SND_PCM_FMT_IMA_ADPCM=0; //  4 /  4 bits
                    VIRTIO_SND_PCM_FMT_MU_LAW=1; //  8 /  8 bits
                    VIRTIO_SND_PCM_FMT_A_LAW=2; //  8 /  8 bits
                    VIRTIO_SND_PCM_FMT_S8=3; //  8 /  8 bits
                    VIRTIO_SND_PCM_FMT_U8=4; //  8 /  8 bits
                    VIRTIO_SND_PCM_FMT_S16=5; // 16 / 16 bits
                    VIRTIO_SND_PCM_FMT_U16=6; // 16 / 16 bits
                    VIRTIO_SND_PCM_FMT_S18_3=7; // 18 / 24 bits
                    VIRTIO_SND_PCM_FMT_U18_3=8; // 18 / 24 bits
                    VIRTIO_SND_PCM_FMT_S20_3=9; // 20 / 24 bits
                    VIRTIO_SND_PCM_FMT_U20_3=10; // 20 / 24 bits
                    VIRTIO_SND_PCM_FMT_S24_3=11; // 24 / 24 bits
                    VIRTIO_SND_PCM_FMT_U24_3=12; // 24 / 24 bits
                    VIRTIO_SND_PCM_FMT_S20=13; // 20 / 32 bits
                    VIRTIO_SND_PCM_FMT_U20=14; // 20 / 32 bits
                    VIRTIO_SND_PCM_FMT_S24=15; // 24 / 32 bits
                    VIRTIO_SND_PCM_FMT_U24=16; // 24 / 32 bits
                    VIRTIO_SND_PCM_FMT_S32=17; // 32 / 32 bits
                    VIRTIO_SND_PCM_FMT_U32=18; // 32 / 32 bits
                    VIRTIO_SND_PCM_FMT_FLOAT=19; // 32 / 32 bits
                    VIRTIO_SND_PCM_FMT_FLOAT64=20; // 64 / 64 bits
                    VIRTIO_SND_PCM_FMT_DSD_U8=21; //  8 /  8 bits
                    VIRTIO_SND_PCM_FMT_DSD_U16=22; // 16 / 16 bits
                    VIRTIO_SND_PCM_FMT_DSD_U32=23; // 32 / 32 bits
                    VIRTIO_SND_PCM_FMT_IEC958_SUBFRAME=24; // 32 / 32 bits
                    VIRTIO_SND_PCM_RATE_5512=0;
                    VIRTIO_SND_PCM_RATE_8000=1;
                    VIRTIO_SND_PCM_RATE_11025=2;
                    VIRTIO_SND_PCM_RATE_16000=3;
                    VIRTIO_SND_PCM_RATE_22050=4;
                    VIRTIO_SND_PCM_RATE_32000=5;
                    VIRTIO_SND_PCM_RATE_44100=6;
                    VIRTIO_SND_PCM_RATE_48000=7;
                    VIRTIO_SND_PCM_RATE_64000=8;
                    VIRTIO_SND_PCM_RATE_88200=9;
                    VIRTIO_SND_PCM_RATE_96000=10;
                    VIRTIO_SND_PCM_RATE_176400=11;
                    VIRTIO_SND_PCM_RATE_192000=12;
                    VIRTIO_SND_PCM_RATE_384000=13;
                    VIRTIO_SND_CHMAP_NONE=0; // undefined
                    VIRTIO_SND_CHMAP_NA=1; // silent
                    VIRTIO_SND_CHMAP_MONO=2; // mono stream
                    VIRTIO_SND_CHMAP_FL=3; // front left
                    VIRTIO_SND_CHMAP_FR=4; // front right
                    VIRTIO_SND_CHMAP_RL=5; // rear left
                    VIRTIO_SND_CHMAP_RR=6; // rear right
                    VIRTIO_SND_CHMAP_FC=7; // front center
                    VIRTIO_SND_CHMAP_LFE=8; // low frequency (LFE)
                    VIRTIO_SND_CHMAP_SL=9; // side left
                    VIRTIO_SND_CHMAP_SR=10; // side right
                    VIRTIO_SND_CHMAP_RC=11; // rear center
                    VIRTIO_SND_CHMAP_FLC=12; // front left center
                    VIRTIO_SND_CHMAP_FRC=13; // front right center
                    VIRTIO_SND_CHMAP_RLC=14; // rear left center
                    VIRTIO_SND_CHMAP_RRC=15; // rear right center
                    VIRTIO_SND_CHMAP_FLW=16; // front left wide
                    VIRTIO_SND_CHMAP_FRW=17; // front right wide
                    VIRTIO_SND_CHMAP_FLH=18; // front left high
                    VIRTIO_SND_CHMAP_FCH=19; // front center high
                    VIRTIO_SND_CHMAP_FRH=20; // front right high
                    VIRTIO_SND_CHMAP_TC=21; // top center
                    VIRTIO_SND_CHMAP_TFL=22; // top front left
                    VIRTIO_SND_CHMAP_TFR=23; // top front right
                    VIRTIO_SND_CHMAP_TFC=24; // top front center
                    VIRTIO_SND_CHMAP_TRL=25; // top rear left
                    VIRTIO_SND_CHMAP_TRR=26; // top rear right
                    VIRTIO_SND_CHMAP_TRC=27; // top rear center
                    VIRTIO_SND_CHMAP_TFLC=28; // top front left center
                    VIRTIO_SND_CHMAP_TFRC=29; // top front right center
                    VIRTIO_SND_CHMAP_TSL=30; // top side left
                    VIRTIO_SND_CHMAP_TSR=31; // top side right
                    VIRTIO_SND_CHMAP_LLFE=32; // left LFE
                    VIRTIO_SND_CHMAP_RLFE=33; // right LFE
                    VIRTIO_SND_CHMAP_BC=34; // bottom center
                    VIRTIO_SND_CHMAP_BLC=35; // bottom left center
                    VIRTIO_SND_CHMAP_BRC=36; // bottom right center
                    VIRTIO_SND_CHMAP_MAX_SIZE=18;
                    SupportedFormats=TPasRISCVUInt64(
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_S8) or
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_U8) or
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_S16) or
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_U16) or
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_S24) or
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_U24) or
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_S32) or
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_U32) or
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_FLOAT)
                                     );
                    SupportedRates=TPasRISCVUInt64(
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_5512) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_8000) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_11025) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_16000) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_22050) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_32000) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_44100) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_48000) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_64000) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_88200) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_96000) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_176400) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_192000) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_384000)
                                    );
                    SampleRates:array[0..13] of TPasRISCVUInt32=(5512,8000,11025,16000,22050,32000,44100,48000,64000,88200,96000,176400,192000,384000);
              type TVirtIOSoundConfig=packed record
                    Jacks:TPasRISCVUInt32;
                    Streams:TPasRISCVUInt32;
                    ChannelMaps:TPasRISCVUInt32;
                    Controls:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundConfig=^TVirtIOSoundConfig;
                   TVirtIOSoundHeader=packed record
                    Code:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundHeader=^TVirtIOSoundHeader;
                   TVirtIOSoundEvent=packed record
                    Header:TVirtIOSoundHeader;
                    Data:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundEvent=^TVirtIOSoundEvent;
                   TVirtIOSoundQueryInfo=packed record
                    Header:TVirtIOSoundHeader;
                    StartID:TPasRISCVUInt32;
                    Count:TPasRISCVUInt32;
                    Size:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundQueryInfo=^TVirtIOSoundQueryInfo;
                   TVirtIOSoundInfo=packed record
                    HDAFunctionGroupNodeID:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundInfo=^TVirtIOSoundInfo;
                   TVirtIOSoundJackHeader=packed record
                    Header:TVirtIOSoundHeader;
                    JackID:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundJackHeader=^TVirtIOSoundJackHeader;
                   TVirtIOSoundJackInfo=packed record
                    Header:TVirtIOSoundInfo;
                    Features:TPasRISCVUInt32;
                    HDARegDefConfig:TPasRISCVUInt32;
                    HDARegCaps:TPasRISCVUInt32;
                    Connected:TPasRISCVUInt8;
                    Padding:array[0..6] of TPasRISCVUInt8;
                   end;
                   PVirtIOSoundJackInfo=^TVirtIOSoundJackInfo;
                   TVirtIOSoundJackInfos=array of TVirtIOSoundJackInfo;
                   TVirtIOSoundJackRemap=packed record
                    Header:TVirtIOSoundJackHeader;
                    Association:TPasRISCVUInt32;
                    Sequence:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundJackRemap=^TVirtIOSoundJackRemap;
                   TVirtIOSoundPCMHeader=packed record
                    Header:TVirtIOSoundHeader;
                    StreamID:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundPCMHeader=^TVirtIOSoundPCMHeader;
                   TVirtIOSoundPCMInfo=packed record
                    Header:TVirtIOSoundInfo;
                    Features:TPasRISCVUInt32;
                    Formats:TPasRISCVUInt64;
                    Rates:TPasRISCVUInt64;
                    Direction:TPasRISCVUInt8;
                    ChannelsMin:TPasRISCVUInt8;
                    ChannelsMax:TPasRISCVUInt8;
                    Padding:array[0..4] of TPasRISCVUInt8;
                   end;
                   PVirtIOSoundPCMInfo=^TVirtIOSoundPCMInfo;
                   TVirtIOSoundPCMSetParams=packed record
                    Header:TVirtIOSoundPCMHeader;
                    BufferBytes:TPasRISCVUInt32;
                    PeriodBytes:TPasRISCVUInt32;
                    Features:TPasRISCVUInt32;
                    Channels:TPasRISCVUInt8;
                    Format:TPasRISCVUInt8;
                    Rate:TPasRISCVUInt8;
                    Padding:TPasRISCVUInt8;
                   end;
                   PVirtIOSoundPCMSetParams=^TVirtIOSoundPCMSetParams;
                   TVirtIOSoundPCMXfer=packed record
                    StreamID:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundPCMXfer=^TVirtIOSoundPCMXfer;
                   TVirtIOSoundPCMStatus=packed record
                    Status:TPasRISCVUInt32;
                    LatencyBytes:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundPCMStatus=^TVirtIOSoundPCMStatus;
                   TVirtIOSoundChMapHeader=packed record
                    Header:TVirtIOSoundHeader;
                    ChannelMapID:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundChMapHeader=^TVirtIOSoundChMapHeader;
                   TVirtIOSoundChMapInfo=packed record
                    Header:TVirtIOSoundInfo;
                    Direction:TPasRISCVUInt8;
                    Channels:TPasRISCVUInt8;
                    Positions:array[0..VIRTIO_SND_CHMAP_MAX_SIZE-1] of TPasRISCVUInt8;
                   end;
                   PVirtIOSoundChMapInfo=^TVirtIOSoundChMapInfo;
                   { TPCMBuffer }
                   TPCMBuffer=class
                    private
                     fDevice:TVirtIOSoundDevice;
                     fRawSize:TPasRISCVUInt64;
                     fRemainingSize:TPasRISCVUInt64;
                     fOffset:TPasRISCVUInt64;
                     fAvailableIndex:TPasRISCVInt64;
                     fPopulated:Boolean;
                     fData:TPasRISCVUInt8DynamicArray;
                     fFloatData:TPasRISCVFloatDynamicArray;
                     fResampledFloatData:TPasRISCVFloatDynamicArray;
                    public
                     constructor Create(const aDevice:TVirtIOSoundDevice); reintroduce;
                     destructor Destroy; override;
                     procedure Clear;
                   end;
                   TPCMBufferQueue=TPasRISCVDynamicQueue<TPCMBuffer>;
                   TPCMStream=class;
                   TPCMStreams=array of TPCMStream;
                   TVirtIOSoundPCMSetParamsArray=array of TVirtIOSoundPCMSetParams;
                   TPCMRingBuffer=TPasMPSingleProducerSingleConsumerRingBuffer;
                   { TPCMStream }
                   TPCMStream=class
                    public
                     type TCommand=
                           (
                            None,
                            SetParameters,
                            Prepare,
                            Start,
                            Stop,
                            Release
                           );
                     const STATE_NONE=0;
                    private
                     fDevice:TVirtIOSoundDevice;
                     fParams:TVirtIOSoundPCMSetParams;
                     fPositions:array[0..VIRTIO_SND_CHMAP_MAX_SIZE-1] of TPasRISCVUInt8;
                     fCommand:TCommand;
                     fActive:TPasMPBool32;
                     fFlushing:TPasMPBool32;
                     fCurrentBuffer:TPCMBuffer;
                     fLock:TPasMPCriticalSection;
                     fBufferQueueLock:TPasMPCriticalSection;
                     fBufferQueue:TPCMBufferQueue;
                     fBufferFreeQueue:TPCMBufferQueue;
                     fPCMRingBuffer:TPCMRingBuffer;
                     fPreviousFrameEndValues:array[0..1] of TPasRISCVFloat;
                     fResamplerPosition:TPasRISCVUInt64;
                    public
                     procedure ReturnBuffer(const aPCMBuffer:TPCMBuffer;const aLock:Boolean);
                   end;
                   TVirtIOSndControlCommand=record
                    private
                     fCtrl:TVirtIOSoundHeader;
                     fResp:TVirtIOSoundHeader;
                     fPayloadSize:PVirtIOSoundHeader;
                   end;
                   PVirtIOSndControlCommand=^TVirtIOSndControlCommand;
             private
              fSampleRate:TPasRISCVUInt64;
              fSoundConfig:TVirtIOSoundConfig;
              fCommandQueueLock:TPasMPCriticalSection;
              fPCMStreams:TPCMStreams;
              fTXScratchBuffer:TPasRISCVFloatDynamicArray;
              fRXScratchBuffer:TPasRISCVFloatDynamicArray;
              fOutputWAVStreamDump:TPasRISCVAudioWAVStreamDump;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function SetParams(const aStreamID:TPasRISCVUInt32;const aParams:TVirtIOSoundPCMSetParams):TPasRISCVUInt32;
              procedure DeviceReset; override;
              function DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean; override;
              procedure FreeBufferQueue(var aBufferQueue:TPCMBufferQueue);
              procedure NotifyTXBuffer(const aPCMBuffer:TPCMBuffer);
              procedure FlushTX;
              procedure FlushRX;
              procedure OutputAudioFillBufferCallback(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
              procedure InputAudioFillBufferCallback(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
             public
              property SampleRate:TPasRISCVUInt64 read fSampleRate write fSampleRate;
            end;
            { TVirtIO9PDevice }
            TVirtIO9PDevice=class(TVirtIODevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10055000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    DefaultIRQ=TPasRISCVUInt64($1);
                    DeviceID=9;
                    VIRTIO_9P_MOUNT_TAG=1;
                    VIRTIO_9P_MOUNT=2;
                    VIRTIO_9P_UNMOUNT=3;
                    VIRTIO_9P_ERROR=4;
                    VIRTIO_9P_STATFS=8;
                    VIRTIO_9P_LOPEN=12;
                    VIRTIO_9P_LCREATE=14;
                    VIRTIO_9P_SYMLINK=16;
                    VIRTIO_9P_MKNOD=18;
                    VIRTIO_9P_READLINK=22;
                    VIRTIO_9P_GETATTR=24;
                    VIRTIO_9P_SETATTR=26;
                    VIRTIO_9P_XATTRWALK=30;
                    VIRTIO_9P_READDIR=40;
                    VIRTIO_9P_FSYNC=50;
                    VIRTIO_9P_LOCK=52;
                    VIRTIO_9P_GETLOCK=54;
                    VIRTIO_9P_LINK=70;
                    VIRTIO_9P_MKDIR=72;
                    VIRTIO_9P_RENAMEAT=74;
                    VIRTIO_9P_UNLINKAT=76;
                    VIRTIO_9P_VERSION=100;
                    VIRTIO_9P_ATTACH=104;
                    VIRTIO_9P_FLUSH=108;
                    VIRTIO_9P_WALK=110;
                    VIRTIO_9P_READ=116;
                    VIRTIO_9P_WRITE=118;
                    VIRTIO_9P_CLUNK=120;
              type { TFIDDescriptor }
                   TFIDDescriptor=class
                    private
                     fDevice:TVirtIO9PDevice;
                     fPrevious:TFIDDescriptor;
                     fNext:TFIDDescriptor;
                     fFID:TPasRISCVUInt32;
                     fFile:TPasRISCV9PFileSystem.TFSFile;
                    public
                   end;
                   TFIDDescriptorHashMap=TPasRISCVHashMap<TPasRISCVUInt32,TFIDDescriptor>;
                   { TFIDDescriptors }
                   TFIDDescriptors=class
                    private
                     fDevice:TVirtIO9PDevice;
                     fLock:TPasMPMultipleReaderSingleWriterLock;
                     fFirst:TFIDDescriptor;
                     fLast:TFIDDescriptor;
                     fHashMap:TFIDDescriptorHashMap;
                    public
                     constructor Create(const aDevice:TVirtIO9PDevice);
                     destructor Destroy; override;
                     function Add(const aFID:TPasRISCVUInt32;const aFile:TPasRISCV9PFileSystem.TFSFile):TFIDDescriptor;
                     function Remove(const aFID:TPasRISCVUInt32):TFIDDescriptor;
                     function Find(const aFID:TPasRISCVUInt32):TFIDDescriptor;
                   end;
                   TOpenInfo=record
                    QueueIndex:TPasRISCVUInt64;
                    DescriptorIndex:TPasRISCVUInt64;
                    Tag:TPasRISCVUInt16;
                   end;
                   POpenInfo=^TOpenInfo;
             private
              fFileSystem:TPasRISCV9PFileSystem;
              fMaximumMessageSize:TPasRISCVUInt32;
              fFIDDescriptors:TFIDDescriptors;
              fRequestInProcess:TPasMPBool32;
              fLock:TPasMPCriticalSection;
              fRecvBuffer:TPasRISCVUInt8DynamicArray;
              fSendBuffer:TPasRISCVUInt8DynamicArray;
              fTempBuffer:TPasRISCVUInt8DynamicArray;
              class function Get9POperationName(const aOperation:TPasRISCVUInt32):TPasRISCVRawByteString; static;
              procedure SendReply(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aID:TPasRISCVUInt8;const aTag:TPasRISCVUInt16;const aPayload:Pointer;const aPayloadSize:TPasRISCVUInt32);
              procedure SendError(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aTag:TPasRISCVUInt16;const aError:TPasRISCVInt32);
              procedure OpenReply(const aQID:TPasRISCV9PFileSystem.PFSQID;const aError:TPasRISCVInt32;const aOpenInfo:POpenInfo);
              procedure OpenCallback(const aFileSystem:TPasRISCV9PFileSystem;const aQID:TPasRISCV9PFileSystem.PFSQID;const aError:TPasRISCVUInt32;const aOpaque:Pointer);
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure DeviceReset; override;
              function DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean; override;
             public
              property FileSystem:TPasRISCV9PFileSystem read fFileSystem write fFileSystem;
            end;
            { TVirtIONetDevice }
            TVirtIONetDevice=class(TVirtIODevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10056000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    DefaultIRQ=TPasRISCVUInt64($16);
                    DeviceID=1;
                    VIRTIO_NET_F_CSUM=TPasRISCVUInt64(1) shl 0;
                    VIRTIO_NET_F_GUEST_CSUM=TPasRISCVUInt64(1) shl 1;
                    VIRTIO_NET_F_CTRL_GUEST_OFFLOADS=TPasRISCVUInt64(1) shl 2;
                    VIRTIO_NET_F_MTU=TPasRISCVUInt64(1) shl 3;
                    VIRTIO_NET_F_MAC=TPasRISCVUInt64(1) shl 5;
                    VIRTIO_NET_F_GUEST_TSO4=TPasRISCVUInt64(1) shl 7;
                    VIRTIO_NET_F_GUEST_TSO6=TPasRISCVUInt64(1) shl 8;
                    VIRTIO_NET_F_GUEST_ECN=TPasRISCVUInt64(1) shl 9;
                    VIRTIO_NET_F_GUEST_UFO=TPasRISCVUInt64(1) shl 10;
                    VIRTIO_NET_F_HOST_TSO4=TPasRISCVUInt64(1) shl 11;
                    VIRTIO_NET_F_HOST_TSO6=TPasRISCVUInt64(1) shl 12;
                    VIRTIO_NET_F_HOST_ECN=TPasRISCVUInt64(1) shl 13;
                    VIRTIO_NET_F_HOST_UFO=TPasRISCVUInt64(1) shl 14;
                    VIRTIO_NET_F_MRG_RXBUF=TPasRISCVUInt64(1) shl 15;
                    VIRTIO_NET_F_STATUS=TPasRISCVUInt64(1) shl 16;
                    VIRTIO_NET_F_CTRL_VQ=TPasRISCVUInt64(1) shl 17;
                    VIRTIO_NET_F_CTRL_RX=TPasRISCVUInt64(1) shl 18;
                    VIRTIO_NET_F_CTRL_VLAN=TPasRISCVUInt64(1) shl 19;
                    VIRTIO_NET_F_CTRL_RX_EXTRA=TPasRISCVUInt64(1) shl 20;
                    VIRTIO_NET_F_GUEST_ANNOUNCE=TPasRISCVUInt64(1) shl 21;
                    VIRTIO_NET_F_MQ=TPasRISCVUInt64(1) shl 22;
                    VIRTIO_NET_F_CTRL_MAC_ADDR=TPasRISCVUInt64(1) shl 23;
                    VIRTIO_NET_F_HASH_TUNNEL=TPasRISCVUInt64(1) shl 51;
                    VIRTIO_NET_F_VQ_NOTF_COAL=TPasRISCVUInt64(1) shl 52;
                    VIRTIO_NET_F_NOTF_COAL=TPasRISCVUInt64(1) shl 53;
                    VIRTIO_NET_F_GUEST_USO4=TPasRISCVUInt64(1) shl 54;
                    VIRTIO_NET_F_GUEST_USO6=TPasRISCVUInt64(1) shl 55;
                    VIRTIO_NET_F_HOST_USO=TPasRISCVUInt64(1) shl 56;
                    VIRTIO_NET_F_HASH_REPORT=TPasRISCVUInt64(1) shl 57;
                    VIRTIO_NET_F_GUEST_HDRLEN=TPasRISCVUInt64(1) shl 59;
                    VIRTIO_NET_F_RSS=TPasRISCVUInt64(1) shl 60;
                    VIRTIO_NET_F_RSC_EXT=TPasRISCVUInt64(1) shl 61;
                    VIRTIO_NET_F_STANDBY=TPasRISCVUInt64(1) shl 62;
                    VIRTIO_NET_F_SPEED_DUPLEX=TPasRISCVUInt64(1) shl 63;
                    VIRTIO_NET_HDR_F_NEEDS_CSUM=1;
                    VIRTIO_NET_HDR_F_DATA_VALID=2;
                    VIRTIO_NET_HDR_GSO_NONE=0;
                    VIRTIO_NET_HDR_GSO_TCPV4=1;
                    VIRTIO_NET_HDR_GSO_UDP=3;
                    VIRTIO_NET_HDR_GSO_TCPV6=4;
                    VIRTIO_NET_HDR_GSO_ECN=$80;
              type TVirtIONetHeader=packed record
                    Flags:TPasRISCVUInt8;
                    GSOType:TPasRISCVUInt8;
                    HDRLen:TPasRISCVUInt16;
                    GSOSize:TPasRISCVUInt16;
                    CSumStart:TPasRISCVUInt16;
                    CSumOffset:TPasRISCVUInt16;
                    NumBuffers:TPasRISCVUInt16;
                   end;
                   PVirtIONetHeader=^TVirtIONetHeader;
              const HeaderSize=SizeOf(TVirtIONetHeader);
             private
              fEthernetDevice:TPasRISCVEthernetDevice;
              fSendBuffer:TPasRISCVUInt8DynamicArray;
              fReceiveBuffer:TPasRISCVUInt8DynamicArray;
              function CanWritePacket:Boolean;
              procedure WritePacket(const aBuffer:Pointer;const aBufferSize:TPasRISCVSizeInt);
              procedure SetCarrier(const aCarrierStatus:Boolean);
              procedure SetEthernetDevice(const aEthernetDevice:TPasRISCVEthernetDevice);
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure DeviceReset; override;
              function DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean; override;
             public
              property EthernetDevice:TPasRISCVEthernetDevice read fEthernetDevice write SetEthernetDevice;
            end;
            { TVirtIORandomGeneratorDevice }
            TVirtIORandomGeneratorDevice=class(TVirtIODevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10057000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    DefaultIRQ=TPasRISCVUInt64($17);
                    DeviceID=4;
             private
              fSendBuffer:TPasRISCVUInt8DynamicArray;
              fReceiveBuffer:TPasRISCVUInt8DynamicArray;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure DeviceReset; override;
              function DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean; override;
            end;
            { TUARTDevice }
            TUARTDevice=class(TBusDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10000000);
                    DefaultSize=TPasRISCVUInt64($100);
                    DefaultIRQ=TPasRISCVUInt64($0a);
                    rhr=0;
                    thr=0;
                    dll=0;
                    ier=1;
                    dlm=1;
                    isr=2;
                    fcr=2;
                    lcr=3;
                    mcr=4;
                    lsr=5;
                    msr=6;
                    scr=7;
                    lsr_dr=$1;
                    lsr_thre=$20;
                    lsr_temt=$40;
                    ier_rdi=$01;
                    ier_thri=$02;
                    lcr_dlab=$80;
                    isr_no_int=$01;
                    isr_thri=$02;
                    isr_rdi=$04;
                    iir_none=$01;
                    iir_thr=$02;
                    iir_recv=$04;
                    iir_fifo=$c0;
              type TCharQueue=TPasMPSingleProducerSingleConsumerBoundedQueue<AnsiChar>;
{$if defined(PasRISCVUseRealConsole)}
                   { TUARTInputThread }
                   TUARTInputThread=class(TPasMPThread)
{$if defined(Windows) and not defined(fpc)}
                    private
                     fConsoleInputHandle:Windows.THANDLE;
{$ifend}
                    private
                     fUARTDevice:TUARTDevice;
                     fEvent:TEvent;
                    protected
                     procedure Execute; override;
                    public
                     constructor Create(const aUARTDevice:TUARTDevice); reintroduce;
                     destructor Destroy; override;
                     procedure Shutdown;
                   end;
                   { TUARTOutputThread }
                   TUARTOutputThread=class(TPasMPThread)
                    private
                     fUARTDevice:TUARTDevice;
                     fEvent:TEvent;
                     fBuffer:Array[0..4095] of AnsiChar;
{$if defined(Windows) and not defined(fpc)}
                     fConsoleOutputHandle:Windows.THANDLE;
{$ifend}
                    protected
                     procedure Execute; override;
                    public
                     constructor Create(const aUARTDevice:TUARTDevice); reintroduce;
                     destructor Destroy; override;
                     procedure Shutdown;
                   end;
{$ifend}
             private
              fIRQ:TPasRISCVUInt64;
              fDLL:TPasRISCVUInt32;
              fDLM:TPasRISCVUInt32;
              fISR:TPasRISCVUInt32;
              fIER:TPasRISCVUInt32;
              fFCR:TPasRISCVUInt32;
              fLCR:TPasRISCVUInt32;
              fMCR:TPasRISCVUInt32;
              fMSR:TPasRISCVUInt32;
              fSCR:TPasRISCVUInt32;
              fInputQueue:TCharQueue;
              fOutputRingBuffer:TPasMPSingleProducerSingleConsumerRingBuffer;
{$if defined(PasRISCVUseRealConsole)}
{$if defined(fpc) and defined(Unix)}
              fOriginalTerm:TTermios;
{$ifend}
              fUARTInputThread:TUARTInputThread;
              fUARTOutputThread:TUARTOutputThread;
{$else}
              fOutputEvent:TPasMPEvent;
{$ifend}
              function Poll:TPasRISCVUInt32;
              function ReadChar:TPasRISCVUInt32;
              procedure WriteChar(const aValue:TPasRISCVUInt32);
              procedure DispatchInterrupt(const aFlags:TPasRISCVUInt32);
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
              procedure Notify;
             public
              property InputQueue:TCharQueue read fInputQueue;
              property OutputRingBuffer:TPasMPSingleProducerSingleConsumerRingBuffer read fOutputRingBuffer;
{$if not defined(PasRISCVUseRealConsole)}
              property OutputEvent:TPasMPEvent read fOutputEvent;
{$ifend}
            end;
            { TDS1742Device } // DS1742 RTC
            TDS1742Device=class(TBusDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($101000);
                    DefaultSize=TPasRISCVUInt64($8);
                    REG_CTL_CENT=$0; // Control, Century
                    REG_SECONDS=$1;  // Seconds [0, 59]
                    REG_MINUTES=$2;  // Minutes [0, 59]
                    REG_HOURS=$3;    // Hours [0, 23]
                    REG_DAY=$4;      // Day of week [1, 7]
                    REG_DATE=$5;     // Day of month [1, 31]
                    REG_MONTH=$6;    // Month [1, 12]
                    REG_YEAR=$7;     // Year [0, 99]
                    DAY_BATT=$80;    // Battery OK
                    CTL_READ=$40;    // Lock registers for read
                    CTL_MASK=$c0;    // Mask of control registers
             private
              fCtl:TPasRISCVUInt8;
              fRegisters:array[0..7] of TPasRISCVUInt8;
              class function ConvertBCD(const aValue:TPasRISCVUInt8):TPasRISCVUInt8; static;
              class function ConvertFromBCD(const aValue:TPasRISCVUInt8):TPasRISCVUInt8; static;
              procedure UpdateRegisters;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TFrameBufferDevice }
            TFrameBufferDevice=class(TBusDevice)
             public
              const FrameReadyAddress=0;
                    ActiveAddress=4;
                    ResolutionAddress=8;
                    BytesPerPixelAddress=12;
                    WidthAddress=16;
                    HeightAddress=20;
                    FrameBufferAddress=$1000;
             private
              fLock:TPasMPMultipleReaderSingleWriterLock;
              fActive:Boolean;
              fAutomaticRefresh:Boolean;
              fWidth:TPasRISCVUInt32;
              fHeight:TPasRISCVUInt32;
              fBytesPerPixel:TPasRISCVUInt32;
              fData:TPasRISCVUInt8DynamicArray;
{$ifdef FrameBufferDeviceDirtyMarking}
              fDirty:TPasMPBool32;
{$endif}
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure ResizeFrameBuffer;
              procedure ClearFrameBuffer;
              function CheckDirtyAndFlush:Boolean;
              function GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
             public
              property Data:TPasRISCVUInt8DynamicArray read fData write fData;
              property Active:Boolean read fActive write fActive;
              property AutomaticRefresh:Boolean read fAutomaticRefresh write fAutomaticRefresh;
              property Width:TPasRISCVUInt32 read fWidth;
              property Height:TPasRISCVUInt32 read fHeight;
              property BytesPerPixel:TPasRISCVUInt32 read fBytesPerPixel;
              property Lock:TPasMPMultipleReaderSingleWriterLock read fLock;
{$ifdef FrameBufferDeviceDirtyMarking}
              property Dirty:TPasMPBool32 read fDirty write fDirty;
{$endif}
            end;
            { TRawKeyboardDevice }
            TRawKeyboardDevice=class(TBusDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10008000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    CountKeyCodes=1024;
                    CountModifiers=8;
                    MOD_SHIFT=TPasRISCVUInt64(1) shl 0;
                    MOD_CTRL=TPasRISCVUInt64(1) shl 1;
                    MOD_ALT=TPasRISCVUInt64(1) shl 2;
                    MOD_GUI=TPasRISCVUInt64(1) shl 3;
                    MOD_CAPS=TPasRISCVUInt64(1) shl 4;
                    MOD_NUM=TPasRISCVUInt64(1) shl 5;
                    MOD_SCROLL=TPasRISCVUInt64(1) shl 6;
                    KeyArraySize=(CountKeyCodes+7) shr 3;
                    KeyArraySizeMask=KeyArraySize-1;
                    KeyArrayAddress=0;
                    ModifiersAddress=KeyArraySize;
                    ModifiersSize=(CountModifiers+7) shr 3;
              type TData=array[0..(KeyArraySize+ModifiersSize)-1] of TPasRISCVUInt8;
                   PData=^TData;
             private
              fData:TData;
              fPointerToData:PData;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
              procedure KeyDown(const aKeyCode:TPasRISCVUInt64);
              procedure KeyUp(const aKeyCode:TPasRISCVUInt64);
              procedure ModifierDown(const aModifier:TPasRISCVUInt64);
              procedure ModifierUp(const aModifier:TPasRISCVUInt64);
             public
              property Data:PData read fPointerToData;
            end;
            TI2CDevice=class;
            { TI2CBusDevice }
            TI2CBusDevice=class
             private
              fMachine:TPasRISCV;
              fI2CDevice:TI2CDevice;
              fIndex:TPasRISCVSizeInt;
              fAddress:TPasRISCVUInt16;
             public
              constructor Create(const aI2CDevice:TI2CDevice); reintroduce; virtual;
              destructor Destroy; override;
              function Start(const aIsWrite:Boolean):Boolean; virtual;
              procedure Stop; virtual;
              function Read(out aValue:TPasRISCVUInt8):Boolean; virtual;
              function Write(const aValue:TPasRISCVUInt8):Boolean; virtual;
            end;
            TI2CBusDevices=array of TI2CBusDevice;
            TI2CBusDeviceAddressMap=array[TPasRISCVUInt16] of TI2CBusDevice;
            { TI2CHIDBusDevice }
            TI2CHIDBusDevice=class(TI2CBusDevice)
             public
              const wHIDDescLength=0;
                    bcdVersion=1;
                    wReportDescLength=2;
                    wReportDescRegister=3;
                    wInputRegister=4;
                    wMaxInputLength=5;
                    wOutputRegister=6;
                    wMaxOutputLength=7;
                    wCommandRegister=8;
                    wDataRegister=9;
                    wVendorID=10;
                    wProductID=11;
                    wVersionID=12;
                    DESC_REG=1;
                    REPORT_REG=2;
                    INPUT_REG=3;
                    OUTPUT_REG=4;
                    COMMAND_REG=5;
                    DATA_REG=6;
                    COMMAND_RESET=1;
                    COMMAND_GET_REPORT=2;
                    COMMAND_SET_REPORT=3;
                    COMMAND_GET_IDLE=4;
                    COMMAND_SET_IDLE=5;
                    COMMAND_GET_PROTOCOL=6;
                    COMMAND_SET_PROTOCOL=7;
                    COMMAND_SET_POWER=8;
                    REPORT_TYPE_INPUT=1;
                    REPORT_TYPE_OUTPUT=2;
                    REPORT_TYPE_FEATURE=3;
                    HID_PROTOCOL_BOOT=0;
                    HID_PROTOCOL_REPORT=1;
                    HID_POWER_ON=0;
                    HID_POWER_SLEEP=1;
              type { TReportIDQueue }
                   TReportIDQueue=record
                    private
                     fFirst:TPasRISCVInt16;
                     fLast:TPasRISCVInt16;
                     fList:array[TPasRISCVUInt8] of TPasRISCVInt16;
                    public
                     procedure Initialize;
                     procedure Insert(const aReportID:TPasRISCVUInt8);
                     function Get:TPasRISCVInt16;
                     procedure RemoveAt(const aReportID:TPasRISCVUInt8);
                   end;
                   PReportIDQueue=^TReportIDQueue;
             private
              fLock:TPasMPSlimReaderWriterLock;
              fIRQ:TPasRISCVUInt32;
              fReportIDQueue:TReportIDQueue;
              fIsWrite:Boolean;
              fIOOffset:TPasRISCVInt32;
              fRegister:TPasRISCVUInt16;
              fCommand:TPasRISCVUInt8;
              fReportType:TPasRISCVUInt8;
              fReportID:TPasRISCVUInt8;
              fDataSize:TPasRISCVUInt16;
              fDataValue:TPasRISCVUInt16;
              fIsReset:Boolean;
              fReportDescriptor:TPasRISCVUInt8DynamicArray;
              fMaxInputSize:TPasRISCVUInt16;
              fMaxOutputSize:TPasRISCVUInt16;
              fVendorID:TPasRISCVUInt16;
              fProductID:TPasRISCVUInt16;
              fVersionID:TPasRISCVUInt16;
             public
              constructor Create(const aI2CDevice:TI2CDevice); override;
              destructor Destroy; override;
              procedure HIDReset; virtual;
              procedure HIDInputAvailable(const aReportID:TPasRISCVUInt8); virtual;
              procedure HIDReadReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;out aValue:TPasRISCVUInt8); virtual;
              procedure HIDWriteReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8); virtual;
              procedure HIDGetIdle(const aReportID:TPasRISCVUInt8;out aIdle:TPasRISCVUInt16); virtual;
              procedure HIDSetIdle(const aReportID:TPasRISCVUInt8;const aIdle:TPasRISCVUInt16); virtual;
              procedure HIDGetProtocol(out aProtocol:TPasRISCVUInt16); virtual;
              procedure HIDSetProtocol(const aProtocol:TPasRISCVUInt16); virtual;
              procedure HIDSetPower(const aPower:TPasRISCVUInt16); virtual;
              procedure Reset(const aIsInit:Boolean);
              procedure InputAvailable(const aReportID:TPasRISCVUInt8);
              function ReadDataSize(const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8):Boolean;
              procedure ReadReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;out aValue:TPasRISCVUInt8);
              function WriteReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8):Boolean;
              function ReadRegister(const aRegister:TPasRISCVUInt16;const aOffset:TPasRISCVUInt32):TPasRISCVUInt8;
              function WriteRegister(const aRegister:TPasRISCVUInt16;const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8):Boolean;
              function Start(const aIsWrite:Boolean):Boolean; override;
              procedure Stop; override;
              function Read(out aValue:TPasRISCVUInt8):Boolean; override;
              function Write(const aValue:TPasRISCVUInt8):Boolean; override;
            end;
            { TI2CHIDKeyboardBusDevice }
            TI2CHIDKeyboardBusDevice=class(TI2CHIDBusDevice)
             public
              const Address=1;
                    IRQ=TPasRISCVUInt64($0c);
                    CountMaximumPressedKeys=6;
                    ReportDescriptor:array[0..62] of TPasRISCVUInt8=
                     (
                      $05,$01,     // Usage Page (Generic Desktop)
                      $09,$06,     // Usage (Keyboard)
                      $a1,$01,     // Collection (Application)
                      $75,$01,     //   Report Size (1)
                      $95,$08,     //   Report Count (8)
                      $05,$07,     //   Usage Page (Key Codes)
                      $19,$e0,     //   Usage Minimum (224)
                      $29,$e7,     //   Usage Maximum (231)
                      $15,$00,     //   Logical Minimum (0)
                      $25,$01,     //   Logical Maximum (1)
                      $81,$02,     //   Input (Data, Variable, Absolute)
                      $95,$01,     //   Report Count (1)
                      $75,$08,     //   Report Size (8)
                      $81,$01,     //   Input (Constant)
                      $95,$05,     //   Report Count (5)
                      $75,$01,     //   Report Size (1)
                      $05,$08,     //   Usage Page (LEDs)
                      $19,$01,     //   Usage Minimum (1)
                      $29,$05,     //   Usage Maximum (5)
                      $91,$02,     //   Output (Data, Variable, Absolute)
                      $95,$01,     //   Report Count (1)
                      $75,$03,     //   Report Size (3)
                      $91,$01,     //   Output (Constant)
                      $95,$06,     //   Report Count (6)
                      $75,$08,     //   Report Size (8)
                      $15,$00,     //   Logical Minimum (0)
                      $25,$ff,     //   Logical Maximum (255)
                      $05,$07,     //   Usage Page (Key Codes)
                      $19,$00,     //   Usage Minimum (0)
                      $29,$ff,     //   Usage Maximum (255)
                      $81,$00,     //   Input (Data, Array)
                      $c0          // End Collection
                     );
             private
              fInputReport:array[0..9] of TPasRISCVUInt8;
              fOutputReport:array[0..2] of TPasRISCVUInt8;
              fKeysPressedRow:array[0..7] of TPasRISCVUInt32;
              fKeysPressed:array[0..7] of TPasRISCVUInt32;
              fLEDs:TPasRISCVUInt32;
             public
              constructor Create(const aI2CDevice:TI2CDevice); override;
              destructor Destroy; override;
              procedure HIDReset; override;
              procedure HIDFillPressedKeys(const aPressed:PPasRISCVUInt8);
              procedure HIDReadReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;out aValue:TPasRISCVUInt8); override;
              procedure HIDWriteReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8); override;
              procedure HandleKeyboard(const aKey:TPasRISCVUInt32;const aDown:Boolean);
            end;
            { TI2CDevice }
            TI2CDevice=class(TBusDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10020000);
                    DefaultSize=TPasRISCVUInt64($14);
                    IRQ=TPasRISCVUInt64($0d);
                    AUTO_ADDR=0;
                    CLKLO=$00; // Clock prescale low byte
                    CLKHI=$04; // Clock prescale high byte
                    CTR=$08; // Control register
                    TXRXR=$0c; // Transmit & Receive register (W/R)
                    CRSR=$10; // Command & Status Register (W/R)
                    CTR_MASK=$c0; // Mask of legal bits
                    CTR_EN=$80; // Core enable bit
                    CTR_IEN=$40; // Interrupt enable bit
                    CR_STA=$80; // Generate (repeated) start condition
                    CR_STO=$40; // Generate stop condition
                    CR_RD=$20; // Read from slave
                    CR_WR=$10; // Write to slave
                    CR_ACK=$08; // Send ACK (0) or NACK (1) to master
                    CR_IACK=$01; // Interrupt acknowledge, clear a pending IRQ
                    SR_ACK=$80; // Received ACK from slave (0), NACK is 1
                    SR_BSY=$40; // I2C bus busy
                    SR_AL=$20; // Arbitration lost
                    SR_TIP=$02; // Transfer in progress
                    SR_IF=$01; // Interrupt flag
             private
              fLock:TPasMPSlimReaderWriterLock;
              fBusDevices:TI2CBusDevices;
              fCountBusDevices:TPasRISCVSizeInt;
              fBusDeviceAddressMap:TI2CBusDeviceAddressMap;
              fSelectedAddress:TPasRISCVUInt16;
              fClock:TPasRISCVUInt16;
              fControl:TPasRISCVUInt8;
              fStatus:TPasRISCVUInt8;
              fTXByte:TPasRISCVUInt8;
              fRXByte:TPasRISCVUInt8;
              procedure DispatchInterrupt;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure AttachBusDevice(const aI2CBusDevice:TI2CBusDevice);
              procedure DetachBusDevice(const aI2CBusDevice:TI2CBusDevice);
              function GetBusDevice(const aAddress:TPasRISCVUInt16):TI2CBusDevice;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TPS2Device }
            TPS2Device=class(TBusDevice)
             public
              const DefaultSize=TPasRISCVUInt64($8);
                    REG_DATA=$0;
                    REG_CTRL=$4;
                    CTRL_RE=$1;
                    CTRL_RI=$100;
                    CTRL_CE=$400;
                    DATA_RVALID=$8000;
             private
              fLock:TPasMPSlimReaderWriterLock;
              fIRQ:TPasRISCVUInt32;
              fControl:TPasRISCVUInt32;
             public
              constructor Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64); reintroduce; virtual;
              destructor Destroy; override;
              function Read(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt; virtual;
              function Write(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt; virtual;
              function Poll:TPasRISCVSizeInt; virtual;
              procedure Notify(const aFlags:TPasRISCVUInt32); virtual;
              procedure Update; virtual;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TPS2KeyboardDevice }
            TPS2KeyboardDevice=class(TPS2Device)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10010000);
                    DefaultIRQ=TPasRISCVUInt64($05);
                    CMD_RESET=$ff;
                    CMD_RESEND=$fe;
                    CMD_SET_DEFAULTS=$f6;
                    CMD_DISABLE_DATA_REPORTING=$f5;
                    CMD_ENABLE_DATA_REPORTING=$f4;
                    CMD_SET_SAMPLE_RATE=$f3;
                    CMD_GET_DEV_ID=$f2;
                    CMD_SET_SCAN_CODE_SET=$f0;
                    CMD_ECHO=$ee;
                    CMD_LEDS=$ed;
                    RSP_ACK=$fa;
                    RSP_NAK=$fe;
                    STATE_CMD=$0;
                    STATE_SET_SAMPLE_RATE=$1;
                    STATE_SET_SCAN_CODE_SET=$2;
                    STATE_SET_LEDS=$3;
                    RateToRealRate:array[0..31] of TPasRISCVUInt16=(300,267,240,218,200,185,171,160,150,133,120,109,100,92,86,80,75,67,60,55,50,46,43,40,37,33,30,28,25,23,21,20);
             private
              fActive:Boolean;
              fKeyState:array[0..31] of TPasRISCVUInt8;
              fState:TPasRISCVUInt8;
              fRate:TPasRISCVUInt8;
              fDelay:TPasRISCVUInt8;
              fReporting:Boolean;
              fLastKey:TPasRISCVRawByteString;
              fRingBuffer:TPasMPSingleProducerSingleConsumerRingBuffer;
              fHIDToPS2ByteMap:array[TPasRISCVUInt8] of TPasRISCVUInt8;
              fTimer:TPasRISCV.TTimer;
              fTimeCmp:TPasRISCVUInt64;
              procedure RingBufferWrite(const aData:TPasRISCVUInt8);
              function RingBufferRead(out aData:TPasRISCVUInt8):Boolean;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              procedure Update; override;
              procedure SetRate(const aRate:TPasRISCVUInt8);
              procedure ResetToDefaults;
              function Command(const aCmd:TPasRISCVUInt8):Boolean;
              function Read(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt; override;
              function Write(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt; override;
              function HIDToPS2KeyCode(const aKey:TPasRISCVUInt32):TPasRISCVRawByteString;
              procedure HandleKeyboard(const aKey:TPasRISCVUInt32;const aPressed:Boolean);
            end;
            { TPS2MouseDevice }
            TPS2MouseDevice=class(TPS2Device)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10011000);
                    DefaultIRQ=TPasRISCVUInt64($06);
                    BTN_LEFT=1;
                    BTN_RIGHT=2;
                    BTN_MIDDLE=4;
                    CMD_RESET=$ff;
                    CMD_RESEND=$fe;
                    CMD_SET_DEFAULTS=$f6;
                    CMD_DISABLE_DATA_REPORTING=$f5;
                    CMD_ENABLE_DATA_REPORTING=$f4;
                    CMD_SET_SAMPLE_RATE=$f3;
                    CMD_GET_DEV_ID=$f2;
                    CMD_SET_REMOTE_MODE=$f0;
                    CMD_SET_WRAP_MODE=$ee;
                    CMD_RESET_WRAP_MODE=$ec;
                    CMD_READ_DATA=$eb;
                    CMD_SET_STREAM_MODE=$ea;
                    CMD_STATUS_REQ=$e9;
                    CMD_SET_RESOLUTION=$e8;
                    CMD_SET_SCALING_2_1=$e7;
                    CMD_SET_SCALING_1_1=$e6;
                    RSP_ACK=$fa;
                    RSP_NAK=$fe;
                    STATE_CMD=$0;
                    STATE_SET_SAMPLE_RATE=$1;
                    STATE_WRAP=$2;
                    STATE_SET_RESOLUTION=$3;
                    MODE_STREAM=$0;
                    MODE_REMOTE=$1;
                    MOUSE_GENERIC=$0;
                    MOUSE_WHEEL=$3;
             private
              fActive:Boolean;
              fButtons:TPasRISCVUInt32;
              fResolutionInitialized:Boolean;
              fX:TPasRISCVInt32;
              fY:TPasRISCVInt32;
              fXMovementCounter:TPasRISCVInt16;
              fYMovementCounter:TPasRISCVInt16;
              fXOverflow:Boolean;
              fYOverflow:Boolean;
              fScroll:TPasRISCVInt32;
              fMode:TPasRISCVUInt8;
              fState:TPasRISCVUInt8;
              fResolution:TPasRISCVUInt8;
              fRate:TPasRISCVUInt8;
              fWheelDetect:TPasRISCVUInt8;
              fReporting:Boolean;
              fRingBuffer:TPasMPSingleProducerSingleConsumerRingBuffer;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              procedure ResetToDefaults;
              procedure Flush;
              procedure MovePacket;
              function Command(const aCmd:TPasRISCVUInt8):Boolean;
              function Read(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt; override;
              function Write(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt; override;
              procedure ButtonPress(const aButtons:TPasRISCVUInt32);
              procedure ButtonRelease(const aButtons:TPasRISCVUInt32);
              procedure Scroll(const aOffset:TPasRISCVInt32);
              procedure RelativeMove(const aDeltaX,aDeltaY:TPasRISCVInt32);
              procedure AbsoluteMove(const aX,aY:TPasRISCVInt32);
            end;
            { TBus }
            TBus=class
             public
             private
              fMachine:TPasRISCV;
              fBusDevices:TBusDeviceArray;
              fCountBusDevices:TPasRISCVUInt64;
              function LoadUnaligned(const aBusDevice:TBusDevice;const aAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
              function StoreUnaligned(const aBusDevice:TBusDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function GetAutoMemoryAddress(const aAddress,aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure AddBusDevice(const aBusDevice:TBusDevice);
              procedure RemoveBusDevice(const aBusDevice:TBusDevice);
              function FindBusDevice(const aAddress:TPasRISCVUInt64):TBusDevice;
              function GetDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
              function Fetch(const aHART:THART;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              function Load(const aHART:THART;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure Store(const aHART:THART;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
              function LoadEx(const aAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
              function StoreEx(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
              procedure Step;
            end;
            { THART }
            THART=class
             public
              type TMode=
                    (
                     User=0,
                     Supervisor=1,
                     Hypervisor=2,
                     Machine=3,
                     Invalid=255
                    );
                   TExceptionValue=
                    (
                     DebuggerBreakpoint=-2,
                     None=-1,
                     InstructionAddressMisaligned=0,
                     InstructionAccessFault=1,
                     IllegalInstruction=2,
                     Breakpoint=3,
                     LoadAddressMisaligned=4,
                     LoadAccessFault=5,
                     StoreAddressMisaligned=6,
                     StoreAccessFault=7,
                     ECallUMode=8,
                     ECallSMode=9,
                     ECallHMode=10,
                     ECallMMode=11,
                     InstructionPageFault=12,
                     LoadPageFault=13,
                     Reserved=14,
                     StorePageFault=15
                    );
                   { TException }
                   TException=class(Exception)
                    private
                     fExceptionValue:TExceptionValue;
                     fExceptionData:TPasRISCVUInt64;
                     fExceptionPC:TPasRISCVUInt64;
                    public
                     constructor Create(const aExceptionValue:TExceptionValue;const aExceptionData,aExceptionPC:TPasRISCVUInt64); reintroduce;
                     destructor Destroy; override;
                    published
                     property ExceptionValue:TExceptionValue read fExceptionValue;
                     property ExceptionData:TPasRISCVUInt64 read fExceptionData;
                     property ExceptionPC:TPasRISCVUInt64 read fExceptionPC;
                   end;
                   TInterruptValue=
                    (
                     None=-1,                    // No Interrupt
                     UserSoftware=0,             // User Software Interrupt
                     SupervisorSoftware=1,       // S-mode Software Interrupt (ACLINT-SSWI)
                     HypervisorSoftware=2,       // H-mode Software Interrupt
                     MachineSoftware=3,          // M-mode Software Interrupt (ACLINT-MSWI)
                     UserTimer=4,                // User Timer Interrupt
                     SupervisorTimer=5,          // S-mode Timer Interrupt (Sstc)
                     HypervisorTimer=6,          // H-mode Timer Interrupt
                     MachineTimer=7,             // M-mode Timer Interrupt (ACLINT-MTIMER)
                     UserExternal=8,             // User External Interrupt
                     SupervisorExternal=9,       // S-mode External Interrupt (PLIC)
                     HypervisorExternal=10,      // H-mode External Interrupt
                     MachineExternal=11,         // M-mode External Interrupt (PLIC)
                     Reserved=12,                // Reserved
                     LocalCounterOverflow=13     // Local Counter Overflow (Sscofpmf)
                    );
                   PInterruptValue=^TInterruptValue;
                   TInterruptValueMasks=class
                    public
                     const UserSoftware=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.UserSoftware);
                           SupervisorSoftware=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.SupervisorSoftware);
                           HypervisorSoftware=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.HypervisorSoftware);
                           MachineSoftware=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.MachineSoftware);
                           UserTimer=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.UserTimer);
                           SupervisorTimer=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.SupervisorTimer);
                           HypervisorTimer=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.HypervisorTimer);
                           MachineTimer=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.MachineTimer);
                           UserExternal=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.UserExternal);
                           SupervisorExternal=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.SupervisorExternal);
                           HypervisorExternal=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.HypervisorExternal);
                           MachineExternal=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.MachineExternal);
                           Reserved=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.Reserved);
                           LocalCounterOverflow=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.LocalCounterOverflow);
                   end;
                   TRegister=
                    (
                     // Raw
                     x0=0,
                     x1=1,
                     x2=2,
                     x3=3,
                     x4=4,
                     x5=5,
                     x6=6,
                     x7=7,
                     x8=8,
                     x9=9,
                     x10=10,
                     x11=11,
                     x12=12,
                     x13=13,
                     x14=14,
                     x15=15,
                     x16=16,
                     x17=17,
                     x18=18,
                     x19=19,
                     x20=20,
                     x21=21,
                     x22=22,
                     x23=23,
                     x24=24,
                     x25=26,
                     x27=27,
                     x28=28,
                     x29=29,
                     x30=30,
                     x31=31,

                     // ABI
                     Zero=0,
                     RA=1,
                     SP=2,
                     GP=3,
                     TP=4,
                     T0=5,
                     T1=6,
                     T2=7,
                     S0=8,
                     S1=9,
                     A0=10,
                     A1=11,
                     A2=12,
                     A3=13,
                     A4=14,
                     A5=15,
                     A6=16,
                     A7=17,
                     S2=18,
                     S3=19,
                     S4=20,
                     S5=21,
                     S6=22,
                     S7=23,
                     S8=24,
                     S9=25,
                     S10=26,
                     S11=27,
                     T3=28,
                     T4=29,
                     T5=30,
                     T6=31
                    );
                   PRegister=^TRegister;
                   TRegisters=array[TRegister] of TPasRISCVUInt64;
                   PRegisters=^TRegisters;
                   TFPURegister=
                    (

                     // Raw
                     f0=0,
                     f1=1,
                     f2=2,
                     f3=3,
                     f4=4,
                     f5=5,
                     f6=6,
                     f7=7,
                     f8=8,
                     f9=9,
                     f10=10,
                     f11=11,
                     f12=12,
                     f13=13,
                     f14=14,
                     f15=15,
                     f16=16,
                     f17=17,
                     f18=18,
                     f19=19,
                     f20=20,
                     f21=21,
                     f22=22,
                     f23=23,
                     f24=24,
                     f25=25,
                     f26=26,
                     f27=27,
                     f28=28,
                     f29=29,
                     f30=30,
                     f31=31,

                     // ABI
                     ft0=0,
                     ft1=1,
                     ft2=2,
                     ft3=3,
                     ft4=4,
                     ft5=5,
                     ft6=6,
                     ft7=7,
                     fs0=8,
                     fs1=9,
                     fa0=10,
                     fa1=11,
                     fa2=12,
                     fa3=13,
                     fa4=14,
                     fa5=15,
                     fa6=16,
                     fa7=17,
                     fs2=18,
                     fs3=19,
                     fs4=20,
                     fs5=21,
                     fs6=22,
                     fs7=23,
                     fs8=24,
                     fs9=25,
                     fs10=26,
                     fs11=27,
                     ft8=28,
                     ft9=29,
                     ft10=30,
                     ft11=31

                    );
                   PFPURegister=^TFPURegister;
                   TFPURegisterValue=record
                    case TPasRISCVUInt8 of
                     0:(
                      ui32:TPasRISCVUInt32;
                      NaNBoxUI32:TPasRISCVUInt32;
                     );
                     1:(
                      ui64:TPasRISCVUInt64;
                     );
                     2:(
                      f32:TPasRISCVFloat;
                     );
                     3:(
                      f64:TPasRISCVDouble;
                     );
                   end;
                   PFPURegisterValue=^TFPURegisterValue;
                   TFPURegisters=array[TFPURegister] of TFPURegisterValue;
                   PFPURegisters=^TFPURegisters;
                   TFClass=class
                    public
                     const NEG_INF=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 0);
                           NEG_NORMAL=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 1);
                           NEG_SUBNORMAL=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 2);
                           NEG_ZERO=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 3);
                           POS_ZERO=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 4);
                           POS_SUBNORMAL=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 5);
                           POS_NORMAL=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 6);
                           POS_INF=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 7);
                           NAN_SIG=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 8);
                           NAN_QUIET=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 9);
                   end;
                   { TCSR }
                   TCSR=record
                    public
                     const ENVCFG_CBIE=TPasRISCVUInt64(1) shl 4;
                           ENVCFG_CBCFE=TPasRISCVUInt64(1) shl 6;
                           ENVCFG_CBZE=TPasRISCVUInt64(1) shl 7;
                           ENVCFG_ADUE=TPasRISCVUInt64(1) shl 61;
                           ENVCFG_PBMTE=TPasRISCVUInt64(1) shl 62;
                           ENVCFG_STCE=TPasRISCVUInt64(1) shl 63;
                           MSECCFG_USEED=TPasRISCVUInt64(1) shl 8;
                           MSECCFG_SSEED=TPasRISCVUInt64(1) shl 9;
                           CSR_FFLAGS_MASK=$1f;
                           CSR_FRM_MASK=$7;
                           CSR_FCSR_MASK=$ff;
                           CSR_STATUS_FS_MASK=$6000;
                           CSR_MEDELEG_MASK=TPasRISCVUInt64($b109);
                           CSR_MIDELEG_MASK=TPasRISCVUInt64($0222);
                           CSR_MEIP_MASK=TPasRISCVUInt64($aaa);
                           CSR_SEIP_MASK=TPasRISCVUInt64($222);
                           CSR_MENVCFG_MASK=TPasRISCVUInt64($a0000000000000d0); //e
                           CSR_SENVCFG_MASK=TPasRISCVUInt64($d0);
                           CSR_MSECCFG_MASK=$300;
                           MNSTATUS_NMIE=$8;
                           MNSTATUS_MNPV=$80;
                           MNSTATUS_MNPP=$1800;
                           // Indirect CSRs
                           CSRI_MIPRIO_0=$30;
                           CSRI_MIPRIO_15=$3f;
                           CSRI_EIDELIVERY=$70;
                           CSRI_EITHRESHOLD=$72;
                           CSRI_EIP0=$80;
                           CSRI_EIP63=$bf;
                           CSRI_EIE0=$c0;
                           CSRI_EIE63=$ff;
                     type TAddress=class
                           public
                            const USTATUS=$0;
                                  FFLAGS=$1;
                                  FRM=$2;
                                  FCSR=$3;
                                  UVEC=$5;
                                  SEED=$15; // (Zkr)
                                  UEPC=$41;
                                  UCAUSE=$42;
                                  UTVAL=$43;
                                  SSTATUS=$100;
                                  SEDELEG=$102;
                                  SIDELEG=$103;
                                  SIE=$104;
                                  STVEC=$105;
                                  SCOUNTEREN=$106;
                                  SENVCFG=$10a;
                                  SSCRATCH=$140;
                                  SEPC=$141;
                                  SCAUSE=$142;
                                  STVAL=$143;
                                  SIP=$144;
                                  STIMECMP=$14d;
                                  SISELECT=$150;
                                  SIREG=$151;
                                  SIREG2=$152;
                                  SIREG3=$153;
                                  SIREG4=$154;
                                  SIREG5=$155;
                                  SIREG6=$156;
                                  SIREG7=$157;
                                  STOPEI=$15c;
                                  STIMECMPH=$15d;
                                  SATP=$180;
                                  MSTATUS=$300;
                                  MISA=$301;
                                  MEDELEG=$302;
                                  MIDELEG=$303;
                                  MIE=$304;
                                  MTVEC=$305;
                                  MCOUNTEREN=$306;
                                  MENVCFG=$30a;
                                  MSTATUSH=$310;
                                  MEDELEGH=$312;
                                  MENVCFGH=$31a;
                                  MCOUNTINHIBIT=$320;
                                  MSCRATCH=$340;
                                  MEPC=$341;
                                  MCAUSE=$342;
                                  MTVAL=$343;
                                  MIP=$344;
                                  MISELECT=$350;
                                  MIREG=$351;
                                  MIREG2=$352;
                                  MIREG3=$353;
                                  MIREG4=$354;
                                  MIREG5=$355;
                                  MIREG6=$356;
                                  MIREG7=$357;
                                  MTOPEI=$35c;
                                  MNSCRATCH=$740;
                                  MNEPC=$741;
                                  MNCAUSE=$742;
                                  MNSTATUS=$744;
                                  MSECCFG=$747;
                                  MSECCFGH=$757;
                                  TSELECT=$7a0;
                                  TDATA1=$7a1;
                                  TDATA2=$7a2;
                                  TINFO=$7a4;
                                  DCSR=$7b0;
                                  DPC=$7b1;
                                  DSCRATCH0=$7b2;
                                  DSCRATCH2=$7b3;
                                  MCYCLE=$b00;
                                  MCYCLEH=$b80;
                                  MINSTRET=$b02;
                                  MINSTRETH=$b82;
                                  CYCLE=$c00;
                                  CYCLEH=$c80;
                                  INSTRET=$c02;
                                  INSTRETH=$c82;
                                  TIME=$c01;
                                  TIMEMS=$c10;
                                  TIMEH=$c81;
                                  STOPI=$db0;
                                  MVENDORID=$f11;
                                  MARCHID=$f12;
                                  MIMPID=$f13;
                                  MHARTID=$f14;
                                  MCONFIGPTR=$f15;
                                  MTOPI=$fb0;
                          end;
                          TMask=class
                           public
                            const MSTATUS=TPasRISCVUInt64($f007fffaa);
                                  SSTATUS=TPasRISCVUInt64($3000de722);
                            type TStatus=class
                                  public
                                   const SIE=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 1);
                                         MIE=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 3);
                                         SPIE=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 5);
                                         UBE=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 6);
                                         SPP=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 8);
                                         FS=TPasRISCVUInt64($6000);
                                         XS=TPasRISCVUInt64($18000);
                                         MPRV=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 17);
                                         SUM=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 18);
                                         MXR=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 19);
                                         TVM=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 20);
                                         TW=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 21);
                                         UXL=TPasRISCVUInt64($300000000);
                                         SD=TPasRISCVUInt64($8000000000000000);//TPasRISCVUInt64(TPasRISCVUInt64(1) shl 63);
                                         //SSTATUS=TPasRISCVUInt64(SIE or SPIE or UBE or SPP or FS or XS or SUM or MXR or UXL or TPasRISCVUInt64(SD));
                                 end;
                                 TSSTATUSBit=class
                                  public
                                   const SIE=1;
                                         SPIE=5;
                                         SPP=8;
                                 end;
                                 TMSTATUSBit=class
                                  public
                                   const MIE=3;
                                         MPIE=7;
                                         MPP=11;
                                         MPRV=17;
                                         SUM=18;
                                         MXR=19;
                                         TVM=20;
                                         TW=21;
                                         TSR=22;
                                 end;
                          end;
                          TMISA=class
                           public
                            type TExtension=class
                                  public
                                   const A_EXT=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 0);
                                         C_EXT=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 2);
                                         D_EXT=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 3);
                                         RV32E=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 4);
                                         F_EXT=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 5);
                                         HYPERVISOR=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 7);
                                         RV32I_64I_128I=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 8);
                                         M_EXT=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 12);
                                         N_EXT=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 13);
                                         QUAD_EXT=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 16);
                                         SUPERVISOR=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 18);
                                         USER=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 20);
                                         NON_STD_PRESENT=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 22);
                                         XLEN_32=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 31);
                                         XLEN_64=TPasRISCVUInt64(TPasRISCVUInt64(2) shl 62);
                                 end;
                          end;
                          TFPUExceptionMasks=class
                           public
                            const Inexact=1 shl 0;
                                  Underflow=1 shl 1;
                                  Overflow=1 shl 2;
                                  DivByZero=1 shl 3;
                                  Invalid=1 shl 4;
                                  Mask=Inexact or Underflow or Overflow or DivByZero or Invalid;
                          end;
                          TFloatingPointRoundingModes=
                           (
                            RoundToNearestEven=0,       // RNE - Round to nearest, ties to even
                            RoundToZero=1,              // RTZ - Round to zero
                            RoundDown=2,                // RDN - Round down - towards -inf
                            RoundUp=3,                  // RUP - Round up - towards +inf
                            RoundNearestMaxMagnitude=4, // RMM - Round to nearest, ties to max magnitude
                            RoundDynamic=7,
                            Mask=1 or 2 or 4
                           );
                          TFS=class
                           public
                            const Off=0;
                                  Initial=1;
                                  Clean=2;
                                  Dirty=3;
                          end;
                    private
                     fHART:THART;
                     fData:array[0..4095] of TPasRISCVUInt64;
                    public
                     procedure Init(const aHART:THART);
                     function Load(const aAddress:TPasRISCVUInt64):TPasRISCVUInt64;
                     procedure Store(const aAddress,aValue:TPasRISCVUInt64);
                     procedure SetFPUException(const aValue:TPasRISCVUInt64);
                     procedure ClearFPUExceptions;
                     procedure SetFPURM(const aValue:TPasRISCVUInt64);
                     procedure ClearFPURM;
                     procedure SetFS(const aValue:TPasRISCVUInt64);
                     function GetFS:TPasRISCVUInt64;
                     procedure ClearFS;
                     procedure SetFSDirty; //inline;
                     function IsFPUEnabled:Boolean;
                   end;
                   PCSR=^TCSR;
                   TState=record
                    public
                     type TBounce=record
                           case TPasRISCVUInt8 of
                            0:(
                             i32:TPasRISCVInt32;
                            );
                            1:(
                             ui32:TPasRISCVUInt32;
                            );
                            2:(
                             i64:TPasRISCVUInt64;
                            );
                            3:(
                             ui64:TPasRISCVUInt64;
                            );
                            4:(
                             i128:TPasMPInt128Record;
                            );
                            5:(
                             ui128:TPasMPInt128Record;
                            );
                          end;
                          PBounce=^TBounce;
                    public
                     Registers:TRegisters;
                     FPURegisters:TFPURegisters;
//                   LastPC:TPasRISCVUInt64;
                     PC:TPasRISCVUInt64;
                     Mode:TPasRISCV.THART.TMode;
                     CSR:TCSR;
                     Sleep:TPasMPBool32;
                     EnablePaging:TPasMPBool32;
                     PageTable:TPasRISCVUInt64;
                     PendingIRQs:TPasRISCVUInt64;
                     ExceptionValue:TExceptionValue;
                     ExceptionData:TPasRISCVUInt64;
                     ExceptionPC:TPasRISCVUInt64;
                     Cycle:TPasRISCVUInt64;
                     LSRC:TPasMPBool32;
                     LSRCAddress:TPasRISCVUInt64;
                     LSRCCAS:TPasRISCVUInt64;
                     Bounce:TBounce;
                     CAS128OldValue:TPasMPInt128Record;
                     CAS128NewValue:TPasMPInt128Record;
                     CAS128Result:TPasMPInt128Record;
                   end;
                   PState=^TState;
                   TCSROperation=
                    (
                     Swap,
                     SetBits,
                     ClearBits
                    );
                   TCSRHandler=procedure(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation) of object;
                   TCSRHandlerMap=array[0..4095] of TCSRHandler;
                   { TMMU }
                   TMMU=class
                    public
                     const DIRECT_ACCESS_TLB_ENTRIES=TPasRISCVUInt64(256);
                           DIRECT_ACCESS_TLB_MASK=DIRECT_ACCESS_TLB_ENTRIES-1;
                           PAGE_SHIFT=12;
                           VPN_BITS=9;
                           PAGE_VPN_DIFF=PAGE_SHIFT-VPN_BITS;
                           VPN_MASK=$1ff;
                           PPN_BITS=10;
                           PHYSICAL_BITS=56;
                           PHYSICAL_MASK=TPasRISCVUInt64($00ffffffffffffff);
                           PHYSICAL_INVERSE_MASK=TPasRISCVUInt64($ff00000000000000);
                           PAGE_PNMASK=TPasRISCVUInt64($fffffffffffff000);
                     type TAccessType=
                           (
                            Load=0,            //  R
                            Store=1,           //  W
                            Instruction=2,     //  X
                            LoadInstruction=3, // RX - A special case for when MXR is set and the access is a load, for to distinguish it from a normal load at the MMU translation level
                            DebuggerLoad,      // For debugger access
                            DebuggerStore      // For debugger access
                           );
                          PAccessType=^TAccessType;
                          TAccessFlag=
                           (
                            NoTLBUpdate,                  // Do not update the TLB (for example for when the TLB is updated by the caller)
                            NoTrap,                       // Do not trap
                            IgnoreMMUProtection,          // Ignore MMU protection (for debugging, so that the emulator-level debugger can access all memory)
                            TranslateIntoPhysicalAddress, // Translate into physical address
                            ReadModifyWrite               // Read-Modify-Write (for example for atomic operations)
                           );
                          PAccessFlag=^TAccessFlag;
                          TAccessFlags=set of TAccessFlag;
                          PAccessFlags=^TAccessFlags;
                     const AccessMasks:array[TAccessType] of TPasRISCVUInt64=  // Access masks corresponding to the MMU page table entry bits
                            (
                             $02, // R-- Read
                             $04, // -W- Write
                             $08, // --X Execute
                             $0a, // R-X Read and Execute (for when MXR is set and the access is a load)
                             $0e, // RWX Read, Write and Execute (for debugger access)
                             $0e  // RWX Read, Write and Execute (for debugger access)
                            );
                           DebugAccessFlags:TAccessFlags=[TAccessFlag.NoTrap,TAccessFlag.IgnoreMMUProtection];
                           AccessWrite:array[TAccessType] of Boolean=  // Access flags corresponding to the write aspect
                            (
                             false, // R-- Read
                             true,  // -W- Write
                             false, // --X Execute
                             false, // R-X Read and Execute (for when MXR is set and the access is a load)
                             false, // RWX Read, Write and Execute (for debugger access)
                             true   // RWX Read, Write and Execute (for debugger access)
                            );
                     type TMMUMode=
                           (
                            None=$00,
                            Invalid1=$01,
                            Invalid2=$02,
                            Invalid3=$03,
                            Invalid4=$04,
                            Invalid5=$05,
                            Invalid6=$06,
                            Invalid7=$07,
                            SV39=$08,
                            SV48=$09,
                            SV57=$0a,
                            InvalidB=$0b,
                            InvalidC=$0c,
                            InvalidD=$0D,
                            InvalidE=$0e,
                            InvalidF=$0f
                           );
                         PMMUMode=^TMMUMode;
                         TPTE=TPasRISCVUInt64;
                         TPTEHelper=record helper for TPTE
                          public
                           const Valid=0;
                                 Read_=1;
                                 Write_=2;
                                 Execute=3;
                                 User=4;
                                 Global=5;
                                 Accessed=6;
                                 Dirty=7;
                         end;
                         PPTE=^TPTE;
                         TPTEMasks=record
                          public
                           const Valid=$01;
                                 Read_=$02;
                                 Write_=$04;
                                 Execute=$08;
                                 Leaf=$0a;
                                 User=$10;
                                 Global=$20;
                                 Accessed=$40;
                                 Dirty=$80;
                                 PBMT=TPasRISCVUInt64($6000000000000000);
                                 N=TPasRISCVUInt64($8000000000000000);
                                 Reserved=TPasRISCVUInt64($1fc0000000000000);
                                 PPN_MASK=TPasRISCVUInt64($3ffffffffffc00);
                                 Attr=TPasRISCVUInt64(N or PBMT);
                         end;
                         TDirectAccessTLBEntry=record
                          Read:TPasRISCVUInt64;
                          Write:TPasRISCVUInt64;
                          Execute:TPasRISCVUInt64;
{$ifdef CombinedDirectAccessTLBCache}
                          RelativeMemory:TPasRISCVPtrUInt;
{$else}
                          RelativeMemoryRead:TPasRISCVPtrUInt;
                          RelativeMemoryWrite:TPasRISCVPtrUInt;
                          RelativeMemoryExecute:TPasRISCVPtrUInt;
{$endif}
                         end;
                         PDirectAccessTLBEntry=^TDirectAccessTLBEntry;
                         TDirectAccessTLBEntries=array[0..DIRECT_ACCESS_TLB_ENTRIES-1] of TDirectAccessTLBEntry;
                         TPNArray=array[0..4] of TPasRISCVUInt64;
                     const ModeLevels:array[TMMUMode] of TPasRISCVUInt64=(0,0,0,0,0,0,0,0,3,4,5,0,0,0,0,0);
                   end;
                   { TAIARegFile }
                   TAIARegFile=class
                    public
                     const IRQ_LIMIT=256;
                           ARRAY_LENGTH=(IRQ_LIMIT+31) shr 5;
                    private
                     fMachine:TPasRISCV;
                     fHART:THART;
                     fEIDelivery:TPasRISCVUInt32;
                     fEIThreshold:TPasRISCVUInt32;
                     fEIP:array[0..ARRAY_LENGTH-1] of TPasRISCVUInt32;
                     fEIE:array[0..ARRAY_LENGTH-1] of TPasRISCVUInt32;
                    public
                     constructor Create(const aMachine:TPasRISCV;const aHART:THART); reintroduce;
                     destructor Destroy; override;
                     procedure Reset;
                   end;
                   TAIARegFiles=array[TAIARegFileMode] of TAIARegFile;
                   { TExecutionThread }
                   TExecutionThread=class(TPasMPThread)
                    private
                     fHART:THART;
                    protected
                     procedure Execute; override;
                    public
                     constructor Create(const aHART:THART); reintroduce;
                     destructor Destroy; override;
                     procedure Shutdown;
                   end;
              const ExceptionNames:array[TExceptionValue] of TPasRISCVUTF8String=
                     (
                      'Debugger breakpoint',
                      'Unknown exception',
                      'Instruction address misaligned',
                      'Instruction access fault',
                      'Illegal instruction',
                      'Breakpoint',
                      'Load address misaligned',
                      'Load access fault',
                      'Store address misaligned',
                      'Store access fault',
                      'Environment call from U-mode',
                      'Environment call from S-mode',
                      'Environment call from H-mode',
                      'Environment call from M-mode',
                      'Instruction page fault',
                      'Load page fault',
                      'Reserved',
                      'Store page fault'
                     );
                    InterruptNames:array[TInterruptValue] of TPasRISCVUTF8String=
                     (
                      'Unknown interrupt',
                      'UserSoftware',
                      'SupervisorSoftware',
                      'HypervisorSoftware',
                      'MachineSoftware',
                      'UserTimer',
                      'SupervisorTimer',
                      'HypervisorTimer',
                      'MachineTimer',
                      'UserExternal',
                      'SupervisorExternal',
                      'HypervisorExternal',
                      'MachineExternal',
                      'Reserved',
                      'LocalCounterOverflow'
                     );
                    RegisterRawNames:array[TRegister] of TPasRISCVUTF8String=
                     (
                      'x0','x1','x2','x3','x4','x5','x6','x7',
                      'x8','x9','x10','x11','x12','x13','x14','x15',
                      'x16','x17','x18','x19','x20','x21','x22','x23',
                      'x24','x25','x26','x27','x28','x29','x30','x31'
                     );
                    RegisterABINames:array[TRegister] of TPasRISCVUTF8String=
                     (
                      'zero','ra','sp','gp','tp','t0','t1','t2',
                      's0','s1','a0','a1','a2','a3','a4','a5',
                      'a6','a7','s2','s3','s4','s5','s6','s7',
                      's8','s9','s10','s11','t3','t4','t5','t6'
                     );
                    FPURegisterRawNames:array[TFPURegister] of TPasRISCVUTF8String=
                     (
                      'f0','f1','f2','f3','f4','f5','f6','f7',
                      'f8','f9','f10','f11','f12','f13','f14','f15',
                      'f16','f17','f18','f19','f20','f21','f22','f23',
                      'f24','f25','f26','f27','f28','f29','f30','f31'
                     );
                    FPURegisterABINames:array[TFPURegister] of TPasRISCVUTF8String=
                     (
                      'ft0','ft1','ft2','ft3','ft4','ft5','ft6','ft7',
                      'fs0','fs1','fa0','fa1','fa2','fa3','fa4','fa5',
                      'fa6','fa7','fs2','fs3','fs4','fs5','fs6','fs7',
                      'fs8','fs9','fs10','fs11','ft8','ft9','ft10','ft11'
                     );
             private
              fMachine:TPasRISCV;
              fPHandle:TPasRISCVUInt32;
              fBus:TBus;
              fAIARegFiles:TAIARegFiles;
              fACLINTDevice:TACLINTDevice;
              fMTIMECMP:TPasRISCVUInt64;
              fSTIMECMP:TPasRISCVUInt64;
              fMMUMode:TMMU.TMMUMode;
              fRootPageTable:TPasRISCVUInt64;
              fDirectAccessTLBCache:TMMU.TDirectAccessTLBEntries;
              fState:TState;
              fPointerToState:PState;
              fCSRHandlerMap:TCSRHandlerMap;
              fHARTID:TPasRISCVUInt32;
              fHARTMask:TPasRISCVUInt32;
              fExecutionThread:TExecutionThread;
              fPCG32:TPCG32;
              procedure UpdateMMU;
              function CheckPrivilege(const aCPUMode:THART.TMode;const aAccessType:TMMU.TAccessType):Boolean;
              function AddressTranslate(const aVirtualAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType;const aAccessFlags:TMMU.TAccessFlags):TPasRISCVUInt64;
              procedure FlushTLB(const aInterrupt:Boolean);
              procedure FlushTLBPage(const aInterrupt:Boolean;const aAddress:TPasRISCVUInt64);
              procedure TLBPut(const aVirtualAddress:TPasRISCVUInt64;const aTarget:TPasRISCVPtrUInt;const aAccessType:TMMU.TAccessType);
              procedure TLBPutBusDevice(const aVirtualAddress,aPhysicalAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType);
              procedure RaisePhysicalFault(const aAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType);
              procedure RaisePageFault(const aAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType);
              function Load8(const aAddress:TPasRISCVUInt64):TPasRISCVUInt8; inline;
              procedure LoadRegisterS8(const aRegister:TRegister;const aAddress:TPasRISCVUInt64); inline;
              procedure LoadRegisterU8(const aRegister:TRegister;const aAddress:TPasRISCVUInt64); inline;
              procedure Store8(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt8); inline;
              procedure StoreRegisterU8(const aAddress:TPasRISCVUInt64;const aRegister:TRegister); inline;
              function Load16(const aAddress:TPasRISCVUInt64):TPasRISCVUInt16; inline;
              procedure LoadRegisterS16(const aRegister:TRegister;const aAddress:TPasRISCVUInt64); inline;
              procedure LoadRegisterU16(const aRegister:TRegister;const aAddress:TPasRISCVUInt64); inline;
              procedure Store16(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt16); inline;
              procedure StoreRegisterU16(const aAddress:TPasRISCVUInt64;const aRegister:TRegister); inline;
              function Load32(const aAddress:TPasRISCVUInt64):TPasRISCVUInt32; inline;
              procedure LoadRegisterS32(const aRegister:TRegister;const aAddress:TPasRISCVUInt64); inline;
              procedure LoadRegisterU32(const aRegister:TRegister;const aAddress:TPasRISCVUInt64); inline;
              procedure LoadRegisterF32(const aRegister:TFPURegister;const aAddress:TPasRISCVUInt64); inline;
              procedure Store32(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt32); inline;
              procedure StoreRegisterU32(const aAddress:TPasRISCVUInt64;const aRegister:TRegister); inline;
              procedure StoreRegisterF32(const aAddress:TPasRISCVUInt64;const aRegister:TFPURegister); inline;
              function Load64(const aAddress:TPasRISCVUInt64):TPasRISCVUInt64; //inline;
              procedure LoadRegisterS64(const aRegister:TRegister;const aAddress:TPasRISCVUInt64); inline;
              procedure LoadRegisterU64(const aRegister:TRegister;const aAddress:TPasRISCVUInt64); inline;
              procedure LoadRegisterF64(const aRegister:TFPURegister;const aAddress:TPasRISCVUInt64); inline;
              procedure Store64(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64); //inline;
              procedure StoreRegisterU64(const aAddress:TPasRISCVUInt64;const aRegister:TRegister); inline;
              procedure StoreRegisterF64(const aAddress:TPasRISCVUInt64;const aRegister:TFPURegister); inline;
              function RMWTranslate(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aBounce:Pointer;const aReadOnly:Boolean):Pointer; //inline;
              procedure RMWStore(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aBounce:Pointer); //inline;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
              function LoadEx(const aAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
              function StoreEx(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
              function IsCSRENVCFGEnabled(const aMask:TPasRISCVUInt64):Boolean;
              class function CSROperation(const aOperation:TCSROperation;const aCSR,aRHS:TPasRISCVUInt64):TPasRISCVUInt64; static; inline;
              procedure CSRHandlerDefault(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerDefaultReadOnly(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerPrivileged(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerPrivilegedReadOnly(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerIllegal(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerEnforcedReadOnly(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerFCSR(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerFFLAGS(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerFRM(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerSATP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerSTATUS(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerSTIMECMP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerMIE(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerSIE(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerMIP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerSIP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerMTOPI(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerSTOPI(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerMTOPEI(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerSTOPEI(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              class function CSRAtomicHelper(const aValue:PPasRISCVUInt32;const aRHS:TPasRISCVUInt64;out aDest:TPasRISCVUInt64;const aOperation:TCSROperation):Boolean; static;
              function CSRAIAHelper(const aMode:TMode;const aAIARegFileMode:TAIARegFileMode;const aValue:PPasRISCVUInt32;const aRHS:TPasRISCVUInt64;out aDest:TPasRISCVUInt64;const aOperation:TCSROperation):Boolean;
              function CSRAIAPairHelper(const aMode:TMode;const aAIARegFileMode:TAIARegFileMode;const aReg:TPasRISCVUInt32;const aValue:Pointer;const aRHS:TPasRISCVUInt64;out aDest:TPasRISCVUInt64;const aOperation:TCSROperation):Boolean;
              procedure CSRHandlerIndirect(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CheckTimers;
              procedure CheckInterrupts;
             public
              constructor Create(const aMachine:TPasRISCV;const aHARTID:TPasRISCVUInt32); reintroduce;
              destructor Destroy; override;
              procedure Init;
              procedure SetMode(const aMode:TMode);
              procedure SetException(const aExceptionValue:TExceptionValue;
                                     const aExceptionData:TPasRISCVUInt64;
                                     const aExceptionPC:TPasRISCVUInt64);
              procedure ClearException;
              procedure SetFPUExceptions(const aMask:TPasRISCVUInt32=$3f);
              procedure Breakpoint(const aInstruction:TPasRISCVUInt32);
              function FetchInstruction(const aAddress:TPasRISCVUInt64;out aInstruction:TPasRISCVUInt32):Boolean; //inline;
              function GetInstructionSize(const aInstruction:TPasRISCVUInt32):TPasRISCVUInt64; inline;
              function ExecuteInstruction(const aInstruction:TPasRISCVUInt32):TPasRISCVUInt64;
              function InterruptsRaised:TPasRISCVUInt64; inline;
              function InterruptsPending:TPasRISCVUInt64; inline;
              function InterruptsNotPending:TPasRISCVUInt64; inline;
              procedure ClearInterrupt(const aInterruptValue:TPasRISCV.THART.TInterruptValue);
              procedure RaiseInterrupt(const aInterruptValue:TPasRISCV.THART.TInterruptValue);
              function SetInterrupt(const aInterruptValue:TPasRISCV.THART.TInterruptValue):Boolean;
              procedure SendAIAIRQ(const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aIRQ:TPasRISCVUInt32);
              function UpdateAIAInternal(const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aUpdate,aClaim:Boolean):TPasRISCVUInt32;
              function UpdateAIAState(const aAIARegFileMode:TPasRISCV.TAIARegFileMode):TPasRISCVUInt32;
              function GetAIAIRQ(const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aClaim:Boolean):TPasRISCVUInt32;
              procedure HandleInterrupts;
              procedure ExecuteException;
              procedure SleepUntilNextInterrupt;
              procedure SleepPause;
              procedure Execute;
              procedure ThreadProc;
              procedure DumpRegisters;
             public
              property State:PState read fPointerToState;
             published
              property HARTID:TPasRISCVUInt32 read fHARTID;
              property PHandle:TPasRISCVUInt32 read fPHandle;
            end;
            { TDebugger }
            TDebugger=class
             public
              const GDB_MAX_PACKET_SIZE=65536;
                    SWBREAK_NONE=0;
                    SWBREAK_TRIGGERED=1;
                    SWBREAK_ACTIVE=2;
                    SWBREAK_PAUSED=3;
              type TPacketBuffer=array[0..GDB_MAX_PACKET_SIZE-1] of TPasRISCVUInt8;
                   { TClientThread }
                   TClientThread=class(TPasMPThread)
                    private
                     fDebugger:TDebugger;
                     fSocket:TRNLSocket;
                     fAddress:TRNLAddress;
                     fEvent:TRNLNetworkEvent;
                     fHART:THART;
                     fRecvBuffer:TPacketBuffer;
                     fRecvSize:TPasRISCVSizeInt;
                     fSendBufferString:TPasRISCVRawByteString;
                     class function Hexify(const aNibble:TPasRISCVUInt8):TPasRISCVRawByteChar; static;
                     class function ByteToHex(const aValue:TPasRISCVUInt8):TPasRISCVRawByteString; static;
                     class function LittleEndianBytesToHex(const aData:Pointer;const aBytes:TPasRISCVSizeInt):TPasRISCVRawByteString; static;
                     class function LittleEndianValueToHex(const aValue:TPasRISCVUInt64;const aBytes:TPasRISCVSizeInt):TPasRISCVRawByteString; static;
                     class function HexNibble(const aDigit:TPasRISCVRawByteChar):TPasRISCVUInt8; static;
                     class function HexToByte(const aString:TPasRISCVRawByteString;var aStringPosition:TPasRISCVSizeInt):TPasRISCVUInt8; static;
                     class procedure HexToLittleEndianBytes(const aData:Pointer;const aString:TPasRISCVRawByteString;var aStringPosition:TPasRISCVSizeInt;const aBytes:TPasRISCVSizeInt); static;
                     class function HexToLittleEndianValue(const aString:TPasRISCVRawByteString;var aStringPosition:TPasRISCVSizeInt;const aBytes:TPasRISCVSizeInt):TPasRISCVUInt64; static;
                     procedure Send(const aData:TPasRISCVRawByteString);
                     procedure ReplyACK;
                     procedure ReplyNAK;
                     procedure ResendReply;
                     procedure SendBufferAppend(const aString:TPasRISCVRawByteString);
                     procedure ReplyString(const aString:TPasRISCVRawByteString);
                     procedure ConsumeBytes(const aBytes:TPasRISCVSizeInt);
                     procedure ProcessStep;
                     procedure ProcessContinue;
                     procedure ProcessMemory(const aPacketString:TPasRISCVRawByteString;const aWrite:Boolean);
                     procedure ProcessReadRegisters;
                     procedure ProcessWriteRegisters(const aPacketString:TPasRISCVRawByteString);
                     procedure ProcessSetThread(const aPacketString:TPasRISCVRawByteString);
                     procedure ProcessHaltReason;
                     procedure ProcessQuery(const aPacketString:TPasRISCVRawByteString);
                     procedure ProcessReset;
                     procedure HandlePacket(const aPacketString:TPasRISCVRawByteString);
                     function ParsePacket:Boolean;
                    protected
                     procedure Execute; override;
                    public
                     constructor Create(const aDebugger:TDebugger;const aSocket:TRNLSocket;const aAddress:TRNLAddress); reintroduce;
                     destructor Destroy; override;
                     procedure AfterConstruction; override;
                     procedure BeforeDestruction; override;
                     procedure Shutdown;
                   end;
                   TClientThreadDynamicArray=array of TClientThread;
                   { TServerThread }
                   TServerThread=class(TPasMPThread)
                    private
                     fDebugger:TDebugger;
                     fListenSocket:TRNLSocket;
                    protected
                     procedure Execute; override;
                    public
                     constructor Create(const aDebugger:TDebugger); reintroduce;
                     destructor Destroy; override;
                     procedure Shutdown;
                   end;
             private
              fMachine:TPasRISCV;
              fRNLInstance:TRNLInstance;
              fRNLNetwork:TRNLNetwork;
              fRNLNetworkEvent:TRNLNetworkEvent;
              fClientsInvertedSemaphore:TPasMPInvertedSemaphore;
              fServerAddress:TRNLAddress;
              fLock:TPasMPCriticalSection;
              fClientThreads:TClientThreadDynamicArray;
              fCountClientThreads:TPasRISCVSizeInt;
              fServerThread:TServerThread;
//            fSWBreakState:TPasRISCVInt32;
              fTerminated:Boolean;
             public
              constructor Create(const aMachine:TPasRISCV;const aPort:TPasRISCVUInt16);
              destructor Destroy; override;
              procedure Interrupt;
              procedure NotifyPaused;
              function Halt:Boolean;
              procedure Pause;
              procedure SingleStep;
              procedure Continue_;
              procedure Reset;
              procedure Start;
              procedure Stop;
            end;
            { TConfiguration }
            TConfiguration=class
             private

              fDebugger:Boolean;
              fDebuggerPort:TPasRISCVUInt16;

              fCountHARTs:TPasRISCVUInt64;

              fBootArguments:TPasRISCVRawByteString;

              fBootMemoryBase:TPasRISCVUInt64;
              fBootMemorySize:TPasRISCVUInt64;

              fMemoryBase:TPasRISCVUInt64;
              fMemorySize:TPasRISCVUInt64;

              fCLINTBase:TPasRISCVUInt64;
              fCLINTSize:TPasRISCVUInt64;

              fIMSICMachineBase:TPasRISCVUInt64;
              fIMSICMachineSizePerHART:TPasRISCVUInt64;

              fIMSICSupervisorBase:TPasRISCVUInt64;
              fIMSICSupervisorSizePerHART:TPasRISCVUInt64;

              fAPLICMachineBase:TPasRISCVUInt64;
              fAPLICMachineSize:TPasRISCVUInt64;

              fAPLICSupervisorBase:TPasRISCVUInt64;
              fAPLICSupervisorSize:TPasRISCVUInt64;

              fPLICBase:TPasRISCVUInt64;
              fPLICSize:TPasRISCVUInt64;

              fSYSCONBase:TPasRISCVUInt64;
              fSYSCONSize:TPasRISCVUInt64;

              fUARTBase:TPasRISCVUInt64;
              fUARTSize:TPasRISCVUInt64;
              fUARTIRQ:TPasRISCVUInt64;

              fVirtIOBlockBase:TPasRISCVUInt64;
              fVirtIOBlockSize:TPasRISCVUInt64;
              fVirtIOBlockIRQ:TPasRISCVUInt64;

              fDS1742Base:TPasRISCVUInt64;
              fDS1742Size:TPasRISCVUInt64;

              fFrameBufferBase:TPasRISCVUInt64;
              fFrameBufferSize:TPasRISCVUInt64;
              fFrameBufferWidth:TPasRISCVUInt64;
              fFrameBufferHeight:TPasRISCVUInt64;
              fFrameBufferBytesPerPixel:TPasRISCVUInt64;
              fFrameBufferStride:TPasRISCVUInt64;
              fFrameBufferFormat:TPasRISCVUInt64;

              fRawKeyboardBase:TPasRISCVUInt64;
              fRawKeyboardSize:TPasRISCVUInt64;

              fI2CBase:TPasRISCVUInt64;
              fI2CSize:TPasRISCVUInt64;

              fPS2KeyboardBase:TPasRISCVUInt64;
              fPS2KeyboardSize:TPasRISCVUInt64;
              fPS2KeyboardIRQ:TPasRISCVUInt64;

              fPS2MouseBase:TPasRISCVUInt64;
              fPS2MouseSize:TPasRISCVUInt64;
              fPS2MouseIRQ:TPasRISCVUInt64;

              fVirtIOInputKeyboardBase:TPasRISCVUInt64;
              fVirtIOInputKeyboardSize:TPasRISCVUInt64;
              fVirtIOInputKeyboardIRQ:TPasRISCVUInt64;

              fVirtIOInputMouseBase:TPasRISCVUInt64;
              fVirtIOInputMouseSize:TPasRISCVUInt64;
              fVirtIOInputMouseIRQ:TPasRISCVUInt64;

              fVirtIOSoundBase:TPasRISCVUInt64;
              fVirtIOSoundSize:TPasRISCVUInt64;
              fVirtIOSoundIRQ:TPasRISCVUInt64;

              fVirtIO9PBase:TPasRISCVUInt64;
              fVirtIO9PSize:TPasRISCVUInt64;
              fVirtIO9PIRQ:TPasRISCVUInt64;

              fVirtIONetBase:TPasRISCVUInt64;
              fVirtIONetSize:TPasRISCVUInt64;
              fVirtIONetIRQ:TPasRISCVUInt64;

              fVirtIORandomGeneratorBase:TPasRISCVUInt64;
              fVirtIORandomGeneratorSize:TPasRISCVUInt64;
              fVirtIORandomGeneratorIRQ:TPasRISCVUInt64;

              fBIOS:TMemoryStream;

              fKernel:TMemoryStream;

              fINITRD:TMemoryStream;

              fAIA:Boolean;

             public
              constructor Create;
              destructor Destroy; override;
              procedure Assign(const aConfiguration:TConfiguration);
              procedure LoadBIOSFromFile(const aFileName:TPasRISCVUTF8String);
              procedure LoadBIOSFromStream(const aStream:TStream);
              procedure LoadBIOSFromMemory(const aMemory:pointer;const aSize:TPasRISCVSizeInt);
              procedure LoadKernelFromFile(const aFileName:TPasRISCVUTF8String);
              procedure LoadKernelFromStream(const aStream:TStream);
              procedure LoadKernelFromMemory(const aMemory:pointer;const aSize:TPasRISCVSizeInt);
              procedure LoadINITRDFromFile(const aFileName:TPasRISCVUTF8String);
              procedure LoadINITRDFromStream(const aStream:TStream);
              procedure LoadINITRDFromMemory(const aMemory:pointer;const aSize:TPasRISCVSizeInt);
             public

              property Debugger:Boolean read fDebugger write fDebugger;
              property DebuggerPort:TPasRISCVUInt16 read fDebuggerPort write fDebuggerPort;

              property CountHARTs:TPasRISCVUInt64 read fCountHARTs write fCountHARTs;

              property BootArguments:TPasRISCVRawByteString read fBootArguments write fBootArguments;

              property BootMemoryBase:TPasRISCVUInt64 read fBootMemoryBase write fBootMemoryBase;
              property BootMemorySize:TPasRISCVUInt64 read fBootMemorySize write fBootMemorySize;

              property MemoryBase:TPasRISCVUInt64 read fMemoryBase write fMemoryBase;
              property MemorySize:TPasRISCVUInt64 read fMemorySize write fMemorySize;

              property CLINTBase:TPasRISCVUInt64 read fCLINTBase write fCLINTBase;
              property CLINTSize:TPasRISCVUInt64 read fCLINTSize write fCLINTSize;

              property IMSICMachineBase:TPasRISCVUInt64 read fIMSICMachineBase write fIMSICMachineBase;
              property IMSICMachineSizePerHART:TPasRISCVUInt64 read fIMSICMachineSizePerHART write fIMSICMachineSizePerHART;

              property IMSICSupervisorBase:TPasRISCVUInt64 read fIMSICSupervisorBase write fIMSICSupervisorBase;
              property IMSICSupervisorSizePerHART:TPasRISCVUInt64 read fIMSICSupervisorSizePerHART write fIMSICSupervisorSizePerHART;

              property APLICMachineBase:TPasRISCVUInt64 read fAPLICMachineBase write fAPLICMachineBase;
              property APLICMachineSize:TPasRISCVUInt64 read fAPLICMachineSize write fAPLICMachineSize;

              property APLICSupervisorBase:TPasRISCVUInt64 read fAPLICSupervisorBase write fAPLICSupervisorBase;
              property APLICSupervisorSize:TPasRISCVUInt64 read fAPLICSupervisorSize write fAPLICSupervisorSize;

              property PLICBase:TPasRISCVUInt64 read fPLICBase write fPLICBase;
              property PLICSize:TPasRISCVUInt64 read fPLICSize write fPLICSize;

              property SYSCONBase:TPasRISCVUInt64 read fSYSCONBase write fSYSCONBase;
              property SYSCONSize:TPasRISCVUInt64 read fSYSCONSize write fSYSCONSize;

              property UARTBase:TPasRISCVUInt64 read fUARTBase write fUARTBase;
              property UARTSize:TPasRISCVUInt64 read fUARTSize write fUARTSize;
              property UARTIRQ:TPasRISCVUInt64 read fUARTIRQ write fUARTIRQ;

              property VirtIOBlockBase:TPasRISCVUInt64 read fVirtIOBlockBase write fVirtIOBlockBase;
              property VirtIOBlockSize:TPasRISCVUInt64 read fVirtIOBlockSize write fVirtIOBlockSize;
              property VirtIOBlockIRQ:TPasRISCVUInt64 read fVirtIOBlockIRQ write fVirtIOBlockIRQ;

              property DS1742Base:TPasRISCVUInt64 read fDS1742Base write fDS1742Base;
              property DS1742Size:TPasRISCVUInt64 read fDS1742Size write fDS1742Size;

              property FrameBufferBase:TPasRISCVUInt64 read fFrameBufferBase write fFrameBufferBase;
              property FrameBufferSize:TPasRISCVUInt64 read fFrameBufferSize write fFrameBufferSize;
              property FrameBufferWidth:TPasRISCVUInt64 read fFrameBufferWidth write fFrameBufferWidth;
              property FrameBufferHeight:TPasRISCVUInt64 read fFrameBufferHeight write fFrameBufferHeight;
              property FrameBufferBytesPerPixel:TPasRISCVUInt64 read fFrameBufferBytesPerPixel write fFrameBufferBytesPerPixel;
              property FrameBufferStride:TPasRISCVUInt64 read fFrameBufferStride write fFrameBufferStride;
              property FrameBufferFormat:TPasRISCVUInt64 read fFrameBufferFormat write fFrameBufferFormat;

              property RawKeyboardBase:TPasRISCVUInt64 read fRawKeyboardBase write fRawKeyboardBase;
              property RawKeyboardSize:TPasRISCVUInt64 read fRawKeyboardSize write fRawKeyboardSize;

              property I2CBase:TPasRISCVUInt64 read fI2CBase write fI2CBase;
              property I2CSize:TPasRISCVUInt64 read fI2CSize write fI2CSize;

              property PS2KeyboardBase:TPasRISCVUInt64 read fPS2KeyboardBase write fPS2KeyboardBase;
              property PS2KeyboardSize:TPasRISCVUInt64 read fPS2KeyboardSize write fPS2KeyboardSize;
              property PS2KeyboardIRQ:TPasRISCVUInt64 read fPS2KeyboardIRQ write fPS2KeyboardIRQ;

              property PS2MouseBase:TPasRISCVUInt64 read fPS2MouseBase write fPS2MouseBase;
              property PS2MouseSize:TPasRISCVUInt64 read fPS2MouseSize write fPS2MouseSize;
              property PS2MouseIRQ:TPasRISCVUInt64 read fPS2MouseIRQ write fPS2MouseIRQ;

              property VirtIOInputKeyboardBase:TPasRISCVUInt64 read fVirtIOInputKeyboardBase write fVirtIOInputKeyboardBase;
              property VirtIOInputKeyboardSize:TPasRISCVUInt64 read fVirtIOInputKeyboardSize write fVirtIOInputKeyboardSize;
              property VirtIOInputKeyboardIRQ:TPasRISCVUInt64 read fVirtIOInputKeyboardIRQ write fVirtIOInputKeyboardIRQ;

              property VirtIOInputMouseBase:TPasRISCVUInt64 read fVirtIOInputMouseBase write fVirtIOInputMouseBase;
              property VirtIOInputMouseSize:TPasRISCVUInt64 read fVirtIOInputMouseSize write fVirtIOInputMouseSize;
              property VirtIOInputMouseIRQ:TPasRISCVUInt64 read fVirtIOInputMouseIRQ write fVirtIOInputMouseIRQ;

              property VirtIOSoundBase:TPasRISCVUInt64 read fVirtIOSoundBase write fVirtIOSoundBase;
              property VirtIOSoundSize:TPasRISCVUInt64 read fVirtIOSoundSize write fVirtIOSoundSize;
              property VirtIOSoundIRQ:TPasRISCVUInt64 read fVirtIOSoundIRQ write fVirtIOSoundIRQ;

              property VirtIO9PBase:TPasRISCVUInt64 read fVirtIO9PBase write fVirtIO9PBase;
              property VirtIO9PSize:TPasRISCVUInt64 read fVirtIO9PSize write fVirtIO9PSize;
              property VirtIO9PIRQ:TPasRISCVUInt64 read fVirtIO9PIRQ write fVirtIO9PIRQ;

              property VirtIONetBase:TPasRISCVUInt64 read fVirtIONetBase write fVirtIONetBase;
              property VirtIONetSize:TPasRISCVUInt64 read fVirtIONetSize write fVirtIONetSize;
              property VirtIONetIRQ:TPasRISCVUInt64 read fVirtIONetIRQ write fVirtIONetIRQ;

              property VirtIORandomGeneratorBase:TPasRISCVUInt64 read fVirtIORandomGeneratorBase write fVirtIORandomGeneratorBase;
              property VirtIORandomGeneratorSize:TPasRISCVUInt64 read fVirtIORandomGeneratorSize write fVirtIORandomGeneratorSize;
              property VirtIORandomGeneratorIRQ:TPasRISCVUInt64 read fVirtIORandomGeneratorIRQ write fVirtIORandomGeneratorIRQ;

              property BIOS:TMemoryStream read fBIOS;

              property Kernel:TMemoryStream read fKernel;

              property INITRD:TMemoryStream read fINITRD;

              property AIA:Boolean read fAIA write fAIA;

            end;
            TOnReboot=procedure of object;
            TOnNewFrame=procedure of object;
            TOnCPUException=function(const aHART:THART;const aExceptionValue:THART.TExceptionValue;const aExceptionData:TPasRISCVUInt64;const aExceptionPC:TPasRISCVUInt64):Boolean of object;
      private

       fConfiguration:TConfiguration;

       fAtomicCriticalSection:TCriticalSection;

       fOnCPUException:TOnCPUException;

       fJobManager:TJobManager;

       fFDT:TFDT;

       fFDTStream:TMemoryStream;

       fStartStackPointer:TPasRiscVUInt64;

       fFDTMemoryOffset:TPasRiscVUInt64;

       fBus:TBus;

       fInterrupts:TInterrupts;

       fBootMemoryDevice:TMemoryDevice;

       fMemoryDevice:TMemoryDevice;

       fACLINTDevice:TACLINTDevice;

       fIMSICMachineDevice:TIMSICDevice;

       fIMSICSupervisorDevice:TIMSICDevice;

       fAPLICDevice:TAPLICDevice;

       fPLICDevice:TPLICDevice;

       fINTCDevice:TINTCDevice;

       fSYSCONDevice:TSYSCONDevice;

       fVirtIOBlockDevice:TVirtIOBlockDevice;

       fUARTDevice:TUARTDevice;

       fDS1742Device:TDS1742Device;

       fPCIBusDevice:TPCIBusDevice;

       fNVMeDevice:TNVMeDevice;

       fFrameBufferDevice:TFrameBufferDevice;

       fRawKeyboardDevice:TRawKeyboardDevice;

       fI2CDevice:TI2CDevice;

       fI2CHIDKeyboardBusDevice:TI2CHIDKeyboardBusDevice;

       fPS2KeyboardDevice:TPS2KeyboardDevice;

       fPS2MouseDevice:TPS2MouseDevice;

       fVirtIOInputKeyboardDevice:TVirtIOInputKeyboardDevice;

       fVirtIOInputMouseDevice:TVirtIOInputMouseDevice;

       fVirtIOSoundDevice:TVirtIOSoundDevice;

       fVirtIO9PDevice:TVirtIO9PDevice;

       fVirtIONetDevice:TVirtIONetDevice;

       fVirtIORandomGeneratorDevice:TVirtIORandomGeneratorDevice;

       fCountHARTs:TPasRISCVSizeInt;

       fHART:THART;

       fHARTs:THARTs;

       fRunState:TPasMPUInt32;

       fFlushTLBHARTMask:TPasRISCVUInt32;

       fHARTActiveMask:TPasMPUInt32;
       fHARTRunningMask:TPasMPUInt32;

       fAllHARTMask:TPasRISCVUInt32;

       fHARTWakeUpConditionVariableLock:TPasMPConditionVariableLock;
       fHARTWakeUpConditionVariable:TPasMPConditionVariable;

       fHARTStatusChangeConditionVariableLock:TPasMPConditionVariableLock;
       fHARTStatusChangeConditionVariable:TPasMPConditionVariable;

       fOnReboot:TOnReboot;

       fOnNewFrame:TOnNewFrame;

       fPHandleCounter:TPasMPUInt32;

       fRandomGeneratorLock:TPasMPSlimReaderWriterLock;
       fRandomGenerator:TRNLRandomGenerator;

       fPCG32Lock:TPasMPSlimReaderWriterLock;
       fPCG32:TPasRISCV.TPCG32;

       fKernelOffset:TPasRISCVUInt64;
       fKernelSize:TPasRISCVUInt64;

       fINITRDOffset:TPasRISCVUInt64;
       fINITRDSize:TPasRISCVUInt64;

       fWakeUpConditionVariableLock:TPasMPConditionVariableLock;
       fWakeUpConditionVariable:TPasMPConditionVariable;

       fDebugger:TDebugger;

       procedure ShutdownCPUs;

       procedure InitializeFDT;

      public

       function LoadELFIntoMemory(const aBinary:TMemoryStream;const aOffset:TPasRISCVUInt64;out aSize:TPasRISCVUInt64;const aObjCopy:Boolean):Boolean;

       function LoadBinaryIntoMemory(const aBinary:TMemoryStream;const aOffset:TPasRISCVUInt64;out aSize:TPasRISCVUInt64;const aCanELF:Boolean;const aObjCopy:Boolean):Boolean;

       function LoadINITRDIntoMemory(const aBinary:TMemoryStream;const aOffset:TPasRISCVUInt64;out aSize:TPasRISCVUInt64):Boolean;

       function GetRunning:Boolean;

      public

       constructor Create(const aConfiguration:TConfiguration=nil); reintroduce;
       destructor Destroy; override;
       function AllocatePHandle:TPasRISCVUInt32;
       procedure Reset;
       procedure Execute(const aSingleStep:Boolean);
       procedure Step;
       procedure Run;
       procedure Reboot;
       procedure PowerOff;
       procedure FlushTLB;
       procedure Interrupt;
       procedure WakeUp;
       procedure InterruptAndWakeUp;
       function QueuePause(const aWaitUntilHalted:Boolean):Boolean;
       procedure Pause(const aWaitUntilHalted:Boolean);
       procedure Resume(const aWaitUntilRunning:Boolean);
       procedure SingleStep(const aWaitUntilDone:Boolean);

      published

       property FDT:TFDT read fFDT;

       property FDTStream:TMemoryStream read fFDTStream;

       property Configuration:TConfiguration read fConfiguration;

       property Bus:TBus read fBus;

       property Interrupts:TInterrupts read fInterrupts;

       property BootMemoryDevice:TMemoryDevice read fBootMemoryDevice;

       property ACLINTDevice:TACLINTDevice read fACLINTDevice;

       property IMSICMachineDevice:TIMSICDevice read fIMSICMachineDevice;

       property IMSICSupervisorDevice:TIMSICDevice read fIMSICSupervisorDevice;

       property APLICDevice:TAPLICDevice read fAPLICDevice;

       property PLICDevice:TPLICDevice read fPLICDevice;

       property INTCDevice:TINTCDevice read fINTCDevice;

       property MemoryDevice:TMemoryDevice read fMemoryDevice;

       property VirtIOBlockDevice:TVirtIOBlockDevice read fVirtIOBlockDevice;

       property UARTDevice:TUARTDevice read fUARTDevice;

       property DS1742Device:TDS1742Device read fDS1742Device;

       property PCIBusDevice:TPCIBusDevice read fPCIBusDevice;

       property NVMeDevice:TNVMeDevice read fNVMeDevice;

       property FrameBufferDevice:TFrameBufferDevice read fFrameBufferDevice;

       property RawKeyboardDevice:TRawKeyboardDevice read fRawKeyboardDevice;

       property I2CDevice:TI2CDevice read fI2CDevice;

       property I2CHIDKeyboardBusDevice:TI2CHIDKeyboardBusDevice read fI2CHIDKeyboardBusDevice;

       property PS2KeyboardDevice:TPS2KeyboardDevice read fPS2KeyboardDevice;

       property PS2MouseDevice:TPS2MouseDevice read fPS2MouseDevice;

       property VirtIOInputKeyboardDevice:TVirtIOInputKeyboardDevice read fVirtIOInputKeyboardDevice;

       property VirtIOInputMouseDevice:TVirtIOInputMouseDevice read fVirtIOInputMouseDevice;

       property VirtIOSoundDevice:TVirtIOSoundDevice read fVirtIOSoundDevice;

       property VirtIO9PDevice:TVirtIO9PDevice read fVirtIO9PDevice;

       property VirtIONetDevice:TVirtIONetDevice read fVirtIONetDevice;

       property VirtIORandomGeneratorDevice:TVirtIORandomGeneratorDevice read fVirtIORandomGeneratorDevice;

       property Debugger:TDebugger read fDebugger;

      public

       property HART:THART read fHART;

       property HARTs:THARTs read fHARTs;

      published

       property Running:Boolean read GetRunning;

       property OnReboot:TOnReboot read fOnReboot write fOnReboot;

       property OnNewFrame:TOnNewFrame read fOnNewFrame write fOnNewFrame;

       property OnCPUException:TOnCPUException read fOnCPUException write fOnCPUException;

     end;

const fmCreateTemporary=4;

{$ifndef fpc}
      feInvalidHandle=TPasRISCVInt32(-1);
{$endif}

function IntLog2(x:TPasRISCVUInt32):TPasRISCVUInt32; {$ifdef fpc}{$ifdef CAN_INLINE}inline;{$endif}{$endif}
function IntLog264(x:TPasRISCVUInt64):TPasRISCVUInt32; {$ifdef fpc}{$ifdef CAN_INLINE}inline;{$endif}{$endif}

implementation

type TZeroBuffer=array[0..65535] of TPasRISCVUInt8;

var ZeroBuffer:TZeroBuffer;

{$if defined(PasRISCVCPUDebug)}
var IgnoreInterrupts:boolean=false;
    DumpDebug:boolean=false;
{$ifend}

function FlushStream(const aStream:TStream):Boolean;
{$if defined(fpc)}
begin
 if assigned(aStream) then begin
  if aStream is TFileStream then begin
   result:=TFileStream(aStream).Flush;
  end else if aStream is TPasRISCVFileMappedStream then begin
   result:=TPasRISCVFileMappedStream(aStream).Flush;
  end else begin
   result:=false;
  end;
 end else begin
  result:=false;
 end;
end;
{$elseif defined(Windows)}
begin
 if assigned(aStream) then begin
  if aStream is TFileStream then begin
   result:=FlushFileBuffers(TFileStream(aStream).Handle);
  end else if aStream is TPasRISCVFileMappedStream then begin
   result:=TPasRISCVFileMappedStream(aStream).Flush;
  end else begin
   result:=false;
  end;
 end else begin
  result:=false;
 end;
end;
{$else}
begin
 if assigned(aStream) then begin
  if aStream is TPasRISCVFileMappedStream then begin
   result:=TPasRISCVFileMappedStream(aStream).Flush;
  end else begin
   result:=false;
  end;
 end else begin
  result:=false;
 end;
end;
{$ifend}

procedure FastDecodeDate(const aDate:TPasRISCVInt32;out aYear,aMonth,aDay:TPasRISCVInt32); // Epoch is 0000-Mar-01
var n1,c,nc,n2,z,ny,y,n3,m,d,j:TPasRISCVUInt32;
    p2:TPasRISCVUInt64;
begin

 // Faster than the classic method, because no branches and no lookup tables

 // Century
 n1:=(aDate*4)+3;
 c:=n1 div 146097;
 nc:=(n1 mod 146097) div 4;

 // Year
 n2:=(nc*4)+3;
 p2:=n2*UInt64(2939745);
 z:=p2 div 4294967296;
 ny:=((p2 mod 4294967296) div 2939745) div 4;
 j:=((ny-305) shr 31) and 1; // j:=ord(ny>=306) and 1; // j:=IfThen(ny>=306,1,0);
 aYear:=((c*100)+z)+j;

 // Month and day
 n3:=(ny*2141)+197913;
 aMonth:=(n3 div 65536)-(j*12);
 aDay:=((n3 mod 65536) div 2141)+1;

end;

function FastEncodeDate(const aYear,aMonth,aDay:TPasRISCVInt32):TPasRISCVInt32; // Epoch is 0000-Mar-01
var t,j,y,m,d:TPasRISCVInt32;
begin

 j:=1-(((m-3) shr 31) and 1); // t:=ord(m<3) and 1; // t:=IfThen(m>2,0,1);
 y:=aYear-j;
 if j<>0 then begin
  m:=aMonth+12;
 end else begin
  m:=aMonth;
 end;

{j:=((ny-305) shr 31) and 1; // j:=ord(ny>=306) and 1; // j:=IfThen(ny>=306,1,0);

 t:=1-(((m-3) shr 31) and 1); // t:=ord(m<3) and 1; // t:=IfThen(m>2,0,1);
 y:=aYear-(t+j);
 m:=aMonth-((t-j)*12);}

 d:=aDay-1;

 y:=(((y*1461) div 4)-(y div 100))+(y div 400);
 m:=((m*153)-457) div 5;

 result:=y+m+d;

end;

function IsLeapYear(const aYear:TPasRISCVUInt32):Boolean;
var d:TPasRISCVUInt32;
begin
 // Always does two divisibility checks, 3x faster than the classic method, because lower entropy helps the branch predictor of the CPU
 d:=IfThen((aYear mod 400)<>0,4,16); // 4 shl (ord((aYear mod 100)=0) shl 1); // 4 or 16, 16 isn't wrong here, because if a number is multiple of 100 and 400 at the same time, it's also multiple of 16, and power of two is much cheaper to evaluate,
 result:=(aYear mod d)=0;
end;

function GetLastDayOfMonth(const aYear,aMonth:TPasRISCVInt32):TPasRISCVInt32;
begin
 // Without lookup tables
 case aMonth of
  2:begin
   result:=28+(ord(IsLeapYear(aYear)) and 1);
  end;
  else begin
   result:=30 or (aMonth xor (aMonth shr 3));  // Alternative: result:=30 or ((9*aMonth) div 8);
  end;
 end;
end;

function RoundUpTo32(const aValue,aRoundTo:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=aValue;
 if (aValue and (aRoundTo-1))<>0 then begin
  inc(result,aRoundTo-(aValue and (aRoundTo-1)));
 end;
end;

function FDTHex64(const aValue:TPasRISCVUInt64):TPasRISCVRawByteString;
const HexChars:array[0..15] of TPasRISCVRawByteChar=('0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f');
var Index:TPasRISCVSizeInt;
    Value:TPasRISCVUInt8;
begin
 result:='';
 for Index:=15 downto 0 do begin
  Value:=(aValue shr (Index shl 2)) and $f;
  if (Value<>0) or (length(result)>0) then begin
   result:=result+HexChars[Value];
  end;
 end;
end;

function StrToUIntBase(const aStr:TPasRISCVRawByteString;var aIndex:TPasRISCVSizeInt;out aLen:TPasRISCVSizeInt;const aBase:TPasRISCVUInt8):TPasRISCVUInt64;
var Value:TPasRISCVUInt64;
    Size:TPasRISCVSizeInt;
    DigitValue:TPasRISCVUInt8;
    Base:TPasRISCVUInt8;
begin
 if aBase=0 then begin
  Base:=10;
  if (aIndex<=length(aStr)) and (aStr[aIndex]=TPasRISCVRawByteChar('0')) then begin
   Base:=8;
   if (aIndex+1)<=length(aStr) then begin
    case aStr[aIndex+1] of
     'o','O':begin
      inc(aIndex);
      Base:=8;
     end;
     'x','X':begin
      inc(aIndex);
      Base:=16;
     end;
     'b','B':begin
      inc(aIndex);
      Base:=2;
     end;
    end;
   end;
  end;
 end else begin
  Base:=aBase;
 end;
 if (Base>=2) and (Base<=36) then begin
  Value:=0;
  Size:=0;
  while aIndex<=length(aStr) do begin
   DigitValue:=TPasRISCVUInt8(aStr[aIndex]);
   case DigitValue of
    TPasRISCVUInt8(TPasRISCVRawByteChar('0'))..TPasRISCVUInt8(TPasRISCVRawByteChar('9')):begin
     DigitValue:=DigitValue-TPasRISCVUInt8(TPasRISCVRawByteChar('0'));
    end;
    TPasRISCVUInt8(TPasRISCVRawByteChar('a'))..TPasRISCVUInt8(TPasRISCVRawByteChar('z')):begin
     DigitValue:=DigitValue-TPasRISCVUInt8(TPasRISCVRawByteChar('a'))+10;
    end;
    TPasRISCVUInt8(TPasRISCVRawByteChar('A'))..TPasRISCVUInt8(TPasRISCVRawByteChar('Z')):begin
     DigitValue:=DigitValue-TPasRISCVUInt8(TPasRISCVRawByteChar('A'))+10;
    end;
    else begin
     break;
    end;
   end;
   Value:=(Value*Base)+DigitValue;
   inc(Size);
   inc(aIndex);
  end;
  aLen:=Size;
  result:=Value;
 end else begin
  aLen:=0;
  result:=0;
 end;
end;

{$if not declared(SARLongint)}
function SARLongint(aValue,aShift:TPasRISCVInt32):TPasRISCVInt32;
{$if defined(cpux64) and defined(Windows) and not defined(fpc)}
asm
.noframe
 mov eax,ecx
 mov ecx,edx
 and cl,31
 sar eax,cl
end;
{$else}
begin
 aShift:=aShift and 31;
 if ((TPasRISCVUInt32(aValue) and TPasRISCVUInt32($80000000))<>0) and (aShift<>0) then begin
  result:=TPasRISCVInt32(TPasRISCVUInt32((TPasRISCVUInt32(aValue) shr aShift) or (TPasRISCVUInt32($ffffffff) shl (32-aShift))));
 end else begin
  result:=TPasRISCVUInt32(TPasRISCVUInt32(aValue) shr aShift);
 end;
end;
{$ifend}
{$ifend}

{$if not declared(SARInt64)}
function SARInt64(const aValue:TPasRISCVInt64;aShift:TPasRISCVInt32):TPasRISCVInt64;
{$if defined(cpux64) and defined(Windows) and not defined(fpc)}
asm
.noframe
 mov rax,rcx
 mov ecx,edx
 and cl,63
 sar rax,cl
end;
{$else}
begin
 aShift:=aShift and 63;
 if ((TPasRISCVUInt64(aValue) and TPasRISCVUInt64($8000000000000000))<>0) and (aShift<>0) then begin
  result:=TPasRISCVInt64(TPasRISCVUInt64((TPasRISCVUInt64(aValue) shr aShift) or (TPasRISCVUInt64($ffffffffffffffff) shl (64-aShift))));
 end else begin
  result:=TPasRISCVUInt64(TPasRISCVUInt64(aValue) shr aShift);
 end;
end;
{$ifend}
{$ifend}

{$if not declared(BSRQWord)}
function BSRQWord(const aValue:TPasRISCVUInt64):TPasRISCVUInt64;
var Debruijn64Multiplicator:TPasRISCVUInt64=TPasRISCVUInt64($03f79d71b4cb0a89);
    Debruijn64Shift=58;
    Debruijn64Mask=63;
    Debruijn64Table:array[0..63] of TPasRISCVUInt64=(0,47,1,56,48,27,2,60,57,49,41,37,28,16,3,61,54,58,35,52,50,42,21,44,38,32,29,23,17,11,4,62,
                                                     46,55,26,59,40,36,15,53,34,51,20,43,31,22,10,45,25,39,14,33,19,30,9,24,13,18,8,12,7,6,5,63);
begin
 if Value=0 then begin
  result:=255;
 end else begin
  Value:=Value or (Value shr 1);
  Value:=Value or (Value shr 2);
  Value:=Value or (Value shr 4);
  Value:=Value or (Value shr 8);
  Value:=Value or (Value shr 16);
  Value:=Value or (Value shr 32);
  result:=Debruijn64Table[((Value*Debruijn64Multiplicator) shr Debruijn64Shift) and Debruijn64Mask];
 end;
end;
{$ifend}

{$if not declared(ROLDWord)}
function ROLDWord(const aValue,aAmount:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=(aValue shl (aAmount and $1f)) or (aValue shr (32-(aAmount and $1f)));
end;
{$ifend}

{$if not declared(ROLQWord)}
function ROLQWord(const aValue,aAmount:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 result:=(aValue shl (aAmount and $3f)) or (aValue shr (64-(aAmount and $3f)));
end;
{$ifend}

{$if not declared(RORDWord)}
function RORDWord(const aValue,aAmount:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=(aValue shr (aAmount and $1f)) or (aValue shl (32-(aAmount and $1f)));
end;
{$ifend}

{$if not declared(RORQWord)}
function RORQWord(const aValue,aAmount:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 result:=(aValue shr (aAmount and $3f)) or (aValue shl (64-(aAmount and $3f)));
end;
{$ifend}

{$if defined(fpc) and declared(BSFQWord) and declared(BSRQWord) and declared(PopCnt)}
function CTZQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32;
begin
 if aValue=0 then begin
  result:=64;
 end else begin
  result:=BSFQWord(aValue);
 end;
end;

function CLZQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32;
begin
 if aValue=0 then begin
  result:=0;
 end else begin
  result:=63-BSRQWord(aValue);
 end;
end;

function POPCNTDWord(aValue:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=PopCnt(aValue);
end;

function POPCNTQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32;
begin
 result:=PopCnt(aValue);
end;

{$elseif defined(cpu386)}
function CTZQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32; assembler; stdcall; {$ifdef fpc}nostackframe;{$endif}
asm
 bsf eax,dword ptr [aValue+0]
 jnz @Done
 bsf eax,dword ptr [aValue+4]
 jz @Fail
 add eax,32
 jmp @Done
@Fail:
 xor eax,eax
 not eax
@Done:
end;

function CLZQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32; assembler; stdcall; {$ifdef fpc}nostackframe;{$endif}
asm
 bsr edx,dword ptr [aValue+4]
 jz @LowPart
 add edx,32
 jmp @Done
@LowPart:
 bsr edx,dword ptr [aValue+0]
 jnz @Done
 xor edx,edx
 not edx
@Done:
 mov eax,63
 sub eax,edx
end;

function POPCNTDWord(aValue:TPasRISCVUInt32):TPasRISCVUInt32; assembler; register;
asm
 // result:=Value-((Value shr 1) and $55555555);
 mov edx,eax
 shr eax,1
 and eax,$55555555
 sub edx,eax

 // result:=(result and $33333333)+((result shr 2) and $33333333);
 mov eax,edx
 shr edx,2
 and eax,$33333333
 and edx,$33333333
 add eax,edx

 // result:=(result+(result shr 4)) and $0f0f0f0f;
 mov edx,eax
 shr eax,4
 add eax,edx
 and eax,$0f0f0f0f

 // inc(result,result shr 8);
 mov edx,eax
 shr edx,8
 add eax,edx

 // inc(result,result shr 16);
 mov edx,eax
 shr edx,16
 add eax,edx

 // result:=result and $3f;
 and eax,$3f
end;

function POPCNTQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32; assembler; stdcall;
asm
 mov eax,dword [aValue+0]
 mov ecx,dword [aValue+4]

 // result:=Value-((Value shr 1) and $55555555);
 mov edx,eax
 shr eax,1
 and eax,$55555555
 sub edx,eax

 // result:=(result and $33333333)+((result shr 2) and $33333333);
 mov eax,edx
 shr edx,2
 and eax,$33333333
 and edx,$33333333
 add eax,edx

 // result:=(result+(result shr 4)) and $0f0f0f0f;
 mov edx,eax
 shr eax,4
 add eax,edx
 and eax,$0f0f0f0f

 // inc(result,result shr 8);
 mov edx,eax
 shr edx,8
 add eax,edx

 // inc(result,result shr 16);
 mov edx,eax
 shr edx,16
 add eax,edx

 // result:=result and $3f;
 and eax,$3f

 xchg ecx,eax

 // result:=Value-((Value shr 1) and $55555555);
 mov edx,eax
 shr eax,1
 and eax,$55555555
 sub edx,eax

 // result:=(result and $33333333)+((result shr 2) and $33333333);
 mov eax,edx
 shr edx,2
 and eax,$33333333
 and edx,$33333333
 add eax,edx

 // result:=(result+(result shr 4)) and $0f0f0f0f;
 mov edx,eax
 shr eax,4
 add eax,edx
 and eax,$0f0f0f0f

 // inc(result,result shr 8);
 mov edx,eax
 shr edx,8
 add eax,edx

 // inc(result,result shr 16);
 mov edx,eax
 shr edx,16
 add eax,edx

 // result:=result and $3f;
 and eax,$3f

 add eax,ecx
end;
{$elseif defined(cpuamd64)}
function CTZQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32; assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
{$ifndef fpc}
 .NOFRAME
{$endif}
{$ifdef Windows}
 bsf rax,rcx
{$else}
 bsf rax,rdi
{$endif}
 jnz @Done
 mov eax,64
@Done:
end;

function CLZQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32; assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
{$ifndef fpc}
 .NOFRAME
{$endif}
{$ifdef Windows}
 bsr rcx,rcx
 jnz @Done
 xor rcx,rcx
 not rcx
@Done:
 mov rax,63
 sub rax,rcx
{$else}
 bsr rdi,rdi
 jnz @Done
 xor rdi,rdi
 not rdi
@Done:
 mov rax,63
 sub rax,rdi
{$endif}
end;

function POPCNTDWord(aValue:TPasRISCVUInt32):TPasRISCVUInt64; assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
{$ifndef fpc}
 .NOFRAME
{$endif}
{$ifdef Windows}
 mov eax,ecx
{$else}
 mov eax,edi
{$endif}

 // result:=Value-((Value shr 1) and $55555555);
 mov edx,eax
 shr eax,1
 and eax,$55555555
 sub edx,eax

 // result:=(result and $33333333)+((result shr 2) and $33333333);
 mov eax,edx
 shr edx,2
 and eax,$33333333
 and edx,$33333333
 add eax,edx

 // result:=(result+(result shr 4)) and $0f0f0f0f;
 mov edx,eax
 shr eax,4
 add eax,edx
 and eax,$0f0f0f0f

 // inc(result,result shr 8);
 mov edx,eax
 shr edx,8
 add eax,edx

 // inc(result,result shr 16);
 mov edx,eax
 shr edx,16
 add eax,edx

 // result:=result and $3f;
 and eax,$3f
end;

function POPCNTQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32; assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
{$ifndef fpc}
 .NOFRAME
{$endif}
{$ifdef Windows}
 mov rax,rcx
{$else}
 mov rax,rdi
{$endif}

 // result:=Value-((Value shr 1) and $5555555555555555);
 mov rdx,rax
 shr rax,1
 mov r8,$5555555555555555
 and rax,r8
 sub rdx,rax

 // result:=(result and $3333333333333333)+((result shr 2) and $3333333333333333);
 mov rax,rdx
 shr rdx,2
 mov r8,$3333333333333333
 and rax,r8
 and rdx,r8
 add rax,rdx

 // result:=(result+(result shr 4)) and $0f0f0f0f0f0f0f0f;
 mov rdx,rax
 shr rax,4
 add rax,rdx
 mov r8,$0f0f0f0f0f0f0f0f
 and rax,r8

 // inc(result,result shr 8);
 mov rdx,rax
 shr rdx,8
 add rax,rdx

 // inc(result,result shr 16);
 mov rdx,rax
 shr rdx,16
 add rax,rdx

 // inc(result,result shr 32);
 mov rdx,rax
 shr rdx,32
 add rax,rdx

 // result:=result and $7f;
 and rax,$7f
end;
{$else}
function CTZQWord(aValue:TPasRISCVUInt64):TPasRISCVInt32;
const PasRISCVCTZDebruijn64Multiplicator:TPasRISCVUInt64=TPasRISCVUInt64($07edd5e59a4e28c2);
      PasRISCVCTZDebruijn64Shift=58;
      PasRISCVCTZDebruijn64Mask=63;
      PasRISCVCTZDebruijn64Table:array[0..63] of TPasRISCVInt32=(63,0,58,1,59,47,53,2,60,39,48,27,54,33,42,3,61,51,37,40,49,18,28,20,55,30,34,11,43,14,22,4,
                                                           62,57,46,52,38,26,32,41,50,36,17,19,29,10,13,21,56,45,25,31,35,16,9,12,44,24,15,8,23,7,6,5);

begin
 if aValue=0 then begin
  result:=64;
 end else begin
  result:=PasRISCVCTZDebruijn64Table[(((aValue and (-aValue))*PasRISCVCTZDebruijn64Multiplicator) shr PasRISCVCTZDebruijn64Shift) and PasRISCVCTZDebruijn64Mask];
 end;
end;

function CLZQWord(aValue:TPasRISCVUInt64):TPasRISCVInt32;
const PasRISCVCLZDebruijn64Multiplicator:TPasRISCVUInt64=TPasRISCVUInt64($03f79d71b4cb0a89);
      PasRISCVCLZDebruijn64Shift=58;
      PasRISCVCLZDebruijn64Mask=63;
      PasRISCVCLZDebruijn64Table:array[0..63] of TPasRISCVInt32=(63,16,62,7,15,36,61,3,6,14,22,26,35,47,60,2,9,5,28,11,13,21,42,19,25,31,34,40,46,52,59,1,
                                                           17,8,37,4,23,27,48,10,29,12,43,20,32,41,53,18,38,24,49,30,44,33,54,39,50,45,55,51,56,57,58,0);
begin
 if aValue=0 then begin
  result:=64;
 end else begin
  aValue:=aValue or (aValue shr 1);
  aValue:=aValue or (aValue shr 2);
  aValue:=aValue or (aValue shr 4);
  aValue:=aValue or (aValue shr 8);
  aValue:=aValue or (aValue shr 16);
  aValue:=aValue or (aValue shr 32);
  result:=PasRISCVCLZDebruijn64Table[((aValue*PasRISCVCLZDebruijn64Multiplicator) shr PasRISCVCLZDebruijn64Shift) and PasRISCVCLZDebruijn64Mask];
 end;
end;

function POPCNTDWord(aValue:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 aValue:=aValue-((aValue shr 1) and TPasRISCVUInt32($55555555));
 aValue:=(aValue and TPasRISCVUInt32($33333333))+((aValue shr 2) and TPasRISCVUInt32($33333333));
 aValue:=(aValue+(aValue shr 4)) and TPasRISCVUInt32($0f0f0f0f);
 inc(aValue,aValue shr 8);
 inc(aValue,aValue shr 16);
 result:=aValue and $3f;
end;

function POPCNTQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32;
begin
 aValue:=aValue-((aValue shr 1) and TPasRISCVUInt64($5555555555555555));
 aValue:=(aValue and TPasRISCVUInt64($3333333333333333))+((aValue shr 2) and TPasRISCVUInt64($3333333333333333));
 aValue:=(aValue+(aValue shr 4)) and TPasRISCVUInt64($0f0f0f0f0f0f0f0f);
 inc(aValue,aValue shr 8);
 inc(aValue,aValue shr 16);
 inc(aValue,aValue shr 32);
 result:=aValue and $7f;
end;
{$ifend}

function BitwiseOrCombine(aValue:TPasRISCVUInt64):TPasRISCVUInt64; {$if defined(fpc) and defined(cpuamd64)} assembler; {$if defined(fpc)}nostackframe; {$if defined(Windows)}ms_abi_default;{$else}sysv_abi_default;{$ifend}{$ifend}
asm
{$if not defined(fpc)}
 .noframe
{$ifend}
{$if defined(Windows)}
 // Win64 ABI: rcx, rdx, r8, r9
 movq xmm0,rcx
{$else}
 // SysV ABI: rdi, rsi, rdx, rcx, r8, r9
 movq xmm0,rdi
{$ifend}
 xorps xmm1,xmm1
 pcmpeqb xmm0,xmm1
 pcmpeqb xmm0,xmm1
 movq rax,xmm0
end;
{$else}
begin
 result:=((((aValue or TPasRISCVUInt64($8080808080808080))-TPasRISCVUInt64($0101010101010101)) or aValue) and TPasRISCVUInt64($8080808080808080)) shr 7;
 result:=(result shl 8)-result;
{aValue:=aValue or (((aValue shr 1) or (aValue shl 1)) and TPasRISCVUInt64($7e7e7e7e7e7e7e7e));
 aValue:=aValue or (((aValue shr 2) or (aValue shl 2)) and TPasRISCVUInt64($3c3c3c3c3c3c3c3c));
 aValue:=aValue or ((aValue shr 4) and TPasRISCVUInt64($0f0f0f0f0f0f0f0f));
 result:=aValue or ((aValue shl 4) and TPasRISCVUInt64($f0f0f0f0f0f0f0f0));}
end;
{$ifend}

function ByteSwap32(aValue:TPasRISCVUInt32):TPasRISCVUInt32; {$if defined(fpc) and defined(cpuamd64)} assembler; {$if defined(fpc)}nostackframe; {$if defined(Windows)}ms_abi_default;{$else}sysv_abi_default;{$ifend}{$ifend}
asm
{$if not defined(fpc)}
 .noframe
{$ifend}
{$if defined(Windows)}
 // Win64 ABI: rcx, rdx, r8, r9
 mov eax,ecx
{$else}
 // SysV ABI: rdi, rsi, rdx, rcx, r8, r9
 mov eax,edi
{$ifend}
 bswap eax
end;
{$else}
begin
{result:=((aValue shr 8) and TPasRISCVUInt32($00ff00ff)) or ((aValue and TPasRISCVUInt32($00ff00ff)) shl 8);
 result:=((result shr 16) and TPasRISCVUInt32($0000ffff)) or ((result and TPasRISCVUInt32($0000ffff)) shl 16);}
 result:=((aValue and TPasRISCVUInt64($00000000ff000000)) shr 24) or
         ((aValue and TPasRISCVUInt64($0000000000ff0000)) shr 8) or
         ((aValue and TPasRISCVUInt64($000000000000ff00)) shl 8) or
         ((aValue and TPasRISCVUInt64($00000000000000ff)) shl 24);
end;
{$ifend}

function ByteSwap64(aValue:TPasRISCVUInt64):TPasRISCVUInt64; {$if defined(fpc) and defined(cpuamd64)} assembler; {$if defined(fpc)}nostackframe; {$if defined(Windows)}ms_abi_default;{$else}sysv_abi_default;{$ifend}{$ifend}
asm
{$if not defined(fpc)}
 .noframe
{$ifend}
{$if defined(Windows)}
 // Win64 ABI: rcx, rdx, r8, r9
 mov rax,rcx
{$else}
 // SysV ABI: rdi, rsi, rdx, rcx, r8, r9
 mov rax,rdi
{$ifend}
 bswap rax
end;
{$else}
begin
 result:=((aValue shr 8) and TPasRISCVUInt64($00ff00ff00ff00ff)) or ((aValue and TPasRISCVUInt64($00ff00ff00ff00ff)) shl 8);
 result:=((result shr 16) and TPasRISCVUInt64($0000ffff0000ffff)) or ((result and TPasRISCVUInt64($0000ffff0000ffff)) shl 16);
 result:=((result shr 32) and TPasRISCVUInt64($00000000ffffffff)) or ((result and TPasRISCVUInt64($00000000ffffffff)) shl 32);
{result:=((aValue and TPasRISCVUInt64($ff00000000000000)) shr 56) or
         ((aValue and TPasRISCVUInt64($00ff000000000000)) shr 40) or
         ((aValue and TPasRISCVUInt64($0000ff0000000000)) shr 24) or
         ((aValue and TPasRISCVUInt64($000000ff00000000)) shr 8) or
         ((aValue and TPasRISCVUInt64($00000000ff000000)) shl 8) or
         ((aValue and TPasRISCVUInt64($0000000000ff0000)) shl 24) or
         ((aValue and TPasRISCVUInt64($000000000000ff00)) shl 40) or
         ((aValue and TPasRISCVUInt64($00000000000000ff)) shl 56);}
end;
{$ifend}

function CLMul64(a,b:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 result:=0;
 repeat
  if (b and 1)<>0 then begin
   result:=result xor a;
  end;
  b:=b shr 1;
  a:=a shl 1;
 until a=0;
end;

function CLMulH64(a,b:TPasRISCVUInt64):TPasRISCVUInt64;
var Index:TPasRISCVUInt64;
begin
 result:=0;
 Index:=63;
 repeat
  b:=b shr 1;
  if (b and 1)<>0 then begin
   result:=result xor (a shr Index);
  end;
  dec(Index);
 until b=0;
end;

function CLMulR64(a,b:TPasRISCVUInt64):TPasRISCVUInt64;
var Index:TPasRISCVUInt64;
begin
 result:=0;
 Index:=63;
 repeat
  if (b and 1)<>0 then begin
   result:=result xor (a shr Index);
  end;
  b:=b shr 1;
  dec(Index);
 until b=0;
end;

function RoundDownToPowerOfTwo(x:TPasRISCVUInt32):TPasRISCVUInt32;
begin

 if x=0 then begin

  // Handle zero case
  result:=0;

 end else begin

  // / Propagate the highest bit to the right
  x:=x or (x shr 1);
  x:=x or (x shr 2);
  x:=x or (x shr 4);
  x:=x or (x shr 8);
  x:=x or (x shr 16);

  // Subtract half of the value to get the previous power of 2
  result:=x-(x shr 1);

 end;

end;

function RoundDownToPowerOfTwo64(x:TPasRISCVUInt64):TPasRISCVUInt64;
begin

 if x=0 then begin

  // Handle zero case
  result:=0;

 end else begin

  // / Propagate the highest bit to the right
  x:=x or (x shr 1);
  x:=x or (x shr 2);
  x:=x or (x shr 4);
  x:=x or (x shr 8);
  x:=x or (x shr 16);
  x:=x or (x shr 32);

  // Subtract half of the value to get the previous power of 2
  result:=x-(x shr 1);

 end;

end;

function RoundDownToPowerOfTwoSizeUInt(x:TPasRISCVSizeUInt):TPasRISCVSizeUInt;
begin

 if x=0 then begin

  // Handle zero case
  result:=0;

 end else begin

  // / Propagate the highest bit to the right
  x:=x or (x shr 1);
  x:=x or (x shr 2);
  x:=x or (x shr 4);
  x:=x or (x shr 8);
  x:=x or (x shr 16);
{$ifdef CPU64}
  x:=x or (x shr 32);
{$endif}

  // Subtract half of the value to get the previous power of 2
  result:=x-(x shr 1);

 end;

end;

function RoundUpToPowerOfTwo(x:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 dec(x);
 x:=x or (x shr 1);
 x:=x or (x shr 2);
 x:=x or (x shr 4);
 x:=x or (x shr 8);
 x:=x or (x shr 16);
 result:=x+1;
end;

function RoundUpToPowerOfTwo64(x:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 dec(x);
 x:=x or (x shr 1);
 x:=x or (x shr 2);
 x:=x or (x shr 4);
 x:=x or (x shr 8);
 x:=x or (x shr 16);
 x:=x or (x shr 32);
 result:=x+1;
end;

function RoundUpToPowerOfTwoSizeUInt(x:TPasRISCVSizeUInt):TPasRISCVSizeUInt;
begin
 dec(x);
 x:=x or (x shr 1);
 x:=x or (x shr 2);
 x:=x or (x shr 4);
 x:=x or (x shr 8);
 x:=x or (x shr 16);
{$ifdef CPU64}
 x:=x or (x shr 32);
{$endif}
 result:=x+1;
end;

function RoundNearestToPowerOfTwo(x:TPasRISCVUInt32):TPasRISCVUInt32;
var a,b:TPasRISCVUInt32;
begin
 a:=RoundDownToPowerOfTwo(x);
 b:=RoundUpToPowerOfTwo(x);
 if (x-a)<(b-x) then begin
  result:=a;
 end else begin
  result:=b;
 end;
end;

function RoundNearestToPowerOfTwo64(x:TPasRISCVUInt64):TPasRISCVUInt64;
var a,b:TPasRISCVUInt64;
begin
 a:=RoundDownToPowerOfTwo64(x);
 b:=RoundUpToPowerOfTwo64(x);
 if (x-a)<(b-x) then begin
  result:=a;
 end else begin
  result:=b;
 end;
end;

function RoundNearestToPowerOfTwoSizeUInt(x:TPasRISCVSizeUInt):TPasRISCVSizeUInt;
var a,b:TPasRISCVUInt32;
begin
 a:=RoundDownToPowerOfTwoSizeUInt(x);
 b:=RoundUpToPowerOfTwoSizeUInt(x);
 if (x-a)<(b-x) then begin
  result:=a;
 end else begin
  result:=b;
 end;
end;

function RoundUp(x,y:TPasRISCVUInt32):TPasRISCVUInt32;
var m:TPasRISCVUInt32;
begin
 m:=y-1;
 if (y and m)=0 then begin
  result:=(x+m) and not TPasRISCVUInt32(m);
 end else begin
  result:=((x+m) div y)*y;
 end;
end;

function RoundUp64(x,y:TPasRISCVUInt64):TPasRISCVUInt64;
var m:TPasRISCVUInt64;
begin
 m:=y-1;
 if (y and m)=0 then begin
  result:=(x+m) and not TPasRISCVUInt64(m);
 end else begin
  result:=((x+m) div y)*y;
 end;
end;

function RoundUpSizeUInt(x,y:TPasRISCVSizeUInt):TPasRISCVSizeUInt;
var m:TPasRISCVSizeUInt;
begin
 m:=y-1;
 if (y and m)=0 then begin
  result:=(x+m) and not TPasRISCVSizeUInt(m);
 end else begin
  result:=((x+m) div y)*y;
 end;
end;

function IntLog2(x:TPasRISCVUInt32):TPasRISCVUInt32; {$if defined(fpc)}{$ifdef CAN_INLINE}inline;{$endif}
begin
 if x<>0 then begin
  result:=BSRDWord(x);
 end else begin
  result:=0;
 end;
end;
{$elseif defined(cpu386)}
asm
 test eax,eax
 jz @Done
 bsr eax,eax
 @Done:
end;
{$elseif defined(cpux86_64)}
asm
{$ifndef fpc}
 .NOFRAME
{$endif}
{$ifdef Windows}
 bsr eax,ecx
{$else}
 bsr eax,edi
{$endif}
 jnz @Done
 xor eax,eax
@Done:
end;
{$else}
begin
 x:=x or (x shr 1);
 x:=x or (x shr 2);
 x:=x or (x shr 4);
 x:=x or (x shr 8);
 x:=x or (x shr 16);
 x:=x shr 1;
 dec(x,(x shr 1) and $55555555);
 x:=((x shr 2) and $33333333)+(x and $33333333);
 x:=((x shr 4)+x) and $0f0f0f0f;
 inc(x,x shr 8);
 inc(x,x shr 16);
 result:=x and $3f;
end;
{$ifend}

function IntLog264(x:TPasRISCVUInt64):TPasRISCVUInt32; {$if defined(fpc)}{$ifdef CAN_INLINE}inline;{$endif}
begin
 if x<>0 then begin
  result:=BSRQWord(x);
 end else begin
  result:=0;
 end;
end;
{$elseif defined(cpu386)}
asm
 bsr eax,dword ptr [x+4]
 jz @LowPart
 add eax,32
 jmp @Done
@LowPart:
 xor ecx,ecx
 bsr eax,dword ptr [x+0]
 jnz @Done
 xor eax,eax
@Done:
end;
{$elseif defined(cpux86_64)}
asm
{$ifndef fpc}
 .NOFRAME
{$endif}
{$ifdef Windows}
 bsr rax,rcx
{$else}
 bsr rax,rdi
{$endif}
 jnz @Done
 xor eax,eax
@Done:
end;
{$else}
begin
 x:=x or (x shr 1);
 x:=x or (x shr 2);
 x:=x or (x shr 4);
 x:=x or (x shr 8);
 x:=x or (x shr 16);
 x:=x or (x shr 32);
 x:=x shr 1;
 dec(x,(x shr 1) and $5555555555555555);
 x:=((x shr 2) and $3333333333333333)+(x and $3333333333333333);
 x:=((x shr 4)+x) and $0f0f0f0f0f0f0f0f;
 inc(x,x shr 8);
 inc(x,x shr 16);
 inc(x,x shr 32);
 result:=x and $7f;
end;
{$ifend}

function SignExtend(const aValue,aBits:TPasRISCVUInt64):TPasRISCVInt64; inline;
begin
 result:=SarInt64(TPasRISCVInt64(aValue shl (64-aBits)),64-aBits);
end;

function BitCut(const aValue,aBit,aBits:TPasRISCVUInt64):TPasRISCVUInt64; inline;
begin
 result:=(aValue shr aBit) and TPasRISCVUInt64(TPasRISCVUInt64(TPasRISCVUInt64(1) shl aBits)-1);
end;

function ReadRawFloatUI32(const aValue):TPasRISCVUInt32; inline;
begin
 result:=PPasRISCVUInt32(Pointer(@aValue))^;
end;

function ReadRawFloatF32(const aValue):TPasRISCVFloat; inline;
begin
 result:=PPasRISCVFloat(Pointer(@aValue))^;
end;

function ReadNormalizedFloatUI32(const aValue):TPasRISCVUInt32; inline;
var ui64:TPasRISCVUInt64;
begin
 ui64:=PPasRISCVUInt64(Pointer(@aValue))^;
 if (ui64 and TPasRISCVUInt64($ffffffff00000000))=TPasRISCVUInt64($ffffffff00000000) then begin
  result:=TPasRISCVUInt32(ui64);
 end else begin
  result:=TPasRISCVUInt32($7fc00000);
 end;
end;

function ReadNormalizedFloatF32(const aValue):TPasRISCVFloat;
var ui64:TPasRISCVUInt64;
begin
 ui64:=PPasRISCVUInt64(Pointer(@aValue))^;
 if (ui64 and TPasRISCVUInt64($ffffffff00000000))=TPasRISCVUInt64($ffffffff00000000) then begin
  PPasRISCVUInt32(Pointer(@result))^:=TPasRISCVUInt32(ui64);
 end else begin
  PPasRISCVUInt32(Pointer(@result))^:=TPasRISCVUInt32($7fc00000);
 end;
end;

function GetCountAudioSamples(const aInputSize,aInputChannels,aInputFormat:TPasRISCVSizeInt):TPasRISCVSizeInt;
var BitsPerSample:TPasRISCVSizeInt;
begin
 case aInputFormat of
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_IMA_ADPCM:begin
   BitsPerSample:=4;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_MU_LAW:begin
   BitsPerSample:=8;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_A_LAW:begin
   BitsPerSample:=8;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S8:begin
   BitsPerSample:=8;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U8:begin
   BitsPerSample:=8;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S16:begin
   BitsPerSample:=16;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U16:begin
   BitsPerSample:=16;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S18_3:begin
   BitsPerSample:=24;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U18_3:begin
   BitsPerSample:=24;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S20_3:begin
   BitsPerSample:=24;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U20_3:begin
   BitsPerSample:=24;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S24_3:begin
   BitsPerSample:=24;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U24_3:begin
   BitsPerSample:=24;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S24:begin
   BitsPerSample:=24;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U24:begin
   BitsPerSample:=24;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S32:begin
   BitsPerSample:=32;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U32:begin
   BitsPerSample:=32;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT:begin
   BitsPerSample:=32;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT64:begin
   BitsPerSample:=64;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U8:begin
   BitsPerSample:=8;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U16:begin
   BitsPerSample:=16;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U32:begin
   BitsPerSample:=32;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_IEC958_SUBFRAME:begin
   BitsPerSample:=32;
  end;
  else begin
   BitsPerSample:=0;
  end;
 end;
 if BitsPerSample=0 then begin
  result:=0;
 end else begin
  result:=aInputSize div (((BitsPerSample+7) shr 3)*aInputChannels);
 end;
end;

// Input Format => 32-bit float (as intermedate format for the conversion process) => Output Format
// First format conversion, then channel count conversion
function ConvertAudio(const aInput:Pointer;const aInputChannels,aInputFormat:TPasRISCVSizeInt;const aOutput:Pointer;const aOutputChannels,aOutputFormat:TPasRISCVSizeInt;const aScratchBuffer:PPasRISCVFloatArray;const aCountSamples:TPasRISCVSizeInt):Boolean;
var SampleIndex,ChannelIndex,CountTotalSamples,Offset:TPasRISCVSizeInt;
    Sample:TPasRISCVFloat;
    Value:TPasRISCVInt32;
begin

 // Input Format => 32-bit float (as intermedate format for the conversion process)
 CountTotalSamples:=aCountSamples*aInputChannels;
 case aInputFormat of
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_IMA_ADPCM:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_MU_LAW:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_A_LAW:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S8:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    aScratchBuffer^[SampleIndex]:=TPasRISCVInt32(PPasRISCVInt8Array(aInput)^[SampleIndex])/128.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U8:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    aScratchBuffer^[SampleIndex]:=(TPasRISCVInt32(PPasRISCVUInt8Array(aInput)^[SampleIndex])-128)/128.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S16:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    aScratchBuffer^[SampleIndex]:=TPasRISCVInt32(PPasRISCVInt16Array(aInput)^[SampleIndex])/32768.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U16:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    aScratchBuffer^[SampleIndex]:=TPasRISCVInt32(PPasRISCVUInt16Array(aInput)^[SampleIndex])/32768.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S18_3:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U18_3:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S20_3:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U20_3:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S24_3:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=TPasRISCVInt32((TPasRISCVUInt32(PPasRISCVUInt8Array(aInput)^[(SampleIndex*3)+0]) shl 8) or
                          (TPasRISCVUInt32(PPasRISCVUInt8Array(aInput)^[(SampleIndex*3)+1]) shl 16) or
                          (TPasRISCVUInt32(PPasRISCVUInt8Array(aInput)^[(SampleIndex*3)+2]) shl 24));
    aScratchBuffer^[SampleIndex]:=Value/2147483648.0;
   end;
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U24_3:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=TPasRISCVInt32((TPasRISCVUInt32(PPasRISCVUInt8Array(aInput)^[(SampleIndex*3)+0]) shl 8) or
                          (TPasRISCVUInt32(PPasRISCVUInt8Array(aInput)^[(SampleIndex*3)+1]) shl 16) or
                          (TPasRISCVUInt32(PPasRISCVUInt8Array(aInput)^[(SampleIndex*3)+2]) shl 24))-2147483648;
    aScratchBuffer^[SampleIndex]:=Value/2147483648.0;
   end;
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S20:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=TPasRISCVInt32(PPasRISCVInt32Array(aInput)^[SampleIndex]);
    if Value<-524288 then begin
     Value:=-524288;
    end else if Value>524288 then begin
     Value:=524288;
    end;
    aScratchBuffer^[SampleIndex]:=Value/524288.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U20:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=TPasRISCVInt32(PPasRISCVUInt32Array(aInput)^[SampleIndex])-524288;
    if Value<-524288 then begin
     Value:=-524288;
    end else if Value>524288 then begin
     Value:=524288;
    end;
    aScratchBuffer^[SampleIndex]:=Value/524288.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S24:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=TPasRISCVInt32(PPasRISCVInt32Array(aInput)^[SampleIndex]);
    if Value<-8388608 then begin
     Value:=-8388608;
    end else if Value>8388608 then begin
     Value:=8388608;
    end;
    aScratchBuffer^[SampleIndex]:=Value/8388608.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U24:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=TPasRISCVInt32(PPasRISCVUInt32Array(aInput)^[SampleIndex])-8388608;
    if Value<-8388608 then begin
     Value:=-8388608;
    end else if Value>8388608 then begin
     Value:=8388608;
    end;
    aScratchBuffer^[SampleIndex]:=Value/8388608.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S32:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    aScratchBuffer^[SampleIndex]:=TPasRISCVInt32(PPasRISCVInt32Array(aInput)^[SampleIndex])/2147483648.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U32:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    aScratchBuffer^[SampleIndex]:=(TPasRISCVInt32(PPasRISCVUInt32Array(aInput)^[SampleIndex])-2147483648)/2147483648.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    aScratchBuffer^[SampleIndex]:=TPasRISCVFloat(PPasRISCVFloatArray(aInput)^[SampleIndex]);
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT64:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    aScratchBuffer^[SampleIndex]:=PPasRISCVDoubleArray(aInput)^[SampleIndex];
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U8:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U16:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U32:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_IEC958_SUBFRAME:begin
   result:=false; // Not implemented
   exit;
  end;
  else begin
   result:=false;
   exit;
  end;
 end;

 // Channel count conversion, but only if the channel count differs
 if (aInputChannels<>aOutputChannels) and (aInputChannels>0) and (aOutputChannels>0) then begin
  Offset:=aCountSamples*aInputChannels;
  if aInputChannels<aOutputChannels then begin
   // Expand channels
   if (aInputChannels=1) and (aOutputChannels=2) then begin
    for SampleIndex:=0 to aCountSamples-1 do begin
     aScratchBuffer^[Offset+(SampleIndex*aOutputChannels)+0]:=aScratchBuffer^[SampleIndex];
     aScratchBuffer^[Offset+(SampleIndex*aOutputChannels)+1]:=aScratchBuffer^[SampleIndex];
    end;
   end else begin
    for ChannelIndex:=0 to aInputChannels-1 do begin
     for SampleIndex:=0 to aCountSamples-1 do begin
      aScratchBuffer^[Offset+(SampleIndex*aOutputChannels)+ChannelIndex]:=aScratchBuffer^[(SampleIndex*aInputChannels)+ChannelIndex];
     end;
    end;
    for ChannelIndex:=aInputChannels to aOutputChannels-1 do begin
     for SampleIndex:=0 to aCountSamples-1 do begin
      aScratchBuffer^[Offset+(SampleIndex*aOutputChannels)+ChannelIndex]:=0.0;
     end;
    end;
    // Exception, if input channels are 1 and output channels are 2 or more, we must duplicate the channel to the second channel
    if (aInputChannels=1) and (aOutputChannels>=2) then begin
     for SampleIndex:=0 to aCountSamples-1 do begin
      aScratchBuffer^[Offset+(SampleIndex*aOutputChannels)+1]:=aScratchBuffer^[Offset+(SampleIndex*aOutputChannels)+0];
     end;
    end;
   end;
  end else begin
   // Reduce channels
   if aOutputChannels=1 then begin
    // Exception, if input channels are 2 and output channels are 1, we must mix the channels to mono, don't matter how many other input channels are there
    for SampleIndex:=0 to aCountSamples-1 do begin
     aScratchBuffer^[Offset+(SampleIndex*aOutputChannels)+0]:=(aScratchBuffer^[(SampleIndex*aInputChannels)+0]+aScratchBuffer^[(SampleIndex*aInputChannels)+1])*0.5;
    end;
   end else begin
    for ChannelIndex:=0 to aOutputChannels-1 do begin
     for SampleIndex:=0 to aCountSamples-1 do begin
      aScratchBuffer^[Offset+(SampleIndex*aOutputChannels)+ChannelIndex]:=aScratchBuffer^[(SampleIndex*aInputChannels)+ChannelIndex];
     end;
    end;
   end;
  end;
 end else begin
  Offset:=0;
 end;

 // Clipping if the output format is not float or float64 to prevent integer overflow in the next step
 if (aOutputFormat<>TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT) and (aOutputFormat<>TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT64) then begin
  CountTotalSamples:=aCountSamples*aOutputChannels;
  for SampleIndex:=0 to CountTotalSamples-1 do begin
   Sample:=aScratchBuffer^[Offset+SampleIndex];
   if Sample<-1.0 then begin
    Sample:=-1.0;
   end else if Sample>1.0 then begin
    Sample:=1.0;
   end;
   aScratchBuffer^[Offset+SampleIndex]:=Sample;
  end;
 end;

 // Output Format
 CountTotalSamples:=aCountSamples*aOutputChannels;
 case aOutputFormat of
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_IMA_ADPCM:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_MU_LAW:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_A_LAW:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S8:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round(aScratchBuffer^[Offset+SampleIndex]*128.0);
    if Value<-128 then begin
     Value:=-128;
    end else if Value>127 then begin
     Value:=127;
    end;
    PPasRISCVInt8Array(aOutput)^[SampleIndex]:=TPasRISCVInt8(Value);
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U8:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round((aScratchBuffer^[Offset+SampleIndex]*128.0)+128);
    if Value<0 then begin
     Value:=0;
    end else if Value>255 then begin
     Value:=255;
    end;
    PPasRISCVUInt8Array(aOutput)^[SampleIndex]:=TPasRISCVUInt8(Value);
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S16:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round(aScratchBuffer^[Offset+SampleIndex]*32768.0);
    if Value<-32768 then begin
     Value:=-32768;
    end else if Value>32767 then begin
     Value:=32767;
    end;
    PPasRISCVInt16Array(aOutput)^[SampleIndex]:=TPasRISCVInt16(Value);
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U16:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round((aScratchBuffer^[Offset+Offset+SampleIndex]*32768.0)+32768);
    if Value<0 then begin
     Value:=0;
    end else if Value>65535 then begin
     Value:=65535;
    end;
    PPasRISCVUInt16Array(aOutput)^[SampleIndex]:=TPasRISCVUInt16(Value);
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S18_3:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U18_3:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S20_3:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U20_3:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S24_3:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round(aScratchBuffer^[Offset+SampleIndex]*2147483648.0);
    PPasRISCVUInt8Array(aOutput)^[(SampleIndex*3)+0]:=TPasRISCVUInt8((Value shr 8) and $ff);
    PPasRISCVUInt8Array(aOutput)^[(SampleIndex*3)+1]:=TPasRISCVUInt8((Value shr 16) and $ff);
    PPasRISCVUInt8Array(aOutput)^[(SampleIndex*3)+2]:=TPasRISCVUInt8((Value shr 24) and $ff);
   end;
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U24_3:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round((aScratchBuffer^[Offset+SampleIndex]*2147483648.0)+2147483648);
    PPasRISCVUInt8Array(aOutput)^[(SampleIndex*3)+0]:=TPasRISCVUInt8((Value shr 8) and $ff);
    PPasRISCVUInt8Array(aOutput)^[(SampleIndex*3)+1]:=TPasRISCVUInt8((Value shr 16) and $ff);
    PPasRISCVUInt8Array(aOutput)^[(SampleIndex*3)+2]:=TPasRISCVUInt8((Value shr 24) and $ff);
   end;
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S20:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round(aScratchBuffer^[Offset+SampleIndex]*524288.0);
    if Value<-524288 then begin
     Value:=-524288;
    end else if Value>524287 then begin
     Value:=524287;
    end;
    PPasRISCVInt32Array(aOutput)^[SampleIndex]:=Value;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U20:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round((aScratchBuffer^[Offset+SampleIndex]*524288.0)+524288);
    if Value<0 then begin
     Value:=0;
    end else if Value>1048575 then begin
     Value:=1048575;
    end;
    PPasRISCVUInt32Array(aOutput)^[SampleIndex]:=Value;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S24:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round(aScratchBuffer^[Offset+SampleIndex]*8388608.0);
    if Value<-8388608 then begin
     Value:=-8388608;
    end else if Value>8388607 then begin
     Value:=8388607;
    end;
    PPasRISCVInt32Array(aOutput)^[SampleIndex]:=Value;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U24:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round((aScratchBuffer^[Offset+SampleIndex]*8388608.0)+8388608);
    if Value<0 then begin
     Value:=0;
    end else if Value>16777215 then begin
     Value:=16777215;
    end;
    PPasRISCVUInt32Array(aOutput)^[SampleIndex]:=Value;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S32:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    PPasRISCVInt32Array(aOutput)^[SampleIndex]:=round(aScratchBuffer^[Offset+SampleIndex]*2147483648.0);
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U32:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    PPasRISCVUInt32Array(aOutput)^[SampleIndex]:=round((aScratchBuffer^[Offset+SampleIndex]*2147483648.0)+2147483648);
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    PPasRISCVFloatArray(aOutput)^[SampleIndex]:=aScratchBuffer^[Offset+SampleIndex];
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT64:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    PPasRISCVDoubleArray(aOutput)^[SampleIndex]:=aScratchBuffer^[Offset+SampleIndex];
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U8:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U16:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U32:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_IEC958_SUBFRAME:begin
   result:=false; // Not implemented
   exit;
  end;
  else begin
   result:=false;
   exit;
  end;
 end;

 // We are done

 result:=true;

end;

// 32-bit float linear resampling, with start frame values from the end of the previous frame, for continuous resampling
function ResampleLinear(const aInput:PPasRISCVFloatArray;const aInputSamples:TPasRISCVSizeInt;const aOutput:PPasRISCVFloatArray;const aOutputSamples,aChannels:TPasRISCVSizeInt;const aPreviousFrameEndValues:PPasRISCVFloatArray;var aPosition:TPasRISCVUInt64;const aPositionIncrement:TPasRISCVUInt64):Boolean;
const Div32Bit=1.0/4294967296.0;
var ChannelIndex,OutputSampleIndex,InputSampleIndex,PreviousInputSampleIndex:TPasRISCVSizeInt;
    Sample,PreviousSample,Alpha:TPasRISCVFloat;
    Position:TPasRISCVUInt64;
begin
 Position:=aPosition;
 for ChannelIndex:=0 to aChannels-1 do begin
  Position:=aPosition and TPasRISCVUInt64($ffffffff); // 32.32 fixed point
  for OutputSampleIndex:=0 to aOutputSamples-1 do begin
   InputSampleIndex:=Position shr 32;
   if InputSampleIndex>=aInputSamples then begin
    InputSampleIndex:=aInputSamples-1;
   end;
   PreviousInputSampleIndex:=InputSampleIndex-1;
   if PreviousInputSampleIndex<0 then begin
    PreviousSample:=aPreviousFrameEndValues^[ChannelIndex];
   end else begin
    PreviousSample:=aInput^[(PreviousInputSampleIndex*aChannels)+ChannelIndex];
   end;
   Alpha:=(Position and TPasRISCVUInt64($ffffffff))*Div32Bit;
   Sample:=(PreviousSample*(1.0-Alpha))+(aInput^[(InputSampleIndex*aChannels)+ChannelIndex]*Alpha);
   aOutput^[(OutputSampleIndex*aChannels)+ChannelIndex]:=Sample;
   inc(Position,aPositionIncrement);
  end;
 end;
 for ChannelIndex:=0 to aChannels-1 do begin
  aPreviousFrameEndValues^[ChannelIndex]:=aInput^[((aInputSamples-1)*aChannels)+ChannelIndex];
 end;
 aPosition:=Position;
 result:=true;
end;

function Marshall(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt;var aPOffset:TPasRISCVSizeInt;const aFmt:TPasRISCVRawByteString;const aArgs:array of pointer):Boolean;
var FmtIndex,ArgIndex,Len:TPasRISCVSizeInt;
    BufferBegin,BufferEnd,BufferCurrent:PPasRISCVUInt8;
    c:AnsiChar;
begin
 if aPOffset<aSize then begin
  BufferBegin:=@PPasRISCVUInt8Array(aBuffer)^[aPOffset];
  BufferEnd:=@PPasRISCVUInt8Array(aBuffer)^[aSize];
  BufferCurrent:=BufferBegin;
  FmtIndex:=1;
  while (TPasRISCVPtrUInt(BufferCurrent)<TPasRISCVPtrUInt(BufferEnd)) and (FmtIndex<=length(aFmt)) do begin
   ArgIndex:=FmtIndex-1;
   c:=aFmt[FmtIndex];
   inc(FmtIndex);
   case c of
    'b':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt8))<=TPasRISCVPtrUInt(BufferEnd) then begin
      PPasRISCVUInt8(BufferCurrent)^:=PPasRISCVUInt8(aArgs[ArgIndex])^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt8));
     end else begin
      result:=false;
      exit;
     end;
    end;
    'h':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt16))<=TPasRISCVPtrUInt(BufferEnd) then begin
      PPasRISCVUInt16(BufferCurrent)^:=PPasRISCVUInt16(aArgs[ArgIndex])^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt16));
     end else begin
      result:=false;
      exit;
     end;
    end;
    'w':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt32))<=TPasRISCVPtrUInt(BufferEnd) then begin
      PPasRISCVUInt32(BufferCurrent)^:=PPasRISCVUInt32(aArgs[ArgIndex])^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt32));
     end else begin
      result:=false;
      exit;
     end;
    end;
    'd':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt64))<=TPasRISCVPtrUInt(BufferEnd) then begin
      PPasRISCVUInt64(BufferCurrent)^:=PPasRISCVUInt64(aArgs[ArgIndex])^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt64));
     end else begin
      result:=false;
      exit;
     end;
    end;
    's':begin
     Len:=length(PPasRISCVRawByteString(aArgs[ArgIndex])^);
     if (Len<=65535) and ((TPasRISCVPtrUInt(BufferCurrent)+Len+2)<=TPasRISCVPtrUInt(BufferEnd)) then begin
      PPasRISCVUInt16(BufferCurrent)^:=Len;
      inc(BufferCurrent,sizeof(TPasRISCVUInt16));
      if Len>0 then begin
       Move(PPasRISCVRawByteString(aArgs[ArgIndex])^[1],BufferCurrent^,Len);
       inc(BufferCurrent,Len);
      end;
     end else begin
      result:=false;
      exit;
     end;
    end;
    'Q':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+13)<=TPasRISCVPtrUInt(BufferEnd) then begin
      Move(aArgs[ArgIndex]^,BufferCurrent^,13);
      inc(BufferCurrent,13);
     end else begin
      result:=false;
      exit;
     end;
    end;
    else begin
     result:=false;
     exit;
    end;
   end;
  end;
  inc(aPOffset,TPasRISCVPtrUInt(BufferCurrent)-TPasRISCVPtrUInt(BufferBegin));
  result:=true;
 end;
end;

function Unmarshall(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt;var aPOffset:TPasRISCVSizeInt;const aFmt:TPasRISCVRawByteString;const aArgs:array of pointer):Boolean;
var FmtIndex,ArgIndex,Len:TPasRISCVSizeInt;
    BufferBegin,BufferEnd,BufferCurrent:PPasRISCVUInt8;
    c:AnsiChar;
begin
 if aPOffset<aSize then begin
  BufferBegin:=@PPasRISCVUInt8Array(aBuffer)^[aPOffset];
  BufferEnd:=@PPasRISCVUInt8Array(aBuffer)^[aSize];
  BufferCurrent:=BufferBegin;
  FmtIndex:=1;
  while (TPasRISCVPtrUInt(BufferCurrent)<TPasRISCVPtrUInt(BufferEnd)) and (FmtIndex<=length(aFmt)) do begin
   ArgIndex:=FmtIndex-1;
   c:=aFmt[FmtIndex];
   inc(FmtIndex);
   case c of
    'b':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt8))<=TPasRISCVPtrUInt(BufferEnd) then begin
      PPasRISCVUInt8(aArgs[ArgIndex])^:=PPasRISCVUInt8(BufferCurrent)^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt8));
     end else begin
      result:=false;
      exit;
     end;
    end;
    'h':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt16))<=TPasRISCVPtrUInt(BufferEnd) then begin
      PPasRISCVUInt16(aArgs[ArgIndex])^:=PPasRISCVUInt16(BufferCurrent)^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt16));
     end else begin
      result:=false;
      exit;
     end;
    end;
    'w':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt32))<=TPasRISCVPtrUInt(BufferEnd) then begin
      PPasRISCVUInt32(aArgs[ArgIndex])^:=PPasRISCVUInt32(BufferCurrent)^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt32));
     end else begin
      result:=false;
      exit;
     end;
    end;
    'd':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt64))<=TPasRISCVPtrUInt(BufferEnd) then begin
      PPasRISCVUInt64(aArgs[ArgIndex])^:=PPasRISCVUInt64(BufferCurrent)^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt64));
     end else begin
      result:=false;
      exit;
     end;
    end;
    's':begin
     PPasRISCVRawByteString(aArgs[ArgIndex])^:='';
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt16))<=TPasRISCVPtrUInt(BufferEnd) then begin
      Len:=PPasRISCVUInt16(BufferCurrent)^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt16));
      SetLength(PPasRISCVRawByteString(aArgs[ArgIndex])^,Len);
      if Len>0 then begin
       if (TPasRISCVPtrUInt(BufferCurrent)+Len)<=TPasRISCVPtrUInt(BufferEnd) then begin
        Move(BufferCurrent^,PPasRISCVRawByteString(aArgs[ArgIndex])^[1],Len);
        inc(BufferCurrent,Len);
       end else begin
        result:=false;
        exit;
       end;
      end;
     end else begin
      result:=false;
      exit;
     end;
    end;
    'Q':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+13)<=TPasRISCVPtrUInt(BufferEnd) then begin
      Move(BufferCurrent^,aArgs[ArgIndex]^,13);
      inc(BufferCurrent,13);
     end else begin
      result:=false;
      exit;
     end;
    end;
    else begin
     result:=false;
     exit;
    end;
   end;
  end;
  inc(aPOffset,TPasRISCVPtrUInt(BufferCurrent)-TPasRISCVPtrUInt(BufferBegin));
  result:=true;
 end else begin
  result:=false;
 end;
end;

function DoInflate(const aInData:Pointer;aInLen:TPasRISCVSizeUInt;var aDestData:Pointer;var aDestLen:TPasRISCVSizeUInt;const aParseHeader:Boolean):Boolean;
{$if not defined(fpc)}
const OutChunkSize=65536;
var d_stream:z_stream;
    r:TPasRISCVInt32;
    Allocated,Have:TPasRISCVSizeUInt;
begin
 result:=false;
 aDestLen:=0;
 Allocated:=0;
 aDestData:=nil;
 FillChar(d_stream,SizeOf(z_stream),AnsiChar(#0));
 d_stream.next_in:=aInData;
 d_stream.avail_in:=aInLen;
 if aParseHeader then begin
  r:=inflateInit(d_stream);
 end else begin
  r:=inflateInit2(d_stream,-15{MAX_WBITS});
 end;
 try
  if r=Z_OK then begin
   try
    Allocated:=RoundUpToPowerOfTwo(aInLen);
    if Allocated<OutChunkSize then begin
     Allocated:=OutChunkSize;
    end;
    GetMem(aDestData,Allocated);
    repeat
     repeat
      if Allocated<(aDestLen+OutChunkSize) then begin
       Allocated:=RoundUpToPowerOfTwo(aDestLen+OutChunkSize);
       if assigned(aDestData) then begin
        ReallocMem(aDestData,Allocated);
       end else begin
        GetMem(aDestData,Allocated);
       end;
      end;
      d_stream.next_out:=@PPasRISCVUInt8Array(aDestData)^[aDestLen];
      d_stream.avail_out:=OutChunkSize;
      r:=Inflate(d_stream,Z_NO_FLUSH);
      if r<Z_OK then begin
       break;
      end;
      if d_stream.avail_out<OutChunkSize then begin
       inc(aDestLen,OutChunkSize-d_stream.avail_out);
      end;
     until d_stream.avail_out<>0;
    until (r<Z_OK) or (r=Z_STREAM_END);
   finally
    if r=Z_STREAM_END then begin
     r:=InflateEnd(d_stream);
    end else begin
     InflateEnd(d_stream);
    end;
   end;
  end;
 finally
  if (r=Z_OK) or (r=Z_STREAM_END) then begin
   if assigned(aDestData) then begin
    ReallocMem(aDestData,aDestLen);
   end else begin
    aDestLen:=0;
   end;
   result:=true;
  end else begin
   if assigned(aDestData) then begin
    FreeMem(aDestData);
   end;
   aDestData:=nil;
  end;
 end;
end;
{$elseif defined(fpc) and (defined(Linux) or defined(Android))}
const OutChunkSize=65536;
var d_stream:z_stream;
    r:TPasRISCVInt32;
    Allocated,Have:TPasRISCVSizeUInt;
begin
 result:=false;
 aDestLen:=0;
 Allocated:=0;
 aDestData:=nil;
 FillChar(d_stream,SizeOf(z_stream),AnsiChar(#0));
 d_stream.next_in:=aInData;
 d_stream.avail_in:=aInLen;
 if aParseHeader then begin
  r:=inflateInit(d_stream);
 end else begin
  r:=inflateInit2(d_stream,-15{MAX_WBITS});
 end;
 try
  if r=Z_OK then begin
   try
    Allocated:=RoundUpToPowerOfTwo(aInLen);
    if Allocated<OutChunkSize then begin
     Allocated:=OutChunkSize;
    end;
    GetMem(aDestData,Allocated);
    repeat
     repeat
      if Allocated<(aDestLen+OutChunkSize) then begin
       Allocated:=RoundUpToPowerOfTwo(aDestLen+OutChunkSize);
       if assigned(aDestData) then begin
        ReallocMem(aDestData,Allocated);
       end else begin
        GetMem(aDestData,Allocated);
       end;
      end;
      d_stream.next_out:=@PPasRISCVUInt8Array(aDestData)^[aDestLen];
      d_stream.avail_out:=OutChunkSize;
      r:=Inflate(d_stream,Z_NO_FLUSH);
      if r<Z_OK then begin
       break;
      end;
      if d_stream.avail_out<OutChunkSize then begin
       inc(aDestLen,OutChunkSize-d_stream.avail_out);
      end;
     until d_stream.avail_out<>0;
    until (r<Z_OK) or (r=Z_STREAM_END);
   finally
    if r=Z_STREAM_END then begin
     r:=InflateEnd(d_stream);
    end else begin
     InflateEnd(d_stream);
    end;
   end;
  end;
 finally
  if (r=Z_OK) or (r=Z_STREAM_END) then begin
   if assigned(aDestData) then begin
    ReallocMem(aDestData,aDestLen);
   end else begin
    aDestLen:=0;
   end;
   result:=true;
  end else begin
   if assigned(aDestData) then begin
    FreeMem(aDestData);
   end;
   aDestData:=nil;
  end;
 end;
end;
{$else}
const CLCIndex:array[0..18] of TPasRISCVUInt8=(16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15);
type PTree=^TTree;
     TTree=packed record
      Table:array[0..15] of TPasRISCVUInt16;
      Translation:array[0..287] of TPasRISCVUInt16;
     end;
     PBuffer=^TBuffer;
     TBuffer=array[0..65535] of TPasRISCVUInt8;
     PLengths=^TLengths;
     TLengths=array[0..288+32-1] of TPasRISCVUInt8;
     POffsets=^TOffsets;
     TOffsets=array[0..15] of TPasRISCVUInt16;
     PBits=^TBits;
     TBits=array[0..29] of TPasRISCVUInt8;
     PBase=^TBase;
     TBase=array[0..29] of TPasRISCVUInt16;
var Tag,BitCount,DestSize:TPasRISCVUInt32;
    SymbolLengthTree,DistanceTree,FixedSymbolLengthTree,FixedDistanceTree:PTree;
    LengthBits,DistanceBits:PBits;
    LengthBase,DistanceBase:PBase;
    Source,SourceEnd:PPasRISCVRawByteChar;
    Dest:PPasRISCVRawByteChar;
 procedure IncSize(length:TPasRISCVUInt32);
 var j:TPasRISCVUInt32;
 begin
  if (aDestLen+length)>=DestSize then begin
   if DestSize=0 then begin
    DestSize:=1;
   end;
   while (aDestLen+length)>=DestSize do begin
    inc(DestSize,DestSize);
   end;
   j:=TPasRISCVPtrUInt(Dest)-TPasRISCVPtrUInt(aDestData);
   ReAllocMem(aDestData,DestSize);
   TPasRISCVPtrUInt(Dest):=TPasRISCVPtrUInt(aDestData)+j;
  end;
 end;
 function Adler32(data:Pointer;length:TPasRISCVSizeUInt):TPasRISCVUInt32;
 const BASE=65521;
       NMAX=5552;
 var buf:PPasRISCVRawByteChar;
     s1,s2:TPasRISCVUInt32;
     k,i:TPasRISCVSizeUInt;
 begin
  s1:=1;
  s2:=0;
  buf:=data;
  while length>0 do begin
   if length<NMAX then begin
    k:=length;
   end else begin
    k:=NMAX;
   end;
   dec(length,k);
   for i:=1 to k do begin
    inc(s1,TPasRISCVUInt8(buf^));
    inc(s2,s1);
    inc(buf);
   end;
   s1:=s1 mod BASE;
   s2:=s2 mod BASE;
  end;
  result:=(s2 shl 16) or s1;
 end;
 procedure BuildBitsBase(Bits:PPasRISCVRawByteChar;Base:PPasRISCVUInt16;Delta,First:TPasRISCVInt32);
 var i,Sum:TPasRISCVInt32;
 begin
  for i:=0 to Delta-1 do begin
   Bits[i]:=TPasRISCVRawByteChar(#0);
  end;
  for i:=0 to (30-Delta)-1 do begin
   Bits[i+Delta]:=TPasRISCVRawByteChar(TPasRISCVUInt8(i div Delta));
  end;
  Sum:=First;
  for i:=0 to 29 do begin
   Base^:=Sum;
   inc(Base);
   inc(Sum,1 shl TPasRISCVUInt8(Bits[i]));
  end;
 end;
 procedure BuildFixedTrees(var lt,dt:TTree);
 var i:TPasRISCVInt32;
 begin
  for i:=0 to 6 do begin
   lt.Table[i]:=0;
  end;
  lt.Table[7]:=24;
  lt.Table[8]:=152;
  lt.Table[9]:=112;
  for i:=0 to 23 do begin
   lt.Translation[i]:=256+i;
  end;
  for i:=0 to 143 do begin
   lt.Translation[24+i]:=i;
  end;
  for i:=0 to 7 do begin
   lt.Translation[168+i]:=280+i;
  end;
  for i:=0 to 111 do begin
   lt.Translation[176+i]:=144+i;
  end;
  for i:=0 to 4 do begin
   dt.Table[i]:=0;
  end;
  dt.Table[5]:=32;
  for i:=0 to 31 do begin
   dt.Translation[i]:=i;
  end;
 end;
 procedure BuildTree(var t:TTree;Lengths:PPasRISCVRawByteChar;Num:TPasRISCVInt32);
 var Offsets:POffsets;
     i:TPasRISCVInt32;
     Sum:TPasRISCVUInt32;
 begin
  New(Offsets);
  try
   for i:=0 to 15 do begin
    t.Table[i]:=0;
   end;
   for i:=0 to Num-1 do begin
    inc(t.Table[TPasRISCVUInt8(Lengths[i])]);
   end;
   t.Table[0]:=0;
   Sum:=0;
   for i:=0 to 15 do begin
    Offsets^[i]:=Sum;
    inc(Sum,t.Table[i]);
   end;
   for i:=0 to Num-1 do begin
    if lengths[i]<>TPasRISCVRawByteChar(#0) then begin
     t.Translation[Offsets^[TPasRISCVUInt8(lengths[i])]]:=i;
     inc(Offsets^[TPasRISCVUInt8(lengths[i])]);
    end;
   end;
  finally
   Dispose(Offsets);
  end;
 end;
 function GetBit:TPasRISCVUInt32;
 begin
  if BitCount=0 then begin
   Tag:=TPasRISCVUInt8(Source^);
   inc(Source);
   BitCount:=7;
  end else begin
   dec(BitCount);
  end;
  result:=Tag and 1;
  Tag:=Tag shr 1;
 end;
 function ReadBits(Num,Base:TPasRISCVUInt32):TPasRISCVUInt32;
 var Limit,Mask:TPasRISCVUInt32;
 begin
  result:=0;
  if Num<>0 then begin
   Limit:=1 shl Num;
   Mask:=1;
   while Mask<Limit do begin
    if GetBit<>0 then begin
     inc(result,Mask);
    end;
    Mask:=Mask shl 1;
   end;
  end;
  inc(result,Base);
 end;
 function DecodeSymbol(var t:TTree):TPasRISCVUInt32;
 var Sum,c,l:TPasRISCVInt32;
 begin
  Sum:=0;
  c:=0;
  l:=0;
  repeat
   c:=(c*2)+TPasRISCVInt32(GetBit);
   inc(l);
   inc(Sum,t.Table[l]);
   dec(c,t.Table[l]);
  until not (c>=0);
  result:=t.Translation[Sum+c];
 end;
 procedure DecodeTrees(var lt,dt:TTree);
 var CodeTree:PTree;
     Lengths:PLengths;
     hlit,hdist,hclen,i,num,length,clen,Symbol,Prev:TPasRISCVUInt32;
 begin
  New(CodeTree);
  New(Lengths);
  try
   FillChar(CodeTree^,sizeof(TTree),TPasRISCVRawByteChar(#0));
   FillChar(Lengths^,sizeof(TLengths),TPasRISCVRawByteChar(#0));
   hlit:=ReadBits(5,257);
   hdist:=ReadBits(5,1);
   hclen:=ReadBits(4,4);
   for i:=0 to 18 do begin
    lengths^[i]:=0;
   end;
   for i:=1 to hclen do begin
    clen:=ReadBits(3,0);
    lengths^[CLCIndex[i-1]]:=clen;
   end;
   BuildTree(CodeTree^,PPasRISCVRawByteChar(Pointer(@lengths^[0])),19);
   num:=0;
   while num<(hlit+hdist) do begin
    Symbol:=DecodeSymbol(CodeTree^);
    case Symbol of
     16:begin
      prev:=lengths^[num-1];
      length:=ReadBits(2,3);
      while length>0 do begin
       lengths^[num]:=prev;
       inc(num);
       dec(length);
      end;
     end;
     17:begin
      length:=ReadBits(3,3);
      while length>0 do begin
       lengths^[num]:=0;
       inc(num);
       dec(length);
      end;
     end;
     18:begin
      length:=ReadBits(7,11);
      while length>0 do begin
       lengths^[num]:=0;
       inc(num);
       dec(length);
      end;
     end;
     else begin
      lengths^[num]:=Symbol;
      inc(num);
     end;
    end;
   end;
   BuildTree(lt,PPasRISCVRawByteChar(Pointer(@lengths^[0])),hlit);
   BuildTree(dt,PPasRISCVRawByteChar(Pointer(@lengths^[hlit])),hdist);
  finally
   Dispose(CodeTree);
   Dispose(Lengths);
  end;
 end;
 function InflateBlockData(var lt,dt:TTree):Boolean;
 var Symbol:TPasRISCVUInt32;
     Length,Distance,Offset,i:TPasRISCVInt32;
 begin
  result:=false;
  while (Source<SourceEnd) or (BitCount>0) do begin
   Symbol:=DecodeSymbol(lt);
   if Symbol=256 then begin
    result:=true;
    break;
   end;
   if Symbol<256 then begin
    IncSize(1);
    Dest^:=TPasRISCVRawByteChar(TPasRISCVUInt8(Symbol));
    inc(Dest);
    inc(aDestLen);
   end else begin
    dec(Symbol,257);
    Length:=ReadBits(LengthBits^[Symbol],LengthBase^[Symbol]);
    Distance:=DecodeSymbol(dt);
    Offset:=ReadBits(DistanceBits^[Distance],DistanceBase^[Distance]);
    IncSize(length);
    for i:=0 to length-1 do begin
     Dest[i]:=Dest[i-Offset];
    end;
    inc(Dest,Length);
    inc(aDestLen,Length);
   end;
  end;
 end;
 function InflateUncompressedBlock:Boolean;
 var length,invlength:TPasRISCVUInt32;
 begin
  result:=false;
  length:=(TPasRISCVUInt8(source[1]) shl 8) or TPasRISCVUInt8(source[0]);
  invlength:=(TPasRISCVUInt8(source[3]) shl 8) or TPasRISCVUInt8(source[2]);
  if length<>((not invlength) and $ffff) then begin
   exit;
  end;
  IncSize(length);
  inc(Source,4);
  if Length>0 then begin
   Move(Source^,Dest^,Length);
   inc(Source,Length);
   inc(Dest,Length);
  end;
  BitCount:=0;
  inc(aDestLen,Length);
  result:=true;
 end;
 function InflateFixedBlock:Boolean;
 begin
  result:=InflateBlockData(FixedSymbolLengthTree^,FixedDistanceTree^);
 end;
 function InflateDynamicBlock:Boolean;
 begin
  DecodeTrees(SymbolLengthTree^,DistanceTree^);
  result:=InflateBlockData(SymbolLengthTree^,DistanceTree^);
 end;
 function Uncompress:Boolean;
 var Final,r:Boolean;
     BlockType:TPasRISCVUInt32;
 begin
  result:=false;
  BitCount:=0;
  Final:=false;
  while not Final do begin
   Final:=GetBit<>0;
   BlockType:=ReadBits(2,0);
   case BlockType of
    0:begin
     r:=InflateUncompressedBlock;
    end;
    1:begin
     r:=InflateFixedBlock;
    end;
    2:begin
     r:=InflateDynamicBlock;
    end;
    else begin
     r:=false;
    end;
   end;
   if not r then begin
    exit;
   end;
  end;
  result:=true;
 end;
 function UncompressZLIB:Boolean;
 var cmf,flg:TPasRISCVUInt8;
     a32:TPasRISCVUInt32;
 begin
  result:=false;
  Source:=aInData;
  cmf:=TPasRISCVUInt8(Source[0]);
  flg:=TPasRISCVUInt8(Source[1]);
  if ((((cmf shl 8)+flg) mod 31)<>0) or ((cmf and $f)<>8) or ((cmf shr 4)>7) or ((flg and $20)<>0) then begin
   exit;
  end;
  a32:=(TPasRISCVUInt8(Source[aInLen-4]) shl 24) or (TPasRISCVUInt8(Source[aInLen-3]) shl 16) or (TPasRISCVUInt8(Source[aInLen-2]) shl 8) or (TPasRISCVUInt8(Source[aInLen-1]) shl 0);
  inc(Source,2);
  dec(aInLen,6);
  SourceEnd:=@Source[aInLen];
  result:=Uncompress;
  if not result then begin
   exit;
  end;
  result:=Adler32(aDestData,aDestLen)=a32;
 end;
 function UncompressDirect:Boolean;
 begin
  Source:=aInData;
  SourceEnd:=@Source[aInLen];
  result:=Uncompress;
 end;
begin
 aDestData:=nil;
 LengthBits:=nil;
 DistanceBits:=nil;
 LengthBase:=nil;
 DistanceBase:=nil;
 SymbolLengthTree:=nil;
 DistanceTree:=nil;
 FixedSymbolLengthTree:=nil;
 FixedDistanceTree:=nil;
 try
  New(LengthBits);
  New(DistanceBits);
  New(LengthBase);
  New(DistanceBase);
  New(SymbolLengthTree);
  New(DistanceTree);
  New(FixedSymbolLengthTree);
  New(FixedDistanceTree);
  try
   begin
    FillChar(LengthBits^,sizeof(TBits),TPasRISCVRawByteChar(#0));
    FillChar(DistanceBits^,sizeof(TBits),TPasRISCVRawByteChar(#0));
    FillChar(LengthBase^,sizeof(TBase),TPasRISCVRawByteChar(#0));
    FillChar(DistanceBase^,sizeof(TBase),TPasRISCVRawByteChar(#0));
    FillChar(SymbolLengthTree^,sizeof(TTree),TPasRISCVRawByteChar(#0));
    FillChar(DistanceTree^,sizeof(TTree),TPasRISCVRawByteChar(#0));
    FillChar(FixedSymbolLengthTree^,sizeof(TTree),TPasRISCVRawByteChar(#0));
    FillChar(FixedDistanceTree^,sizeof(TTree),TPasRISCVRawByteChar(#0));
   end;
   begin
    BuildFixedTrees(FixedSymbolLengthTree^,FixedDistanceTree^);
    BuildBitsBase(PPasRISCVRawByteChar(Pointer(@LengthBits^[0])),PPasRISCVUInt16(Pointer(@LengthBase^[0])),4,3);
    BuildBitsBase(PPasRISCVRawByteChar(Pointer(@DistanceBits^[0])),PPasRISCVUInt16(Pointer(@DistanceBase^[0])),2,1);
    LengthBits^[28]:=0;
    LengthBase^[28]:=258;
   end;
   begin
    GetMem(aDestData,4096);
    DestSize:=4096;
    Dest:=aDestData;
    aDestLen:=0;
    if aParseHeader then begin
     result:=UncompressZLIB;
    end else begin
     result:=UncompressDirect;
    end;
    if result then begin
     ReAllocMem(aDestData,aDestLen);
    end else if assigned(aDestData) then begin
     FreeMem(aDestData);
     aDestData:=nil;
    end;
   end;
  finally
   if assigned(LengthBits) then begin
    Dispose(LengthBits);
   end;
   if assigned(DistanceBits) then begin
    Dispose(DistanceBits);
   end;
   if assigned(LengthBase) then begin
    Dispose(LengthBase);
   end;
   if assigned(DistanceBase) then begin
    Dispose(DistanceBase);
   end;
   if assigned(SymbolLengthTree) then begin
    Dispose(SymbolLengthTree);
   end;
   if assigned(DistanceTree) then begin
    Dispose(DistanceTree);
   end;
   if assigned(FixedSymbolLengthTree) then begin
    Dispose(FixedSymbolLengthTree);
   end;
   if assigned(FixedDistanceTree) then begin
    Dispose(FixedDistanceTree);
   end;
  end;
 except
  result:=false;
 end;
end;
{$ifend}

function ConvertScale(const aValue,aFromScale,aToScale:TPasRISCVUInt64):TPasRISCVUInt64;
var FromScaleRemainder:TPasRISCVUInt64;
begin
 FromScaleRemainder:=aValue mod aFromScale;
 result:=((aValue div aFromScale)*aToScale)+((FromScaleRemainder*aToScale) div aFromScale);
end;

const CLOCK_FREQUENCY=TPasRISCV.CLOCK_FREQUENCY;

{$if defined(Windows)}
type TCreateWaitableTimerExW=function(lpTimerAttributes:Pointer;lpTimerName:LPCWSTR;dwFlags,dwDesiredAccess:DWORD):THandle; {$ifdef cpu386}stdcall;{$endif}

     TNtDelayExecution=function(Alertable:BOOL;var Interval:TLargeInteger):LONG{NTSTATUS}; {$ifdef cpu386}stdcall;{$endif}
     TNtQueryTimerResolution=function(var MinimumResolution,MaximumResolution,CurrentResolution:ULONG):LONG{NTSTATUS}; {$ifdef cpu386}stdcall;{$endif}
     TNtSetTimerResolution=function(var DesiredResolution:ULONG;SetResolution:BOOL;var CurrentResolution:ULONG):LONG{NTSTATUS}; {$ifdef cpu386}stdcall;{$endif}

var KERNEL32LibHandle:HMODULE=HMODULE(0);
    CreateWaitableTimerExW:TCreateWaitableTimerExW=nil;

    NTDLLLibHandle:HMODULE=HMODULE(0);
    NtDelayExecution:TNtDelayExecution=nil;
    NtQueryTimerResolution:TNtQueryTimerResolution=nil;
    NtSetTimerResolution:TNtSetTimerResolution=nil;

    MinimumResolution:ULONG=0;
    MaximumResolution:ULONG=0;
    CurrentResolution:ULONG=0;

//function NtDelayExecution(Alertable:BOOL;var Interval:TLargeInteger):LONG{NTSTATUS}; {$ifdef cpu386}stdcall;{$endif} external 'ntdll.dll' name 'NtDelayExecution';
{$ifend}

var GlobalSleepGranularity:TPasRISCVUInt64=5000;
    GlobalSleepThreshold:TPasRISCVUInt64=20000;

{$if defined(fpc) and defined(Unix)}
{$if not declared(clock_gettime)}

const CLOCK_REALTIME=0;
      CLOCK_MONOTONIC=1;
      CLOCK_PROCESS_CPUTIME_ID=2;
      CLOCK_THREAD_CPUTIME_ID=3;
      CLOCK_MONOTONIC_RAW=4;
      CLOCK_REALTIME_COARSE=5;
      CLOCK_MONOTONIC_COARSE=6;

function clock_gettime(clk_id:TPasRISCVInt32;tp:ptimespec):cint; cdecl; external 'c' name 'clock_gettime';
{$ifend}

function GetCurrentTime:TPasRISCVUInt64;
var Now:TTimeSpec;
begin
 clock_gettime(CLOCK_MONOTONIC,@Now);
{$if CLOCK_FREQUENCY=10000000}
 result:=(TPasRISCVUInt64(Now.tv_sec)*10000000)+(TPasRISCVUInt64(Now.tv_nsec) div TPasRISCVUInt64(100));
{$elseif CLOCK_FREQUENCY=1000000}
 result:=(TPasRISCVUInt64(Now.tv_sec)*1000000)+(TPasRISCVUInt64(Now.tv_nsec) div TPasRISCVUInt64(1000));
{$elseif CLOCK_FREQUENCY=100000}
 result:=(TPasRISCVUInt64(Now.tv_sec)*100000)+(TPasRISCVUInt64(Now.tv_nsec) div TPasRISCVUInt64(10000));
{$elseif CLOCK_FREQUENCY=10000}
 result:=(TPasRISCVUInt64(Now.tv_sec)*10000)+(TPasRISCVUInt64(Now.tv_nsec) div TPasRISCVUInt64(100000));
{$elseif CLOCK_FREQUENCY=1000}
 result:=(TPasRISCVUInt64(Now.tv_sec)*1000)+(TPasRISCVUInt64(Now.tv_nsec) div TPasRISCVUInt64(1000000));
{$else}
 result:=(TPasRISCVUInt64(Now.tv_sec)*TPasRISCV.CLOCK_FREQUENCY)+((TPasRISCVUInt64(Now.tv_nsec)*TPasRISCV.CLOCK_FREQUENCY) div TPasRISCVUInt64(1000000000));
{$ifend}
end;

function GetCurrentFrequencyTime(const aFrequency:TPasRISCVUInt64):TPasRISCVUInt64;
var Now:TTimeSpec;
begin
 clock_gettime(CLOCK_MONOTONIC,@Now);
 result:=(TPasRISCVUInt64(Now.tv_sec)*aFrequency)+((TPasRISCVUInt64(Now.tv_nsec)*aFrequency) div TPasRISCVUInt64(1000000000));
end;

{$elseif defined(Windows)}
var QPCLock:TPasMPUInt32=0;
    QPCLast:TPasMPUInt64=0;
    QPCFrequency:TPasMPUInt64=0;
    QPCFrequencyShift:TPasMPUInt32=0;

function GetCurrentTime:TPasRISCVUInt64;
var QPCNow:TPasMPUInt64;
    Value:TPasMPInt64;
begin
 result:=TPasMPInterlocked.Read(QPCLast);
 if TPasMPInterlocked.CompareExchange(QPCLock,1,0)=0 then begin
  if QPCFrequency=0 then begin
   if QueryPerformanceFrequency(Value) and (Value<>0) then begin
    QPCFrequency:=Value;
    while (QPCFrequency and $ffffffffe0000000)<>0 do begin
     QPCFrequency:=QPCFrequency shr 1;
     inc(QPCFrequencyShift);
    end;
   end else begin
    QPCFrequency:=1000;
   end;
  end;
  QueryPerformanceCounter(Value);
  QPCNow:=TPasMPUInt64(Value) shr QPCFrequencyShift;
  if result<=QPCNow then begin
   result:=QPCNow;
   TPasMPInterlocked.Write(QPCLast,result);
  end;
  TPasMPInterlocked.Write(QPCLock,0);
 end;
 if QPCFrequency<>TPasRISCV.CLOCK_FREQUENCY then begin
  result:=ConvertScale(result,QPCFrequency,TPasRISCV.CLOCK_FREQUENCY);
 end;
end;

function GetCurrentFrequencyTime(const aFrequency:TPasRISCVUInt64):TPasRISCVUInt64;
var QPCNow:TPasMPUInt64;
    Value:TPasMPInt64;
begin
 result:=TPasMPInterlocked.Read(QPCLast);
 if TPasMPInterlocked.CompareExchange(QPCLock,1,0)=0 then begin
  if QPCFrequency=0 then begin
   if QueryPerformanceFrequency(Value) and (Value<>0) then begin
    QPCFrequency:=Value;
    while (QPCFrequency and $ffffffffe0000000)<>0 do begin
     QPCFrequency:=QPCFrequency shr 1;
     inc(QPCFrequencyShift);
    end;
   end else begin
    QPCFrequency:=1000;
   enD;
  end;
  QueryPerformanceCounter(Value);
  QPCNow:=TPasMPUInt64(Value) shr QPCFrequencyShift;
  if result<=QPCNow then begin
   result:=QPCNow;
   TPasMPInterlocked.Write(QPCLast,result);
  end;
  TPasMPInterlocked.Write(QPCLock,0);
 end;
 if QPCFrequency<>aFrequency then begin
  result:=ConvertScale(result,QPCFrequency,aFrequency);
 end;
end;

{$else}
function GetCurrentTime:TPasRISCVUInt64;
begin
{$if CLOCK_FREQUENCY=1000}
 result:=GetTickCount64;
{$elseif CLOCK_FREQUENCY=10000}
 result:=GetTickCount64*10;
{$elseif CLOCK_FREQUENCY=100000}
 result:=GetTickCount64*100;
{$elseif CLOCK_FREQUENCY=1000000}
 result:=GetTickCount64*1000;
{$elseif CLOCK_FREQUENCY=10000000}
 result:=GetTickCount64*10000;
{$else}
 result:=ConvertScale(GetTickCount64,1000,TPasRISCV.CLOCK_FREQUENCY);
{$ifend}
end;

function GetCurrentFrequencyTime(const aFrequency:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 result:=ConvertScale(GetTickCount64,1000,aFrequency);
end;
{$ifend}

procedure WaitTime(const aDuration:TPasRISCVUInt64);
var SleepThreshold,TimeA,TimeB,Remaining,WaitForDuration,Difference:TPasRISCVUInt64;
begin

 SleepThreshold:=GlobalSleepThreshold;
 if GlobalSleepGranularity<>0 then begin
  inc(SleepThreshold,aDuration div 6);
 end;

 Remaining:=aDuration;

 TimeA:=GetCurrentTime;

 // Sleep for a while to avoid busy waiting
 while Remaining>SleepThreshold do begin
  WaitForDuration:=ConvertScale(Remaining-SleepThreshold,CLOCK_FREQUENCY,1000);
  if WaitForDuration>0 then begin
   Sleep(WaitForDuration);
  end;
  TimeB:=GetCurrentTime;
  Difference:=TimeB-TimeA;
  if Remaining>Difference then begin
   dec(Remaining,Difference);
  end else begin
   Remaining:=0;
  end;
  TimeA:=TimeB;
 end;

 // Busy wait for the remaining time for more precise timing
 while Remaining>0 do begin
  TimeB:=GetCurrentTime;
  Difference:=TimeB-TimeA;
  if Remaining>Difference then begin
   dec(Remaining,Difference);
  end else begin
   Remaining:=0;
  end;
  TimeA:=TimeB;
 end;

end;

{$if defined(cpu386)}
function feclearexcept(aExceptions:TPasRISCVUInt32=$3f):TPasRISCVUInt32; assembler; register;
asm
 xor eax,eax
 mov ecx,eax
 and ecx,$3f
 fnstsw ax
 test ecx,eax
 jz @SkipFPU
 fnclex
@SkipFPU:
 stmxcsr dword ptr [esp-8]
 and eax,$3f
 or dword ptr [esp-8],eax
 test dword ptr [esp-8],ecx
 jz @SkipSSE
 not ecx
 and dword ptr [esp-8],ecx
 ldmxcsr dword ptr [esp-8]
@SkipSSE:
 xor eax,eax
end;

function fetestexcept(aExceptions:TPasRISCVUInt32=$3f):TPasRISCVUInt32; assembler; register;
asm
 mov ecx,eax
 and ecx,$3f
 push edx
 stmxcsr dword ptr [esp]
 pop edx
 fnstsw ax
 or eax,edx
 and eax,ecx
end;
{$elseif defined(cpuamd64) or defined(cpux64)}
function feclearexcept(aExceptions:TPasRISCVUInt32=$3f):TPasRISCVUInt32; assembler; {$ifdef fpc}ms_abi_default; nostackframe;{$endif}
asm
{$ifndef fpc}
.noframe
{$endif}
 xor rax,rax
 and ecx,$3f
 fnstsw ax
 test ecx,eax
 jz @SkipFPU
 fnclex
@SkipFPU:
 stmxcsr dword ptr [rsp-8]
 and eax,$3f
 or dword ptr [rsp-8],eax
 test dword ptr [rsp-8],ecx
 jz @SkipSSE
 not ecx
 and dword ptr [rsp-8],ecx
 ldmxcsr dword ptr [rsp-8]
@SkipSSE:
 xor rax,rax
end;

function fetestexcept(aExceptions:TPasRISCVUInt32=$3f):TPasRISCVUInt32; assembler; {$ifdef fpc}ms_abi_default; nostackframe;{$endif}
asm
{$ifndef fpc}
.noframe
{$endif}
 and rcx,$3f
 push rdx
 stmxcsr dword ptr [rsp]
 pop rdx
 fnstsw ax
 or eax,edx
 and eax,ecx
end;
{$else}
function feclearexcept(aExceptions:TPasRISCVUInt32=$3f):TPasRISCVUInt32;
begin
 result:=0;
end;

function fetestexcept(aExceptions:TPasRISCVUInt32=$3f):TPasRISCVUInt32;
begin
 result:=0;
end;
{$ifend}

{$if defined(cpuamd64)}
function MULHU(a,b:TPasRISCVUInt64):TPasRISCVUInt64; assembler; {$if defined(fpc)}nostackframe; {$if defined(Windows)}ms_abi_default;{$else}sysv_abi_default;{$ifend}{$ifend}
asm
{$if not defined(fpc)}
 .noframe
{$ifend}
{$if defined(Windows)}
 // Win64 ABI: rcx, rdx, r8, r9
 mov rax,rcx
 mul rdx
 mov rax,rdx
{$else}
 // SysV ABI: rdi, rsi, rdx, rcx, r8, r9
 mov rax,rdi
 mul rsi
 mov rax,rdx
{$ifend}
end;
{$else}
function MULHU(const a,b:TPasRISCVUInt64):TPasRISCVUInt64;
var LoLo,HiLo,LoHi,HiHi,Cross:TPasRISCVUInt64;
begin
 LoLo:=(a and TPasRISCVUInt64($ffffffff))*(b and TPasRISCVUInt64($ffffffff));
 HiLo:=(a shr 32)*(b and TPasRISCVUInt64($ffffffff));
 LoHi:=(a and TPasRISCVUInt64($ffffffff))*(b shr 32);
 HiHi:=(a shr 32)*(b shr 32);
 Cross:=(LoLo shr 32)+((HiLo and TPasRISCVUInt64($ffffffff))+LoHi);
 result:=(HiLo shr 32)+((Cross shr 32)+HiHi);
end;
{$ifend}

function MULH(const a,b:TPasRISCVInt64):TPasRISCVUInt64;
begin
 result:=MULHU(a,b);
 if a<0 then begin
  dec(result,b);
 end;
 if b<0 then begin
  dec(result,a);
 end;
end;

function MULHSU(const a:TPasRISCVInt64;const b:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 result:=MULHU(a,b);
 if a<0 then begin
  dec(result,b);
 end;
end;

function IsFloat32NaNOrInfinite(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt32($7f800000))=TPasRISCVUInt32($7f800000);
end;

function IsFloat32NaN(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=((Casted and TPasRISCVUInt32($7f800000))=TPasRISCVUInt32($7f800000)) and ((Casted and TPasRISCVUInt32($007fffff))<>0);
end;

function IsFloat32QuietNaN(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt32($7fc00000))=TPasRISCVUInt32($7fc00000);
end;

function IsFloat32SignalingNaN(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=((Casted and TPasRISCVUInt32($7fc00000))=TPasRISCVUInt32($7f800000)) and ((Casted and TPasRISCVUInt32($003fffff))<>0);
end;

function IsFloat32CanonicalNaN(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=Casted=TPasRISCVUInt32($7fc00000);
end;

function IsFloat32Infinite(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt32($7fffffff))=TPasRISCVUInt32($7f800000);
end;

function IsFloat32Negative(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt32($80000000))<>0;
end;

function IsFloat32SubNormal(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt32($7fffffff))<TPasRISCVUInt32($00800000);
end;

function IsFloat32Normal(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=((Casted and TPasRISCVUInt32($7fffffff))>=TPasRISCVUInt32($00800000)) and
         ((Casted and TPasRISCVUInt32($7f800000))<>TPasRISCVUInt32($7f800000));
end;

function IsFloat32Zero(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt32($7fffffff))=0;
end;

function Float32Classify(const aValue:TPasRISCVFloat):TPasRISCVFPType;
var Casted:TPasRISCVUInt32;
begin
 Casted:=TPasRISCVUInt32(Pointer(@aValue)^) and $7fffffff; // Mask out sign bit
 if (Casted and $7f800000)=$7f800000 then begin
  if (Casted and $007fffff)=0 then begin
   result:=TPasRISCVFPType.Infinite;
  end else if (Casted and $7fc00000)<>TPasRISCVUInt32($7fc00000) then begin
   result:=TPasRISCVFPType.SignalingNaN;
  end else begin
   result:=TPasRISCVFPType.QuietNaN;
  end;
 end else begin
  if Casted>=$00800000 then begin
   result:=TPasRISCVFPType.Normal;
  end else if Casted=0 then begin
   result:=TPasRISCVFPType.Zero;
  end else begin
   result:=TPasRISCVFPType.Subnormal;
  end;
 end;
end;

procedure SplitFloat32(const aValue:TPasRISCVFloat;out aIntPart,aFracPart:TPasRISCVFloat);
var Casted,Mask:TPasRISCVUInt32;
    Exponent:TPasRISCVInt32;
begin

 Casted:=TPasRISCVUInt32(Pointer(@aValue)^);
 Exponent:=TPasRISCVInt32((Casted shr 23) and $ff)-$7f;

 // No fractional part
 if Exponent>=23 then begin
  aIntPart:=aValue;
  if (Exponent=$80) and ((Casted and TPasRISCVUInt32($007fffff))<>0) then begin
   // NaN
   aFracPart:=aValue;
   exit;
  end;
  Casted:=Casted and TPasRISCVUInt32($80000000); // Signed zero
  aFracPart:=TPasRISCVFloat(Pointer(@Casted)^);
  exit;
 end;

 // No integral part
 if Exponent<0 then begin
  Casted:=Casted and TPasRISCVUInt32($80000000); // Signed zero
  aIntPart:=TPasRISCVFloat(Pointer(@Casted)^);
  aFracPart:=aValue;
  exit;
 end;

 Mask:=TPasRISCVUInt32($007fffff) shr Exponent;
 if (Casted and Mask)=0 then begin
  aIntPart:=aValue;
  Casted:=Casted and TPasRISCVUInt32($80000000); // Signed zero
  aFracPart:=TPasRISCVFloat(Pointer(@Casted)^);
  exit;
 end;

 Casted:=Casted and not Mask;
 aIntPart:=TPasRISCVFloat(Pointer(@Casted)^);
 aFracPart:=aValue-aIntPart;

end;

function RoundToNearestTiesToEven32(const aValue:TPasRISCVFloat):TPasRISCVFloat;
var Fraction,AbsFraction:TPasRISCVFloat;
begin
 case Float32Classify(aValue) of
  TPasRISCVFPType.Infinite:begin
   result:=Trunc(aValue);
  end;
  TPasRISCVFPType.QuietNaN,
  TPasRISCVFPType.SignalingNaN:begin
   result:=aValue;
  end;
  TPasRISCVFPType.Normal,
  TPasRISCVFPType.Subnormal:begin
   SplitFloat32(aValue,result,Fraction);
   AbsFraction:=abs(Fraction);
   if AbsFraction>0.5 then begin
    if Fraction>0.0 then begin
     result:=result+1.0;
    end else begin
     result:=result-1.0;
    end;
   end else if AbsFraction<0.5 then begin
    // Do nothing
   end else begin
    if (Trunc(result) and 1)<>0 then begin
     if Fraction>0.0 then begin
      result:=result+1.0;
     end else begin
      result:=result-1.0;
     end;
    end;
   end;
  end;
  else {TPasRISCVFPType.Zero:}begin
   result:=0.0;
  end;
 end;
end;

function RoundToNearestTiesToMaxMagnitude32(const aValue:TPasRISCVFloat):TPasRISCVFloat;
var Fraction:TPasRISCVFloat;
begin
 case Float32Classify(aValue) of
  TPasRISCVFPType.Infinite:begin
   result:=Trunc(aValue);
  end;
  TPasRISCVFPType.QuietNaN,
  TPasRISCVFPType.SignalingNaN:begin
   result:=aValue;
  end;
  TPasRISCVFPType.Normal,
  TPasRISCVFPType.Subnormal:begin
   SplitFloat32(aValue,result,Fraction);
   if Fraction>=0.5 then begin
    result:=result+1.0;
   end else if Fraction<=-0.5 then begin
    result:=result-1.0;
   end;
  end;
  else {TPasRISCVFPType.Zero:}begin
   result:=0.0;
  end;
 end;
end;

function IsFloat64NaNOrInfinite(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt64($7ff0000000000000))=TPasRISCVUInt64($7ff0000000000000);
end;

function IsFloat64NaN(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=((Casted and TPasRISCVUInt64($7ff0000000000000))=TPasRISCVUInt64($7ff0000000000000)) and ((Casted and TPasRISCVUInt64($000fffffffffffff))<>0);
end;

function IsFloat64QuietNaN(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt64($7ff8000000000000))=TPasRISCVUInt64($7ff8000000000000);
end;

function IsFloat64SignalingNaN(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=((Casted and TPasRISCVUInt64($7ff8000000000000))=TPasRISCVUInt64($7ff0000000000000)) and ((Casted and TPasRISCVUInt64($0007ffffffffffff))<>0);
end;

function IsFloat64CanonicalNaN(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=Casted=TPasRISCVUInt64($7ff8000000000000);
end;

function IsFloat64Infinite(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt64($7fffffffffffffff))=TPasRISCVUInt64($7ff0000000000000);
end;

function IsFloat64Negative(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt64($8000000000000000))<>0;
end;

function IsFloat64SubNormal(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt64($7fffffffffffffff))<TPasRISCVUInt64($0010000000000000);
end;

function IsFloat64Normal(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=((Casted and TPasRISCVUInt64($7fffffffffffffff))>=TPasRISCVUInt64($0010000000000000)) and
         ((Casted and TPasRISCVUInt64($7ff0000000000000))<>TPasRISCVUInt64($7ff0000000000000));
end;

function IsFloat64Zero(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt64($7fffffffffffffff))=0;
end;

function Float64Classify(const aValue:TPasRISCVDouble):TPasRISCVFPType;
var Casted:TPasRISCVUInt64;
begin
 Casted:=TPasRISCVUInt64(Pointer(@aValue)^) and TPasRISCVUInt64($7fffffffffffffff); // Mask out sign bit
 if (Casted and TPasRISCVUInt64($7ff0000000000000))=TPasRISCVUInt64($7ff0000000000000) then begin
  if (Casted and TPasRISCVUInt64($000fffffffffffff))=0 then begin
   result:=TPasRISCVFPType.Infinite;
  end else if (Casted and TPasRISCVUInt64($7ff8000000000000))<>TPasRISCVUInt64($7ff8000000000000) then begin
   result:=TPasRISCVFPType.SignalingNaN;
  end else begin
   result:=TPasRISCVFPType.QuietNaN;
  end;
 end else begin
  if Casted>=TPasRISCVUInt64($0010000000000000) then begin
   result:=TPasRISCVFPType.Normal;
  end else if Casted=0 then begin
   result:=TPasRISCVFPType.Zero;
  end else begin
   result:=TPasRISCVFPType.Subnormal;
  end;
 end;
end;

procedure SplitFloat64(const aValue:TPasRISCVDouble;out aIntPart,aFracPart:TPasRISCVDouble);
var Casted,Mask:TPasRISCVUInt64;
    Exponent:TPasRISCVInt64;
begin

 Casted:=TPasRISCVUInt64(Pointer(@aValue)^);
 Exponent:=TPasRISCVInt64((Casted shr 52) and $7ff)-$3ff;

 // No fractional part
 if Exponent>=52 then begin
  aIntPart:=aValue;
  if (Exponent=$400) and ((Casted and TPasRISCVUInt64($000fffffffffffff))<>0) then begin
   // NaN
   aFracPart:=aValue;
   exit;
  end;
  Casted:=Casted and TPasRISCVUInt64($8000000000000000); // Signed zero
  aFracPart:=TPasRISCVDouble(Pointer(@Casted)^);
  exit;
 end;

 // No integral part
 if Exponent<0 then begin
  Casted:=Casted and TPasRISCVUInt64($8000000000000000); // Signed zero
  aIntPart:=TPasRISCVDouble(Pointer(@Casted)^);
  aFracPart:=aValue;
  exit;
 end;

 Mask:=TPasRISCVUInt64($000fffffffffffff) shr Exponent;
 if (Casted and Mask)=0 then begin
  aIntPart:=aValue;
  Casted:=Casted and TPasRISCVUInt64($8000000000000000); // Signed zero
  aFracPart:=TPasRISCVDouble(Pointer(@Casted)^);
  exit;
 end;

 Casted:=Casted and not Mask;
 aIntPart:=TPasRISCVDouble(Pointer(@Casted)^);
 aFracPart:=aValue-aIntPart;

end;

function RoundToNearestTiesToEven64(const aValue:TPasRISCVDouble):TPasRISCVDouble;
var Fraction,AbsFraction:TPasRISCVDouble;
begin
 case Float64Classify(aValue) of
  TPasRISCVFPType.Infinite:begin
   result:=Trunc(aValue);
  end;
  TPasRISCVFPType.QuietNaN,
  TPasRISCVFPType.SignalingNaN:begin
   result:=aValue;
  end;
  TPasRISCVFPType.Normal,
  TPasRISCVFPType.Subnormal:begin
   SplitFloat64(aValue,result,Fraction);
   AbsFraction:=abs(Fraction);
   if AbsFraction>0.5 then begin
    if Fraction>0.0 then begin
     result:=result+1.0;
    end else begin
     result:=result-1.0;
    end;
   end else if AbsFraction<0.5 then begin
    // Do nothing
   end else begin
    if (Trunc(result) and 1)<>0 then begin
     if Fraction>0.0 then begin
      result:=result+1.0;
     end else begin
      result:=result-1.0;
     end;
    end;
   end;
  end;
  else {TPasRISCVFPType.Zero:}begin
   result:=0.0;
  end;
 end;
end;

function RoundToNearestTiesToMaxMagnitude64(const aValue:TPasRISCVDouble):TPasRISCVDouble;
var Fraction:TPasRISCVDouble;
begin
 case Float64Classify(aValue) of
  TPasRISCVFPType.Infinite:begin
   result:=Trunc(aValue);
  end;
  TPasRISCVFPType.QuietNaN,
  TPasRISCVFPType.SignalingNaN:begin
   result:=aValue;
  end;
  TPasRISCVFPType.Normal,
  TPasRISCVFPType.Subnormal:begin
   SplitFloat64(aValue,result,Fraction);
   if Fraction>=0.5 then begin
    result:=result+1.0;
   end else if Fraction<=-0.5 then begin
    result:=result-1.0;
   end;
  end;
  else {TPasRISCVFPType.Zero:}begin
   result:=0.0;
  end;
 end;
end;

{ TPasRISCVDynamicQueue<T> }

procedure TPasRISCVDynamicQueue<T>.Initialize;
begin
 Items:=nil;
 Head:=0;
 Tail:=0;
 Count:=0;
 Size:=0;
end;

procedure TPasRISCVDynamicQueue<T>.Finalize;
begin
 Clear;
end;

procedure TPasRISCVDynamicQueue<T>.GrowResize(const aSize:TPasRISCVSizeInt);
var Index,OtherIndex:TPasRISCVSizeInt;
    NewItems:TQueueItems;
begin
 SetLength(NewItems,aSize);
 OtherIndex:=Head;
 for Index:=0 to Count-1 do begin
  NewItems[Index]:=Items[OtherIndex];
  inc(OtherIndex);
  if OtherIndex>=Size then begin
   OtherIndex:=0;
  end;
 end;
 Items:=NewItems;
 Head:=0;
 Tail:=Count;
 Size:=aSize;
end;

procedure TPasRISCVDynamicQueue<T>.Clear;
begin
 while Count>0 do begin
  dec(Count);
  System.Finalize(Items[Head]);
  inc(Head);
  if Head>=Size then begin
   Head:=0;
  end;
 end;
 Items:=nil;
 Head:=0;
 Tail:=0;
 Count:=0;
 Size:=0;
end;

function TPasRISCVDynamicQueue<T>.IsEmpty:boolean;
begin
 result:=Count=0;
end;

procedure TPasRISCVDynamicQueue<T>.EnqueueAtFront(const aItem:T);
var Index:TPasRISCVSizeInt;
begin
 if Size<=Count then begin
  GrowResize(Count+1);
 end;
 dec(Head);
 if Head<0 then begin
  inc(Head,Size);
 end;
 Index:=Head;
 Items[Index]:=aItem;
 inc(Count);
end;

procedure TPasRISCVDynamicQueue<T>.Enqueue(const aItem:T);
var Index:TPasRISCVSizeInt;
begin
 if Size<=Count then begin
  GrowResize(Count+1);
 end;
 Index:=Tail;
 inc(Tail);
 if Tail>=Size then begin
  Tail:=0;
 end;
 Items[Index]:=aItem;
 inc(Count);
end;

function TPasRISCVDynamicQueue<T>.Dequeue(out aItem:T):boolean;
begin
 result:=Count>0;
 if result then begin
  dec(Count);
  aItem:=Items[Head];
  System.Finalize(Items[Head]);
  FillChar(Items[Head],SizeOf(T),#0);
  if Count=0 then begin
   Head:=0;
   Tail:=0;
  end else begin
   inc(Head);
   if Head>=Size then begin
    Head:=0;
   end;
  end;
 end;
end;

function TPasRISCVDynamicQueue<T>.Dequeue:boolean;
begin
 result:=Count>0;
 if result then begin
  dec(Count);
  System.Finalize(Items[Head]);
  FillChar(Items[Head],SizeOf(T),#0);
  if Count=0 then begin
   Head:=0;
   Tail:=0;
  end else begin
   inc(Head);
   if Head>=Size then begin
    Head:=0;
   end;
  end;
 end;
end;

function TPasRISCVDynamicQueue<T>.Peek(out aItem:T):boolean;
begin
 result:=Count>0;
 if result then begin
  aItem:=Items[Head];
 end;
end;

{ TPasRISCVDynamicQueue<T> }

constructor TPasRISCVThreadSafeDynamicQueue<T>.Create;
begin
 inherited Create;
 fLock:=TPasMPSlimReaderWriterLock.Create;
 fItems:=nil;
 fHead:=0;
 fTail:=0;
 fCount:=0;
 fSize:=0;
end;

destructor TPasRISCVThreadSafeDynamicQueue<T>.Destroy;
begin
 Clear;
 FreeAndNil(fLock);
 inherited Destroy;
end;

procedure TPasRISCVThreadSafeDynamicQueue<T>.GrowResize(const aSize:TPasRISCVSizeInt);
var Index,OtherIndex:TPasRISCVSizeInt;
    NewItems:TQueueItems;
begin
 SetLength(NewItems,aSize);
 OtherIndex:=fHead;
 for Index:=0 to fCount-1 do begin
  NewItems[Index]:=fItems[OtherIndex];
  inc(OtherIndex);
  if OtherIndex>=fSize then begin
   OtherIndex:=0;
  end;
 end;
 fItems:=NewItems;
 fHead:=0;
 fTail:=fCount;
 fSize:=aSize;
end;

procedure TPasRISCVThreadSafeDynamicQueue<T>.Clear;
begin
 fLock.Acquire;
 try
  while fCount>0 do begin
   dec(fCount);
   System.Finalize(fItems[fHead]);
   inc(fHead);
   if fHead>=fSize then begin
    fHead:=0;
   end;
  end;
  fItems:=nil;
  fHead:=0;
  fTail:=0;
  fCount:=0;
  fSize:=0;
 finally
  fLock.Release;
 end;
end;

function TPasRISCVThreadSafeDynamicQueue<T>.IsEmpty:boolean;
begin
 fLock.Acquire;
 try
  result:=fCount=0;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCVThreadSafeDynamicQueue<T>.EnqueueAtFront(const aItem:T);
var Index:TPasRISCVSizeInt;
begin
 fLock.Acquire;
 try
  if fSize<=fCount then begin
   GrowResize(fCount+1);
  end;
  dec(fHead);
  if fHead<0 then begin
   inc(fHead,fSize);
  end;
  Index:=fHead;
  fItems[Index]:=aItem;
  inc(fCount);
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCVThreadSafeDynamicQueue<T>.Enqueue(const aItem:T);
var Index:TPasRISCVSizeInt;
begin
 fLock.Acquire;
 try
  if fSize<=fCount then begin
   GrowResize(fCount+1);
  end;
  Index:=fTail;
  inc(fTail);
  if fTail>=fSize then begin
   fTail:=0;
  end;
  fItems[Index]:=aItem;
  inc(fCount);
 finally
  fLock.Release;
 end;
end;

function TPasRISCVThreadSafeDynamicQueue<T>.Dequeue(out aItem:T):boolean;
begin
 while not TryDequeue(aItem) do begin
  TPasMP.Yield;
 end;
 result:=true;
end;

function TPasRISCVThreadSafeDynamicQueue<T>.Dequeue:boolean;
begin
 while not TryDequeue do begin
  TPasMP.Yield;
 end;
 result:=true;
end;

function TPasRISCVThreadSafeDynamicQueue<T>.TryDequeue(out aItem:T):boolean;
begin
 fLock.Acquire;
 try
  result:=fCount>0;
  if result then begin
   dec(fCount);
   aItem:=fItems[fHead];
   System.Finalize(fItems[fHead]);
   FillChar(fItems[fHead],SizeOf(T),#0);
   if fCount=0 then begin
    fHead:=0;
    fTail:=0;
   end else begin
    inc(fHead);
    if fHead>=fSize then begin
     fHead:=0;
    end;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

function TPasRISCVThreadSafeDynamicQueue<T>.TryDequeue:boolean;
begin
 fLock.Acquire;
 try
  result:=fCount>0;
  if result then begin
   dec(fCount);
   System.Finalize(fItems[fHead]);
   FillChar(fItems[fHead],SizeOf(T),#0);
   if fCount=0 then begin
    fHead:=0;
    fTail:=0;
   end else begin
    inc(fHead);
    if fHead>=fSize then begin
     fHead:=0;
    end;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

function TPasRISCVThreadSafeDynamicQueue<T>.Peek(out aItem:T):boolean;
begin
 fLock.Acquire;
 try
  result:=fCount>0;
  if result then begin
   aItem:=fItems[fHead];
  end;
 finally
  fLock.Release;
 end;
end;

{ TPasRISCVHashMap }

{$warnings off}
{$hints off}

constructor TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TEntityEnumerator.Create(const aHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
begin
 fHashMap:=aHashMap;
 fIndex:=-1;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TEntityEnumerator.GetCurrent:TEntity;
begin
 result:=fHashMap.fEntities[fIndex];
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TEntityEnumerator.MoveNext:boolean;
begin
 repeat
  inc(fIndex);
  if fIndex<fHashMap.fSize then begin
   if fHashMap.fEntities[fIndex].State=TEntity.Used then begin
    result:=true;
    exit;
   end;
  end else begin
   break;
  end;
 until false;
 result:=false;
end;

constructor TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TKeyEnumerator.Create(const aHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
begin
 fHashMap:=aHashMap;
 fIndex:=-1;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TKeyEnumerator.GetCurrent:TPasRISCVHashMapKey;
begin
 result:=fHashMap.fEntities[fIndex].Key;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TKeyEnumerator.MoveNext:boolean;
begin
 repeat
  inc(fIndex);
  if fIndex<fHashMap.fSize then begin
   if fHashMap.fEntities[fIndex].State=TEntity.Used then begin
    result:=true;
    exit;
   end;
  end else begin
   break;
  end;
 until false;
 result:=false;
end;

constructor TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TPasRISCVHashMapValueEnumerator.Create(const aHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
begin
 fHashMap:=aHashMap;
 fIndex:=-1;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TPasRISCVHashMapValueEnumerator.GetCurrent:TPasRISCVHashMapValue;
begin
 result:=fHashMap.fEntities[fIndex].Value;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TPasRISCVHashMapValueEnumerator.MoveNext:boolean;
begin
 repeat
  inc(fIndex);
  if fIndex<fHashMap.fSize then begin
   if fHashMap.fEntities[fIndex].State=TEntity.Used then begin
    result:=true;
    exit;
   end;
  end else begin
   break;
  end;
 until false;
 result:=false;
end;

constructor TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TEntitiesObject.Create(const aOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
begin
 inherited Create;
 fOwner:=aOwner;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TEntitiesObject.GetEnumerator:TEntityEnumerator;
begin
 result:=TEntityEnumerator.Create(fOwner);
end;

constructor TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TKeysObject.Create(const aOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
begin
 inherited Create;
 fOwner:=aOwner;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TKeysObject.GetEnumerator:TKeyEnumerator;
begin
 result:=TKeyEnumerator.Create(fOwner);
end;

constructor TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TValuesObject.Create(const aOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
begin
 inherited Create;
 fOwner:=aOwner;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TValuesObject.GetEnumerator:TPasRISCVHashMapValueEnumerator;
begin
 result:=TPasRISCVHashMapValueEnumerator.Create(fOwner);
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TValuesObject.GetValue(const aKey:TPasRISCVHashMapKey):TPasRISCVHashMapValue;
begin
 result:=fOwner.GetValue(aKey);
end;

procedure TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TValuesObject.SetValue(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue);
begin
 fOwner.SetValue(aKey,aValue);
end;

constructor TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.Create(const aDefaultValue:TPasRISCVHashMapValue);
begin
 inherited Create;
 fSize:=0;
 fLogSize:=0;
 fCountNonEmptyEntites:=0;
 fCountDeletedEntites:=0;
 fEntities:=nil;
 fDefaultValue:=aDefaultValue;
 fCanShrink:=true;
 fEntitiesObject:=TEntitiesObject.Create(self);
 fKeysObject:=TKeysObject.Create(self);
 fValuesObject:=TValuesObject.Create(self);
 Resize;
end;

destructor TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.Destroy;
var Index:TPasRISCVSizeInt;
begin
 Clear;
 for Index:=0 to length(fEntities)-1 do begin
  Finalize(fEntities[Index].Key);
  Finalize(fEntities[Index].Value);
 end;
 fEntities:=nil;
 FreeAndNil(fEntitiesObject);
 FreeAndNil(fKeysObject);
 FreeAndNil(fValuesObject);
 inherited Destroy;
end;

procedure TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.Clear(const aCanFree:Boolean);
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to length(fEntities)-1 do begin
  Finalize(fEntities[Index].Key);
  Finalize(fEntities[Index].Value);
 end;
 fCountNonEmptyEntites:=0;
 fCountDeletedEntites:=0;
 if fCanShrink and aCanFree then begin
  fSize:=0;
  fLogSize:=0;
  fEntities:=nil;
  Resize;
 end else begin
  for Index:=0 to length(fEntities)-1 do begin
   fEntities[Index].State:=TEntity.Empty;
  end;
 end;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.HashData(const aData:TPasRISCVPointer;const aDataLength:TPasRISCVUInt32):TPasRISCVUInt32;
// xxHash32
const PRIME32_1=TPasRISCVUInt32(2654435761);
      PRIME32_2=TPasRISCVUInt32(2246822519);
      PRIME32_3=TPasRISCVUInt32(3266489917);
      PRIME32_4=TPasRISCVUInt32(668265263);
      PRIME32_5=TPasRISCVUInt32(374761393);
      Seed=TPasRISCVUInt32($1337c0d3);
      v1Initialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVUInt64(Seed)+TPasRISCVUInt64(PRIME32_1)+TPasRISCVUInt64(PRIME32_2)));
      v2Initialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVUInt64(Seed)+TPasRISCVUInt64(PRIME32_2)));
      v3Initialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVUInt64(Seed)+TPasRISCVUInt64(0)));
      v4Initialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Seed)-TPasRISCVInt64(PRIME32_1))));
      HashInitialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVUInt64(Seed)+TPasRISCVUInt64(PRIME32_5)));
var v1,v2,v3,v4:TPasRISCVUInt32;
    p,e,Limit:PPasRISCVUInt8;
begin
 p:=aData;
 if aDataLength>=16 then begin
  v1:=v1Initialization;
  v2:=v2Initialization;
  v3:=v3Initialization;
  v4:=v4Initialization;
  e:=@PPasRISCVUInt8Array(aData)^[aDataLength-16];
  repeat
{$if defined(fpc) and declared(ROLDWord)}
   v1:=ROLDWord(v1+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2)),13)*TPasRISCVUInt32(PRIME32_1);
{$else}
   inc(v1,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2));
   v1:=((v1 shl 13) or (v1 shr 19))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
   inc(p,SizeOf(TPasRISCVUInt32));
{$if defined(fpc) and declared(ROLDWord)}
   v2:=ROLDWord(v2+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2)),13)*TPasRISCVUInt32(PRIME32_1);
{$else}
   inc(v2,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2));
   v2:=((v2 shl 13) or (v2 shr 19))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
   inc(p,SizeOf(TPasRISCVUInt32));
{$if defined(fpc) and declared(ROLDWord)}
   v3:=ROLDWord(v3+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2)),13)*TPasRISCVUInt32(PRIME32_1);
{$else}
   inc(v3,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2));
   v3:=((v3 shl 13) or (v3 shr 19))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
   inc(p,SizeOf(TPasRISCVUInt32));
{$if defined(fpc) and declared(ROLDWord)}
   v4:=ROLDWord(v4+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2)),13)*TPasRISCVUInt32(PRIME32_1);
{$else}
   inc(v4,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2));
   v4:=((v4 shl 13) or (v4 shr 19))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
   inc(p,SizeOf(TPasRISCVUInt32));
  until {%H-}TPasRISCVPtrUInt(p)>{%H-}TPasRISCVPtrUInt(e);
{$if defined(fpc) and declared(ROLDWord)}
  result:=ROLDWord(v1,1)+ROLDWord(v2,7)+ROLDWord(v3,12)+ROLDWord(v4,18);
{$else}
  result:=((v1 shl 1) or (v1 shr 31))+
          ((v2 shl 7) or (v2 shr 25))+
          ((v3 shl 12) or (v3 shr 20))+
          ((v4 shl 18) or (v4 shr 14));
{$ifend}
 end else begin
  result:=HashInitialization;
 end;
 inc(result,aDataLength);
 e:=@PPasRISCVUInt8Array(aData)^[aDataLength];
 while ({%H-}TPasRISCVPtrUInt(p)+SizeOf(TPasRISCVUInt32))<={%H-}TPasRISCVPtrUInt(e) do begin
{$if defined(fpc) and declared(ROLDWord)}
  result:=ROLDWord(result+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_3)),17)*TPasRISCVUInt32(PRIME32_4);
{$else}
  inc(result,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_3));
  result:=((result shl 17) or (result shr 15))*TPasRISCVUInt32(PRIME32_4);
{$ifend}
  inc(p,SizeOf(TPasRISCVUInt32));
 end;
 while {%H-}TPasRISCVPtrUInt(p)<{%H-}TPasRISCVPtrUInt(e) do begin
{$if defined(fpc) and declared(ROLDWord)}
  result:=ROLDWord(result+(TPasRISCVUInt8(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_5)),11)*TPasRISCVUInt32(PRIME32_1);
{$else}
  inc(result,TPasRISCVUInt8(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_5));
  result:=((result shl 11) or (result shr 21))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
  inc(p,SizeOf(TPasRISCVUInt8));
 end;
 result:=(result xor (result shr 15))*TPasRISCVUInt32(PRIME32_2);
 result:=(result xor (result shr 13))*TPasRISCVUInt32(PRIME32_3);
 result:=result xor (result shr 16);
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.HashKey(const aKey:TPasRISCVHashMapKey):TPasRISCVUInt32;
var p:TPasRISCVUInt64;
begin
 // We're hoping here that the compiler is here so smart, so that the compiler optimizes the
 // unused if-branches away
{$ifndef ExtraStringHashMap}
 if (SizeOf(TPasRISCVHashMapKey)=SizeOf(AnsiString)) and
    (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(AnsiString)) then begin
  result:=HashData(PPasRISCVUInt8(@AnsiString(TPasRISCVPointer(@aKey)^)[1]),length(AnsiString(TPasRISCVPointer(@aKey)^))*SizeOf(AnsiChar));
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(UTF8String)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(UTF8String)) then begin
  result:=HashData(PPasRISCVUInt8(@UTF8String(TPasRISCVPointer(@aKey)^)[1]),length(UTF8String(TPasRISCVPointer(@aKey)^))*SizeOf(AnsiChar));
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(RawByteString)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(RawByteString)) then begin
  result:=HashData(PPasRISCVUInt8(@RawByteString(TPasRISCVPointer(@aKey)^)[1]),length(RawByteString(TPasRISCVPointer(@aKey)^))*SizeOf(AnsiChar));
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(WideString)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(WideString)) then begin
  result:=HashData(PPasRISCVUInt8(@WideString(TPasRISCVPointer(@aKey)^)[1]),length(WideString(TPasRISCVPointer(@aKey)^))*SizeOf(WideChar));
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(UnicodeString)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(UnicodeString)) then begin
  result:=HashData(PPasRISCVUInt8(@UnicodeString(TPasRISCVPointer(@aKey)^)[1]),length(UnicodeString(TPasRISCVPointer(@aKey)^))*SizeOf(WideChar));
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(String)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(String)) then begin
  result:=HashData(PPasRISCVUInt8(@String(TPasRISCVPointer(@aKey)^)[1]),length(String(TPasRISCVPointer(@aKey)^))*SizeOf(Char));
 end else{$endif}begin
  case SizeOf(TPasRISCVHashMapKey) of
   SizeOf(UInt16):begin
    // 16-bit big => use 16-bit integer-rehashing
    result:=TPasRISCVUInt16(TPasRISCVPointer(@aKey)^);
    result:=(result or (((not result) and $ffff) shl 16));
    dec(result,result shl 6);
    result:=result xor (result shr 17);
    dec(result,result shl 9);
    result:=result xor (result shl 4);
    dec(result,result shl 3);
    result:=result xor (result shl 10);
    result:=result xor (result shr 15);
   end;
   SizeOf(TPasRISCVUInt32):begin
    // 32-bit big => use 32-bit integer-rehashing
    result:=TPasRISCVUInt32(TPasRISCVPointer(@aKey)^);
    dec(result,result shl 6);
    result:=result xor (result shr 17);
    dec(result,result shl 9);
    result:=result xor (result shl 4);
    dec(result,result shl 3);
    result:=result xor (result shl 10);
    result:=result xor (result shr 15);
   end;
   SizeOf(TPasRISCVUInt64):begin
    // 64-bit big => use 64-bit to 32-bit integer-rehashing
    p:=TPasRISCVUInt64(TPasRISCVPointer(@aKey)^);
    p:=(not p)+(p shl 18); // p:=((p shl 18)-p-)1;
    p:=p xor (p shr 31);
    p:=p*21; // p:=(p+(p shl 2))+(p shl 4);
    p:=p xor (p shr 11);
    p:=p+(p shl 6);
    result:=TPasRISCVUInt32(TPasRISCVPtrUInt(p xor (p shr 22)));
   end;
   else begin
    result:=HashData(PPasRISCVUInt8(TPasRISCVPointer(@aKey)),SizeOf(TPasRISCVHashMapKey));
   end;
  end;
 end;
{$if defined(CPU386) or defined(CPUAMD64)}
 // Special case: The hash value may be never zero
 result:=result or (-TPasRISCVUInt32(ord(result=0) and 1));
{$else}
 if result=0 then begin
  // Special case: The hash value may be never zero
  result:=$ffffffff;
 end;
{$ifend}
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.CompareKey(const aKeyA,aKeyB:TPasRISCVHashMapKey):boolean;
var Index:TPasRISCVInt32;
    pA,pB:PPasRISCVUInt8Array;
begin
 // We're hoping also here that the compiler is here so smart, so that the compiler optimizes the
 // unused if-branches away
{$ifndef ExtraStringHashMap}
 if (SizeOf(TPasRISCVHashMapKey)=SizeOf(AnsiString)) and
    (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(AnsiString)) then begin
  result:=AnsiString(TPasRISCVPointer(@aKeyA)^)=AnsiString(TPasRISCVPointer(@aKeyB)^);
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(UTF8String)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(UTF8String)) then begin
  result:=UTF8String(TPasRISCVPointer(@aKeyA)^)=UTF8String(TPasRISCVPointer(@aKeyB)^);
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(RawByteString)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(RawByteString)) then begin
  result:=RawByteString(TPasRISCVPointer(@aKeyA)^)=RawByteString(TPasRISCVPointer(@aKeyB)^);
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(WideString)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(WideString)) then begin
  result:=WideString(TPasRISCVPointer(@aKeyA)^)=WideString(TPasRISCVPointer(@aKeyB)^);
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(UnicodeString)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(UnicodeString)) then begin
  result:=UnicodeString(TPasRISCVPointer(@aKeyA)^)=UnicodeString(TPasRISCVPointer(@aKeyB)^);
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(String)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(String)) then begin
  result:=String(TPasRISCVPointer(@aKeyA)^)=String(TPasRISCVPointer(@aKeyB)^);
 end else{$endif}begin
  case SizeOf(TPasRISCVHashMapKey) of
   SizeOf(TPasRISCVUInt8):begin
    result:=UInt8(TPasRISCVPointer(@aKeyA)^)=UInt8(TPasRISCVPointer(@aKeyB)^);
   end;
   SizeOf(TPasRISCVUInt16):begin
    result:=UInt16(TPasRISCVPointer(@aKeyA)^)=UInt16(TPasRISCVPointer(@aKeyB)^);
   end;
   SizeOf(TPasRISCVUInt32):begin
    result:=TPasRISCVUInt32(TPasRISCVPointer(@aKeyA)^)=TPasRISCVUInt32(TPasRISCVPointer(@aKeyB)^);
   end;
   SizeOf(TPasRISCVUInt64):begin
    result:=TPasRISCVUInt64(TPasRISCVPointer(@aKeyA)^)=TPasRISCVUInt64(TPasRISCVPointer(@aKeyB)^);
   end;
{$ifdef fpc}
   SizeOf(TPasRISCVHashMapUInt128):begin
    result:=(TPasRISCVHashMapUInt128(TPasRISCVPointer(@aKeyA)^)[0]=TPasRISCVHashMapUInt128(TPasRISCVPointer(@aKeyB)^)[0]) and
            (TPasRISCVHashMapUInt128(TPasRISCVPointer(@aKeyA)^)[1]=TPasRISCVHashMapUInt128(TPasRISCVPointer(@aKeyB)^)[1]);
   end;
{$endif}
   else begin
    Index:=0;
    pA:=@aKeyA;
    pB:=@aKeyB;
    while (Index+SizeOf(TPasRISCVUInt32))<SizeOf(TPasRISCVHashMapKey) do begin
     if TPasRISCVUInt32(TPasRISCVPointer(@pA^[Index])^)<>TPasRISCVUInt32(TPasRISCVPointer(@pB^[Index])^) then begin
      result:=false;
      exit;
     end;
     inc(Index,SizeOf(TPasRISCVUInt32));
    end;
    while (Index+SizeOf(UInt8))<SizeOf(TPasRISCVHashMapKey) do begin
     if UInt8(TPasRISCVPointer(@pA^[Index])^)<>UInt8(TPasRISCVPointer(@pB^[Index])^) then begin
      result:=false;
      exit;
     end;
     inc(Index,SizeOf(UInt8));
    end;
    result:=true;
   end;
  end;
 end;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.FindEntity(const aKey:TPasRISCVHashMapKey):PEntity;
var Index,HashCode,Mask,Step:TPasRISCVSizeUInt;
begin
 HashCode:=HashKey(aKey);
 Mask:=(2 shl fLogSize)-1;
 Step:=((HashCode shl 1)+1) and Mask;
 Index:=HashCode shr (32-fLogSize);
 repeat
  result:=@fEntities[Index];
  if (result^.State=TEntity.Empty) or ((result^.State=TEntity.Used) and CompareKey(result^.Key,aKey)) then begin
   exit;
  end;
  Index:=(Index+Step) and Mask;
 until false;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.FindEntityForAdd(const aKey:TPasRISCVHashMapKey):PEntity;
var Index,HashCode,Mask,Step:TPasRISCVSizeUInt;
    DeletedEntity:PEntity;
begin
 HashCode:=HashKey(aKey);
 Mask:=(2 shl fLogSize)-1;
 Step:=((HashCode shl 1)+1) and Mask;
 Index:=HashCode shr (32-fLogSize);
 DeletedEntity:=nil;
 repeat
  result:=@fEntities[Index];
  case result^.State of
   TEntity.Empty:begin
    break;
   end;
   TEntity.Deleted:begin
    if not assigned(DeletedEntity) then begin
     DeletedEntity:=result;
    end;
   end;
   else {TEntity.Used:}begin
    if CompareKey(result^.Key,aKey) then begin
     exit;
    end;
   end;
  end;
  Index:=(Index+Step) and Mask;
 until false;
 if assigned(DeletedEntity) then begin
  result:=DeletedEntity;
 end;
end;

procedure TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.Resize;
var Index:TPasRISCVSizeInt;
    OldEntities:TEntities;
    OldEntity:PEntity;
begin

 fLogSize:={$ifdef cpu64}IntLog264{$else}IntLog2{$endif}(fCountNonEmptyEntites)+1;

 fSize:=2 shl fLogSize;

 fCountNonEmptyEntites:=0;

 fCountDeletedEntites:=0;

 OldEntities:=fEntities;

 fEntities:=nil;
 SetLength(fEntities,fSize);

 for Index:=0 to length(fEntities)-1 do begin
  fEntities[Index].State:=TEntity.Empty;
 end;

 if length(OldEntities)>0 then begin
  try
   for Index:=0 to length(OldEntities)-1 do begin
    OldEntity:=@OldEntities[Index];
    if OldEntity^.State=TEntity.Used then begin
     Add(OldEntity^.Key,OldEntity^.Value);
    end;
{   Finalize(OldEntity^.Key);
    Finalize(OldEntity^.Value);}
   end;
  finally
   OldEntities:=nil;
  end;
 end;

end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.Add(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue):PEntity;
begin
 while fCountNonEmptyEntites>=(1 shl fLogSize) do begin
  Resize;
 end;
 result:=FindEntityForAdd(aKey);
 case result^.State of
  TEntity.Empty:begin
   inc(fCountNonEmptyEntites);
  end;
  TEntity.Deleted:begin
   dec(fCountDeletedEntites);
  end;
  else begin
  end;
 end;
 result^.State:=TEntity.Used;
 result^.Key:=aKey;
 result^.Value:=aValue;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.Get(const aKey:TPasRISCVHashMapKey;const aCreateIfNotExist:boolean):PEntity;
var Value:TPasRISCVHashMapValue;
begin
 result:=FindEntity(aKey);
 case result^.State of
  TEntity.Used:begin
  end;
  else {TEntity.Empty,TEntity.Deleted:}begin
   if aCreateIfNotExist then begin
    Initialize(Value);
    result:=Add(aKey,Value);
   end else begin
    result:=nil;
   end;
  end;
 end;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TryGet(const aKey:TPasRISCVHashMapKey;out aValue:TPasRISCVHashMapValue):boolean;
var Entity:PEntity;
begin
 Entity:=FindEntity(aKey);
 result:=Entity^.State=TEntity.Used;
 if result then begin
  aValue:=Entity^.Value;
 end else begin
  Initialize(aValue);
 end;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.ExistKey(const aKey:TPasRISCVHashMapKey):boolean;
begin
 result:=FindEntity(aKey)^.State=TEntity.Used;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.Delete(const aKey:TPasRISCVHashMapKey):boolean;
var Entity:PEntity;
begin
 Entity:=FindEntity(aKey);
 result:=Entity^.State=TEntity.Used;
 if result then begin
  Entity^.State:=TEntity.Deleted;
  Finalize(Entity^.Key);
  Finalize(Entity^.Value);
  inc(fCountDeletedEntites);
  if fCanShrink and (fSize>=8) and (fCountDeletedEntites>=((fSize+3) shr 2)) then begin
   dec(fCountNonEmptyEntites,fCountDeletedEntites);
   Resize;
  end;
 end;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.GetValue(const aKey:TPasRISCVHashMapKey):TPasRISCVHashMapValue;
var Entity:PEntity;
begin
 Entity:=FindEntity(aKey);
 if Entity^.State=TEntity.Used then begin
  result:=Entity^.Value;
 end else begin
  result:=fDefaultValue;
 end;
end;

procedure TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.SetValue(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue);
begin
 Add(aKey,aValue);
end;

{$ifdef ExtraStringHashMap}
{ TPasRISCVStringHashMap }

constructor TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TEntityEnumerator.Create(const aHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
begin
 fHashMap:=aHashMap;
 fIndex:=-1;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TEntityEnumerator.GetCurrent:TEntity;
begin
 result:=fHashMap.fEntities[fIndex];
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TEntityEnumerator.MoveNext:boolean;
begin
 repeat
  inc(fIndex);
  if fIndex<fHashMap.fSize then begin
   if fHashMap.fEntities[fIndex].State=TEntity.Used then begin
    result:=true;
    exit;
   end;
  end else begin
   break;
  end;
 until false;
 result:=false;
end;

constructor TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TKeyEnumerator.Create(const aHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
begin
 fHashMap:=aHashMap;
 fIndex:=-1;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TKeyEnumerator.GetCurrent:TPasRISCVHashMapKey;
begin
 result:=fHashMap.fEntities[fIndex].Key;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TKeyEnumerator.MoveNext:boolean;
begin
 repeat
  inc(fIndex);
  if fIndex<fHashMap.fSize then begin
   if fHashMap.fEntities[fIndex].State=TEntity.Used then begin
    result:=true;
    exit;
   end;
  end else begin
   break;
  end;
 until false;
 result:=false;
end;

constructor TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TPasRISCVHashMapValueEnumerator.Create(const aHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
begin
 fHashMap:=aHashMap;
 fIndex:=-1;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TPasRISCVHashMapValueEnumerator.GetCurrent:TPasRISCVHashMapValue;
begin
 result:=fHashMap.fEntities[fIndex].Value;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TPasRISCVHashMapValueEnumerator.MoveNext:boolean;
begin
 repeat
  inc(fIndex);
  if fIndex<fHashMap.fSize then begin
   if fHashMap.fEntities[fIndex].State=TEntity.Used then begin
    result:=true;
    exit;
   end;
  end else begin
   break;
  end;
 until false;
 result:=false;
end;

constructor TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TEntitiesObject.Create(const aOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
begin
 inherited Create;
 fOwner:=aOwner;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TEntitiesObject.GetEnumerator:TEntityEnumerator;
begin
 result:=TEntityEnumerator.Create(fOwner);
end;

constructor TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TKeysObject.Create(const aOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
begin
 inherited Create;
 fOwner:=aOwner;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TKeysObject.GetEnumerator:TKeyEnumerator;
begin
 result:=TKeyEnumerator.Create(fOwner);
end;

constructor TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TValuesObject.Create(const aOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
begin
 inherited Create;
 fOwner:=aOwner;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TValuesObject.GetEnumerator:TPasRISCVHashMapValueEnumerator;
begin
 result:=TPasRISCVHashMapValueEnumerator.Create(fOwner);
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TValuesObject.GetValue(const aKey:TPasRISCVHashMapKey):TPasRISCVHashMapValue;
begin
 result:=fOwner.GetValue(aKey);
end;

procedure TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TValuesObject.SetValue(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue);
begin
 fOwner.SetValue(aKey,aValue);
end;

constructor TPasRISCVStringHashMap<TPasRISCVHashMapValue>.Create(const aDefaultValue:TPasRISCVHashMapValue);
begin
 inherited Create;
 fSize:=0;
 fLogSize:=0;
 fCountNonEmptyEntites:=0;
 fCountDeletedEntites:=0;
 fEntities:=nil;
 fDefaultValue:=aDefaultValue;
 fCanShrink:=true;
 fEntitiesObject:=TEntitiesObject.Create(self);
 fKeysObject:=TKeysObject.Create(self);
 fValuesObject:=TValuesObject.Create(self);
 Resize;
end;

destructor TPasRISCVStringHashMap<TPasRISCVHashMapValue>.Destroy;
var Index:TPasRISCVSizeInt;
begin
 Clear;
 for Index:=0 to length(fEntities)-1 do begin
  Finalize(fEntities[Index].Key);
  Finalize(fEntities[Index].Value);
 end;
 fEntities:=nil;
 FreeAndNil(fEntitiesObject);
 FreeAndNil(fKeysObject);
 FreeAndNil(fValuesObject);
 inherited Destroy;
end;

procedure TPasRISCVStringHashMap<TPasRISCVHashMapValue>.Clear(const aCanFree:Boolean);
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to length(fEntities)-1 do begin
  Finalize(fEntities[Index].Key);
  Finalize(fEntities[Index].Value);
 end;
 fCountNonEmptyEntites:=0;
 fCountDeletedEntites:=0;
 if fCanShrink and aCanFree then begin
  fSize:=0;
  fLogSize:=0;
  fEntities:=nil;
  Resize;
 end else begin
  for Index:=0 to length(fEntities)-1 do begin
   fEntities[Index].State:=TEntity.Empty;
  end;
 end;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.HashKey(const aKey:TPasRISCVHashMapKey):TPasRISCVUInt32;
// xxHash32
const PRIME32_1=TPasRISCVUInt32(2654435761);
      PRIME32_2=TPasRISCVUInt32(2246822519);
      PRIME32_3=TPasRISCVUInt32(3266489917);
      PRIME32_4=TPasRISCVUInt32(668265263);
      PRIME32_5=TPasRISCVUInt32(374761393);
      Seed=TPasRISCVUInt32($1337c0d3);
      v1Initialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVUInt64(Seed)+TPasRISCVUInt64(PRIME32_1)+TPasRISCVUInt64(PRIME32_2)));
      v2Initialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVUInt64(Seed)+TPasRISCVUInt64(PRIME32_2)));
      v3Initialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVUInt64(Seed)+TPasRISCVUInt64(0)));
      v4Initialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Seed)-TPasRISCVInt64(PRIME32_1))));
      HashInitialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVUInt64(Seed)+TPasRISCVUInt64(PRIME32_5)));
var v1,v2,v3,v4,DataLength:TPasRISCVUInt32;
    p,e,Limit:PPasRISCVUInt8;
begin
 p:=TPasRISCVPointer(@aKey[1]);
 DataLength:=length(aKey)*SizeOf(aKey[1]);
 if DataLength>=16 then begin
  v1:=v1Initialization;
  v2:=v2Initialization;
  v3:=v3Initialization;
  v4:=v4Initialization;
  e:=@PPasRISCVUInt8Array(TPasRISCVPointer(@aKey[1]))^[DataLength-16];
  repeat
{$if defined(fpc) and declared(ROLDWord)}
   v1:=ROLDWord(v1+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2)),13)*TPasRISCVUInt32(PRIME32_1);
{$else}
   inc(v1,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2));
   v1:=((v1 shl 13) or (v1 shr 19))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
   inc(p,SizeOf(TPasRISCVUInt32));
{$if defined(fpc) and declared(ROLDWord)}
   v2:=ROLDWord(v2+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2)),13)*TPasRISCVUInt32(PRIME32_1);
{$else}
   inc(v2,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2));
   v2:=((v2 shl 13) or (v2 shr 19))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
   inc(p,SizeOf(TPasRISCVUInt32));
{$if defined(fpc) and declared(ROLDWord)}
   v3:=ROLDWord(v3+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2)),13)*TPasRISCVUInt32(PRIME32_1);
{$else}
   inc(v3,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2));
   v3:=((v3 shl 13) or (v3 shr 19))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
   inc(p,SizeOf(TPasRISCVUInt32));
{$if defined(fpc) and declared(ROLDWord)}
   v4:=ROLDWord(v4+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2)),13)*TPasRISCVUInt32(PRIME32_1);
{$else}
   inc(v4,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2));
   v4:=((v4 shl 13) or (v4 shr 19))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
   inc(p,SizeOf(TPasRISCVUInt32));
  until {%H-}TPasRISCVPtrUInt(p)>{%H-}TPasRISCVPtrUInt(e);
{$if defined(fpc) and declared(ROLDWord)}
  result:=ROLDWord(v1,1)+ROLDWord(v2,7)+ROLDWord(v3,12)+ROLDWord(v4,18);
{$else}
  result:=((v1 shl 1) or (v1 shr 31))+
          ((v2 shl 7) or (v2 shr 25))+
          ((v3 shl 12) or (v3 shr 20))+
          ((v4 shl 18) or (v4 shr 14));
{$ifend}
 end else begin
  result:=HashInitialization;
 end;
 inc(result,DataLength);
 e:=@PPasRISCVUInt8Array(TPasRISCVPointer(@aKey[1]))^[DataLength];
 while ({%H-}TPasRISCVPtrUInt(p)+SizeOf(TPasRISCVUInt32))<={%H-}TPasRISCVPtrUInt(e) do begin
{$if defined(fpc) and declared(ROLDWord)}
  result:=ROLDWord(result+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_3)),17)*TPasRISCVUInt32(PRIME32_4);
{$else}
  inc(result,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_3));
  result:=((result shl 17) or (result shr 15))*TPasRISCVUInt32(PRIME32_4);
{$ifend}
  inc(p,SizeOf(TPasRISCVUInt32));
 end;
 while {%H-}TPasRISCVPtrUInt(p)<{%H-}TPasRISCVPtrUInt(e) do begin
{$if defined(fpc) and declared(ROLDWord)}
  result:=ROLDWord(result+(TPasRISCVUInt8(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_5)),11)*TPasRISCVUInt32(PRIME32_1);
{$else}
  inc(result,TPasRISCVUInt8(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_5));
  result:=((result shl 11) or (result shr 21))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
  inc(p,SizeOf(TPasRISCVUInt8));
 end;
 result:=(result xor (result shr 15))*TPasRISCVUInt32(PRIME32_2);
 result:=(result xor (result shr 13))*TPasRISCVUInt32(PRIME32_3);
 result:=result xor (result shr 16);
{$if defined(CPU386) or defined(CPUAMD64)}
 // Special case: The hash value may be never zero
 result:=result or (-TPasRISCVUInt32(ord(result=0) and 1));
{$else}
 if result=0 then begin
  // Special case: The hash value may be never zero
  result:=$ffffffff;
 end;
{$ifend}
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.FindEntity(const aKey:TPasRISCVHashMapKey):PEntity;
var Index,HashCode,Mask,Step:TPasRISCVSizeUInt;
begin
 HashCode:=HashKey(aKey);
 Mask:=(2 shl fLogSize)-1;
 Step:=((HashCode shl 1)+1) and Mask;
 Index:=HashCode shr (32-fLogSize);
 repeat
  result:=@fEntities[Index];
  if (result^.State=TEntity.Empty) or ((result^.State=TEntity.Used) and (result^.Key=aKey)) then begin
   exit;
  end;
  Index:=(Index+Step) and Mask;
 until false;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.FindEntityForAdd(const aKey:TPasRISCVHashMapKey):PEntity;
var Index,HashCode,Mask,Step:TPasRISCVSizeUInt;
    DeletedEntity:PEntity;
begin
 HashCode:=HashKey(aKey);
 Mask:=(2 shl fLogSize)-1;
 Step:=((HashCode shl 1)+1) and Mask;
 Index:=HashCode shr (32-fLogSize);
 DeletedEntity:=nil;
 repeat
  result:=@fEntities[Index];
  case result^.State of
   TEntity.Empty:begin
    break;
   end;
   TEntity.Deleted:begin
    if not assigned(DeletedEntity) then begin
     DeletedEntity:=result;
    end;
   end;
   else {TEntity.Used:}begin
    if result^.Key=aKey then begin
     exit;
    end;
   end;
  end;
  Index:=(Index+Step) and Mask;
 until false;
 if assigned(DeletedEntity) then begin
  result:=DeletedEntity;
 end;
end;

procedure TPasRISCVStringHashMap<TPasRISCVHashMapValue>.Resize;
var Index:TPasRISCVSizeInt;
    OldEntities:TEntities;
    OldEntity:PEntity;
begin

 fLogSize:={$ifdef cpu64}IntLog264{$else}IntLog2{$endif}(fCountNonEmptyEntites)+1;

 fSize:=2 shl fLogSize;

 fCountNonEmptyEntites:=0;

 fCountDeletedEntites:=0;

 OldEntities:=fEntities;

 fEntities:=nil;
 SetLength(fEntities,fSize);

 for Index:=0 to length(fEntities)-1 do begin
  fEntities[Index].State:=TEntity.Empty;
 end;

 if length(OldEntities)>0 then begin
  try
   for Index:=0 to length(OldEntities)-1 do begin
    OldEntity:=@OldEntities[Index];
    if OldEntity^.State=TEntity.Used then begin
     Add(OldEntity^.Key,OldEntity^.Value);
    end;
{   Finalize(OldEntity^.Key);
    Finalize(OldEntity^.Value);}
   end;
  finally
   OldEntities:=nil;
  end;
 end;

end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.Add(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue):PEntity;
begin
 while fCountNonEmptyEntites>=(1 shl fLogSize) do begin
  Resize;
 end;
 result:=FindEntityForAdd(aKey);
 case result^.State of
  TEntity.Empty:begin
   inc(fCountNonEmptyEntites);
  end;
  TEntity.Deleted:begin
   dec(fCountDeletedEntites);
  end;
  else begin
  end;
 end;
 result^.State:=TEntity.Used;
 result^.Key:=aKey;
 result^.Value:=aValue;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.Get(const aKey:TPasRISCVHashMapKey;const aCreateIfNotExist:boolean):PEntity;
var Value:TPasRISCVHashMapValue;
begin
 result:=FindEntity(aKey);
 case result^.State of
  TEntity.Used:begin
  end;
  else {TEntity.Empty,TEntity.Deleted:}begin
   if aCreateIfNotExist then begin
    Initialize(Value);
    result:=Add(aKey,Value);
   end else begin
    result:=nil;
   end;
  end;
 end;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TryGet(const aKey:TPasRISCVHashMapKey;out aValue:TPasRISCVHashMapValue):boolean;
var Entity:PEntity;
begin
 Entity:=FindEntity(aKey);
 result:=Entity^.State=TEntity.Used;
 if result then begin
  aValue:=Entity^.Value;
 end else begin
  Initialize(aValue);
 end;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.ExistKey(const aKey:TPasRISCVHashMapKey):boolean;
begin
 result:=FindEntity(aKey)^.State=TEntity.Used;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.Delete(const aKey:TPasRISCVHashMapKey):boolean;
var Entity:PEntity;
begin
 Entity:=FindEntity(aKey);
 result:=Entity^.State=TEntity.Used;
 if result then begin
  Entity^.State:=TEntity.Deleted;
  Finalize(Entity^.Key);
  Finalize(Entity^.Value);
  inc(fCountDeletedEntites);
  if fCanShrink and (fSize>=8) and (fCountDeletedEntites>=((fSize+3) shr 2)) then begin
   dec(fCountNonEmptyEntites,fCountDeletedEntites);
   Resize;
  end;
 end;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.GetValue(const aKey:TPasRISCVHashMapKey):TPasRISCVHashMapValue;
var Entity:PEntity;
begin
 Entity:=FindEntity(aKey);
 if Entity^.State=TEntity.Used then begin
  result:=Entity^.Value;
 end else begin
  result:=fDefaultValue;
 end;
end;

procedure TPasRISCVStringHashMap<TPasRISCVHashMapValue>.SetValue(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue);
begin
 Add(aKey,aValue);
end;
{$endif}

{ TPasRISCVFileMappedStream }

constructor TPasRISCVFileMappedStream.Create(const aFileName:String;aMode:TPasRISCVUInt16;const aMappingWholeFile:Boolean);
{$ifdef unix}
const Access:array[0..4] of TPasRISCVUInt32=(O_RdOnly,O_WrOnly,O_RdWr,O_RdWr,O_RdWr);
      CreateFlag:array[0..4] of TPasRISCVUInt32=(0,0,0,O_Creat,O_Creat);
var StatInfo:BaseUnix.Stat;
    ModeEx:TPasRISCVUInt32;
begin
 inherited Create;
 fAllocationGranularity:=65536;
 fFileName:=aFileName;
 ModeEx:=aMode and not (fmShareExclusive or fmShareExclusive or fmShareDenyRead or fmShareDenyWrite or fmShareDenyNone);
 fCurrentViewOffset:=0;
 fCurrentViewSize:=0;
 if aMappingWholeFile then begin
  fViewSize:=TPasRISCVInt64($4000000000000000);
 end else begin
  fViewSize:=DefaultViewSize;
 end;
 fViewMask:=fViewSize-1;
 fReadOnly:=ModeEx=0;
 FTemporary:=ModeEx=fmCreateTemporary;
 if aMode=fmCreate then begin
  ModeEx:=3;
 end;
 fFileHandle:=fpOpen(PChar(fFileName),Access[ModeEx] or CreateFlag[ModeEx]);
 if fFileHandle<>feInvalidHandle then begin
  if fpfstat(fFileHandle,StatInfo)<>0 then begin
   raise Exception.Create('Cann''t access file');
  end;
  fSize:=StatInfo.st_size;
  if fSize<1 then begin
   FpLseek(fFileHandle,1,Seek_Set);
   fSize:=1;
  end;
  CreateMapView;
 end else begin
  raise Exception.Create('Can''t access file');
 end;
end;
{$else}
const Access:array[0..4] of TPasRISCVUInt32=(GENERIC_READ,GENERIC_WRITE,GENERIC_READ or GENERIC_WRITE,GENERIC_READ or GENERIC_WRITE,GENERIC_READ or GENERIC_WRITE);
      CreateFlag:array[0..4] of TPasRISCVUInt32=(OPEN_EXISTING,OPEN_EXISTING,OPEN_EXISTING,CREATE_ALWAYS,CREATE_ALWAYS);
var ModeEx,FileFlags,ShareFlags:TPasRISCVUInt32;
    SystemInfo:TSystemInfo;
begin
 inherited Create;
 GetSystemInfo(SystemInfo);
 fAllocationGranularity:=SystemInfo.dwAllocationGranularity;
 fFileName:=aFileName;
 ModeEx:=aMode and not (fmShareExclusive or fmShareExclusive or fmShareDenyRead or fmShareDenyWrite or fmShareDenyNone);
 fCurrentViewOffset:=0;
 fCurrentViewSize:=0;
 if aMappingWholeFile then begin
  fViewSize:=TPasRISCVInt64($4000000000000000);
 end else begin
  fViewSize:=DefaultViewSize;
 end;
 fViewMask:=fViewSize-1;
 fReadOnly:=ModeEx=0;
 if aMode=fmCreate then begin
  ModeEx:=3;
 end;
 if ModeEx<>4 then begin
  FileFlags:=FILE_ATTRIBUTE_NORMAL;
 end else begin
  FileFlags:=FILE_FLAG_DELETE_ON_CLOSE;
 end;
 ShareFlags:=FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE;
 if (aMode and fmShareDenyNone)=0 then begin
  if (aMode and fmShareExclusive)<>0 then begin
   ShareFlags:=0;
  end else begin
   if (aMode and fmShareDenyRead)<>0 then begin
    ShareFlags:=ShareFlags and not FILE_SHARE_READ;
   end;
   if (aMode and fmShareDenyWrite)<>0 then begin
    ShareFlags:=ShareFlags and not (FILE_SHARE_WRITE or FILE_SHARE_DELETE);
   end;
  end;
 end;
 fFileHandle:=CreateFile(PChar(fFileName),Access[ModeEx],ShareFlags,nil,CreateFlag[ModeEx],FileFlags,0);
 if fFileHandle<>INVALID_HANDLE_VALUE then begin
  fSize:=GetFileSize(fFileHandle,nil);
  if fSize<1 then begin
   SetFilePointer(fFileHandle,1,nil,FILE_BEGIN);
   SetEndOfFile(fFileHandle);
   fSize:=1;
  end;
  CreateMapView;
 end else begin
  raise Exception.Create(SysErrorMessage(GetLastError));
 end;
end;
{$endif}

destructor TPasRISCVFileMappedStream.Destroy;
begin
 CloseMapView;
{$ifdef unix}
 if fFileHandle<>feInvalidHandle then begin
  fpclose(fFileHandle);
  fFileHandle:=feInvalidHandle;
 end;
 if FTemporary then begin
  FpUnlink(fFileName);
 end;
{$else}
 if fFileHandle<>INVALID_HANDLE_VALUE then begin
  CloseHandle(fFileHandle);
  fFileHandle:=INVALID_HANDLE_VALUE;
 end;
{$endif}
 inherited Destroy;
end;

procedure TPasRISCVFileMappedStream.CreateMapView;
{$ifdef unix}
var StatInfo:BaseUnix.Stat;
begin
 if fpfstat(fFileHandle,StatInfo)<>0 then begin
  CloseMapView;
  raise Exception.Create('Cannot create map view.');
  exit;
 end;
 fSize:=StatInfo.st_size;
 if fSize=0 then begin
  CloseMapView;
  raise Exception.Create('Cannot create map view.');
  exit;
 end;
 fCurrentViewSize:=fViewSize;
 if (fCurrentViewOffset+fCurrentViewSize)>fSize then begin
  fCurrentViewSize:=fSize-fCurrentViewOffset;
 end;
 if ReadOnly then begin
  fMemory:=fpmmap(nil,fCurrentViewSize,PROT_READ,MAP_PRIVATE,fFileHandle,fCurrentViewOffset);
 end else begin
  fMemory:=fpmmap(nil,fCurrentViewSize,PROT_READ or PROT_WRITE,MAP_SHARED,fFileHandle,fCurrentViewOffset);
 end;
 if TPasRISCVPtrUInt(fMemory)=TPasRISCVPtrUInt(TPasRISCVPtrInt(-1)) then begin
  fMemory:=nil;
  CloseMapView;
  raise Exception.Create('Cannot create map view.');
 end;
end;
{$else}
begin
 if ReadOnly then begin
  fMapHandle:=CreateFileMapping(fFileHandle,nil,PAGE_READONLY,0,fSize,nil);
 end else begin
  fMapHandle:=CreateFileMapping(fFileHandle,nil,PAGE_READWRITE,0,fSize,nil);
 end;
 if fMapHandle=0 then begin
  raise Exception.Create(SysErrorMessage(GetLastError));
 end;
 fCurrentViewSize:=fViewSize;
 if (fCurrentViewOffset+fCurrentViewSize)>fSize then begin
  fCurrentViewSize:=fSize-fCurrentViewOffset;
 end;
 if ReadOnly then begin
  fMemory:=MapViewOfFile(fMapHandle,FILE_MAP_READ,TPasRISCVUInt32(fCurrentViewOffset shr 32),TPasRISCVUInt32(fCurrentViewOffset),fCurrentViewSize);
 end else begin
  fMemory:=MapViewOfFile(fMapHandle,FILE_MAP_READ or FILE_MAP_WRITE,TPasRISCVUInt32(fCurrentViewOffset shr 32),TPasRISCVUInt32(fCurrentViewOffset),fCurrentViewSize);
 end;
 if not assigned(fMemory) then begin
  raise Exception.Create(SysErrorMessage(GetLastError));
 end;
end;
{$endif}

procedure TPasRISCVFileMappedStream.UpdateMapView;
begin
 if (fPosition<fCurrentViewOffset) or ((fCurrentViewOffset+fCurrentViewSize)<fPosition) then begin
  if (fAllocationGranularity and (fAllocationGranularity-1))<>0 then begin
   fCurrentViewOffset:=fPosition;
   if (fCurrentViewOffset mod fAllocationGranularity)<>0 then begin
    dec(fCurrentViewOffset,fCurrentViewOffset mod fAllocationGranularity);
   end;
   fCurrentViewSize:=fViewSize;
   if (fCurrentViewSize mod fAllocationGranularity)<>0 then begin
    inc(fCurrentViewSize,fAllocationGranularity-(fCurrentViewOffset mod fAllocationGranularity));
   end;
  end else begin
   fCurrentViewOffset:=fPosition and not (fAllocationGranularity-1);
   fCurrentViewSize:=(fViewSize+(fAllocationGranularity-1)) and not (fAllocationGranularity-1);
  end;
  if fCurrentViewOffset<0 then begin
   fCurrentViewOffset:=0;
  end;
  if (fCurrentViewOffset+fCurrentViewSize)>fSize then begin
   fCurrentViewSize:=fSize-fCurrentViewOffset;
  end;
{$ifdef unix}
  if assigned(fMemory) then begin
   fpmunmap(fMemory,fCurrentViewSize);
   fMemory:=nil;
  end;
  if ReadOnly then begin
   fMemory:=fpmmap(nil,fCurrentViewSize,PROT_READ,MAP_PRIVATE,fFileHandle,fCurrentViewOffset);
  end else begin
   fMemory:=fpmmap(nil,fCurrentViewSize,PROT_READ or PROT_WRITE,MAP_SHARED,fFileHandle,fCurrentViewOffset);
  end;
  if TPasRISCVPtrUInt(fMemory)=TPasRISCVPtrUInt(TPasRISCVPtrInt(-1)) then begin
   fMemory:=nil;
   CloseMapView;
   raise Exception.Create('Cannot create map view.');
  end;
{$else}
  if assigned(fMemory) then begin
   UnmapViewOfFile(fMemory);
   fMemory:=nil;
  end;
  if ReadOnly then begin
   fMemory:=MapViewOfFile(fMapHandle,FILE_MAP_READ,TPasRISCVUInt32(fCurrentViewOffset shr 32),TPasRISCVUInt32(fCurrentViewOffset),fCurrentViewSize);
  end else begin
   fMemory:=MapViewOfFile(fMapHandle,FILE_MAP_READ or FILE_MAP_WRITE,TPasRISCVUInt32(fCurrentViewOffset shr 32),TPasRISCVUInt32(fCurrentViewOffset),fCurrentViewSize);
  end;
  if not assigned(fMemory) then begin
   raise Exception.Create(SysErrorMessage(GetLastError));
  end;
{$endif}
 end;
end;

procedure TPasRISCVFileMappedStream.CloseMapView;
begin
{$ifdef unix}
 if assigned(fMemory) then begin
  fpmunmap(fMemory,fCurrentViewSize);
  fMemory:=nil;
 end;
{if fFileHandle<>feInvalidHandle then begin
  fpClose(fFileHandle);
  fFileHandle:=feInvalidHandle;
 end;}
{$else}
 if assigned(fMemory) then begin
  UnmapViewOfFile(fMemory);
  fMemory:=nil;
 end;
 if fMapHandle<>0 then begin
  CloseHandle(fMapHandle);
 end;
{$endif}
end;

procedure TPasRISCVFileMappedStream.SetSize(aNewSize:TPasRISCVInt32);
begin
 SetSize(TPasRISCVInt64(aNewSize));
end;

procedure TPasRISCVFileMappedStream.SetSize(const aNewSize:TPasRISCVInt64);
begin
 CloseMapView;
{$ifdef unix}
 FpLseek(fFileHandle,aNewSize,Seek_Set);
{$else}
 SetFilePointer(fFileHandle,aNewSize,nil,FILE_BEGIN);
 SetEndOfFile(fFileHandle);
{$endif}
 if fCurrentViewOffset>aNewSize then begin
  fCurrentViewOffset:=(aNewSize-1) and fViewMask;
 end;
 if fCurrentViewOffset<0 then begin
  fCurrentViewOffset:=0;
 end;
 fSize:=aNewSize;
 CreateMapView;
end;

procedure TPasRISCVFileMappedStream.Clear;
begin
 SetSize(1);
 fPosition:=0;
 fCurrentViewOffset:=0;
end;

function TPasRISCVFileMappedStream.Flush:Boolean;
begin
{$ifdef unix}
 // At freepascal is no fpmsync or msync, so we must do it over this workaround
 CloseMapView;
 result:=fpfsync(fFileHandle)=0;
 CreateMapView;
{$else}
 if assigned(fMemory) then begin
  FlushViewOfFile(fMemory,fCurrentViewSize);
  result:=FlushFileBuffers(fFileHandle);
 end else begin
  CloseMapView;
  result:=FlushFileBuffers(fFileHandle);
  CreateMapView;
 end;
{$endif}
end;

function TPasRISCVFileMappedStream.Seek(const aOffset:TPasRISCVInt64;aOrigin:TSeekOrigin):TPasRISCVInt64;
begin
 case aOrigin of
  soBeginning:begin
   fPosition:=aOffset;
  end;
  soCurrent:begin
   fPosition:=fPosition+aOffset;
  end;
  soEnd:begin
   fPosition:=fSize+aOffset;
  end;
 end;
 if fPosition>fSize then begin
  SetSize(fPosition);
 end;
 UpdateMapView;
 result:=fPosition;
end;

function TPasRISCVFileMappedStream.Read(var aBuffer;aCount:TPasRISCVInt32):TPasRISCVInt32;
var Remain,ToDo:TPasRISCVInt32;
    BufferPointer:PAnsiChar;
begin
 if assigned(fMemory) then begin
  if (fPosition+aCount)>Size then begin
   aCount:=fSize-fPosition;
  end;
  Remain:=aCount;
  BufferPointer:=@aBuffer;
  while Remain>0 do begin
   UpdateMapView;
   ToDo:=Remain;
   if (fPosition+ToDo)>(fCurrentViewOffset+fCurrentViewSize) then begin
    ToDo:=(fCurrentViewOffset+fCurrentViewSize)-fPosition;
   end;
   Move(PPasRISCVUInt8Array(fMemory)^[fPosition-fCurrentViewOffset],BufferPointer^,ToDo);
   inc(fPosition,ToDo);
   inc(BufferPointer,ToDo);
   dec(Remain,ToDo);
  end;
  result:=aCount;
 end else begin
  raise Exception.Create('No data available');
 end;
end;

function TPasRISCVFileMappedStream.Write(const aBuffer;aCount:TPasRISCVInt32):TPasRISCVInt32;
var Remain,ToDo:TPasRISCVInt32;
    BufferPointer:PAnsiChar;
begin
 if assigned(fMemory) and not ReadOnly then begin
  if (fPosition+aCount)>fSize then begin
   SetSize(fPosition+aCount);
  end;
  Remain:=aCount;
  BufferPointer:=@aBuffer;
  while Remain>0 do begin
   UpdateMapView;
   ToDo:=Remain;
   if (fPosition+ToDo)>(fCurrentViewOffset+fCurrentViewSize) then begin
    ToDo:=(fCurrentViewOffset+fCurrentViewSize)-fPosition;
   end;
   Move(BufferPointer^,PPasRISCVUInt8Array(fMemory)^[fPosition-fCurrentViewOffset],ToDo);
   inc(fPosition,ToDo);
   inc(BufferPointer,ToDo);
   dec(Remain,ToDo);
  end;
  result:=aCount;
 end else begin
  raise Exception.Create('Cannot access memory data');
 end;
end;

{ TPasRISCVAudioWAVStreamDump }

constructor TPasRISCVAudioWAVStreamDump.Create(const aSampleRate:TPasRISCVInt32;const aStream:TStream;const aDoFreeStream:boolean=true);
begin
 inherited Create;

 fStream:=aStream;

 fDoFreeStream:=aDoFreeStream;

 fSampleRate:=aSampleRate;

 fChannels:=2;

 fBitsPerSample:=32;

 fWaveFileHeader.Signature:=TPasRISCVAudioWAVFormat.RIFFSignature;
 fWaveFileHeader.Size:=0;
 fWaveFileHeader.WAVESignature:=TPasRISCVAudioWAVFormat.WAVESignature;

 fWaveFormatHeader.FormatTag:=3;
 fWaveFormatHeader.Channels:=fChannels;
 fWaveFormatHeader.SamplesPerSecond:=fSampleRate;
 fWaveFormatHeader.AvgBytesPerSecond:=((fSampleRate*fChannels*fBitsPerSample)+7) shr 3;
 fWaveFormatHeader.SampleSize:=((fChannels*fBitsPerSample)+7) shr 3;
 fWaveFormatHeader.BitsPerSample:=fBitsPerSample;

 fWaveFormatChunkHeader.Signature:=TPasRISCVAudioWAVFormat.FMTSignature;
 fWaveFormatChunkHeader.Size:=SizeOf(TPasRISCVAudioWAVFormat.TWaveFormatHeader);

 fWaveDataChunkHeader.Signature:=TPasRISCVAudioWAVFormat.DATASignature;
 fWaveDataChunkHeader.Size:=0;

 fFileHeaderOffset:=fStream.Position;
 fStream.WriteBuffer(fWaveFileHeader,SizeOf(TPasRISCVAudioWAVFormat.TWaveFileHeader));

 fFormatChunkHeaderOffset:=fStream.Position;
 fStream.WriteBuffer(fWaveFormatChunkHeader,SizeOf(TPasRISCVAudioWAVFormat.TWaveChunkHeader));
 fStream.WriteBuffer(fWaveFormatHeader,SizeOf(TPasRISCVAudioWAVFormat.TWaveFormatHeader));

 fDataChunkHeaderOffset:=fStream.Position;
 fStream.WriteBuffer(fWaveDataChunkHeader,SizeOf(TPasRISCVAudioWAVFormat.TWaveChunkHeader));

 fDataOffset:=fStream.Position;

 fDataSize:=0;

 fBufferFloats:=nil;

 SetLength(fBufferFloats,65536);

end;

destructor TPasRISCVAudioWAVStreamDump.Destroy;
begin
 Flush;
 if fDoFreeStream then begin
  FreeAndNil(fStream);
 end;
 fBufferFloats:=nil;
 inherited Destroy;
end;

procedure TPasRISCVAudioWAVStreamDump.Flush;
begin

 if assigned(fStream) and (fDataSize>0) then begin

  fStream.Seek(fDataChunkHeaderOffset,soFromBeginning);
  fWaveDataChunkHeader.Size:=fDataSize;
  fStream.WriteBuffer(fWaveDataChunkHeader,SizeOf(TPasRISCVAudioWAVFormat.TWaveChunkHeader));

  fStream.Seek(fFileHeaderOffset,soFromBeginning);
  fWaveFileHeader.Size:=SizeOf(TPasRISCVAudioWAVFormat.TWaveChunkHeader)+
                        SizeOf(TPasRISCVAudioWAVFormat.TWaveFormatHeader)+
                        SizeOf(TPasRISCVAudioWAVFormat.TWaveChunkHeader)+
                        fDataSize;
  fStream.WriteBuffer(fWaveFileHeader,SizeOf(TPasRISCVAudioWAVFormat.TWaveFileHeader));

  fStream.Seek(0,soFromEnd);

 end;

end;

procedure TPasRISCVAudioWAVStreamDump.Dump(const aData:TPasRISCVPointer;const aDataSize:TPasRISCVSizeInt;const aFloat:Boolean);
var CountSamples,Index:TPasRISCVSizeInt;
begin

 if assigned(fStream) and (aDataSize>=SizeOf(TPasRISCVUInt32)) then begin

  if aFloat then begin
   CountSamples:=aDataSize shr 2; // Mono-wise 32 bit stereo samples
  end else begin
   CountSamples:=aDataSize shr 1; // Mono-wise 16 bit stereo samples
  end;

  // Check if buffer is big enough, if not, resize it
  if length(fBufferFloats)<CountSamples then begin
   SetLength(fBufferFloats,CountSamples*2);
  end;

  // Transfer samples
  if aFloat then begin
   for Index:=0 to CountSamples-1 do begin
    fBufferFloats[Index]:=PPasRISCVFloatArray(aData)^[Index];
   end;
  end else  begin
   for Index:=0 to CountSamples-1 do begin
    fBufferFloats[Index]:=PPasRISCVInt16Array(aData)^[Index]/32768.0;
   end;
  end;

  fStream.Seek(fDataOffset+fDataSize,soFromBeginning);
  fStream.WriteBuffer(fBufferFloats[0],aDataSize); // same byte size as aDataSize since uint32 = 4 bytes like float32 as well

  inc(fDataSize,aDataSize);

  Flush; // Flush every time, because we can't know when the stream is closed, so that the header is valid anyway

 end;

end;

{ TPasRISCV9PFileSystem }

constructor TPasRISCV9PFileSystem.Create;
begin
 inherited Create;
end;

destructor TPasRISCV9PFileSystem.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV9PFileSystem.Delete(const aFile:TPasRISCV9PFileSystem.TFSFile);
begin
end;

procedure TPasRISCV9PFileSystem.StatFS(out aStatFS:TPasRISCV9PFileSystem.TFSStatFS);
begin
end;

function TPasRISCV9PFileSystem.Attach(out aFile:TPasRISCV9PFileSystem.TFSFile;const aQID:TPasRISCV9PFileSystem.PFSQID;const aUID:TPasRISCVUInt32;const aUName,aAName:TPasRISCVRawByteString):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.Walk(out aFiles:TPasRISCV9PFileSystem.TFSFile;const aQIDs:TPasRISCV9PFileSystem.PFSQIDArray;const aFile:TPasRISCV9PFileSystem.TFSFile;const aCount:TPasRISCVSizeInt;const aNames:array of TPasRISCVRawByteString):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.MkDir(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.Open(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aFlags:TPasRISCVUInt32;const aOnOpenCompletion:TPasRISCV9PFileSystem.TOnOpenCompletion;const aOpaque:Pointer):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.Create_(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aFlags:TPasRISCVUInt32;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.ReadDir(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.Read(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.Write(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
begin
 result:=P9_ENOTSUP;
end;

procedure TPasRISCV9PFileSystem.Close(const aFile:TPasRISCV9PFileSystem.TFSFile);
begin
end;

function TPasRISCV9PFileSystem.Stat(const aFile:TPasRISCV9PFileSystem.TFSFile;out aStat:TPasRISCV9PFileSystem.TFSStat):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.SetAttr(const aFile:TPasRISCV9PFileSystem.TFSFile;const aMask,aMode,aUID,aGID:TPasRISCVUInt32;const aSize,aATimeSec,aATimeNSec,aMTimeSec,aMTimeNSec,aCTimeSec,aCTimeNSec:TPasRISCVUInt64):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.Link(const aDestFile,aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.SymLink(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName,aTarget:TPasRISCVRawByteString;const aGID:TPasRISCVUInt32):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.MkNod(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aMajor,aMinor,aGID:TPasRISCVUInt32):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.ReadLink(const aBuffer:Pointer;const aSize:TPasRISCVInt64;const aFile:TPasRISCV9PFileSystem.TFSFile):TPasRISCVInt64;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.RenameAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aNewFile:TPasRISCV9PFileSystem.TFSFile;const aNewName:TPasRISCVRawByteString):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.UnlinkAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.Lock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.GetLock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

{$if defined(fpc) and defined(Unix)}

{ TPasRISCV9PFileSystemPOSIX }

procedure RewindDir(dirp:PDIR); cdecl; external 'c' name 'rewinddir';
function MkNod_(pathname:PAnsiChar;Mode:mode_t;dev:dev_t):cint; cdecl; external 'c' name 'mknod';
function lchown(pathname:PAnsiChar;uid:UID_T;gid:gid_t):cint; cdecl; external 'c' name 'lchown';
function Remove_(pathname:PAnsiChar):cint; cdecl; external 'c' name 'remove';

constructor TPasRISCV9PFileSystemPOSIX.Create(const aRootPath:TPasRISCVRawByteString);
begin
 inherited Create;
 fRootPath:=aRootPath;
end;

destructor TPasRISCV9PFileSystemPOSIX.Destroy;
begin
 fRootPath:='';
 inherited Destroy;
end;

function TPasRISCV9PFileSystemPOSIX.POSIXErrorCodeToP9ErrorCode(const aErrorCode:TPasRISCVInt32):TPasRISCVInt32;
begin
 case aErrorCode of
  0:begin
   result:=0;
  end;
  ESysEPERM:begin
   result:=P9_EPERM;
  end;
  ESysENOENT:begin
   result:=P9_ENOENT;
  end;
  ESysEIO:begin
   result:=P9_EIO;
  end;
  ESysEEXIST:begin
   result:=P9_EEXIST;
  end;
  ESysEINVAL:begin
   result:=P9_EINVAL;
  end;
  ESysENOSPC:begin
   result:=P9_ENOSPC;
  end;
  ESysENOTEMPTY:begin
   result:=P9_ENOTEMPTY;
  end;
  ESysEPROTO:begin
   result:=P9_EPROTO;
  end;
  ESysEOPNOTSUPP:begin
   result:=P9_ENOTSUP;
  end;
  else begin
   result:=P9_EINVAL;
  end;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.P9OpenFlagsToPOSIXOpenFlags(const aFlags:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=aFlags and P9_O_NOACCESS;
 if (aFlags and P9_O_CREAT)<>0 then begin
  result:=result or O_CREAT;
 end;
 if (aFlags and P9_O_EXCL)<>0 then begin
  result:=result or O_EXCL;
 end;
{if (aFlags and P9_O_NOCTTY)<>0 then begin
  result:=result or O_NOCTTY;
 end;}
 if (aFlags and P9_O_TRUNC)<>0 then begin
  result:=result or O_TRUNC;
 end;
 if (aFlags and P9_O_APPEND)<>0 then begin
  result:=result or O_APPEND;
 end;
 if (aFlags and P9_O_NONBLOCK)<>0 then begin
  result:=result or O_NONBLOCK;
 end;
 if (aFlags and P9_O_DSYNC)<>0 then begin
  result:=result or O_SYNC; //O_DSYNC
 end;
{if (aFlags and P9_O_FASYNC)<>0 then begin
  result:=result or O_FASYNC;
 end;
 if (aFlags and P9_O_DIRECT)<>0 then begin
  result:=result or O_DIRECT;
 end;
 if (aFlags and P9_O_LARGEFILE)<>0 then begin
  result:=result or O_LARGEFILE;
 end;
 if (aFlags and P9_O_DIRECTORY)<>0 then begin
  result:=result or O_DIRECTORY;
 end;}
 if (aFlags and P9_O_NOFOLLOW)<>0 then begin
  result:=result or O_NOFOLLOW;
 end;
{if (aFlags and P9_O_NOATIME)<>0 then begin
  result:=result or O_NOATIME;
 end;
 if (aFlags and P9_O_CLOEXEC)<>0 then begin
  result:=result or O_CLOEXEC;
 end;}
 if (aFlags and P9_O_SYNC)<>0 then begin
  result:=result or O_SYNC;
 end;
end;

procedure TPasRISCV9PFileSystemPOSIX.StatToQID(const aQID:TPasRISCV9PFileSystem.PFSQID;const aStat:PStat);
begin
 aQID^.Type_:=0;
 if (aStat.st_mode and S_IFDIR)<>0 then begin
  aQID^.Type_:=aQID^.Type_ or P9_QTDIR;
 end;
 if (aStat.st_mode and S_IFLNK)<>0 then begin
  aQID^.Type_:=aQID^.Type_ or P9_QTSYMLINK;
 end;
 aQID^.Version:=0; // no caching on client
 aQID^.Path:=aStat.st_ino;
end;

function TPasRISCV9PFileSystemPOSIX.ComposePath(const aPath,aName:TPasRISCVRawByteString):TPasRISCVRawByteString;
const DirectorySeparator='/';
begin
 result:=aPath;
 if (length(result)>0) and (result[length(result)]<>DirectorySeparator) then begin
  result:=result+DirectorySeparator;
 end;
 result:=result+aName;
end;

function TPasRISCV9PFileSystemPOSIX.CreateFileObject(const aPath:TPasRISCVRawByteString;const aUID:TPasRISCVUInt32):TPasRISCV9PFileSystem.TFSFile;
begin
 result:=TFSFile.Create;
 result.fPath:=aPath;
 result.fUID:=aUID;
 result.fIsOpened:=false;
 result.fIsDirectory:=false;
 result.fStream:=nil;
 result.fFile:=-1;
 result.fDirectory:=nil;
end;

procedure TPasRISCV9PFileSystemPOSIX.Delete(const aFile:TPasRISCV9PFileSystem.TFSFile);
begin
 if assigned(aFile) then begin
  if aFile.fIsOpened then begin
   Close(aFile);
  end;
  aFile.fIsOpened:=false;
  aFile.fIsDirectory:=false;
  aFile.fPath:='';
  if assigned(aFile.fStream) then begin
   FreeAndNil(aFile.fStream);
  end;
  if assigned(aFile.fDirectory) then begin
   try
    FreeMem(aFile.fDirectory);
   finally
    aFile.fDirectory:=nil;
   end;
  end;
  aFile.Free;
 end;
end;

procedure TPasRISCV9PFileSystemPOSIX.StatFS(out aStatFS:TPasRISCV9PFileSystem.TFSStatFS);
var StatFSData:TStatFS;
begin
 if fpStatFS(PAnsiChar(fRootPath),@StatFSData)=0 then begin
  aStatFS.BSize:=StatFSData.bsize;
  aStatFS.Blocks:=StatFSData.blocks;
  aStatFS.BFree:=StatFSData.bfree;
  aStatFS.BAvail:=StatFSData.bavail;
  aStatFS.Files:=StatFSData.files;
  aStatFS.FFree:=StatFSData.ffree;
 end else begin
  FillChar(aStatFS,SizeOf(TFSStatFS),#0);
 end;
end;

function TPasRISCV9PFileSystemPOSIX.Attach(out aFile:TPasRISCV9PFileSystem.TFSFile;const aQID:TPasRISCV9PFileSystem.PFSQID;const aUID:TPasRISCVUInt32;const aUName,aAName:TPasRISCVRawByteString):TPasRISCVInt32;
var StatData:TStat;
begin
 if fpLStat(PAnsiChar(fRootPath),@StatData)=0 then begin
  aFile:=CreateFileObject(fRootPath,aUID);
  StatToQID(aQID,@StatData);
  result:=0;
 end else begin
  aFile:=nil;
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end;
end;

function TPasRISCV9PFileSystemPOSIX.Walk(out aFiles:TPasRISCV9PFileSystem.TFSFile;const aQIDs:TPasRISCV9PFileSystem.PFSQIDArray;const aFile:TPasRISCV9PFileSystem.TFSFile;const aCount:TPasRISCVSizeInt;const aNames:array of TPasRISCVRawByteString):TPasRISCVInt32;
var Path,Path1:TPasRISCVRawByteString;
    StatData:TStat;
    Index:TPasRISCVSizeInt;
begin
 Path:=aFile.fPath;
 result:=0;
 for Index:=0 to aCount-1 do begin
  Path1:=ComposePath(Path,aNames[Index]);
  if fpLStat(PAnsiChar(Path1),@StatData)=0 then begin
   Path:=Path1;
   StatToQID(@aQIDs[Index],@StatData);
   inc(result);
  end else begin
   break;
  end;
 end;
 aFiles:=CreateFileObject(Path,aFile.fUID);
end;

function TPasRISCV9PFileSystemPOSIX.MkDir(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32;
var Path:TPasRISCVRawByteString;
    StatData:TStat;
begin
 Path:=ComposePath(aFile.fPath,aName);
 if fpMkDir(PAnsiChar(Path),aMode)<0 then begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end else begin
  if fpLStat(PAnsiChar(Path),@StatData)=0 then begin
   StatToQID(aQID,@StatData);
   result:=0;
  end else begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
  end;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.Open(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aFlags:TPasRISCVUInt32;const aOnOpenCompletion:TPasRISCV9PFileSystem.TOnOpenCompletion;const aOpaque:Pointer):TPasRISCVInt32;
var StatData:TStat;
    Flags:TPasRISCVUInt32;
begin
 if fpLStat(PAnsiChar(aFile.fPath),@StatData)=0 then begin
  StatToQID(aQID,@StatData);
  Flags:=P9OpenFlagsToPOSIXOpenFlags(aFlags);
  if (aFlags and P9_O_DIRECTORY)<>0 then begin
   aFile.fDirectory:=FpOpenDir(PAnsiChar(aFile.fPath));
   if assigned(aFile.fDirectory) then begin
    aFile.fIsOpened:=true;
    aFile.fIsDirectory:=true;
    result:=0;
   end else begin
    result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
   end;
  end else begin
   aFile.fFile:=fpOpen(PAnsiChar(aFile.fPath),Flags and not O_CREAT);
   if aFile.fFile>=0 then begin
    aFile.fIsOpened:=true;
    aFile.fIsDirectory:=false;
    result:=0;
   end else begin
    result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
   end;
  end;
 end else begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end;
end;

function TPasRISCV9PFileSystemPOSIX.Create_(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aFlags:TPasRISCVUInt32;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32;
var StatData:TStat;
    ret,fd:cint;
    Mode,Flags:TPasRISCVUInt32;
    Path:TPasRISCVRawByteString;
begin
 Close(aFile);
 Path:=ComposePath(aFile.fPath,aName);
 Flags:=P9OpenFlagsToPOSIXOpenFlags(aFlags);
 Mode:=aMode and (O_RdOnly or O_WRONLY or O_RDWR);
 Mode:=(Flags or Mode) and (O_RdOnly or O_WRONLY or O_RDWR);
 Flags:=Flags or Mode;
 fd:=fpOpen(PAnsiChar(Path),Flags or O_CREAT,Mode);
 if fd<0 then begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end else begin
  ret:=fpLStat(PAnsiChar(Path),@StatData);
  if ret=0 then begin
   StatToQID(aQID,@StatData);
   aFile.fPath:=Path;
   aFile.fIsOpened:=true;
   aFile.fIsDirectory:=false;
   aFile.fFile:=fd;
   result:=0;
  end else begin
   fpClose(fd);
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
  end;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.ReadDir(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
var de:Pdirent;
    len,pos,name_len,dflags:TPasRISCVSizeInt;
    StatData:TStat;
    Path:TPasRISCVRawByteString;
    Offset:TOff;
begin
 if (not aFile.fIsOpened) or (not aFile.fIsDirectory) then begin
  result:=-P9_EPROTO;
 end else begin
  result:=0;
{ if aOffset=0 then begin
   RewindDir(aFile.fDirectory);
  end else begin
   SeekDir(aFile.fDirectory,aOffset);
  end;}
  SeekDir(aFile.fDirectory,aOffset);
  pos:=0;
  repeat
   de:=fpReadDir(aFile.fDirectory^);
   if assigned(de) then begin
    name_len:=StrLen(de^.d_name);
    Len:=13+8+1+2+name_len;
    if (pos+len)<=aSize then begin
     Offset:=TellDir(aFile.fDirectory);
     dflags:=0;
     if de^.d_type=DT_UNKNOWN then begin
      Path:=ComposePath(aFile.fPath,de^.d_name);
      if fpLStat(PAnsiChar(Path),@StatData)=0 then begin
       if (StatData.st_mode and S_IFDIR)<>0 then begin
        dflags:=dflags or P9_QTDIR;
       end;
       if (StatData.st_mode and S_IFLNK)<>0 then begin
        dflags:=dflags or P9_QTSYMLINK;
       end;
      end;
     end else begin
      if (de^.d_type and (S_IFDIR shr 12))<>0 then begin
       dflags:=dflags or P9_QTDIR;
      end;
      if (de^.d_type and (S_IFLNK shr 12))<>0 then begin
       dflags:=dflags or P9_QTSYMLINK;
      end;
     end;
     PPasRISCVUInt8Array(aBuffer)^[pos]:=dflags; inc(pos);
     PPasRISCVUInt32(@PPasRISCVUInt8Array(aBuffer)^[pos])^:=0; inc(pos,SizeOf(TPasRISCVUInt32));
     PPasRISCVUInt64(@PPasRISCVUInt8Array(aBuffer)^[pos])^:=de^.d_fileno; inc(pos,SizeOf(TPasRISCVUInt64));
     PPasRISCVUInt64(@PPasRISCVUInt8Array(aBuffer)^[pos])^:=Offset; inc(pos,SizeOf(TPasRISCVUInt64));
     PPasRISCVUInt8Array(aBuffer)^[pos]:=dflags; inc(pos);
     PPasRISCVUInt16(@PPasRISCVUInt8Array(aBuffer)^[pos])^:=name_len; inc(pos,SizeOf(TPasRISCVUInt16));
     Move(de^.d_name,PPasRISCVUInt8Array(aBuffer)^[pos],name_len); inc(pos,name_len);
    end else begin
     break;
    end;
   end else begin
    break;
   end;
  until false;
  result:=pos;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.Read(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
begin
 if (not aFile.fIsOpened) or (aFile.fIsDirectory) then begin
  result:=-P9_EPROTO;
 end else begin
  result:=fpPRead(aFile.fFile,aBuffer,aSize,aOffset);
  if result<0 then begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
  end;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.Write(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
begin
 if (not aFile.fIsOpened) or (aFile.fIsDirectory) then begin
  result:=-P9_EPROTO;
 end else begin
  result:=fpPWrite(aFile.fFile,aBuffer,aSize,aOffset);
  if result<0 then begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
  end;
 end;
end;

procedure TPasRISCV9PFileSystemPOSIX.Close(const aFile:TPasRISCV9PFileSystem.TFSFile);
begin
 if aFile.fIsOpened then begin
  if aFile.fIsDirectory then begin
   fpCloseDir(aFile.fDirectory^);
  end else begin
   fpClose(aFile.fFile);
  end;
  aFile.fIsOpened:=false;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.Stat(const aFile:TPasRISCV9PFileSystem.TFSFile;out aStat:TPasRISCV9PFileSystem.TFSStat):TPasRISCVInt32;
var StatData:TStat;
begin
 if fpLStat(PAnsiChar(aFile.fPath),@StatData)=0 then begin
  StatToQID(@aStat.qid,@StatData);
  aStat.Mode:=StatData.st_mode;
  aStat.UID:=StatData.st_uid;
  aStat.GID:=StatData.st_gid;
  aStat.NLink:=StatData.st_nlink;
  aStat.RDev:=StatData.st_rdev;
  aStat.Size:=StatData.st_size;
  aStat.BlkSize:=StatData.st_blksize;
  aStat.Blocks:=StatData.st_blocks;
  aStat.ATimeSec:=StatData.st_atime;
  aStat.ATimeNSec:=StatData.st_atime_nsec;
  aStat.MTimeSec:=StatData.st_mtime;
  aStat.MTimeNSec:=StatData.st_mtime_nsec;
  aStat.CTimeSec:=StatData.st_ctime;
  aStat.CTimeNSec:=StatData.st_ctime_nsec;
  result:=0;
 end else begin
  result:=-P9_ENOENT;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.SetAttr(const aFile:TPasRISCV9PFileSystem.TFSFile;const aMask,aMode,aUID,aGID:TPasRISCVUInt32;const aSize,aATimeSec,aATimeNSec,aMTimeSec,aMTimeNSec,aCTimeSec,aCTimeNSec:TPasRISCVUInt64):TPasRISCVInt32;
var //StatData:TStat;
    ts:tkernel_timespecs;
    ctime_updated:boolean;
    UID,GID:TPasRISCVInt32;
    fd:cint;
begin

 if (aMask and (P9_SETATTR_UID or P9_SETATTR_GID))<>0 then begin
  if (aMask and P9_SETATTR_UID)<>0 then begin
   UID:=aUID;
  end else begin
   UID:=-1;
  end;
  if (aMask and P9_SETATTR_GID)<>0 then begin
   GID:=aGID;
  end else begin
   GID:=-1;
  end;
  if LChOwn(PAnsiChar(aFile.fPath),UID,GID)<0 then begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
   exit;
  end;
  ctime_updated:=true;
 end else begin
  ctime_updated:=false;
 end;

 if (aMask and P9_SETATTR_MODE)<>0 then begin
  if fpChMod(PAnsiChar(aFile.fPath),aMode)<0 then begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
   exit;
  end;
  ctime_updated:=true;
 end;

 if (aMask and P9_SETATTR_SIZE)<>0 then begin
  if aFile.fIsOpened then begin
   if fpFTruncate(aFile.fFile,aSize)<0 then begin
    result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
    exit;
   end;
  end else begin
   fd:=fpOpen(PAnsiChar(aFile.fPath),O_WRONLY);
   if fd<0 then begin
    result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
    exit;
   end;
   if fpFTruncate(fd,aSize)<0 then begin
    fpClose(fd);
    result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
    exit;
   end;
   fpClose(fd);
  end;
{if fpTruncate(PAnsiChar(aFile.fPath),aSize)<0 then begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
   exit;
  end;}
  ctime_updated:=true;
 end;

 if (aMask and (P9_SETATTR_ATIME or P9_SETATTR_MTIME))<>0 then begin
  if (aMask and P9_SETATTR_ATIME)<>0 then begin
   if (aMask and P9_SETATTR_ATIME_SET)<>0 then begin
    ts[0].tv_sec:=aATimeSec;
    ts[0].tv_nsec:=aATimeNSec;
   end else begin
    ts[0].tv_sec:=0;
    ts[0].tv_nsec:=UTIME_NOW;
   end;
  end else begin
   ts[0].tv_sec:=0;
   ts[0].tv_nsec:=UTIME_OMIT;
  end;
  if (aMask and P9_SETATTR_MTIME)<>0 then begin
   if (aMask and P9_SETATTR_MTIME_SET)<>0 then begin
    ts[1].tv_sec:=aMTimeSec;
    ts[1].tv_nsec:=aMTimeNSec;
   end else begin
    ts[1].tv_sec:=0;
    ts[1].tv_nsec:=UTIME_NOW;
   end;
  end else begin
   ts[1].tv_sec:=0;
   ts[1].tv_nsec:=UTIME_OMIT;
  end;
  if utimensat(AT_FDCWD,PAnsiChar(aFile.fPath),ts,AT_SYMLINK_NOFOLLOW)<0 then begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
   exit;
  end;
  ctime_updated:=true;
 end;

 if ((aMask and P9_SETATTR_CTIME)<>0) and not ctime_updated then begin
  if LChown(PAnsiChar(aFile.fPath),TUID(-1),TGID(-1))<0 then begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
   exit;
  end;
 end;

 result:=0;

end;

function TPasRISCV9PFileSystemPOSIX.Link(const aDestFile,aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32;
var Path:TPasRISCVRawByteString;
begin
 Path:=ComposePath(aDestFile.fPath,aName);
 if fpLink(PAnsiChar(aFile.fPath),PAnsiChar(Path))<0 then begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end else begin
  result:=0;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.SymLink(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName,aTarget:TPasRISCVRawByteString;const aGID:TPasRISCVUInt32):TPasRISCVInt32;
var Path:TPasRISCVRawByteString;
    StatData:TStat;
begin
 Path:=ComposePath(aFile.fPath,aName);
 if fpSymLink(PAnsiChar(aTarget),PAnsiChar(Path))<0 then begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end else begin
  if fpLStat(PAnsiChar(Path),@StatData)=0 then begin
   StatToQID(aQID,@StatData);
   result:=0;
  end else begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
  end;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.MkNod(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aMajor,aMinor,aGID:TPasRISCVUInt32):TPasRISCVInt32;
var Path:TPasRISCVRawByteString;
    StatData:TStat;
begin
 Path:=ComposePath(aFile.fPath,aName);
 if MkNod_(PAnsiChar(Path),aMode,((aMajor and $fff) shl 8) or (aMinor and $ff))<0 then begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end else begin
  if fpLStat(PAnsiChar(Path),@StatData)=0 then begin
   StatToQID(aQID,@StatData);
   result:=0;
  end else begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
  end;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.ReadLink(const aBuffer:Pointer;const aSize:TPasRISCVInt64;const aFile:TPasRISCV9PFileSystem.TFSFile):TPasRISCVInt64;
begin
 result:=fpReadLink(PAnsiChar(aFile.fPath),aBuffer,aSize-1);
 if result<0 then begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end else begin
  PPasRISCVUInt8Array(aBuffer)^[result]:=0;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.RenameAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aNewFile:TPasRISCV9PFileSystem.TFSFile;const aNewName:TPasRISCVRawByteString):TPasRISCVInt32;
var Path,NewPath:TPasRISCVRawByteString;
begin
 Path:=ComposePath(aFile.fPath,aName);
 NewPath:=ComposePath(aNewFile.fPath,aNewName);
 if fpRename(PAnsiChar(Path),PAnsiChar(NewPath))<0 then begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end else begin
  result:=0;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.UnlinkAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32;
var Path:TPasRISCVRawByteString;
begin
 Path:=ComposePath(aFile.fPath,aName);
 if Remove_(PAnsiChar(Path))<0 then begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end else begin
  result:=0;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.Lock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32;
var fl:FLock;
    errno:cint;
begin
 if (not aFile.fIsOpened) or (aFile.fIsDirectory) then begin
  result:=-P9_EPROTO;
 end else begin
  fl.l_type:=aLock^.Type_;
  fl.l_whence:=SEEK_SET;
  fl.l_start:=aLock^.Start;
  fl.l_len:=aLock^.Length;
  if fpFcntl(aFile.fFile,F_SETLK,fl)=0 then begin
   result:=P9_LOCK_SUCCESS;
  end else begin
   errno:=fpGetErrNo;
   if (errno=ESysEAGAIN) or (errno=ESysEACCES) then begin
    result:=P9_LOCK_BLOCKED;
   end else begin
    result:=-POSIXErrorCodeToP9ErrorCode(errno);
   end;
  end;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.GetLock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32;
var fl:Flock;
begin
 if (not aFile.fIsOpened) or (aFile.fIsDirectory) then begin
  result:=-P9_EPROTO;
 end else begin
  fl.l_type:=aLock^.Type_;
  fl.l_whence:=SEEK_SET;
  fl.l_start:=aLock^.Start;
  fl.l_len:=aLock^.Length;
  if fpFcntl(aFile.fFile,F_GETLK,fl)=0 then begin
   aLock^.Type_:=fl.l_type;
   aLock^.Start:=fl.l_start;
   aLock^.Length:=fl.l_len;
   result:=0;
  end else begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
  end;
 end;
end;

{$elseif defined(Windows)}

{ TPasRISCV9PFileSystemWindows }

constructor TPasRISCV9PFileSystemWindows.Create(const aRootPath:TPasRISCVRawByteString);
begin
 inherited Create;
 fRootPath:=aRootPath;
end;

destructor TPasRISCV9PFileSystemWindows.Destroy;
begin
 fRootPath:='';
 inherited Destroy;
end;

function TPasRISCV9PFileSystemWindows.FileTimeToUnixTime(const aFileTime:TFileTime):TPasRISCVUInt64;
var SystemTime:TSystemTime;
    DateTime:TDateTime;
begin
 // Convert FILETIME to SYSTEMTIME
 if FileTimeToSystemTime(aFileTime,SystemTime) then begin
  DateTime:=SystemTimeToDateTime(SystemTime);
  result:=DateTimeToUnix(DateTime);
 end else begin
  result:=0;
 end;
end;

function TPasRISCV9PFileSystemWindows.UnixTimeToFileTime(const aUnixTime:TPasRISCVUInt64):TFileTime;
var DateTime:TDateTime;
    SystemTime:TSystemTime;
begin
 DateTime:=UnixToDateTime(aUnixTime);
 DateTimeToSystemTime(DateTime,SystemTime);
 SystemTimeToFileTime(SystemTime,result);
end;

function TPasRISCV9PFileSystemWindows.Win32FileAttributesToP9Mode(const aFileAttributes:DWORD):TPasRISCVUInt32;
begin
 result:=P9_S_IRWXUGO; // Default permissions for Windows files since they are not POSIX compliant, so just use RWX for all for now
 if (aFileAttributes and FILE_ATTRIBUTE_DIRECTORY)<>0 then begin
  result:=result or P9_S_IFDIR;
 end else begin
  result:=result or P9_S_IFREG;
 end;
 if (aFileAttributes and FILE_ATTRIBUTE_REPARSE_POINT)<>0 then begin
  result:=result or P9_S_IFLNK;
 end;
 if (aFileAttributes and FILE_ATTRIBUTE_READONLY)<>0 then begin
  result:=result and not P9_S_IWOGU; // Remove write permissions for owner, group, and others, as the file is read-only
 end;
{if (aFileAttributes and FILE_ATTRIBUTE_HIDDEN)<>0 then begin
  result:=result and not P9_S_IROGU; // Remove read permissions for owner, group, and others, as the file is hidden
 end;
 if (aFileAttributes and FILE_ATTRIBUTE_SYSTEM)<>0 then begin
  result:=result and not P9_S_IXOGU; // Remove execute permissions for owner, group, and others, as the file is a system file
 end;}
end;

function TPasRISCV9PFileSystemWindows.Win32ErrorCodeToP9ErrorCode(const aErrorCode:DWORD):TPasRISCVInt32;
begin
 case aErrorCode of
  ERROR_SUCCESS:begin
   result:=0;
  end;
  ERROR_ACCESS_DENIED:begin
   result:=-P9_EPERM;
  end;
  ERROR_FILE_NOT_FOUND:begin
   result:=-P9_ENOENT;
  end;
  ERROR_IO_DEVICE,
  ERROR_IO_PENDING,
  ERROR_GEN_FAILURE:begin
   result:=-P9_EIO;
  end;
  ERROR_ALREADY_EXISTS:begin
   result:=-P9_EEXIST;
  end;
  ERROR_PATH_NOT_FOUND,
  ERROR_DIRECTORY:begin
   result:=-P9_ENOTDIR;
  end;
  ERROR_INVALID_PARAMETER,
  ERROR_INVALID_HANDLE:begin
   result:=-P9_EINVAL;
  end;
  ERROR_DISK_FULL:begin
   result:=-P9_ENOSPC;
  end;
  ERROR_DIR_NOT_EMPTY:begin
   result:=-P9_ENOTEMPTY;
  end;
  ERROR_PROTOCOL_UNREACHABLE:begin
   result:=-P9_EPROTO;
  end;
  ERROR_NOT_SUPPORTED:begin
   result:=-P9_ENOTSUP;
  end;
  else begin
   result:=-P9_EINVAL;
  end;
 end;
end;

function TPasRISCV9PFileSystemWindows.P9OpenFlagsToWin32OpenFlags(const aFlags:TPasRISCVUInt32):DWORD;
const FILE_FLAG_OPEN_REPARSE_POINT=$200000;
var Access:DWORD;
    CreationDisposition:DWORD;
    FlagsAndAttributes:DWORD;
begin

 // Initialize Access based on P9_O_NOACCESS (acting as O_ACCMODE mask)
 case aFlags and P9_O_NOACCESS of
  P9_O_RDONLY:begin
   Access:=GENERIC_READ;
  end;
  P9_O_WRONLY:begin
   Access:=GENERIC_WRITE;
  end;
  P9_O_RDWR:begin
   Access:=GENERIC_READ or GENERIC_WRITE;
  end;
  else begin
   Access:=0; // Default or undefined access
  end;
 end;

 // Determine CreationDisposition
 if (aFlags and P9_O_CREAT)<>0 then begin
  if (aFlags and P9_O_EXCL)<>0 then begin
   CreationDisposition:=CREATE_NEW;
  end else begin
   CreationDisposition:=CREATE_ALWAYS;
  end;
 end else begin
  CreationDisposition:=OPEN_EXISTING;
 end;

 // Initialize FlagsAndAttributes with default
 FlagsAndAttributes:=FILE_ATTRIBUTE_NORMAL;

 // Map additional flags
 if (aFlags and P9_O_TRUNC)<>0 then begin
  FlagsAndAttributes:=FlagsAndAttributes or TRUNCATE_EXISTING;
 end;
 if (aFlags and P9_O_APPEND)<>0 then begin
  FlagsAndAttributes:=FlagsAndAttributes or FILE_APPEND_DATA;
 end;
 if (aFlags and P9_O_NONBLOCK)<>0 then begin
  FlagsAndAttributes:=FlagsAndAttributes or FILE_FLAG_OVERLAPPED;
 end;
 if (aFlags and P9_O_DSYNC)<>0 then begin
  FlagsAndAttributes:=FlagsAndAttributes or FILE_FLAG_WRITE_THROUGH;
 end;
 if (aFlags and P9_O_SYNC)<>0 then begin
  FlagsAndAttributes:=FlagsAndAttributes or FILE_FLAG_WRITE_THROUGH;
 end;
 if (aFlags and P9_O_DIRECT)<>0 then begin
  FlagsAndAttributes:=FlagsAndAttributes or FILE_FLAG_NO_BUFFERING;
 end;
 if (aFlags and P9_O_DIRECTORY)<>0 then begin
  FlagsAndAttributes:=FlagsAndAttributes or FILE_FLAG_BACKUP_SEMANTICS;
 end;
 if (aFlags and P9_O_NOFOLLOW)<>0 then begin
  FlagsAndAttributes:=FlagsAndAttributes or FILE_FLAG_OPEN_REPARSE_POINT;
 end;

 // Combine Access, CreationDisposition, and FlagsAndAttributes
 result:=Access or CreationDisposition or FlagsAndAttributes;

 // Note: The following flags are ignored as they have no direct Win32 equivalents:
 // P9_O_NOCTTY, P9_O_FASYNC, P9_O_LARGEFILE, P9_O_NOATIME, P9_O_CLOEXEC

end;

procedure TPasRISCV9PFileSystemWindows.StatToQID(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFileInfo:BY_HANDLE_FILE_INFORMATION);
begin
 aQID^.Type_:=0;
 if (aFileInfo.dwFileAttributes and FILE_ATTRIBUTE_DIRECTORY)<>0 then begin
  aQID^.Type_:=aQID^.Type_ or P9_QTDIR;
 end;
 if (aFileInfo.dwFileAttributes and FILE_ATTRIBUTE_REPARSE_POINT)<>0 then begin
  aQID^.Type_:=aQID^.Type_ or P9_QTSYMLINK;
 end;
 if (aFileInfo.dwFileAttributes and FILE_ATTRIBUTE_TEMPORARY)<>0 then begin
  aQID^.Type_:=aQID^.Type_ or P9_QTTMP;
 end;
 aQID^.Version:=0; // No caching on client
 aQID^.Path:=(TPasRISCVUInt64(aFileInfo.nFileIndexHigh) shl 32) or aFileInfo.nFileIndexLow;
end;

function TPasRISCV9PFileSystemWindows.ComposePath(const aPath,aName:TPasRISCVRawByteString):TPasRISCVRawByteString;
const DirectorySeparator='\';
begin
 result:=aPath;
 if (length(result)>0) and (result[length(result)]<>DirectorySeparator) then begin
  result:=result+DirectorySeparator;
 end;
 result:=result+aName;
end;

function TPasRISCV9PFileSystemWindows.CreateFileObject(const aPath:TPasRISCVRawByteString;const aUID:TPasRISCVUInt32):TPasRISCV9PFileSystem.TFSFile;
begin
 result:=TFSFile.Create;
 result.fPath:=aPath;
 result.fUID:=aUID;
 result.fIsOpened:=false;
 result.fIsDirectory:=false;
 result.fStream:=nil; // unused
 result.fFileHandle:=INVALID_HANDLE_VALUE;
 result.fDirectoryHandle:=INVALID_HANDLE_VALUE;
 result.fIsOverlapped:=false;
end;

procedure TPasRISCV9PFileSystemWindows.Delete(const aFile:TPasRISCV9PFileSystem.TFSFile);
begin

 if assigned(aFile) then begin

  if aFile.fIsOpened then begin
   Close(aFile);
  end;

  aFile.fIsOpened:=false;
  aFile.fIsDirectory:=false;
  aFile.fPath:='';

  if aFile.fFileHandle<>INVALID_HANDLE_VALUE then begin
   CloseHandle(aFile.fFileHandle);
   aFile.fFileHandle:=INVALID_HANDLE_VALUE;
  end;

  if aFile.fDirectoryHandle<>INVALID_HANDLE_VALUE then begin
   CloseHandle(aFile.fDirectoryHandle);
   aFile.fDirectoryHandle:=INVALID_HANDLE_VALUE;
  end;

  aFile.Free;

 end;

end;

procedure TPasRISCV9PFileSystemWindows.StatFS(out aStatFS:TPasRISCV9PFileSystem.TFSStatFS);
var FreeBytesAvailable,TotalNumberOfBytes,TotalNumberOfFreeBytes:ULONGLONG;
begin
 if GetDiskFreeSpaceExA(PAnsiChar(RawByteString(fRootPath)),@FreeBytesAvailable,@TotalNumberOfBytes,@TotalNumberOfFreeBytes) then begin
  aStatFS.BSize:=4096; // Typically, Windows uses 4096 bytes as block size
  aStatFS.Blocks:=(TotalNumberOfBytes+(aStatFS.BSize-1)) div aStatFS.BSize;
  aStatFS.BFree:=(TotalNumberOfFreeBytes+(aStatFS.BSize-1)) div aStatFS.BSize;
  aStatFS.BAvail:=(FreeBytesAvailable+(aStatFS.BSize-1)) div aStatFS.BSize;
  aStatFS.Files:=$2000000; // Windows does not provide a direct count
  aStatFS.FFree:=$1000000; // Windows does not provide a direct count
 end else begin
  FillChar(aStatFS,SizeOf(TFSStatFS),#0);
 end;
end;

function TPasRISCV9PFileSystemWindows.Attach(out aFile:TPasRISCV9PFileSystem.TFSFile;const aQID:TPasRISCV9PFileSystem.PFSQID;const aUID:TPasRISCVUInt32;const aUName,aAName:TPasRISCVRawByteString):TPasRISCVInt32;
var Handle:THandle;
    FileInfo:BY_HANDLE_FILE_INFORMATION;
begin

 Handle:=CreateFileA(PAnsiChar(RawByteString(fRootPath)),
                     GENERIC_READ,
                     FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE,
                     nil,
                     OPEN_EXISTING,
                     FILE_FLAG_BACKUP_SEMANTICS,
                     0);

 if Handle=INVALID_HANDLE_VALUE then begin

  aFile:=nil;
  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);

 end else begin

  try
   if GetFileInformationByHandle(Handle,FileInfo) then begin
    aFile:=CreateFileObject(fRootPath,aUID);
    StatToQID(aQID,FileInfo);
    result:=0;
   end else begin
    aFile:=nil;
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
   end;
  finally
   CloseHandle(Handle);
  end;

 end;

end;

function TPasRISCV9PFileSystemWindows.Walk(out aFiles:TPasRISCV9PFileSystem.TFSFile;const aQIDs:TPasRISCV9PFileSystem.PFSQIDArray;const aFile:TPasRISCV9PFileSystem.TFSFile;const aCount:TPasRISCVSizeInt;const aNames:array of TPasRISCVRawByteString):TPasRISCVInt32;
var CurrentPath,NewPath:TPasRISCVRawByteString;
    FileInfo:BY_HANDLE_FILE_INFORMATION;
    Index:TPasRISCVSizeInt;
    Handle:THandle;
begin

 CurrentPath:=aFile.fPath;
 result:=0;

 for Index:=0 to aCount-1 do begin

  NewPath:=ComposePath(CurrentPath,aNames[Index]);

  Handle:=CreateFileA(PAnsiChar(RawByteString(NewPath)),
                      GENERIC_READ,
                      FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE,
                      nil,
                      OPEN_EXISTING,
                      FILE_FLAG_BACKUP_SEMANTICS,
                      0);

  if Handle=INVALID_HANDLE_VALUE then begin
   break;
  end;

  try
   if GetFileInformationByHandle(Handle,FileInfo) then begin
    StatToQID(@aQIDs[Index],FileInfo);
    inc(result);
    CurrentPath:=NewPath;
   end else begin
    break;
   end;
  finally
   CloseHandle(Handle);
  end;

 end;

 aFiles:=CreateFileObject(CurrentPath,aFile.fUID);

end;

function TPasRISCV9PFileSystemWindows.MkDir(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32;
var Path:TPasRISCVRawByteString;
    Success:BOOL;
    Handle:THandle;
    FileInfo:BY_HANDLE_FILE_INFORMATION;
begin

 Path:=ComposePath(aFile.fPath,aName);
 Success:=CreateDirectoryA(PAnsiChar(RawByteString(Path)),nil);

 if Success then begin

  Handle:=CreateFileA(PAnsiChar(RawByteString(Path)),
                      GENERIC_READ,
                      FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE,
                      nil,
                      OPEN_EXISTING,
                      FILE_FLAG_BACKUP_SEMANTICS,
                      0);

  if Handle<>INVALID_HANDLE_VALUE then begin

   try
    if GetFileInformationByHandle(Handle,FileInfo) then begin
     StatToQID(aQID,FileInfo);
     result:=0;
    end else begin
     result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
    end;
   finally
    CloseHandle(Handle);
   end;

  end else begin

   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);

  end;

 end else begin

  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);

 end;

end;

function TPasRISCV9PFileSystemWindows.Open(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aFlags:TPasRISCVUInt32;const aOnOpenCompletion:TPasRISCV9PFileSystem.TOnOpenCompletion;const aOpaque:Pointer):TPasRISCVInt32;
var DesiredAccess,ShareMode,CreationDisposition,FlagsAndAttributes:DWORD;
    Handle:THandle;
    FileInfo:BY_HANDLE_FILE_INFORMATION;
begin

 // Map 9P open flags to Win32 flags
 DesiredAccess:=P9OpenFlagsToWin32OpenFlags(aFlags);

 // Define share mode to allow other processes to read/write/delete
 ShareMode:=FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE;

 // Determine creation disposition based on flags
{if (aFlags and P9_O_CREAT)<>0 then begin
  if (aFlags and P9_O_EXCL)<>0 then begin
   CreationDisposition:=CREATE_NEW;
  end else begin
   CreationDisposition:=CREATE_ALWAYS;
  end;
 end else begin}
  CreationDisposition:=OPEN_EXISTING;
{end;//}

 // Define additional flags and attributes based on the mapping
 FlagsAndAttributes:=0; // Already included in P9OpenFlagsToWin32OpenFlags

 // Open the file or directory
 Handle:=CreateFileA(PAnsiChar(RawByteString(aFile.fPath)),
                     DesiredAccess,
                     ShareMode,
                     nil,
                     CreationDisposition,
                     FlagsAndAttributes or FILE_FLAG_BACKUP_SEMANTICS,
                     0);

 // Check if the handle is valid
 if Handle<>INVALID_HANDLE_VALUE then begin

  try

   // Retrieve file information to populate QID
   if GetFileInformationByHandle(Handle,FileInfo) then begin

    StatToQID(aQID,FileInfo);
    aFile.fIsOpened:=true;
    aFile.fIsDirectory:=(FileInfo.dwFileAttributes and FILE_ATTRIBUTE_DIRECTORY)<>0;
    aFile.fFileHandle:=INVALID_HANDLE_VALUE;
    aFile.fDirectoryHandle:=INVALID_HANDLE_VALUE;

    aFile.fIsOverlapped:=(FlagsAndAttributes and FILE_FLAG_OVERLAPPED)<>0;

    // Assign the appropriate handle
    if aFile.fIsDirectory then begin
     aFile.fDirectoryHandle:=Handle;
    end else begin
     aFile.fFileHandle:=Handle;
    end;

    result:=0;

   end else begin

    // If file information retrieval failed, close the handle and return an error

    // Close the handle
    CloseHandle(Handle);

    // Return error code
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);

   end;

  except
   // If an exception occurred, close the handle and re-raise the exception
   CloseHandle(Handle);
   raise;
  end;

 end else begin

  // If the handle is invalid, return an error code
  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);

 end;

end;

function TPasRISCV9PFileSystemWindows.Create_(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aFlags:TPasRISCVUInt32;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32;
var Path:TPasRISCVRawByteString;
    DesiredAccess,ShareMode,CreationDisposition,FlagsAndAttributes:DWORD;
    Handle:THandle;
    FileInfo:BY_HANDLE_FILE_INFORMATION;
begin

 // Compose the full path for the new file
 Path:=ComposePath(aFile.fPath,aName);

 // Map 9P open flags to Win32 flags
 DesiredAccess:=P9OpenFlagsToWin32OpenFlags(aFlags);

{// Share mode set to exclusive access (no sharing)
 ShareMode:=0;}

 // Define share mode to allow other processes to read/write/delete
 ShareMode:=FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE;

 // Determine creation disposition based on flags
{if (aFlags and P9_O_CREAT)<>0 then begin}
  if (aFlags and P9_O_EXCL)<>0 then begin
   CreationDisposition:=CREATE_NEW;
  end else begin
   CreationDisposition:=CREATE_ALWAYS;
  end;
{end else begin
  CreationDisposition:=OPEN_EXISTING;
 end;}

 // Flags and Attributes are already included in P9OpenFlagsToWin32OpenFlags
 FlagsAndAttributes:=0;

 // Create or open the file
 Handle:=CreateFileA(PAnsiChar(RawByteString(Path)),
                     DesiredAccess,
                     ShareMode,
                     nil,
                     CreationDisposition,
                     FlagsAndAttributes,
                     0);

 if Handle<>INVALID_HANDLE_VALUE then begin

  try
   // Retrieve file information to populate QID
   if GetFileInformationByHandle(Handle,FileInfo) then begin

    StatToQID(aQID,FileInfo);
    aFile.fIsOpened:=true;
    aFile.fIsDirectory:=(FileInfo.dwFileAttributes and FILE_ATTRIBUTE_DIRECTORY)<>0;
    aFile.fFileHandle:=INVALID_HANDLE_VALUE;
    aFile.fDirectoryHandle:=INVALID_HANDLE_VALUE;

    aFile.fIsOverlapped:=(FlagsAndAttributes and FILE_FLAG_OVERLAPPED)<>0;

    // Assign the appropriate handle
    if aFile.fIsDirectory then begin
     aFile.fDirectoryHandle:=Handle;
    end else begin
     aFile.fFileHandle:=Handle;
    end;

    result:=0;

   end else begin

    // If file information retrieval failed, close the handle and return an error

    // Close the handle
    CloseHandle(Handle);

    // Return error code
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);

   end;

  except
   // If an exception occurred, close the handle and re-raise the exception
   CloseHandle(Handle);
   raise;
  end;

 end else begin

  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);

 end;

end;

function TPasRISCV9PFileSystemWindows.ReadDir(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
var FindHandle:THandle;
    FindData:WIN32_FIND_DATAA;
    Path:TPasRISCVRawByteString;
    EntryOffset,RequiredSize:TPasRISCVSizeInt;
    BytesWritten:TPasRISCVSizeInt;
    NameLen:TPasRISCVUInt16;
    EntryType:TPasRISCVUInt8;
    PathU64:TPasRISCVUInt64;
    FileInfo:BY_HANDLE_FILE_INFORMATION;
    FileName:TPasRISCVUTF8String;
    Handle:THandle;
begin

 // Check if the file is a directory
 if not aFile.fIsDirectory then begin
  result:=-P9_EPROTO;
  exit;
 end;

 // Compose the search path with wildcard
 Path:=ComposePath(aFile.fPath,'*');

 // Initiate the directory search
 FindHandle:=Windows.FindFirstFileA(PAnsiChar(RawByteString(Path)),FindData);
 if FindHandle=INVALID_HANDLE_VALUE then begin
  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
  exit;
 end;

 try

  BytesWritten:=0;

  EntryOffset:=0;

  result:=0;

  PathU64:=0;

  repeat

   // Skip '.' and '..'
{  if (RawByteString(FindData.cFileName)='.') or (RawByteString(FindData.cFileName)='..') then begin
    continue;
   end;}

   // Skip entries before offset
   if EntryOffset<aOffset then begin
    inc(EntryOffset);
    continue;
   end;

   inc(EntryOffset);

   // Calculate required space: Type (1) + Version (4) + Path (8) + Name length (2) + Name
   NameLen:=Length(PAnsiChar(Pointer(@FindData.cFileName)));
   RequiredSize:=13+8+1+2+NameLen;
   if (BytesWritten+RequiredSize)>aSize then begin
    break;
   end;

   // Determine Type
   EntryType:=0;

   if (FindData.dwFileAttributes and FILE_ATTRIBUTE_DIRECTORY)<>0 then begin
    EntryType:=EntryType or P9_QTDIR;
   end;

   if (FindData.dwFileAttributes and FILE_ATTRIBUTE_REPARSE_POINT)<>0 then begin
    EntryType:=EntryType or P9_QTSYMLINK;
   end;

   if (FindData.dwFileAttributes and FILE_ATTRIBUTE_TEMPORARY)<>0 then begin
    EntryType:=EntryType or P9_QTTMP;
   end;

   FileName:=ComposePath(aFile.fPath,RawByteString(FindData.cFileName));
   Handle:=CreateFileA(PAnsiChar(RawByteString(FileName)),
                       GENERIC_READ,
                       FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE,
                       nil,
                       OPEN_EXISTING,
                       FILE_FLAG_BACKUP_SEMANTICS,
                       0);

   if Handle=INVALID_HANDLE_VALUE then begin

    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);

   end else begin

    try
     if GetFileInformationByHandle(Handle,FileInfo) then begin
      PathU64:=(TPasRISCVUInt64(FileInfo.nFileIndexHigh) shl 32) or FileInfo.nFileIndexLow;
     end else begin
      result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
     end;
    finally
     CloseHandle(Handle);
    end;

   end;

   PPasRISCVUInt8Array(aBuffer)^[BytesWritten]:=EntryType; inc(BytesWritten);
   PPasRISCVUInt32(@PPasRISCVUInt8Array(aBuffer)^[BytesWritten])^:=0; inc(BytesWritten,SizeOf(TPasRISCVUInt32));
   PPasRISCVUInt64(@PPasRISCVUInt8Array(aBuffer)^[BytesWritten])^:=PathU64; inc(BytesWritten,SizeOf(TPasRISCVUInt64));
   PPasRISCVUInt64(@PPasRISCVUInt8Array(aBuffer)^[BytesWritten])^:=EntryOffset; inc(BytesWritten,SizeOf(TPasRISCVUInt64));
   PPasRISCVUInt8Array(aBuffer)^[BytesWritten]:=EntryType; inc(BytesWritten);
   PPasRISCVUInt16(@PPasRISCVUInt8Array(aBuffer)^[BytesWritten])^:=NameLen; inc(BytesWritten,SizeOf(TPasRISCVUInt16));
   FileName:=UTF8String(FindData.cFileName);
   Move(FileName[1],PPasRISCVUInt8Array(aBuffer)^[BytesWritten],NameLen); inc(BytesWritten,NameLen);

  until (result=0) and not Windows.FindNextFileA(FindHandle,FindData);

  if result=0 then begin
   result:=BytesWritten;
  end;

 finally
  Windows.FindClose(FindHandle);
 end;

end;

{$if not declared(SetFilePointerEx)}
function SetFilePointerEx(hFile:HANDLE;liDistanceToMove:TPasMPUInt64;lpNewFilePointer:PPasMPUInt64;dwMoveMethod:DWORD):BOOL; {$ifdef cpu386}stdcall;{$endif} external 'kernel32.dll' name 'SetFilePointerEx';
{$ifend}

function TPasRISCV9PFileSystemWindows.Read(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
var BytesRead:DWORD;
    Overlapped:TOverlapped;
    Success:BOOL;
//  FilePointer:LARGE_INTEGER;
begin

 // Validate that the file is opened and not a directory
 if (not aFile.fIsOpened) or aFile.fIsDirectory then begin
  result:=-P9_EPROTO;
  exit;
 end;

 if aFile.fIsOverlapped then begin

  // Initialize the OVERLAPPED structure for asynchronous I/O
  ZeroMemory(@Overlapped,SizeOf(TOverlapped));
  Overlapped.Offset:=DWORD(aOffset and $ffffffff);
  Overlapped.OffsetHigh:=DWORD((aOffset shr 32) and $ffffffff);

  // Perform asynchronous write
  Success:=ReadFile(aFile.fFileHandle,aBuffer^,DWORD(aSize),BytesRead,@Overlapped);

  if Success then begin

   // If the operation completed synchronously, return the number of bytes read
   result:=BytesRead;

  end else begin

   // Check if the operation is pending
   if GetLastError=ERROR_IO_PENDING then begin

    // Wait for the operation to complete
    if GetOverlappedResult(aFile.fFileHandle,Overlapped,BytesRead,true) then begin
     result:=BytesRead;
    end else begin
     result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
    end;

   end else begin

    // If the operation failed, return the error code
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
   end;

  end;

 end else begin

  // Perform synchronous write without OVERLAPPED

  // Set the file pointer to aOffset
//FilePointer.QuadPart:=aOffset;
  if SetFilePointerEx(aFile.fFileHandle,aOffset,nil,FILE_BEGIN) then begin

   // Perform synchronous read
   if ReadFile(aFile.fFileHandle,aBuffer^,DWORD(aSize),BytesRead,nil) then begin
    result:=BytesRead;
   end else begin
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
   end;

  end else begin
   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
  end;

 end;

end;

function TPasRISCV9PFileSystemWindows.Write(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
var BytesWritten:DWORD;
    Overlapped:TOverlapped;
    Success:BOOL;
//  FilePointer:LARGE_INTEGER;
begin

 // Validate that the file is opened and not a directory
 if (not aFile.fIsOpened) or aFile.fIsDirectory then begin
  result:=-P9_EPROTO;
  exit;
 end;

 if aFile.fIsOverlapped then begin

  // Initialize the OVERLAPPED structure for asynchronous I/O
  ZeroMemory(@Overlapped,SizeOf(TOverlapped));
  Overlapped.Offset:=DWORD(aOffset and $ffffffff);
  Overlapped.OffsetHigh:=DWORD((aOffset shr 32) and $ffffffff);

  // Perform asynchronous write
  Success:=WriteFile(aFile.fFileHandle,aBuffer^,DWORD(aSize),BytesWritten,@Overlapped);

  if Success then begin

   // If the operation completed synchronously, return the number of bytes written
   result:=BytesWritten;

  end else begin

   // Check if the operation is pending
   if GetLastError=ERROR_IO_PENDING then begin

    // Wait for the operation to complete
    if GetOverlappedResult(aFile.fFileHandle,Overlapped,BytesWritten,true) then begin
     result:=BytesWritten;
    end else begin
     result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
    end;

   end else begin

    // If the operation failed, return the error code
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
   end;

  end;

 end else begin

  // Perform synchronous write without OVERLAPPED

  // Set the file pointer to aOffset
//FilePointer.QuadPart:=aOffset;
  if SetFilePointerEx(aFile.fFileHandle,aOffset,nil,FILE_BEGIN) then begin

   // Perform synchronous write
   if WriteFile(aFile.fFileHandle,aBuffer^,DWORD(aSize),BytesWritten,nil) then begin
    result:=BytesWritten;
   end else begin
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
   end;

  end else begin
   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
  end;

 end;

end;

procedure TPasRISCV9PFileSystemWindows.Close(const aFile:TPasRISCV9PFileSystem.TFSFile);
begin
 if aFile.fIsOpened then begin
  if not aFile.fIsDirectory and (aFile.fFileHandle<>INVALID_HANDLE_VALUE) then begin
   CloseHandle(aFile.fFileHandle);
   aFile.fFileHandle:=INVALID_HANDLE_VALUE;
  end else if aFile.fIsDirectory and (aFile.fDirectoryHandle<>INVALID_HANDLE_VALUE) then begin
   CloseHandle(aFile.fDirectoryHandle);
   aFile.fDirectoryHandle:=INVALID_HANDLE_VALUE;
  end;
  aFile.fIsOpened:=false;
  aFile.fIsDirectory:=false;
 end;
end;

function TPasRISCV9PFileSystemWindows.Stat(const aFile:TPasRISCV9PFileSystem.TFSFile;out aStat:TPasRISCV9PFileSystem.TFSStat):TPasRISCVInt32;
var Handle:THandle;
    FileInfo:BY_HANDLE_FILE_INFORMATION;
    Success:BOOL;
    TargetName:String;
begin

 Handle:=CreateFileA(PAnsiChar(RawByteString(aFile.fPath)),
                     GENERIC_READ,
                     FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE,
                     nil,
                     OPEN_EXISTING,
                     FILE_FLAG_BACKUP_SEMANTICS,
                     0);

 if Handle=INVALID_HANDLE_VALUE then begin
  result:=-P9_ENOENT;
  exit;
 end;

 try
  Success:=GetFileInformationByHandle(Handle,FileInfo);
  if Success then begin
   StatToQID(@aStat.qid,FileInfo);
   aStat.Mode:=Win32FileAttributesToP9Mode(FileInfo.dwFileAttributes);
{  if FileGetSymLinkTarget(aFile.fPath,TargetName) then begin
    aStat.Mode:=aStat.Mode or P9_S_IFLNK;
   end;}
   aStat.UID:=0; // Windows does not use UID/GID in the same way
   aStat.GID:=0;
   aStat.NLink:=FileInfo.nNumberOfLinks;
   aStat.RDev:=0; // Not applicable
   aStat.Size:=(TPasRISCVUInt64(FileInfo.nFileSizeHigh) shl 32) or FileInfo.nFileSizeLow;
   aStat.BlkSize:=4096; // Default block size
   aStat.Blocks:=(aStat.Size+(aStat.BlkSize-1)) div aStat.BlkSize;
   aStat.ATimeSec:=FileTimeToUnixTime(FileInfo.ftLastAccessTime);
   aStat.ATimeNSec:=0;
   aStat.MTimeSec:=FileTimeToUnixTime(FileInfo.ftLastWriteTime);
   aStat.MTimeNSec:=0;
   aStat.CTimeSec:=FileTimeToUnixTime(FileInfo.ftCreationTime);
   aStat.CTimeNSec:=0;
   result:=0;
  end else begin
   result:=-P9_ENOENT;
  end;
 finally
  CloseHandle(Handle);
 end;

end;

function TPasRISCV9PFileSystemWindows.SetAttr(const aFile:TPasRISCV9PFileSystem.TFSFile;const aMask,aMode,aUID,aGID:TPasRISCVUInt32;const aSize,aATimeSec,aATimeNSec,aMTimeSec,aMTimeNSec,aCTimeSec,aCTimeNSec:TPasRISCVUInt64):TPasRISCVInt32;
var Attributes:DWORD;
    Success:BOOL;
    Handle:THandle;
    NewFileTime:FILETIME;
    SystemTime:TSystemTime;
//  NewSize:LARGE_INTEGER;
    ftCreation,ftLastAccess,ftLastWrite:FILETIME;
begin

 // Handle mode changes
 if (aMask and P9_SETATTR_MODE)<>0 then begin
  Attributes:=0;
  if ((aMode and P9_QTDIR)<>0) and ((aMode and P9_QTFILE)=0) then begin
   Attributes:=FILE_ATTRIBUTE_DIRECTORY;
  end else begin
   Attributes:=FILE_ATTRIBUTE_NORMAL; // Default
  end;
  if (aMode and P9_QTSYMLINK)<>0 then begin
   Attributes:=Attributes or FILE_ATTRIBUTE_REPARSE_POINT;
  end;
  Success:=SetFileAttributesA(PAnsiChar(RawByteString(aFile.fPath)),Attributes);
  if not Success then begin
   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
   exit;
  end;
 end;

 // Handle size changes
 if (aMask and P9_SETATTR_SIZE)<>0 then begin
  Handle:=CreateFileA(PAnsiChar(RawByteString(aFile.fPath)),
                      GENERIC_WRITE,
                      0,
                      nil,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      0);
  if Handle=INVALID_HANDLE_VALUE then begin
   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
   exit;
  end;
  try
// NewSize.QuadPart:=aSize;
   if not SetFilePointerEx(Handle,aSize,nil,FILE_BEGIN) then begin
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
    exit;
   end;
   Success:=SetEndOfFile(Handle);
   if not Success then begin
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
    exit;
   end;
  finally
   CloseHandle(Handle);
  end;
 end;

 // Handle timestamps
 if (aMask and (P9_SETATTR_ATIME or P9_SETATTR_MTIME))<>0 then begin
  Handle:=CreateFileA(PAnsiChar(RawByteString(aFile.fPath)),
                      GENERIC_WRITE,
                      0,
                      nil,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      0);
  if Handle=INVALID_HANDLE_VALUE then begin
   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
   exit;
  end;
  try

   // Retrieve existing creation time
   Success:=GetFileTime(Handle,@ftCreation,@ftLastAccess,@ftLastWrite);
   if not Success then begin
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
    exit;
   end;

   // Update access time if needed
   if (aMask and P9_SETATTR_ATIME)<>0 then begin
    ftLastAccess:=UnixTimeToFileTime(aATimeSec);
   end;

   // Update modification time if needed
   if (aMask and P9_SETATTR_MTIME)<>0 then begin
    ftLastWrite:=UnixTimeToFileTime(aMTimeSec);
   end;

   // Update creation time if needed
   if (aMask and P9_SETATTR_CTIME)<>0 then begin
    ftCreation:=UnixTimeToFileTime(aCTimeSec);
   end;

   // Set the new times
   Success:=SetFileTime(Handle,@ftCreation,@ftLastAccess,@ftLastWrite);
   if not Success then begin
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
    exit;
   end;

  finally
   CloseHandle(Handle);
  end;
 end;

 // Note: UID and GID are not directly applicable in Windows; typically, you would handle security descriptors instead.

 result:=0;

end;

{$if not declared(CreateHardLinkA)}
function CreateHardLinkA(lpFileName,lpExistingFileName:LPCSTR;lpSecurityAttributes:LPSECURITY_ATTRIBUTES):BOOL; {$ifdef cpu386}stdcall;{$endif} external 'kernel32.dll' name 'CreateHardLinkA';
{$ifend}

function TPasRISCV9PFileSystemWindows.Link(const aDestFile,aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32;
var NewPath:RawByteString;
    Success:BOOL;
begin
 NewPath:=ComposePath(aDestFile.fPath,aName);
 Success:=CreateHardLinkA(PAnsiChar(NewPath),PAnsiChar(aFile.fPath),nil);
 if Success then begin
  result:=0;
 end else begin
  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
 end;
end;

{$if not declared(CreateSymbolicLinkA)}
function CreateSymbolicLinkA(lpSymlinkFileName,lpTargetFileName:LPCSTR;dwFlags:DWORD):BOOL; {$ifdef cpu386}stdcall;{$endif} external 'kernel32.dll' name 'CreateSymbolicLinkA';
{$ifend}

function TPasRISCV9PFileSystemWindows.Symlink(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName,aTarget:TPasRISCVRawByteString;const aGID:TPasRISCVUInt32):TPasRISCVInt32;
const SYMBOLIC_LINK_FLAG_DIRECTORY=$1;
var NewPath:TPasRISCVRawByteString;
    Success:BOOL;
    Handle:THandle;
    FileInfo:BY_HANDLE_FILE_INFORMATION;
    IsDirectory:BOOL;
    TargetHandle:THandle;
    TargetFileInfo:BY_HANDLE_FILE_INFORMATION;
begin

 NewPath:=ComposePath(aFile.fPath,aName);

 // Determine if the target is a directory to set appropriate flags
 IsDirectory:=false;
 TargetHandle:=CreateFileA(PAnsiChar(RawByteString(aTarget)),
                           0,
                           FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE,
                           nil,
                           OPEN_EXISTING,
                           FILE_FLAG_BACKUP_SEMANTICS,
                           0);

 if TargetHandle<>INVALID_HANDLE_VALUE then begin
  if GetFileInformationByHandle(TargetHandle,TargetFileInfo) then begin
   IsDirectory:=(TargetFileInfo.dwFileAttributes and FILE_ATTRIBUTE_DIRECTORY)<>0;
  end;
  CloseHandle(TargetHandle);
 end;

 Success:=CreateSymbolicLinkA(PAnsiChar(RawByteString(NewPath)),
                              PAnsiChar(RawByteString(aTarget)),
                              IfThen(IsDirectory,SYMBOLIC_LINK_FLAG_DIRECTORY,0));

 if not Success then begin
  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
  exit;
 end;

 // Retrieve file information to populate QID
 Handle:=CreateFileA(PAnsiChar(RawByteString(NewPath)),
                     GENERIC_READ,
                     FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE,
                     nil,
                     OPEN_EXISTING,
                     FILE_FLAG_BACKUP_SEMANTICS,
                     0);

 if Handle=INVALID_HANDLE_VALUE then begin
  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
  exit;
 end;

 try
  if GetFileInformationByHandle(Handle,FileInfo) then begin
   StatToQID(aQID,FileInfo);
   result:=0;
  end else begin
   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
  end;
 finally
  CloseHandle(Handle);
 end;

end;

function TPasRISCV9PFileSystemWindows.MkNod(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aMajor,aMinor,aGID:TPasRISCVUInt32):TPasRISCVInt32;
begin
 // Windows does not support device nodes like POSIX. Return not supported. Simple as that.
 result:=-P9_ENOTSUP;
end;

function TPasRISCV9PFileSystemWindows.ReadLink(const aBuffer:Pointer;const aSize:TPasRISCVInt64;const aFile:TPasRISCV9PFileSystem.TFSFile):TPasRISCVInt64;
var TargetName:{$ifdef fpc}UnicodeString{$else}String{$endif};
    UTF8Target:TPasRISCVUTF8String;
begin
 if FileGetSymLinkTarget(aFile.fPath,TargetName) then begin
  UTF8Target:=TargetName;
  if length(UTF8Target)<aSize then begin
   if length(UTF8Target)>0 then begin
    Move(UTF8Target[1],aBuffer^,length(UTF8Target));
   end;
   PPasRISCVInt8Array(aBuffer)[length(UTF8Target)]:=0;
   result:=length(UTF8Target);
  end else begin
   result:=-P9_EINVAL;
  end;
 end else begin
  if FileExists(aFile.fPath) then begin
   result:=-P9_EIO;
  end else begin
   result:=-P9_EEXIST;
  end;
 end;
end;

function TPasRISCV9PFileSystemWindows.RenameAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aNewFile:TPasRISCV9PFileSystem.TFSFile;const aNewName:TPasRISCVRawByteString):TPasRISCVInt32;
var OldPath,NewPath:TPasRISCVRawByteString;
    Success:BOOL;
begin
 OldPath:=ComposePath(aFile.fPath,aName);
 NewPath:=ComposePath(aNewFile.fPath,aNewName);
 Success:=MoveFileExA(PAnsiChar(RawByteString(OldPath)),PAnsiChar(RawByteString(NewPath)),MOVEFILE_REPLACE_EXISTING);
 if Success then begin
  result:=0;
 end else begin
  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
 end;
end;

function TPasRISCV9PFileSystemWindows.UnlinkAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32;
var Path:TPasRISCVRawByteString;
    Success:BOOL;
begin
 Path:=ComposePath(aFile.fPath,aName);
 if (GetFileAttributesA(PAnsiChar(RawByteString(Path))) and FILE_ATTRIBUTE_DIRECTORY)<>0 then begin
  Success:=RemoveDirectoryA(PAnsiChar(RawByteString(Path)));
 end else begin
  Success:=DeleteFileA(PAnsiChar(RawByteString(Path)));
 end;
 if Success then begin
  result:=0;
 end else begin
  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
 end;
end;

function TPasRISCV9PFileSystemWindows.Lock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32;
var LockType,LockMode:DWORD;
    Success:BOOL;
    Overlapped:TOverlapped;
    FilerPointer:LARGE_INTEGER;
begin

 result:=-P9_ENOTSUP;
 exit;

 // Validate that the file is opened and not a directory
 if not aFile.fIsOpened or aFile.fIsDirectory then begin
  result:=-P9_EPROTO;
  exit;
 end;

 // Initialize the OVERLAPPED structure for asynchronous I/O
 ZeroMemory(@Overlapped,SizeOf(TOverlapped));
 Overlapped.Offset:=DWORD(aLock.Start and $ffffffff);
 Overlapped.OffsetHigh:=DWORD((aLock.Start shr 32) and $ffffffff);

 if aLock.Type_=P9_LOCK_TYPE_UNLCK then begin

  // Perform unlock
  Success:=UnlockFileEx(aFile.fFileHandle,
                        0,
                        DWORD(aLock.Length and $ffffffff),
                        DWORD(aLock.Length shr 32),
                        Overlapped);
  if Success then begin
   result:=0;
  end else begin
   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
  end;

 end else begin

  // Determine lock type
  case aLock.Type_ of
   P9_LOCK_TYPE_RDLCK:begin
    LockType:=LOCKFILE_EXCLUSIVE_LOCK;
    LockMode:=LOCKFILE_FAIL_IMMEDIATELY;
   end;
   P9_LOCK_TYPE_WRLCK:begin
    LockType:=LOCKFILE_EXCLUSIVE_LOCK;
    LockMode:=0;
   end;
   else begin
    result:=-P9_EINVAL;
    exit;
   end;
  end;

  // Perform lock
  Success:=LockFileEx(aFile.fFileHandle,
                      LockType,
                      0,
                      DWORD(aLock.Length and $ffffffff),
                      DWORD(aLock.Length shr 32),
                      Overlapped);
  if Success then begin
   result:=0;
  end else begin
   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
  end;

 end;

end;

function TPasRISCV9PFileSystemWindows.GetLock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32;
var LockType,LockMode:DWORD;
    Success:BOOL;
    Overlapped:TOverlapped;
    FilerPointer:LARGE_INTEGER;
begin

 result:=-P9_ENOTSUP;
 exit;

end;

{$ifend}

{ TPasRISCVEthernetDevice }

constructor TPasRISCVEthernetDevice.Create;
begin

 inherited Create;

 fMACAddress[0]:=$02;
 fMACAddress[1]:=$00;
 fMACAddress[2]:=$00;
 fMACAddress[3]:=$00;
 fMACAddress[4]:=$00;
 fMACAddress[5]:=$01;

 fOnCanWritePacket:=nil;

 fOnWritePacket:=nil;

 fOnSetCarrier:=nil;

end;

destructor TPasRISCVEthernetDevice.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCVEthernetDevice.GenerateMACAddress;
var RandomGenerator:TRNLRandomGenerator;
begin
 RandomGenerator:=TRNLRandomGenerator.Create;
 try
  RandomGenerator.GetRandomBytes(fMACAddress,SizeOf(TMACAddress));
  fMACAddress[0]:=(fMACAddress[0] and $fe) or $02;
 finally
  FreeAndNil(RandomGenerator);
 end;
end;

procedure TPasRISCVEthernetDevice.Shutdown;
begin
end;

procedure TPasRISCVEthernetDevice.WritePacket(const aBuffer:Pointer;const aBufferSize:TPasRISCVSizeInt);
begin
end;

{$if defined(fpc) and defined(unix)}

{ TPasRISCVEthernetDeviceTUN }

constructor TPasRISCVEthernetDeviceTUN.TNetworkThread.Create(const aEthernetDevice:TPasRISCVEthernetDeviceTUN);
begin
 fEthernetDevice:=aEthernetDevice;
 fEvent:=TPasMPEvent.Create(nil,true,false,'');
 inherited Create(false);
end;

destructor TPasRISCVEthernetDeviceTUN.TNetworkThread.Destroy;
begin
 Shutdown;
 FreeAndNil(fEvent);
 inherited Destroy;
end;

procedure TPasRISCVEthernetDeviceTUN.TNetworkThread.Shutdown;
begin
 if not Finished then begin
  Terminate;
  fEvent.SetEvent;
  WaitFor;
 end;
end;

procedure TPasRISCVEthernetDeviceTUN.TNetworkThread.Execute;
begin
 NameThreadForDebugging('TPasRISCVEthernetDeviceTUN.TNetworkThread');
 fEthernetDevice.ThreadProc;
end;

constructor TPasRISCVEthernetDeviceTUN.Create;
begin
 inherited Create;
 fTunFD:=-1;
 fSelectedFilled:=false;
 fThread:=nil;
 fpFD_ZERO(fRFDS);
 fpFD_ZERO(fWFDS);
 fpFD_ZERO(fEFDS);
end;

destructor TPasRISCVEthernetDeviceTUN.Destroy;
begin
 Shutdown;
 FreeAndNil(fThread);
 inherited Destroy;
end;

procedure TPasRISCVEthernetDeviceTUN.Shutdown;
begin
 if assigned(fThread) then begin
  try
   fThread.Shutdown;
  finally
   FreeAndNil(fThread);
  end;
 end;
 if fTunFD>=0 then begin
  fpClose(fTunFD);
  fTunFD:=-1;
 end;
end;

function TPasRISCVEthernetDeviceTUN.Open(const aInterfaceName:TPasRISCVRawByteString):Boolean;
var ifr:Tifreq;
    r:TPasRISCVInt32;
    Len:TPasRISCVSizeInt;
begin

 Shutdown;

 fTunFD:=fpOpen('/dev/net/tun',O_RDWR);
 if fTunFD<0 then begin
  result:=false;
  exit;
 end;

 FillChar(ifr,SizeOf(Tifreq),#0);

 ifr.ifr_ifru.ifru_flags:=IFF_TAP or IFF_NO_PI;

 Len:=Length(aInterfaceName);
 if Len>SizeOf(ifr.ifr_ifrn.ifr_name)-1 then begin
  Len:=SizeOf(ifr.ifr_ifrn.ifr_name)-1;
 end;
 FillChar(ifr.ifr_ifrn.ifr_name[0],SizeOf(ifr.ifr_ifrn.ifr_name),#0);
 if Len>0 then begin
  Move(aInterfaceName[1],ifr.ifr_ifrn.ifr_name[0],Len);
 end;

 r:=fpIOCtl(fTunFD,TUNSETIFF,@ifr);
 if r<>0 then begin
  fpClose(fTunFD);
  fTunFD:=-1;
  result:=false;
  exit;
 end;

 fpfcntl(fTunFD,F_SETFL,O_NONBLOCK);

 fThread:=TNetworkThread.Create(self);

 result:=true;

end;

procedure TPasRISCVEthernetDeviceTUN.WritePacket(const aBuffer:Pointer;const aBufferSize:TPasRISCVSizeInt);
begin
 if fTunFD>=0 then begin
  fpWrite(fTunFD,aBuffer,aBufferSize);
 end;
end;

procedure TPasRISCVEthernetDeviceTUN.ThreadProc;
const Delay:TTimeVal=(tv_sec:0;tv_usec:10000); // 10ms as balance between waiting and termination when shutting down
var Len:TPasRISCVInt32;
begin
 while not fThread.Terminated do begin
  if assigned(fOnCanWritePacket) and fOnCanWritePacket then begin
   fpFD_ZERO(fRFDS);
   fpFD_ZERO(fWFDS);
   fpFD_ZERO(fEFDS);
   fpFD_SET(fTunFD,fRFDS);
   if fpSelect(fTunFD+1,@fRFDS,@fWFDS,@fEFDS,@Delay)>0 then begin
    if fThread.Terminated then begin
     break;
    end else if fpFD_ISSET(fTunFD,fRFDS)<>0 then begin
     Len:=fpRead(fTunFD,@fBuffer,Length(fBuffer));
     if (Len>0) and assigned(fOnWritePacket) then begin
      fOnWritePacket(@fBuffer,Len);
     end;
    end;
   end;
  end;
 end;
end;
{$ifend}


{ TPasRISCV.TPCG32 }

procedure TPasRISCV.TPCG32.Init(const aSeed:TPasRISCVUInt64);
begin
 if aSeed=0 then begin
  fState:=DefaultState;
  fIncrement:=DefaultStream;
 end else begin
  fState:=DefaultState xor (aSeed*362436069);
  if fState=0 then begin
   fState:=DefaultState;
  end;
  fIncrement:=DefaultStream xor (aSeed*1566083941);
  inc(fIncrement,1-(fIncrement and 1));
 end;
end;

function TPasRISCV.TPCG32.Get32:TPasRISCVUInt32;
var OldState:TPasRISCVUInt64;
{$ifndef fpc}
    XorShifted,Rotation:TPasRISCVUInt32;
{$endif}
begin
 OldState:=fState;
 fState:=(OldState*TPCG32.Mult)+fIncrement;
{$ifdef fpc}
 result:=RORDWord(((OldState shr 18) xor OldState) shr 27,OldState shr 59);
{$else}
 XorShifted:=((OldState shr 18) xor OldState) shr 27;
 Rotation:=OldState shr 59;
 result:=(XorShifted shr Rotation) or (XorShifted shl ((-Rotation) and 31));
{$endif}
end;

function TPasRISCV.TPCG32.GetUnbiasedBounded(const aRange:TPasRISCVUInt32):TPasRISCVUInt32;
var x,l,t:TPasRISCVUInt32;
    m:TPasRISCVUInt64;
begin
 if aRange<=1 then begin
  // For ranges of 0 or 1, just output always zero, but do a dummy Get32 call with discarding its result
  Get32;
  result:=0;
 end else {$if (defined(fpc) and declared(BSRDWord)) or declared(CLZDWord)}if (aRange and (aRange-1))<>0 then{$ifend}begin
  // For non-power-of-two ranges: Debiased Integer Multiplication — Lemire's Method
  x:=Get32;
  m:=TPasRISCVUInt64(x);
  m:=m*TPasRISCVUInt64(aRange);
  l:=TPasRISCVUInt32(m and $ffffffff);
  if l<aRange then begin
   t:=-aRange;
   if t>=aRange then begin
    dec(t,aRange);
    if t>=aRange then begin
     t:=t mod aRange;
    end;
   end;
   while l<t do begin
    x:=Get32;
    m:=TPasRISCVUInt64(x);
    m:=m*TPasRISCVUInt64(aRange);
    l:=TPasRISCVUInt32(m and $ffffffff);
   end;
  end;
  result:=m shr 32;
{$if (defined(fpc) and declared(BSRDWord)) or declared(CLZDWord)}
 end else begin
  // For power-of-two ranges: Bitmask with Rejection (Unbiased) — Apple's Method
  m:=TPasRISCVUInt32($ffffffff);
  t:=aRange-1;
{$if defined(fpc) and declared(BSRDWord)}
  m:=m shr (31-BSRDWord(t or 1));
{$else}
  m:=m shr CLZDWord(t or 1);
{$ifend}
  repeat
   result:=Get32 and m;
  until result<=t;
{$ifend}
 end;
end;

{ TPasRISCV.TFDT.TFDTProperty }

constructor TPasRISCV.TFDT.TFDTProperty.Create;
begin
 inherited Create;
 fName:='';
 fData:=nil;
 fLen:=0;
end;

destructor TPasRISCV.TFDT.TFDTProperty.Destroy;
begin
 fName:='';
 fData:=nil;
 inherited Destroy;
end;

{ TPasRISCV.TFDT.TFDTNode }

constructor TPasRISCV.TFDT.TFDTNode.Create(const aFDT:TFDT;const aName:TPasRISCVRawByteString);
begin
 inherited Create;
 fFDT:=aFDT;
 fName:=aName;
 fParent:=nil;
 fProperties:=nil;
 fCountProperties:=0;
 fNodes:=nil;
 fCountNodes:=0;
 fPHandle:=0;
end;

constructor TPasRISCV.TFDT.TFDTNode.Create(const aFDT:TFDT;const aName:TPasRISCVRawByteString;const aAddress:TPasRISCVUInt64);
begin
 inherited Create;
 fFDT:=aFDT;
 fName:=aName+'@'+FDTHex64(aAddress);
 fParent:=nil;
 fProperties:=nil;
 fCountProperties:=0;
 fNodes:=nil;
 fCountNodes:=0;
 fPHandle:=0;
end;

destructor TPasRISCV.TFDT.TFDTNode.Destroy;
var Index:TPasRISCVSizeInt;
begin

 fName:='';

 for Index:=0 to fCountProperties-1 do begin
  FreeAndNil(fProperties[Index]);
 end;
 fProperties:=nil;

 for Index:=0 to fCountNodes-1 do begin
  FreeAndNil(fNodes[Index]);
 end;
 fNodes:=nil;

 inherited Destroy;

end;

procedure TPasRISCV.TFDT.TFDTNode.AddChild(const aNode:TFDTNode);
var Index:TPasRISCVSizeInt;
begin
 Index:=fCountNodes;
 inc(fCountNodes);
 if length(fNodes)<fCountNodes then begin
  SetLength(fNodes,fCountNodes+((fCountNodes+1) shr 1));
 end;
 fNodes[Index]:=aNode;
end;

function TPasRISCV.TFDT.TFDTNode.FindNode(const aName:TPasRISCVRawByteString):TFDTNode;
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to fCountNodes-1 do begin
  if fNodes[Index].fName=aName then begin
   result:=fNodes[Index];
   exit;
  end;
 end;
 result:=nil;
end;

function TPasRISCV.TFDT.TFDTNode.FindNode(const aName:TPasRISCVRawByteString;const aAddress:TPasRISCVUInt64):TFDTNode;
var Index:TPasRISCVSizeInt;
    CompareName:TPasRISCVRawByteString;
begin
 CompareName:=aName+'@'+FDTHex64(aAddress);
 for Index:=0 to fCountNodes-1 do begin
  if fNodes[Index].fName=CompareName then begin
   result:=fNodes[Index];
   exit;
  end;
 end;
 result:=nil;
end;

function TPasRISCV.TFDT.TFDTNode.FindNodeAny(const aName:TPasRISCVRawByteString):TFDTNode;
var Index:TPasRISCVSizeInt;
    CompareName:TPasRISCVRawByteString;
begin
 CompareName:=aName+'@';
 for Index:=0 to fCountNodes-1 do begin
  if pos(CompareName,fNodes[Index].fName)=1 then begin
   result:=fNodes[Index];
   exit;
  end;
 end;
 result:=nil;
end;

function TPasRISCV.TFDT.TFDTNode.GetNewPHandle:TPasRISCVUInt32;
begin
 inc(fFDT.fPHandleCounter);
 result:=fFDT.fPHandleCounter;
end;

function TPasRISCV.TFDT.TFDTNode.GetPHandle:TPasRISCVUInt32;
begin
 if length(fName)>0 then begin
  if TPasRISCV.TFDT.IsIllegalPHandle(fPHandle) then begin
   fPHandle:=GetNewPHandle;
   AddPropertyU32('phandle',fPHandle);
  end;
  result:=fPHandle;
 end else begin
  result:=0;
 end;
end;

function TPasRISCV.TFDT.TFDTNode.AddProperty(const aName:TPasRISCVRawByteString;const aData;const aSize:TPasRISCVUInt32):TPasRISCV.TFDT.TFDTProperty;
var Index:TPasRISCVSizeInt;
begin
 Index:=fCountProperties;
 inc(fCountProperties);
 if length(fProperties)<fCountProperties then begin
  SetLength(fProperties,fCountProperties+((fCountProperties+1) shr 1));
 end;
 fProperties[Index]:=TPasRISCV.TFDT.TFDTProperty.Create;
 result:=fProperties[Index];
 result.fName:=aName;
 result.fData:=nil;
 if aSize>0 then begin
  SetLength(result.fData,aSize);
  Move(aData,result.fData[0],aSize);
  result.fLen:=aSize;
 end else begin
  result.fLen:=0;
 end;
end;

function TPasRISCV.TFDT.TFDTNode.AddPropertyU32(const aName:TPasRISCVRawByteString;const aValue:TPasRISCVUInt32):TFDTProperty;
var Data:TPasRISCVUInt32;
begin
{$ifdef LITTLE_ENDIAN}
 Data:=(aValue shr 24) or ((aValue shr 8) and $ff00) or ((aValue shl 8) and $ff0000) or (aValue shl 24);
{$else}
 Data:=aValue;
{$endif}
 result:=AddProperty(aName,Data,SizeOf(TPasRISCVUInt32));
end;

function TPasRISCV.TFDT.TFDTNode.AddPropertyU64(const aName:TPasRISCVRawByteString;const aValue:TPasRISCVUInt64):TFDTProperty;
var Data:TPasRISCVUInt64;
begin
{$ifdef LITTLE_ENDIAN}
 Data:=(aValue shr 56) or ((aValue shr 40) and $ff00) or ((aValue shr 24) and $ff0000) or ((aValue shr 8) and $ff000000) or ((aValue shl 8) and $ff00000000) or ((aValue shl 24) and $ff0000000000) or ((aValue shl 40) and $ff000000000000) or (aValue shl 56);
{$else}
 Data:=aValue;
{$endif}
 result:=AddProperty(aName,Data,SizeOf(TPasRISCVUInt64));
end;

function TPasRISCV.TFDT.TFDTNode.AddPropertyCells(const aName:TPasRISCVRawByteString;const aCells:PPasRISCVUInt32;const aCountCells:TPasRISCVSizeInt):TFDTProperty;
var Index:TPasRISCVSizeInt;
    Data:TPasRISCVUInt32DynamicArray;
    Value:TPasRISCVUInt32;
    Cell:PPasRISCVUInt32;
begin
 Data:=nil;
 try
  SetLength(Data,aCountCells);
  Cell:=aCells;
  for Index:=0 to aCountCells-1 do begin
   Value:=Cell^;
   inc(Cell);
{$ifdef LITTLE_ENDIAN}
   Data[Index]:=(Value shr 24) or ((Value shr 8) and $ff00) or ((Value shl 8) and $ff0000) or (Value shl 24);
{$else}
   Data[Index]:=Value;
{$endif}
  end;
  result:=AddProperty(aName,Data[0],aCountCells*SizeOf(TPasRISCVUInt32));
 finally
  Data:=nil;
 end;
end;

function TPasRISCV.TFDT.TFDTNode.AddPropertyString(const aName,aValue:TPasRISCVRawByteString):TFDTProperty;
var Value:TPasRISCVRawByteString;
begin
 Value:=aValue+#0; // Null terminated
 result:=AddProperty(aName,Value[1],length(Value));
end;

function TPasRISCV.TFDT.TFDTNode.AddPropertyReg(const aName:TPasRISCVRawByteString;const aBegin,aSize:TPasRISCVUInt64):TFDTProperty;
var Data:array[0..1] of TPasRISCVUInt64;
begin
{$ifdef LITTLE_ENDIAN}
 Data[0]:=(aBegin shr 56) or ((aBegin shr 40) and $ff00) or ((aBegin shr 24) and $ff0000) or ((aBegin shr 8) and $ff000000) or ((aBegin shl 8) and $ff00000000) or ((aBegin shl 24) and $ff0000000000) or ((aBegin shl 40) and $ff000000000000) or (aBegin shl 56);
 Data[1]:=(aSize shr 56) or ((aSize shr 40) and $ff00) or ((aSize shr 24) and $ff0000) or ((aSize shr 8) and $ff000000) or ((aSize shl 8) and $ff00000000) or ((aSize shl 24) and $ff0000000000) or ((aSize shl 40) and $ff000000000000) or (aSize shl 56);
{$else}
 Data[0]:=aBegin;
 Data[1]:=aSize;
{$endif}
 result:=AddProperty(aName,Data[0],SizeOf(Data));
end;

function TPasRISCV.TFDT.TFDTNode.DeleteProperty(const aName:TPasRISCVRawByteString):Boolean;
var Index:TPasRISCVSizeInt;
    Property_:TPasRISCV.TFDT.TFDTProperty;
begin
 for Index:=0 to fCountProperties-1 do begin
  if fProperties[Index].fName=aName then begin
   Property_:=fProperties[Index];
   try
    fProperties[Index]:=nil;
    if Index<fCountProperties-1 then begin
     Move(fProperties[Index+1],fProperties[Index],(fCountProperties-Index-1)*SizeOf(TFDTProperty));
    end;
    dec(fCountProperties);
   finally
    FreeAndNil(Property_);
   end;
   result:=true;
   exit;
  end;
 end;
 result:=false;
end;

function TPasRISCV.TFDT.TFDTNode.FindProperty(const aName:TPasRISCVRawByteString):TFDTProperty;
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to fCountProperties-1 do begin
  if fProperties[Index].fName=aName then begin
   result:=fProperties[Index];
   exit;
  end;
 end;
 result:=nil;
end;

procedure TPasRISCV.TFDT.TFDTNode.GetTreeSize(var aSize:TFDTSizeDescriptor);
var NameLen:TPasRISCVSizeInt;
    Index:TPasRISCVSizeInt;
    Property_:TPasRISCV.TFDT.TFDTProperty;
    Node:TPasRISCV.TFDT.TFDTNode;
begin

 NameLen:=RoundUpTo32(length(fName)+1,SizeOf(TPasRISCVUInt32));
 inc(aSize.StructSize,SizeOf(TPasRISCVUInt32)+NameLen);

 for Index:=0 to fCountProperties-1 do begin
  Property_:=fProperties[Index];
  inc(aSize.StructSize,SizeOf(TPasRISCVUInt32)*3);
  inc(aSize.StructSize,RoundUpTo32(Property_.fLen,SizeOf(TPasRISCVUInt32)));
  inc(aSize.StringsSize,RoundUpTo32(length(Property_.fName)+1,SizeOf(TPasRISCVUInt32)));
 end;

 for Index:=0 to fCountNodes-1 do begin
  Node:=fNodes[Index];
  Node.GetTreeSize(aSize);
 end;

 inc(aSize.StructSize,SizeOf(TPasRISCVUInt32));

end;

procedure TPasRISCV.TFDT.TFDTNode.SerializeToStream(const aFDT:TFDT);
 procedure WriteBigEndian32(const aValue:TPasRISCVUInt32);
 var Value:TPasRISCVUInt32;
 begin
 {$ifdef LITTLE_ENDIAN}
  Value:=(aValue shr 24) or ((aValue shr 8) and $ff00) or ((aValue shl 8) and $ff0000) or (aValue shl 24);
 {$else}
  Value:=aValue;
 {$endif}
  aFDT.fMemoryStream.Seek(aFDT.fStructOffset,soBeginning);
  aFDT.fMemoryStream.WriteBuffer(Value,SizeOf(TPasRISCVUInt32));
  inc(aFDT.fStructOffset,SizeOf(TPasRISCVUInt32));
 end;
 procedure WriteString(const aValue:TPasRISCVRawByteString);
 var Value:TPasRISCVRawByteString;
 begin
  Value:=aValue+#0;
  aFDT.fMemoryStream.Seek(aFDT.fStructOffset,soBeginning);
  aFDT.fMemoryStream.WriteBuffer(Value[1],length(Value));
  aFDT.fStructOffset:=RoundUpTo32(aFDT.fStructOffset+length(Value),SizeOf(TPasRISCVUInt32));
 end;
 procedure WriteData(const aValue;const aSize:TPasRISCVUInt32);
 begin
  aFDT.fMemoryStream.Seek(aFDT.fStructOffset,soBeginning);
  aFDT.fMemoryStream.WriteBuffer(aValue,aSize);
  aFDT.fStructOffset:=RoundUpTo32(aFDT.fStructOffset+aSize,SizeOf(TPasRISCVUInt32));
 end;
 procedure WriteName(const aValue:TPasRISCVRawByteString);
 var Value:TPasRISCVRawByteString;
 begin
  Value:=aValue+#0;
  aFDT.fMemoryStream.Seek(aFDT.fStringsOffset,soBeginning);
  aFDT.fMemoryStream.WriteBuffer(Value[1],length(Value));
  aFDT.fStringsOffset:=RoundUpTo32(aFDT.fStringsOffset+length(Value),SizeOf(TPasRISCVUInt32));
 end;
var NameLen:TPasRISCVSizeInt;
    Index:TPasRISCVSizeInt;
    Property_:TPasRISCV.TFDT.TFDTProperty;
    Node:TPasRISCV.TFDT.TFDTNode;
begin

 WriteBigEndian32(FDT_BEGIN_NODE);
 WriteString(fName);

 for Index:=0 to fCountProperties-1 do begin
  Property_:=fProperties[Index];
  WriteBigEndian32(FDT_PROP);
  WriteBigEndian32(Property_.fLen);
  WriteBigEndian32(aFDT.fStringsOffset-aFDT.fStringsBegin);
  WriteData(Property_.fData[0],Property_.fLen);
  WriteName(Property_.fName);
 end;

 for Index:=0 to fCountNodes-1 do begin
  Node:=fNodes[Index];
  Node.SerializeToStream(aFDT);
 end;

 WriteBigEndian32(FDT_END_NODE);

end;

procedure TPasRISCV.TFDT.WriteBigEndian32(const aValue:TPasRISCVUInt32);
var Value:TPasRISCVUInt32;
begin
{$ifdef LITTLE_ENDIAN}
 Value:=(aValue shr 24) or ((aValue shr 8) and $ff00) or ((aValue shl 8) and $ff0000) or (aValue shl 24);
{$else}
 Value:=aValue;
{$endif}
 fMemoryStream.WriteBuffer(Value,SizeOf(TPasRISCVUInt32));
end;

procedure TPasRISCV.TFDT.SerializeToStream(const aStream:TStream);
var SizeDescriptor:TFDTSizeDescriptor;
begin

 SizeDescriptor:=GetTreeSize;
 inc(SizeDescriptor.StructSize,SizeOf(TPasRISCVUInt32)); // FDT_END

 fMemoryStream:=TMemoryStream.Create;
 try

  fBufferSize:=FDT_HDR_SIZE+FDT_RSV_SIZE+SizeDescriptor.StructSize;
  fReservedOffset:=FDT_HDR_SIZE;
  fStructOffset:=FDT_HDR_SIZE+FDT_RSV_SIZE;
  fStringsBegin:=fBufferSize;
  fStringsOffset:=fStringsBegin;
  inc(fBufferSize,SizeDescriptor.StringsSize);

  fMemoryStream.SetSize(fBufferSize);

  FillChar(fMemoryStream.Memory^,fBufferSize,#0);

  WriteBigEndian32(FDT_MAGIC);
  WriteBigEndian32(fBufferSize);
  WriteBigEndian32(fStructOffset);
  WriteBigEndian32(fStringsOffset);
  WriteBigEndian32(fReservedOffset);
  WriteBigEndian32(FDT_VERSION);
  WriteBigEndian32(FDT_COMP_VERSION);
  WriteBigEndian32(0); // boot_cpuid
  WriteBigEndian32(SizeDescriptor.StringsSize);
  WriteBigEndian32(SizeDescriptor.StructSize);

  fRoot.SerializeToStream(self);

  aStream.Seek(fStructOffset,soBeginning);
  WriteBigEndian32(FDT_END);
  inc(fStructOffset,SizeOf(TPasRISCVUInt32));

  aStream.Seek(0,soBeginning);
  fMemoryStream.Seek(0,soBeginning);
  aStream.CopyFrom(fMemoryStream,fMemoryStream.Size);

 finally
  FreeAndNil(fMemoryStream);
 end;

end;

{ TPasRISCV.TTimer }

procedure TPasRISCV.TTimer.Rebase(const aTime:TPasRISCVUInt64);
begin
 TPasMPInterlocked.Write(fBeginTime,GetCurrentFrequencyTime(TPasMPInterlocked.Read(fFrequency))-aTime);
end;

procedure TPasRISCV.TTimer.Initialize(const aFrequency:TPasRISCVUInt64);
begin
 fFrequency:=aFrequency;
 Rebase(0);
end;

function TPasRISCV.TTimer.Get:TPasRISCVUInt64;
begin
 result:=GetCurrentFrequencyTime(fFrequency)-TPasMPInterlocked.Read(fBeginTime);
end;

{ TPasRISCV.TTimeCmp }

procedure TPasRISCV.TTimeCmp.Initialize(const aTimer:TPasRISCV.PTimer);
begin
 fTimer:=aTimer;
 fTimeCmp:=TPasRISCVUInt64($ffffffffffffffff);
end;

function TPasRISCV.TTimeCmp.GetTimeCmp:TPasMPUInt64;
begin
 result:=TPasMPInterlocked.Read(fTimeCmp);
end;

procedure TPasRISCV.TTimeCmp.SetTimeCmp(aTimeCmp:TPasMPUInt64);
begin
 TPasMPInterlocked.Write(fTimeCmp,aTimeCmp);
end;

function TPasRISCV.TTimeCmp.Pending:Boolean;
begin
 result:=fTimer^.Get>=TPasMPInterlocked.Read(fTimeCmp);
end;

function TPasRISCV.TTimeCmp.Delay:TPasMPUInt64;
var Timer,TimeCmp:TPasMPUInt64;
begin
 Timer:=fTimer^.Get;
 TimeCmp:=TPasMPInterlocked.Read(fTimeCmp);
 if Timer<TimeCmp then begin
  result:=TimeCmp-Timer;
 end else begin
  result:=0;
 end;
end;

function TPasRISCV.TTimeCmp.DelayNS:TPasMPUInt64;
var Timer,TimeCmp:TPasMPUInt64;
begin
 Timer:=fTimer^.Get;
 TimeCmp:=TPasMPInterlocked.Read(fTimeCmp);
 if Timer<TimeCmp then begin
  result:=TimeCmp-Timer;
  if result>TPasMPUInt64($400000000) then begin
   result:=TPasMPUInt64($400000000);
  end;
  result:=(result*TPasMPUInt64(1000000000)) div fTimer.fFrequency;
 end else begin
  result:=0;
 end;
end;

{ TPasRISCV.TThreadTimer }

constructor TPasRISCV.TThreadTimer.Create(const aOnTimer:TThreadTimerEvent);
begin
 fInterval:=CLOCK_FREQUENCY;
 fEvent:=TPasMPEvent.Create(nil,false,false,'');
 fOnTimer:=aOnTimer;
 inherited Create(false);
end;

destructor TPasRISCV.TThreadTimer.Destroy;
begin
 Shutdown;
 FreeAndNil(fEvent);
 inherited Destroy;
end;

procedure TPasRISCV.TThreadTimer.Shutdown;
begin
 if not Finished then begin
  Terminate;
  fEvent.SetEvent;
  WaitFor;
 end;
end;

procedure TPasRISCV.TThreadTimer.Execute;
begin
 NameThreadForDebugging('TPasRISCV.TThreadTimer');
 while not Terminated do begin
  case fEvent.WaitFor of
   wrSignaled:begin
    if Terminated then begin
     break;
    end else begin
     if fInterval>0 then begin
      WaitTime(fInterval);
     end;
     if assigned(fOnTimer) and (fInterval>0) then begin
      fOnTimer;
     end;
    end;
   end;
   else begin
   end;
  end;
 end;
end;

procedure TPasRISCV.TThreadTimer.SetInterval(const aInterval:TPasRISCVUInt64);
begin
 fInterval:=aInterval;
 fEvent.SetEvent;
end;

{ TPasRISCV.TFDT }

constructor TPasRISCV.TFDT.Create;
begin
 inherited Create;
 fPHandleCounter:=0;
 fRoot:=TPasRISCV.TFDT.TFDTNode.Create(self,'');
end;

destructor TPasRISCV.TFDT.Destroy;
begin
 FreeAndNil(fRoot);
 inherited Destroy;
end;

class function TPasRISCV.TFDT.NameWithAddr(const aName:TPasRISCVRawByteString;const aAddress:TPasRISCVUInt64):TPasRISCVRawByteString;
begin
 result:=aName+'@'+FDTHex64(aAddress);
end;

class function TPasRISCV.TFDT.IsIllegalPHandle(const aPHandle:TPasRISCVUInt32):Boolean;
begin
 result:=aPHandle=0;
end;

function TPasRISCV.TFDT.GetTreeSize:TFDTSizeDescriptor;
begin
 result.StructSize:=0;
 result.StringsSize:=0;
 fRoot.GetTreeSize(result);
end;

{ TPasRISCV.TBusDevice }

constructor TPasRISCV.TBusDevice.Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64);
begin
 inherited Create;
 fMachine:=aMachine;
 fBase:=aBase;
 fSize:=aSize;
 fPHandle:=fMachine.AllocatePHandle;
 fUnalignedAccessSupport:=true;
 fMinOpSize:=1;
 fMaxOpSize:=8;
 fSubBusDevices:=nil;
 fCountSubBusDevices:=0;
end;

destructor TPasRISCV.TBusDevice.Destroy;
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to fCountSubBusDevices-1 do begin
  FreeAndNil(fSubBusDevices[Index]);
 end;
 fSubBusDevices:=nil;
 fCountSubBusDevices:=0;
 inherited Destroy;
end;

procedure TPasRISCV.TBusDevice.AddSubBusDevice(const aSubBusDevice:TBusDevice);
var Index:TPasRISCVSizeInt;
begin
 Index:=fCountSubBusDevices;
 inc(fCountSubBusDevices);
 if length(fSubBusDevices)<fCountSubBusDevices then begin
  SetLength(fSubBusDevices,fCountSubBusDevices+((fCountSubBusDevices+1) shr 1)); // Grow by 1.5
 end;
 fSubBusDevices[Index]:=aSubBusDevice;
end;

function TPasRISCV.TBusDevice.FindSubBusDevice(const aAddress:TPasRISCVUInt64):TPasRISCV.TBusDevice;
var Index:TPasRISCVSizeInt;
    SubBusDevice:TBusDevice;
begin
 for Index:=0 to fCountSubBusDevices-1 do begin
  SubBusDevice:=fSubBusDevices[Index];
  if (SubBusDevice.fBase<=aAddress) and ((aAddress-SubBusDevice.fBase)<SubBusDevice.fSize) then begin
   result:=SubBusDevice;
   exit;
  end;
 end;
 result:=self;
end;

procedure TPasRISCV.TBusDevice.SetBase(const aValue:TPasRISCVUInt64);
begin
 fBase:=aValue;
end;

procedure TPasRISCV.TBusDevice.SetSize(const aValue:TPasRISCVUInt64);
begin
 fSize:=aValue;
end;

procedure TPasRISCV.TBusDevice.SetEnd(const aValue:TPasRISCVUInt64);
begin
 fSize:=(aValue-fBase)+1;
end;

procedure TPasRISCV.TBusDevice.Reset;
begin
end;

function TPasRISCV.TBusDevice.GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
var Index:TPasRISCVSizeInt;
    SubBusDevice:TBusDevice;
begin
 for Index:=0 to fCountSubBusDevices-1 do begin
  SubBusDevice:=fSubBusDevices[Index];
  if (SubBusDevice.fBase<=aAddress) and ((aAddress-SubBusDevice.fBase)<SubBusDevice.fSize) then begin
   result:=SubBusDevice.GetDeviceDirectMemoryAccessPointer(aAddress,aSize,aWrite,aBounce);
   if assigned(result) then begin
    exit;
   end;
  end;
 end;
 result:=nil;
end;

function TPasRISCV.TBusDevice.GetGlobalDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
begin
 result:=fMachine.fBus.GetDirectMemoryAccessPointer(aAddress,aSize,aWrite,aBounce);
end;

function TPasRISCV.TBusDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Index:TPasRISCVSizeInt;
    SubBusDevice:TBusDevice;
begin
 for Index:=0 to fCountSubBusDevices-1 do begin
  SubBusDevice:=fSubBusDevices[Index];
  if (SubBusDevice.fBase<=aAddress) and ((aAddress-SubBusDevice.fBase)<SubBusDevice.fSize) then begin
   result:=SubBusDevice.Load(aAddress,aSize);
   exit;
  end;
 end;
 result:=0;
end;

procedure TPasRISCV.TBusDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Index:TPasRISCVSizeInt;
    SubBusDevice:TBusDevice;
begin
 for Index:=0 to fCountSubBusDevices-1 do begin
  SubBusDevice:=fSubBusDevices[Index];
  if (SubBusDevice.fBase<=aAddress) and ((aAddress-SubBusDevice.fBase)<SubBusDevice.fSize) then begin
   SubBusDevice.Store(aAddress,aValue,aSize);
   exit;
  end;
 end;
end;

procedure TPasRISCV.TBusDevice.Step;
begin
end;

{ TPasRISCV.TInterrupts }

constructor TPasRISCV.TInterrupts.Create(const aMachine:TPasRISCV);
begin
 inherited Create;
 fMachine:=aMachine;
 FillChar(fIRQAllocationBitmap,SizeOf(fIRQAllocationBitmap),#0);
end;

destructor TPasRISCV.TInterrupts.Destroy;
begin
 inherited Destroy;
end;

function TPasRISCV.TInterrupts.AllocateIRQ:TPasRISCVUInt32;
var Index:TPasRISCVUInt32;
    Mask,IRQMask:TPasRISCVUInt32;
begin
 for Index:=0 to length(fIRQAllocationBitmap)-1 do begin
  Mask:=TPasMPInterlocked.Read(fIRQAllocationBitmap[Index]);
  while Mask<>TPasRISCVUInt32($ffffffff) do begin
   result:=(Index shl 5) or TPasMPMath.BitScanForward32(not Mask);
   IRQMask:=TPasRISCVUInt32(TPasRISCVUInt32(1) shl result);
   if (TPasMPInterlocked.ExchangeBitwiseOr(fIRQAllocationBitmap[Index],IRQMask) and IRQMask)=0 then begin
    exit;
   end else begin
    Mask:=TPasMPInterlocked.Read(fIRQAllocationBitmap[Index]);
   end;
  end;
 end;
 result:=NoIRQ;
end;

function TPasRISCV.TInterrupts.AcquireIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
var Index:TPasRISCVUInt32;
    Mask:TPasRISCVUInt32;
begin
 Index:=aIRQ shr 5;
 Mask:=TPasRISCVUInt32(TPasRISCVUInt32(1) shl (aIRQ and $1f));
 if Index<length(fIRQAllocationBitmap) then begin
  result:=(TPasMPInterlocked.ExchangeBitwiseOr(fIRQAllocationBitmap[Index],Mask) and Mask)=0;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TInterrupts.ReleaseIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
var Index:TPasRISCVUInt32;
    Mask:TPasRISCVUInt32;
begin
 Index:=aIRQ shr 5;
 Mask:=TPasRISCVUInt32(TPasRISCVUInt32(1) shl (aIRQ and $1f));
 if Index<length(fIRQAllocationBitmap) then begin
  result:=(TPasMPInterlocked.ExchangeBitwiseAnd(fIRQAllocationBitmap[Index],not Mask) and Mask)<>0;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TInterrupts.SendIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
begin
 result:=fMachine.fINTCDevice.SendIRQ(aIRQ);
end;

function TPasRISCV.TInterrupts.RaiseIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
begin
 result:=fMachine.fINTCDevice.RaiseIRQ(aIRQ);
end;

function TPasRISCV.TInterrupts.LowerIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
begin
 result:=fMachine.fINTCDevice.LowerIRQ(aIRQ);
end;

{ TPasRISCV.TACLINTDevice.TCLINTMTimerSubDevice }

// For own MMIO sub-region with other minimum and maximum operation sizes, so it calls just the parent class methods for Load and Store.
// So no big magic here, just a simple wrapper class for the CLINT MTIME registers with different minimum and maximum operation sizes for
// aligned accesses.

constructor TPasRISCV.TACLINTDevice.TCLINTMTimerSubDevice.Create(const aACLINTDevice:TACLINTDevice);
begin
 inherited Create(aACLINTDevice.fMachine,aACLINTDevice.fBase+MTimeCmpAddress,MTimeCmpAddressSize);
 fACLINTDevice:=aACLINTDevice;
 fUnalignedAccessSupport:=false;
 fMinOpSize:=8; // <= these are the only differences to the parent class
 fMaxOpSize:=8;
end;

destructor TPasRISCV.TACLINTDevice.TCLINTMTimerSubDevice.Destroy;
begin
 inherited Destroy;
end;

function TPasRISCV.TACLINTDevice.TCLINTMTimerSubDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 result:=fACLINTDevice.Load(aAddress,aSize);
end;

procedure TPasRISCV.TACLINTDevice.TCLINTMTimerSubDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
begin
 fACLINTDevice.Store(aAddress,aValue,aSize);
end;

{ TPasRISCV.TACLINTDevice }

constructor TPasRISCV.TACLINTDevice.Create(const aMachine:TPasRISCV);
begin

 inherited Create(aMachine,aMachine.fConfiguration.fCLINTBase,aMachine.fConfiguration.fCLINTSize);

 fStartTime:=GetCurrentTime;

 fUnalignedAccessSupport:=false;
 fMinOpSize:=4;
 fMaxOpSize:=4;

 fCLINTMTimerSubDevice:=TCLINTMTimerSubDevice.Create(self);
 AddSubBusDevice(fCLINTMTimerSubDevice);

end;

destructor TPasRISCV.TACLINTDevice.Destroy;
begin
 inherited Destroy; // where each sub-device is also destroyed
end;

procedure TPasRISCV.TACLINTDevice.Reset;
begin
 inherited Reset;
 fStartTime:=GetCurrentTime;
end;

function TPasRISCV.TACLINTDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var CountHARTs,Address,HARTID:TPasRISCVUInt64;
begin
 CountHARTs:=length(fMachine.fHARTs);
 Address:=aAddress-fBase;
 if (Address>=MSIPAddress) and (Address<(MSIPAddress+(CountHARTs shl 2))) then begin
  HARTID:=(Address-MSIPAddress) shr 2;
  result:=(fMachine.fHARTs[HARTID].InterruptsRaised shr TPasRISCVUInt32(THART.TInterruptValue.MachineSoftware)) and 1;
 end else if (Address>=MTimeCmpAddress) and (Address<(MTimeCmpAddress+(CountHARTs shl 3))) then begin
  HARTID:=(Address-MTimeCmpAddress) shr 3;
  result:=fMachine.fHARTs[HARTID].fMTIMECMP;
 end else if (Address>=MTimeAddress) and (Address<(MTimeAddress+8)) then begin
  result:=GetTime;
 end else if (Address>=SSIPAddress) and (Address<(SSIPAddress+(CountHARTs shl 2))) then begin
  HARTID:=(Address-SSIPAddress) shr 2;
  result:=(fMachine.fHARTs[HARTID].InterruptsRaised shr TPasRISCVUInt32(THART.TInterruptValue.SupervisorSoftware)) and 1;
 end else begin
  result:=0;
 end;
end;

procedure TPasRISCV.TACLINTDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var CountHARTs,Address,HARTID,Time:TPasRISCVUInt64;
begin
 CountHARTs:=length(fMachine.fHARTs);
 Address:=aAddress-fBase;
 if (Address>=MSIPAddress) and (Address<(MSIPAddress+(CountHARTs shl 2))) then begin
  HARTID:=(Address-MSIPAddress) shr 2;
  if (aValue and 1)<>0 then begin
   fMachine.fHARTs[HARTID].RaiseInterrupt(THART.TInterruptValue.MachineSoftware);
  end else begin
   fMachine.fHARTs[HARTID].ClearInterrupt(THART.TInterruptValue.MachineSoftware);
  end;
 end else if (Address>=MTimeCmpAddress) and (Address<(MTimeCmpAddress+(CountHARTs shl 3))) then begin
  HARTID:=(Address-MTimeCmpAddress) shr 3;
  fMachine.fHARTs[HARTID].fMTIMECMP:=aValue;
  if GetTime>=aValue then begin
   fMachine.fHARTs[HARTID].RaiseInterrupt(THART.TInterruptValue.MachineTimer);
  end else begin
   fMachine.fHARTs[HARTID].ClearInterrupt(THART.TInterruptValue.MachineTimer);
  end;
 end else if (Address>=MTimeAddress) and (Address<(MTimeAddress+8)) then begin
  fStartTime:=GetTime-aValue;
  Time:=GetTime;
  for HARTID:=1 to CountHARTs do begin
   if Time>=fMachine.fHARTs[HARTID-1].fMTIMECMP then begin
    fMachine.fHARTs[HARTID-1].RaiseInterrupt(THART.TInterruptValue.MachineTimer);
   end else begin
    fMachine.fHARTs[HARTID-1].ClearInterrupt(THART.TInterruptValue.MachineTimer);
   end;
  end;
 end else if (Address>=SSIPAddress) and (Address<(SSIPAddress+(CountHARTs shl 2))) then begin
  HARTID:=(Address-SSIPAddress) shr 2;
  if (aValue and 1)<>0 then begin
   fMachine.fHARTs[HARTID].RaiseInterrupt(THART.TInterruptValue.SupervisorSoftware);
  end else begin
   fMachine.fHARTs[HARTID].ClearInterrupt(THART.TInterruptValue.SupervisorSoftware);
  end;
 end;
end;

function TPasRISCV.TACLINTDevice.GetTime:TPasRISCVUInt64;
begin
 result:=TPasRISCVUInt64(GetCurrentTime-fStartTime);
end;

function TPasRISCV.TACLINTDevice.GetCachedTime(var aTime:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 if aTime=TPasRISCVUInt64($ffffffffffffffff) then begin
  aTime:=GetTime;
 end;
 result:=aTime;
end;

{ TPasRISCV.TIMSICDevice }

constructor TPasRISCV.TIMSICDevice.Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64;const aAIARegFileMode:TPasRISCV.TAIARegFileMode);
begin
 inherited Create(aMachine,aBase,aSize);
 fAIARegFileMode:=aAIARegFileMode;
 fUnalignedAccessSupport:=false;
 fMinOpSize:=4;
 fMaxOpSize:=4;
end; 

destructor TPasRISCV.TIMSICDevice.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV.TIMSICDevice.Reset;
begin
 inherited Reset;
end;

function TPasRISCV.TIMSICDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 result:=0;
end;

procedure TPasRISCV.TIMSICDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
const IMSIC_REG_SETEIPNUM_LE=$00;
      IMSIC_REG_SETEIPNUM_BE=$04;
var Address,HARTID:TPasRISCVUInt64;
    HART:TPasRISCV.THART;
begin
 Address:=aAddress-fBase;
 if (Address>=0) and (Address<Size) then begin
  HARTID:=Address shr 12;
  if HARTID<length(fMachine.fHARTs) then begin
   HART:=fMachine.fHARTs[HARTID];
   case Address and $ffc of
    IMSIC_REG_SETEIPNUM_LE:begin
     HART.SendAIAIRQ(fAIARegFileMode,TPasRISCVUInt32(aValue));
    end; 
    IMSIC_REG_SETEIPNUM_BE:begin
     HART.SendAIAIRQ(fAIARegFileMode,ByteSwap32(TPasRISCVUInt32(aValue)));
    end; 
    else begin
    end;
   end;
  end;
 end;     
end;

{ TPasRISCV.TAPLICDevice.TDomainDevice }

constructor TPasRISCV.TAPLICDevice.TDomainDevice.Create(const aAPLICDevice:TAPLICDevice;const aBase,aSize:TPasRISCVUInt64;const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aRootDomain:Boolean);
begin
 inherited Create(aAPLICDevice.fMachine,aBase,aSize);
 fAPLICDevice:=aAPLICDevice;
 fAIARegFileMode:=aAIARegFileMode;
 fRootDomain:=aRootDomain;
 if fAIARegFileMode=TPasRISCV.TAIARegFileMode.Machine then begin
  fDelegationInvert:=$ffffffff;
 end else begin
  fDelegationInvert:=0;
 end;
 fUnalignedAccessSupport:=false;
 fMinOpSize:=4;
 fMaxOpSize:=4;
end;

destructor TPasRISCV.TAPLICDevice.TDomainDevice.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.Reset;
begin
 inherited Reset;
end;

function TPasRISCV.TAPLICDevice.TDomainDevice.ValidBits(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
begin
 if aReg<APLIC_SRC_REGS then begin
  TPasMPMemoryBarrier.ReadDependency;
  result:=fAPLICDevice.fDelegated[aReg] xor fDelegationInvert;
 end else begin
  result:=0;
 end;
end; 

function TPasRISCV.TAPLICDevice.TDomainDevice.ValidSrc(const aSrc:TPasRISCVUInt64):Boolean;
var Mask:TPasRISCVUInt32;
begin
 Mask:=TPasRISCVUInt32(1) shl (aSrc and 31);
 result:=(ValidBits(aSrc shr 5) and Mask)<>0;
end;

function TPasRISCV.TAPLICDevice.TDomainDevice.UngatedSrc(const aSrc:TPasRISCVUInt64):Boolean;
begin
 if ValidSrc(aSrc) then begin
  result:=fAPLICDevice.RectifiedSrc(aSrc) or fAPLICDevice.DetachedSrc(aSrc);
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TAPLICDevice.TDomainDevice.ReadIP(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
begin
 if aReg<APLIC_SRC_REGS then begin
  TPasMPMemoryBarrier.ReadDependency;
  result:=fAPLICDevice.fPending[aReg] and ValidBits(aReg);
 end else begin
  result:=0;
 end;
end;

function TPasRISCV.TAPLICDevice.TDomainDevice.ReadIN(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
begin
 result:=fAPLICDevice.RectifiedBits(aReg) and ValidBits(aReg);
end;

function TPasRISCV.TAPLICDevice.TDomainDevice.ReadIE(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
begin
 if aReg<APLIC_SRC_REGS then begin
  TPasMPMemoryBarrier.ReadDependency;
  result:=fAPLICDevice.fEnabled[aReg] and ValidBits(aReg);
 end else begin
  result:=0;
 end;
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.SetIPNum(const aSrc:TPasRISCVUInt64);
begin
 if UngatedSrc(aSrc) then begin
  fAPLICDevice.NotifyInterrupt(aSrc);
 end;
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.SetIP(const aReg:TPasRISCVUInt64;const aBits:TPasRISCVUInt32);
var SetValue:TPasRISCVUInt32;
    Index:TPasRISCVInt32;
begin
 if aReg<APLIC_SRC_REGS then begin
  SetValue:=aBits and ValidBits(aReg);
  if SetValue<>0 then begin
   for Index:=0 to 31 do begin
    if (SetValue and (TPasRISCVUInt32(1) shl Index))<>0 then begin
     SetIPNum((aReg shl 5) or TPasRISCVUInt64(Index));
    end;
   end;
  end;
 end;
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.ClearIP(const aReg:TPasRISCVUInt64;const aBits:TPasRISCVUInt32);
var ClearValue:TPasRISCVUInt32;
begin
 if aReg<APLIC_SRC_REGS then begin
  ClearValue:=aBits and ValidBits(aReg);
  if ClearValue<>0 then begin
   TPasMPInterlocked.ExchangeBitwiseAnd(fAPLICDevice.fPending[aReg],not ClearValue);
   TPasMPMemoryBarrier.Write;
  end;
 end;
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.ClearIPNum(const aSrc:TPasRISCVUInt64);
var Reg:TPasRISCVUInt64;
    Mask:TPasRISCVUInt32;
begin
 Reg:=aSrc shr 5;
 Mask:=TPasRISCVUInt32(1) shl (aSrc and 31);
 ClearIP(Reg,Mask);
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.SetIE(const aReg:TPasRISCVUInt64;const aBits:TPasRISCVUInt32);
var SetValue,Deliver:TPasRISCVUInt32;
    Index:TPasRISCVInt32;
begin
 if aReg<APLIC_SRC_REGS then begin
  SetValue:=aBits and ValidBits(aReg);
  SetValue:=SetValue and not TPasMPInterlocked.ExchangeBitwiseOr(fAPLICDevice.fEnabled[aReg],SetValue);
  if SetValue<>0 then begin
   Deliver:=TPasMPInterlocked.ExchangeBitwiseAnd(fAPLICDevice.fPending[aReg],not SetValue);
   TPasMPMemoryBarrier.Write;
   if Deliver<>0 then begin
    for Index:=0 to 31 do begin
     if (Deliver and (TPasRISCVUInt32(1) shl Index))<>0 then begin
      fAPLICDevice.NotifyInterrupt((aReg shl 5) or TPasRISCVUInt64(Index));
     end;
    end;
   end;
  end;
 end;
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.SetIENum(const aSrc:TPasRISCVUInt64);
var Reg:TPasRISCVUInt64;
    Mask:TPasRISCVUInt32; 
begin
 Reg:=aSrc shr 5;
 Mask:=TPasRISCVUInt32(1) shl (aSrc and 31);
 SetIE(Reg,Mask);
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.ClearIE(const aReg:TPasRISCVUInt64;const aBits:TPasRISCVUInt32);
var ClearValue:TPasRISCVUInt32;
begin
 if aReg<APLIC_SRC_REGS then begin
  ClearValue:=aBits and ValidBits(aReg);
  if ClearValue<>0 then begin
   TPasMPInterlocked.ExchangeBitwiseAnd(fAPLICDevice.fEnabled[aReg],not ClearValue);
   TPasMPMemoryBarrier.Write;
  end;
 end;
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.ClearIENum(const aSrc:TPasRISCVUInt64);
var Reg:TPasRISCVUInt64;
    Mask:TPasRISCVUInt32; 
begin
 Reg:=aSrc shr 5;
 Mask:=TPasRISCVUInt32(1) shl (aSrc and 31);
 ClearIE(Reg,Mask);
end;
 
function TPasRISCV.TAPLICDevice.TDomainDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address,Reg:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 if (Address>=0) and (Address<Size) then begin
  case Address of
   APLIC_REG_DOMAINCFG:begin
    result:=fAPLICDevice.fDomainCfg[fAIARegFileMode] or APLIC_DOMAINCFG;   
   end;
   APLIC_REG_MMSIADDRCFGH,APLIC_REG_SMSIADDRCFGH:begin
    result:=APLIC_MSIADDRCFGH_L;
   end;
   APLIC_REG_SETIP_0..APLIC_REG_SETIP_31:begin
    result:=ReadIP((Address-APLIC_REG_SETIP_0) shr 2);
   end;
   APLIC_REG_IN_CLRIP_0..APLIC_REG_IN_CLRIP_31:begin
    result:=ReadIN((Address-APLIC_REG_IN_CLRIP_0) shr 2);
   end;
   APLIC_REG_SOURCECFG_1..APLIC_REG_SOURCECFG_1023:begin
    Reg:=((Address-APLIC_REG_SOURCECFG_1) shr 2)+1;
    if ValidSrc(Reg) then begin
     TPasMPMemoryBarrier.ReadDependency;
     result:=fAPLICDevice.fSource[Reg];
    end else begin
     if fRootDomain then begin
      result:=APLIC_SOURCECFG_DETACHED;
     end else begin
      result:=0;
     end;
    end;
   end;
   APLIC_REG_TARGET_1..APLIC_REG_TARGET_1023:begin
    Reg:=((Address-APLIC_REG_TARGET_1) shr 2)+1;
    if ValidSrc(Reg) then begin
     TPasMPMemoryBarrier.ReadDependency;
     result:=fAPLICDevice.fTarget[Reg];
    end else begin
     result:=0;
    end;
   end;
   else begin
    result:=0;
   end;
  end;
 end else begin
  result:=0;
 end;
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address,Reg:TPasRISCVUInt64;
    Mask,Cfg:TPasRISCVUInt32;
begin
 Address:=aAddress-fBase;
 if (Address>=0) and (Address<Size) then begin
  case Address of
   APLIC_REG_DOMAINCFG:begin
    TPasMPMemoryBarrier.ReadWrite;
    fAPLICDevice.fDomainCfg[fAIARegFileMode]:=TPasRISCVUInt32(aValue) and APLIC_DOMAINCFG_IE;
    TPasMPMemoryBarrier.Write;
   end;
   APLIC_REG_SETIPNUM,APLIC_REG_SETIPNUM_LE:begin
    SetIPNum(TPasRISCVUInt64(TPasRISCVUInt32(aValue)));
   end; 
   APLIC_REG_SETIPNUM_BE:begin
    SetIPNum(TPasRISCVUInt64(ByteSwap32(TPasRISCVUInt32(aValue))));
   end;
   APLIC_REG_SETIENUM:begin
    SetIENum(TPasRISCVUInt64(TPasRISCVUInt32(aValue)));
   end;
   APLIC_REG_CLRIENUM:begin
    ClearIENum(TPasRISCVUInt64(TPasRISCVUInt32(aValue)));
   end;
   APLIC_REG_GENMSI:begin
    fAPLICDevice.GenerateMSI(fAIARegFileMode,TPasRISCVUInt32(aValue));
   end;
   APLIC_REG_SETIP_0..APLIC_REG_SETIP_31:begin
    SetIP((Address-APLIC_REG_SETIP_0) shr 2,TPasRISCVUInt32(aValue));
   end;
   APLIC_REG_IN_CLRIP_0..APLIC_REG_IN_CLRIP_31:begin
    ClearIP((Address-APLIC_REG_IN_CLRIP_0) shr 2,TPasRISCVUInt32(aValue));
   end;
   APLIC_REG_SETIE_0..APLIC_REG_SETIE_31:begin
    SetIE((Address-APLIC_REG_SETIE_0) shr 2,TPasRISCVUInt32(aValue));
   end;
   APLIC_REG_CLRIE_0..APLIC_REG_CLRIE_31:begin
    ClearIE((Address-APLIC_REG_CLRIE_0) shr 2,TPasRISCVUInt32(aValue));
   end;
   APLIC_REG_SOURCECFG_1..APLIC_REG_SOURCECFG_1023:begin
    Reg:=((Address-APLIC_REG_SOURCECFG_1) shr 2)+1;
    if fRootDomain then begin
     Mask:=TPasRISCVUInt32(1) shl (Reg and 31);
     if (aValue and APLIC_SOURCECFG_DELEGATE)<>0 then begin
      TPasMPInterlocked.ExchangeBitwiseOr(fAPLICDevice.fDelegated[Reg shr 5],Mask);
     end else begin
      TPasMPInterlocked.ExchangeBitwiseAnd(fAPLICDevice.fDelegated[Reg shr 5],not Mask);
     end; 
    end;
    if ValidSrc(Reg) then begin
     Cfg:=aValue and APLIC_SOURCECFG_MASK;
     Mask:=TPasRISCVUInt32(1) shl (Reg and 31);
     TPasMPMemoryBarrier.ReadWrite;
//   writeln(Reg,' ',Cfg,' ',aValue);
     fAPLICDevice.fSource[Reg]:=Cfg;
     TPasMPMemoryBarrier.Write;
     case Cfg of
      APLIC_SOURCECFG_LVL_LOW,APLIC_SOURCECFG_EDGE_FALL:begin
       TPasMPInterlocked.ExchangeBitwiseOr(fAPLICDevice.fInvert[Reg shr 5],Mask);
      end;
      else begin
       TPasMPInterlocked.ExchangeBitwiseAnd(fAPLICDevice.fInvert[Reg shr 5],not Mask);
      end;
     end;
    end;
   end;
   APLIC_REG_TARGET_1..APLIC_REG_TARGET_1023:begin
    Reg:=((Address-APLIC_REG_TARGET_1) shr 2)+1;
    if ValidSrc(Reg) then begin
     TPasMPMemoryBarrier.ReadWrite;
     fAPLICDevice.fTarget[Reg]:=TPasRISCVUInt32(aValue);
     TPasMPMemoryBarrier.Write;
    end;
   end;
   else begin
   end;
  end;
 end;
end;

{ TPasRISCV.TAPLICDevice }

constructor TPasRISCV.TAPLICDevice.Create(const aMachine:TPasRISCV);
var StartAddress,EndAddress,
    MachineBase,MachineSize,
    SupervisorBase,SupervisorSize:TPasRISCVUInt64;
begin
 MachineBase:=aMachine.fConfiguration.fAPLICMachineBase;
 MachineSize:=aMachine.fConfiguration.fAPLICMachineSize;
 SupervisorBase:=aMachine.fConfiguration.fAPLICSupervisorBase;
 SupervisorSize:=aMachine.fConfiguration.fAPLICSupervisorSize;
 if MachineBase<SupervisorBase then begin
  StartAddress:=MachineBase;
  EndAddress:=SupervisorBase+SupervisorSize;
 end else begin
  StartAddress:=SupervisorBase;
  EndAddress:=MachineBase+MachineSize;
 end;
 inherited Create(aMachine,StartAddress,EndAddress-StartAddress);
 fUnalignedAccessSupport:=false;
 fMinOpSize:=4;
 fMaxOpSize:=4;
 fDomainDevices[TPasRISCV.TAIARegFileMode.Machine]:=TDomainDevice.Create(self,MachineBase,MachineSize,TPasRISCV.TAIARegFileMode.Machine,true);
 fDomainDevices[TPasRISCV.TAIARegFileMode.Supervisor]:=TDomainDevice.Create(self,SupervisorBase,SupervisorSize,TPasRISCV.TAIARegFileMode.Supervisor,false);
 AddSubBusDevice(fDomainDevices[TPasRISCV.TAIARegFileMode.Machine]);
 AddSubBusDevice(fDomainDevices[TPasRISCV.TAIARegFileMode.Supervisor]);
 Reset;
end;

destructor TPasRISCV.TAPLICDevice.Destroy;
begin
 inherited Destroy; // where each sub-device is also destroyed
end;

procedure TPasRISCV.TAPLICDevice.Reset;
var Mode:TPasRISCV.TAIARegFileMode;
begin
 inherited Reset;
 FillChar(fDomainCfg,SizeOf(TDomainCfg),#0);
 FillChar(fDelegated,SizeOf(TRegisters),#$ff); // All sources delegated in root domain
 FillChar(fRaised,SizeOf(TRegisters),#0);
 FillChar(fInvert,SizeOf(TRegisters),#0);
 FillChar(fPending,SizeOf(TRegisters),#0);
 FillChar(fEnabled,SizeOf(TRegisters),#0);
 FillChar(fSource,SizeOf(TSources),#0);
 FillChar(fTarget,SizeOf(TSources),#0);
 for Mode:=Low(TPasRISCV.TAIARegFileMode) to High(TPasRISCV.TAIARegFileMode) do begin
  if assigned(fDomainDevices[Mode]) then begin
   fDomainDevices[Mode].Reset;
  end;
 end;
end;

procedure TPasRISCV.TAPLICDevice.GenerateMSI(const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aTarget:TPasRISCVUInt32);
var HARTID:TPasRISCVUInt32;
begin
 HARTID:=aTarget shr 18;
 if HARTID<length(fMachine.fHARTs) then begin
  fMachine.fHARTs[HARTID].SendAIAIRQ(aAIARegFileMode,aTarget and $3ff);
 end;
end;

function TPasRISCV.TAPLICDevice.RectifiedBits(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
var Raised,Invert:TPasRISCVUInt32;
begin
 if aReg<APLIC_SRC_REGS then begin
  TPasMPMemoryBarrier.ReadDependency;
  Raised:=fRaised[aReg];
  TPasMPMemoryBarrier.ReadDependency;
  Invert:=fInvert[aReg];
  result:=Raised xor Invert;
 end else begin
  result:=0;
 end;
end;

function TPasRISCV.TAPLICDevice.RectifiedSrc(const aSrc:TPasRISCVUInt64):Boolean;
var Mask:TPasRISCVUInt32;
begin
 Mask:=TPasRISCVUInt32(1) shl (aSrc and 31);
 result:=(RectifiedBits(aSrc shr 5) and Mask)<>0;
end;

function TPasRISCV.TAPLICDevice.DetachedSrc(const aSrc:TPasRISCVUInt64):Boolean;
begin
 if aSrc<APLIC_SRC_LIMIT then begin
  TPasMPMemoryBarrier.ReadDependency;
  result:=fSource[aSrc]<=APLIC_SOURCECFG_DETACHED;
 end else begin
  result:=true;
 end;
end;

procedure TPasRISCV.TAPLICDevice.NotifyInterrupt(const aSrc:TPasRISCVUInt64); 
var Reg:TPasRISCVUInt64;
    Mask,Enabled,DomainCfg,Target:TPasRISCVUInt32;
    SMode:Boolean;
    AIARegFileMode:TPasRISCV.TAIARegFileMode;
begin
 if aSrc<APLIC_SRC_LIMIT then begin
  Reg:=aSrc shr 5;
  Mask:=TPasRISCVUInt32(1) shl (aSrc and 31);
  TPasMPMemoryBarrier.ReadDependency;
  SMode:=(fDelegated[Reg] and Mask)<>0;
  if SMode then begin
   AIARegFileMode:=TPasRISCV.TAIARegFileMode.Supervisor;
  end else begin
   AIARegFileMode:=TPasRISCV.TAIARegFileMode.Machine;
  end;
  TPasMPMemoryBarrier.ReadDependency;
  Enabled:=fEnabled[Reg] and Mask;
  TPasMPMemoryBarrier.ReadDependency;
  DomainCfg:=fDomainCfg[AIARegFileMode] or APLIC_DOMAINCFG; // Domain config
  if ((Enabled and Mask)<>0) and ((DomainCfg and APLIC_DOMAINCFG_IE)<>0) then begin
   TPasMPMemoryBarrier.ReadDependency;
   Target:=fTarget[aSrc];
   GenerateMSI(AIARegFileMode,Target);
  end else begin
   TPasMPInterlocked.ExchangeBitwiseOr(fPending[Reg],Mask);
  end;
 end;
end;

procedure TPasRISCV.TAPLICDevice.EdgeInterrupt(const aSrc:TPasRISCVUInt64);
begin
 if not DetachedSrc(aSrc) then begin
  NotifyInterrupt(aSrc);
 end;
end;

procedure TPasRISCV.TAPLICDevice.UpdateInterrupt(const aSrc:TPasRISCVUInt64);
begin
 if RectifiedSrc(aSrc) then begin
  EdgeInterrupt(aSrc);
 end;
end; 

function TPasRISCV.TAPLICDevice.SendIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
begin
 if (aIRQ>0) and (aIRQ<APLIC_SRC_LIMIT) then begin
  EdgeInterrupt(aIRQ);
 end;
 result:=false;
end;

function TPasRISCV.TAPLICDevice.RaiseIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
var Mask:TPasRISCVUInt32;
begin
 if (aIRQ>0) and (aIRQ<APLIC_SRC_LIMIT) then begin
  Mask:=TPasRISCVUInt32(1) shl (aIRQ and 31);
  if ((not TPasMPInterlocked.ExchangeBitwiseOr(fRaised[aIRQ shr 5],Mask)) and Mask)<>0 then begin
   UpdateInterrupt(aIRQ);
  end; 
  result:=true;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TAPLICDevice.LowerIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
var Mask:TPasRISCVUInt32;
begin
 if (aIRQ>0) and (aIRQ<APLIC_SRC_LIMIT) then begin
  Mask:=TPasRISCVUInt32(1) shl (aIRQ and 31);
  if ((TPasMPInterlocked.ExchangeBitwiseAnd(fRaised[aIRQ shr 5],not Mask)) and not Mask)<>0 then begin
   UpdateInterrupt(aIRQ);
  end;
  result:=true;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TAPLICDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 result:=inherited Load(aAddress,aSize);
end;

procedure TPasRISCV.TAPLICDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
begin
 inherited Store(aAddress,aValue,aSize);
end;

{ TPasRISCV.TPLICDevice }

constructor TPasRISCV.TPLICDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fPLICBase,aMachine.fConfiguration.fPLICSize);
 fUnalignedAccessSupport:=false;
 fMinOpSize:=4;
 fMaxOpSize:=4;
 fAllocationIRQCounter:=0;
 fCountContexts:=fMachine.fCountHARTs shl 1;
 Reset;
end;

destructor TPasRISCV.TPLICDevice.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV.TPLICDevice.Reset;
begin
 FillChar(fPriority,SizeOf(fPriority),#0);
 FillChar(fPending,SizeOf(fPending),#0);
 FillChar(fRaised,SizeOf(fRaised),#0);
 FillChar(fEnable,SizeOf(fEnable),#0);
 FillChar(fThreshold,SizeOf(fThreshold),#0);
end;

function TPasRISCV.TPLICDevice.IsIRQPending(const aIRQ:TPasRISCVUInt32):Boolean;
begin
 result:=(TPasMPInterlocked.Read(fPending[aIRQ shr 5]) and (TPasRISCVUInt32(1) shl (aIRQ and 31)))<>0;
end;

function TPasRISCV.TPLICDevice.IsIRQEnabled(const aContext,aIRQ:TPasRISCVUInt32):Boolean;
begin
 result:=(TPasMPInterlocked.Read(fEnable[aContext][aIRQ shr 5]) and (TPasRISCVUInt32(1) shl (aIRQ and 31)))<>0;
end;

function TPasRISCV.TPLICDevice.NotifyContextIRQ(const aContext,aIRQ:TPasRISCVUInt32):Boolean;
var HARTID:TPasRISCVUInt32;
begin
 if IsIRQEnabled(aContext,aIRQ) and
    (TPasMPInterlocked.Read(fPriority[aIRQ])>TPasMPInterlocked.Read(fThreshold[aContext])) then begin
  HARTID:=aContext shr 1;
  if HARTID<length(fMachine.fHARTs) then begin
   if (aContext and 1)<>0 then begin
    fMachine.fHARTs[HARTID].RaiseInterrupt(TPasRISCV.THART.TInterruptValue.SupervisorExternal);
   end else begin
    fMachine.fHARTs[HARTID].RaiseInterrupt(TPasRISCV.THART.TInterruptValue.MachineExternal);
   end;
  end;
  result:=true;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TPLICDevice.NotifyIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
var Context:TPasRISCVUInt32;
begin
 for Context:=0 to fCountContexts-1 do begin
  if NotifyContextIRQ(Context,aIRQ) then begin
   result:=true;
   exit;
  end;
 end;
 result:=false;
end;

procedure TPasRISCV.TPLICDevice.UpdateIRQ(const aIRQ:TPasRISCVUInt32);
begin
 if IsIRQPending(aIRQ) then begin
  NotifyIRQ(aIRQ);
 end;
end;

procedure TPasRISCV.TPLICDevice.UpdateContextIRQRegister(const aContext,aRegister:TPasRISCVUInt32);
var IRQs,Index:TPasRISCVUInt32;
begin
 IRQs:=TPasMPInterlocked.Read(fPending[aRegister]) and TPasMPInterlocked.Read(fEnable[aContext][aRegister]);
 if IRQs<>0 then begin
  for Index:=0 to 31 do begin
   UpdateIRQ((aRegister shl 5) or Index);
  end;
 end;
end;

function TPasRISCV.TPLICDevice.UpdateContext(const aContext:TPasRISCVUInt32;const aClaim:Boolean):TPasRISCVUInt32;
var Threshold,NotifyingIRQs,HighestPriorityIRQ,Priority,MaxPriority,IRQs,Index,IRQ,HARTID:TPasRISCVUInt32;
begin
 HARTID:=aContext shr 1;
 if HARTID<length(fMachine.fHARTs) then begin
  if (aContext and 1)<>0 then begin
   fMachine.fHARTs[HARTID].ClearInterrupt(TPasRISCV.THART.TInterruptValue.SupervisorExternal);
  end else begin
   fMachine.fHARTs[HARTID].ClearInterrupt(TPasRISCV.THART.TInterruptValue.MachineExternal);
  end;
 end;
 Threshold:=TPasMPInterlocked.Read(fThreshold[aContext]);
 NotifyingIRQs:=0;
 HighestPriorityIRQ:=0;
 MaxPriority:=0;
 for Index:=0 to PLIC_SRC_REG_COUNT-1 do begin
  IRQs:=TPasMPInterlocked.Read(fPending[Index]) and TPasMPInterlocked.Read(fEnable[aContext][Index]);
  while IRQs<>0 do begin
   IRQ:=(Index shl 5) or TPasMPMath.BitScanForward32(IRQs); // Find first set bit
   Priority:=TPasMPInterlocked.Read(fPriority[IRQ]);
   if Threshold<Priority then begin
    inc(NotifyingIRQs);
   end;
   if MaxPriority<Priority then begin
    MaxPriority:=Priority;
    HighestPriorityIRQ:=IRQ;
   end;
   IRQs:=IRQs and (IRQs-1); // Mask out first set bit
  end;
 end;
 if aClaim and (Threshold<MaxPriority) then begin
  dec(NotifyingIRQs);
 end;
 if NotifyingIRQs<>0 then begin
  if HARTID<length(fMachine.fHARTs) then begin
   if (aContext and 1)<>0 then begin
    fMachine.fHARTs[HARTID].RaiseInterrupt(TPasRISCV.THART.TInterruptValue.SupervisorExternal);
   end else begin
    fMachine.fHARTs[HARTID].RaiseInterrupt(TPasRISCV.THART.TInterruptValue.MachineExternal);
   end;
  end;
 end;
 result:=HighestPriorityIRQ;
end;

procedure TPasRISCV.TPLICDevice.FullUpdate;
var Context:TPasRISCVUInt32;
begin
 for Context:=0 to fCountContexts-1 do begin
  UpdateContext(Context,false);
 end;
end;

procedure TPasRISCV.TPLICDevice.SetIRQPriority(const aIRQ,aPriority:TPasRISCVUInt32);
var OldPriority:TPasRISCVUInt32;
begin
 OldPriority:=TPasMPInterlocked.Exchange(fPriority[aIRQ],aPriority);
 if aPriority<OldPriority then begin
  if IsIRQPending(aIRQ) then begin
   // Pending IRQ priority was lowered - do a full PLIC state update
   FullUpdate;
  end;
 end else if aPriority>OldPriority then begin
  // IRQ priority was raised - do a partial check
  UpdateIRQ(aIRQ);
 end;
end;

procedure TPasRISCV.TPLICDevice.SetEnableBits(const aContext,aRegister,aEnable:TPasRISCVUInt32);
var OldEnable,IRQsDisabled:TPasRISCVUInt32;
begin
 OldEnable:=TPasMPInterlocked.Exchange(fEnable[aContext][aRegister],aEnable);
 IRQsDisabled:=OldEnable and not aEnable;
 if IRQsDisabled<>0 then begin
  if (IRQsDisabled and TPasMPInterlocked.Read(fPending[aRegister]))<>0 then begin
   // Some pending IRQs were disabled - do a full PLIC state update
   FullUpdate;
  end;
 end else if (aEnable and not OldEnable)<>0 then begin
  // Some IRQs were enabled - do a partial check
  UpdateContextIRQRegister(aContext,aRegister);
 end;
end;

procedure TPasRISCV.TPLICDevice.SetContextThreshold(const aContext,aThreshold:TPasRISCVUInt32);
var OldThreshold:TPasRISCVUInt32;
begin
 OldThreshold:=TPasMPInterlocked.Exchange(fThreshold[aContext],aThreshold);
 if OldThreshold<>aThreshold then begin
  // Context threshold changed - do a context update
  UpdateContext(aContext,false);
 end;
end;

function TPasRISCV.TPLICDevice.ClaimIRQ(const aContext:TPasRISCVUInt32):TPasRISCVUInt32;
var IRQ,Mask:TPasRISCVUInt32;
begin
 repeat
  IRQ:=UpdateContext(aContext,true);
  if IRQ<>0 then begin
   Mask:=TPasRISCVUInt32(1) shl (IRQ and 31);
   if (TPasMPInterlocked.ExchangeBitwiseAnd(fPending[IRQ shr 5],not Mask) and Mask)=0 then begin
    // Someone stole our IRQ in the meantime, retry
    continue;
   end;
  end;
  break;
 until false;
 result:=IRQ;
end;

procedure TPasRISCV.TPLICDevice.CompleteIRQ(const aContext,aIRQ:TPasRISCVUInt32);
var Raised:TPasRISCVUInt32;
begin
 Raised:=TPasMPInterlocked.Read(fRaised[aIRQ shr 5]) and (TPasRISCVUInt32(1) shl (aIRQ and 31));
 if Raised<>0 then begin
  TPasMPInterlocked.BitwiseOr(fPending[aIRQ shr 5],Raised);
  NotifyContextIRQ(aContext,aIRQ);
 end;
end;

function TPasRISCV.TPLICDevice.AllocateIRQ:TPasRISCVUInt32;
begin
 result:=TPasMPInterlocked.Increment(fAllocationIRQCounter);
 if result>=PLIC_SOURCE_MAX then begin
  raise EPasRISCV.Create('Out of IRQs');
 end;
end;

function TPasRISCV.TPLICDevice.SendIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
var Mask:TPasRISCVUInt32;
begin
 if (aIRQ>0) or (aIRQ<PLIC_SOURCE_MAX) then begin
  Mask:=TPasRISCVUInt32(1) shl (aIRQ and 31);
  if (TPasMPInterlocked.ExchangeBitwiseOr(fPending[aIRQ shr 5],Mask) and Mask)=0 then begin
   NotifyIRQ(aIRQ);
  end;
  result:=true;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TPLICDevice.RaiseIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
var Mask:TPasRISCVUInt32;
begin
 if (aIRQ>0) or (aIRQ<PLIC_SOURCE_MAX) then begin
  Mask:=TPasRISCVUInt32(1) shl (aIRQ and 31);
  if (TPasMPInterlocked.ExchangeBitwiseOr(fRaised[aIRQ shr 5],Mask) and Mask)=0 then begin
   SendIRQ(aIRQ);
  end;
  result:=true;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TPLICDevice.LowerIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
begin
 if (aIRQ>0) or (aIRQ<PLIC_SOURCE_MAX) then begin
  TPasMPInterlocked.BitwiseAnd(fRaised[aIRQ shr 5],not (TPasRISCVUInt32(1) shl (aIRQ and 31)));
  result:=true;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TPLICDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address,{Offset,}Context,IRQ,Register:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 if (Address>=SourcePriorityAddress) and (Address<=SourcePriorityEndAddress) then begin
  IRQ:=Address shr 2;
  if (IRQ>0) and (IRQ<PLIC_SOURCE_MAX) then begin
   result:=TPasMPInterlocked.Read(fPriority[IRQ]);
  end else begin
   result:=0;
  end;
 end else if (Address>=PendingAddress) and (Address<=PendingEndAddress) then begin
  Register:=(Address-PendingAddress) shr 2;
  if Register<PLIC_SRC_REG_COUNT then begin
   result:=TPasMPInterlocked.Read(fPending[Register]);
  end else begin
   result:=0;
  end;
 end else if (Address>=EnableAddress) and (Address<=EnableEndAddress) then begin
  dec(Address,EnableAddress);
  Register:=(Address shr 2) and 31;
  Context:=Address shr 7;
  if (Register<PLIC_SRC_REG_COUNT) and (Context<fCountContexts) then begin
   result:=TPasMPInterlocked.Read(fEnable[Context][Register]);
  end else begin
   result:=0;
  end;
 end else if (Address>=ThresholdClaimAddress) and (Address<=ThresholdClaimEndAddress) then begin
  dec(Address,ThresholdClaimAddress);
  Register:=(Address shr 2) and 1023;
  Context:=Address shr 12;
  if Context<fCountContexts then begin
   case Register of
    CTXFLAG_THRESHOLD:begin
     result:=TPasMPInterlocked.Read(fThreshold[Context]);
    end;
    CTXFLAG_COMPLETE:begin
     result:=ClaimIRQ(Context);
    end;
    else begin
     result:=0;
    end;
   end;
  end else begin
   result:=0;
  end;
 end else begin
  result:=0;
 end;
{Offset:=Address and 7;
 result:=(result shr (Offset shl 3)) and TPasRISCVUInt64(TPasRISCVUInt64(TPasRISCVUInt64(1) shl (aSize shl 3))-1);//}
end;

procedure TPasRISCV.TPLICDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address,Context,IRQ,Register:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 if (Address>=SourcePriorityAddress) and (Address<=SourcePriorityEndAddress) then begin
  IRQ:=Address shr 2;
  if (IRQ>0) and (IRQ<PLIC_SOURCE_MAX) then begin
   SetIRQPriority(IRQ,aValue);
  end;
 end else if (Address>=PendingAddress) and (Address<=PendingEndAddress) then begin
{ Register:=(Address-PendingAddress) shr 2;
  if Register<PLIC_SRC_REG_COUNT then begin
   TPasMPInterlocked.Write(fPending[Register],aValue);
  end;//}
  // R/O, do nothing. Pending bits are cleared by reading CLAIMCOMPLETE register
 end else if (Address>=EnableAddress) and (Address<=EnableEndAddress) then begin
  dec(Address,EnableAddress);
  Register:=(Address shr 2) and 31;
  Context:=Address shr 7;
  if (Register<PLIC_SRC_REG_COUNT) and (Context<fCountContexts) then begin
   SetEnableBits(Context,Register,aValue);
  end;
 end else if (Address>=ThresholdClaimAddress) and (Address<=ThresholdClaimEndAddress) then begin
  dec(Address,ThresholdClaimAddress);
  Register:=(Address shr 2) and 1023;
  Context:=Address shr 12;
  if Context<fCountContexts then begin
   case Register of
    CTXFLAG_THRESHOLD:begin
     SetContextThreshold(Context,aValue);
    end;
    CTXFLAG_COMPLETE:begin
     CompleteIRQ(Context,aValue);
    end;
    else begin
    end;
   end;
  end;
 end;
end;

{ TPasRISCV.TSYSCONDevice }

constructor TPasRISCV.TSYSCONDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fSYSCONBase,aMachine.fConfiguration.fSYSCONSize);
end;

destructor TPasRISCV.TSYSCONDevice.Destroy;
begin
 inherited Destroy;
end;

function TPasRISCV.TSYSCONDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 if aAddress=fBase then begin
  result:=TPasRISCVUInt64($ffffffffffffffff);
 end else begin
  result:=0;
 end;
end;

procedure TPasRISCV.TSYSCONDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
begin
 if aAddress=fBase then begin
  case aValue of
   PowerOffValue:begin
    fMachine.PowerOff;
   end;
   RebootValue:begin
    fMachine.Reboot;
   end;
  end;
 end;
end;

{ TPasRISCV.TPCIMemoryDevice }

constructor TPasRISCV.TPCIMemoryDevice.Create(const aMachine:TPasRISCV;const aPCIDevice:TPCIDevice;const aPCIFunc:TPCIFunc;const aBase,aSize:TPasRISCVUInt64;const aOnLoad:TOnLoad;const aOnStore:TOnStore);
begin
 fPCIBusDevice:=aPCIDevice.fBus;
 fPCIDevice:=aPCIDevice;
 fPCIFunc:=aPCIFunc;
 fOnLoad:=aOnLoad;
 fOnStore:=aOnStore;
 inherited Create(aMachine,aBase,aSize,nil,assigned(fOnLoad) or assigned(fOnStore));
end;

destructor TPasRISCV.TPCIMemoryDevice.Destroy;
begin
 inherited Destroy;
end;

function TPasRISCV.TPCIMemoryDevice.GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
begin
 if assigned(fOnLoad) or assigned(fOnStore) then begin
  result:=aBounce;
 end else begin
  result:=inherited GetDeviceDirectMemoryAccessPointer(aAddress,aSize,aWrite,aBounce);
 end;
end;

function TPasRISCV.TPCIMemoryDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 if assigned(fOnLoad) then begin
  result:=fOnLoad(self,aAddress,aSize);
 end else begin
  result:=inherited Load(aAddress,aSize);
 end;
end;

procedure TPasRISCV.TPCIMemoryDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
begin
 if assigned(fOnStore) then begin
  fOnStore(self,aAddress,aValue,aSize);
 end else begin
  inherited Store(aAddress,aValue,aSize);
 end;
end;

{ TPasRISCV.TPCIFunc }

constructor TPasRISCV.TPCIFunc.Create(const aBus:TPasRISCV.TPCIBusDevice;const aDevice:TPasRISCV.TPCIDevice;const aFuncDesc:TPasRISCV.TPCIFuncDescriptor);
var BARIndex:TPasRISCVUInt32;
    BARRegion:TPCIBARRegion;
    PCIMemoryDevice:TPCIMemoryDevice;
begin
 inherited Create;
 fBus:=aBus;
 fDevice:=aDevice;
 fStatus:=0;
 fCommand:=TPCI.PCI_CMD_DEFAULT;
 fIRQLine:=0;
 fVendorID:=aFuncDesc.fVendorID;
 fDeviceID:=aFuncDesc.fDeviceID;
 fClassCode:=aFuncDesc.fClassCode;
 fProgIF:=aFuncDesc.fProgIF;
 fRevisionID:=aFuncDesc.fRevisionID;
 fIRQPin:=aFuncDesc.fIRQPin;
 fBridgeIO:=0;
 fBridgeMem:=0;
 if fIRQPin<>0 then begin
//writeln('IRQs: ',TPCI.PCI_IRQs[0],' ',TPCI.PCI_IRQs[1],' ',TPCI.PCI_IRQs[2],' ',TPCI.PCI_IRQs[3],' PCIFuncIRQPinID: ',TPCIBusDevice.PCIFuncIRQPinID(self));
  fIRQLine:=fBus.fIRQs[TPCIBusDevice.PCIFuncIRQPinID(self)];
 end else begin
  fIRQLine:=0;
 end;
 fExpansionROM:=nil;
//writeln('PCI Func: ',LowerCase(IntToHex(fVendorID,4)),' ',LowerCase(IntToHex(fDeviceID,4)),' ',LowerCase(IntToHex(fClassCode,6)),' ',LowerCase(IntToHex(fProgIF,2)),' ',LowerCase(IntToHex(fRevisionID,2)),' ',LowerCase(IntToHex(fIRQPin,2)),' ',LowerCase(IntToHex(fIRQLine,2)));
 for BARIndex:=0 to TPCI.PCI_FUNC_BARS-1 do begin
  fBARMemoryDevices[BARIndex]:=nil;
 end;
 for BARIndex:=0 to TPCI.PCI_FUNC_BARS-1 do begin
  BARRegion:=aFuncDesc.fBARRegions[BARIndex];
  if BARRegion.fSize<>0 then begin
{$ifdef NewPCI}
   BARRegion.fAddress:=GetBARAddress(BARRegion.fSize);
   PCIMemoryDevice:=TPCIMemoryDevice.Create(fBus.fMachine,aDevice,self,BARRegion.fAddress,BARRegion.fSize,BARRegion.fOnLoad,BARRegion.fOnStore);
   fBARMemoryDevices[BARIndex]:=PCIMemoryDevice;
   fBus.fMachine.fBus.AddBusDevice(PCIMemoryDevice);
{$else}
   BARRegion.fSize:=(BARRegion.fSize+15) and TPasRISCVUInt64($fffffffffffffff0);
   if BARRegion.fSize<>0 then begin
    BARRegion.fAddress:=fBus.fMemAddr+((BARRegion.fSize-fBus.fMemAddr) mod BARRegion.fSize);
    dec(fBus.fMemSize,(BARRegion.fAddress+BARRegion.fSize)-fBus.fMemAddr);
    fBus.fMemAddr:=BARRegion.fAddress+BARRegion.fSize;
    PCIMemoryDevice:=TPCIMemoryDevice.Create(fBus.fMachine,aDevice,self,BARRegion.fAddress,BARRegion.fSize,BARRegion.fOnLoad,BARRegion.fOnStore);
    fBARMemoryDevices[BARIndex]:=PCIMemoryDevice;
    fBus.fMachine.fBus.AddBusDevice(PCIMemoryDevice);
   end;
{$endif}
  end;
 end;
end;

destructor TPasRISCV.TPCIFunc.Destroy;
var BarIndex:TPasRISCVUInt32;
    PCIMemoryDevice:TPCIMemoryDevice;
begin
 for BarIndex:=0 to TPCI.PCI_FUNC_BARS-1 do begin
  PCIMemoryDevice:=fBARMemoryDevices[BarIndex];
  if assigned(PCIMemoryDevice) and assigned(fBus) and assigned(fBus.fMachine) and assigned(fBus.fMachine.fBus) then begin
   fBus.fMachine.fBus.RemoveBusDevice(PCIMemoryDevice);
  end;
  FreeAndNil(fBARMemoryDevices[BarIndex]);
 end;
 FreeAndNil(fExpansionROM);
 inherited Destroy;
end;

function TPasRISCV.TPCIFunc.IsUpperHalf(const aBarID:TPasRISCVSizeUInt):Boolean;
begin
 result:=(aBarID<>0) and (not assigned(fBARMemoryDevices[aBarID])) and assigned(fBARMemoryDevices[aBarID-1]);
end;

function TPasRISCV.TPCIFunc.Is64Bit(const aBarID:TPasRISCVSizeUInt):Boolean;
begin
 result:=((aBarID+1)<TPCI.PCI_FUNC_BARS) and assigned(fBARMemoryDevices[aBarID]) and not assigned(fBARMemoryDevices[aBarID+1]);
end;

function TPasRISCV.TPCIFunc.GetEffectiveBar(const aBarID:TPasRISCVSizeUInt):TPCIMemoryDevice;
begin
 if IsUpperHalf(aBarID) then begin
  result:=fBARMemoryDevices[aBarID-1];
 end else begin
  result:=fBARMemoryDevices[aBarID];
 end;
end;

function TPasRISCV.TPCIFunc.GetBARAddress(const aBARSize:TPasRISCVUInt64):TPasRISCVUInt64;
var AlignSize,TemporaryAddress:TPasRISCVUInt64;
begin
 AlignSize:=RoundUpToPowerOfTwo64(Max(aBARSize,$1000));
 result:=fBus.fMemAddr;
 repeat
  TemporaryAddress:=fBus.fMachine.fBus.GetAutoMemoryAddress(result,AlignSize);
  if result=TemporaryAddress then begin
   break;
  end else begin
   result:=TemporaryAddress+((AlignSize-TemporaryAddress) and (AlignSize-1));
  end;
 until false;
end;

procedure TPasRISCV.TPCIFunc.SendIRQ(const aMSIID:TPasRISCVUInt32;const aRaiseIRQ:Boolean);
var IRQ:TPasRISCVUInt32;
begin
 if (fIRQPin<>0) and ((TPasMPInterlocked.Read(fCommand) and TPCI.PCI_CMD_INTX_DISABLE)=0) then begin
  TPasMPInterlocked.BitwiseOr(fStatus,TPCI.PCI_STATUS_INTX);
  IRQ:=fBus.fIRQs[TPasRISCV.TPCIBusDevice.PCIFuncIRQPinID(self)];
  if aRaiseIRQ then begin
   fBus.fMachine.fInterrupts.RaiseIRQ(IRQ);
  end else begin
   fBus.fMachine.fInterrupts.SendIRQ(IRQ);
  end;
 end;
end;

procedure TPasRISCV.TPCIFunc.RaiseIRQ(const aMSIID:TPasRISCVUInt32);
begin
 SendIRQ(aMSIID,true);
end;

procedure TPasRISCV.TPCIFunc.LowerIRQ;
var IRQ:TPasRISCVUInt32;
begin
 TPasMPInterlocked.BitwiseAnd(fStatus,TPasRISCVUInt32(not TPCI.PCI_STATUS_INTX));
 IRQ:=fBus.fIRQs[TPasRISCV.TPCIBusDevice.PCIFuncIRQPinID(self)];
 fBus.fMachine.fInterrupts.LowerIRQ(IRQ);
end;

procedure TPasRISCV.TPCIFunc.LowerIRQ(const aMSIID:TPasRISCVUInt32);
begin
 LowerIRQ;
end;

{ TPasRISCV.TPCIBusDevice }

constructor TPasRISCV.TPCIBusDevice.Create(const aMachine:TPasRISCV);
var IRQPinIndex:TPasRISCVSizeInt;
begin
 inherited Create(aMachine,TPasRISCV.TPCI.PCI_BASE_DEFAULT_MMIO,256 shl BusShift);
 fIOAddr:=TPasRISCV.TPCI.PCI_IO_DEFAULT_ADDR;
 fIOSize:=TPasRISCV.TPCI.PCI_IO_DEFAULT_SIZE;
 fMemAddr:=TPasRISCV.TPCI.PCI_MEM32_DEFAULT_MMIO;
 fMemSize:=TPasRISCV.TPCI.PCI_MEM32_DEFAULT_SIZE;
 fBusID:=0;
 for IRQPinIndex:=0 to TPCI.PCI_BUS_IRQS-1 do begin
  fIRQs[IRQPinIndex]:=TPCI.PCI_IRQs[IRQPinIndex];
 end;
 Reset;
 FillChar(fDevices,SizeOf(fDevices),#0);
 fCountDevices:=0;
 fHostBridgeDevice:=TPCIHostBridgeDevice.Create(self);
 AddBusDevice(fHostBridgeDevice);
 fUnalignedAccessSupport:=false;
 fMinOpSize:=4;
 fMaxOpSize:=4;
end;

destructor TPasRISCV.TPCIBusDevice.Destroy;
begin
 RemoveBusDevice(fHostBridgeDevice);
 FreeAndNil(fHostBridgeDevice);
 inherited Destroy;
end;

procedure TPasRISCV.TPCIBusDevice.Reset;
begin
end;

function TPasRISCV.TPCIBusDevice.GetFunc(const aBus,aDev,aFunc:TPasRISCVUInt32):TPasRISCV.TPCIFunc;
var Device:TPCIDevice;
begin
 if aDev<TPCI.PCI_BUS_DEVS then begin
  Device:=fDevices[aDev];
  if assigned(Device) then begin
   result:=Device.fFuncs[aFunc];
  end else begin
   result:=nil;
  end;
 end else begin
  result:=nil;
 end;
end;

class function TPasRISCV.TPCIBusDevice.GetIRQID(const aDeviceID,aIRQPin:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=(aDeviceID+aIRQPin+3) and 3;
end;

class function TPasRISCV.TPCIBusDevice.PCIFuncIRQPinID(const aFunc:TPasRISCV.TPCIFunc):TPasRISCVUInt32;
begin
 result:=GetIRQID(aFunc.fDeviceID,aFunc.fIRQPin);
end;

procedure TPasRISCV.TPCIBusDevice.AddBusDevice(const aDevice:TPasRISCV.TPCIDevice);
var DeviceID:TPasRISCVUInt32;
begin
 DeviceID:=0;
 while (DeviceID<TPCI.PCI_BUS_DEVS) and assigned(fDevices[DeviceID]) do begin
  inc(DeviceID);
 end;
 if DeviceID<TPCI.PCI_BUS_DEVS then begin
  fDevices[DeviceID]:=aDevice;
  inc(fCountDevices);
 end else begin
  raise EPasRISCV.Create('Too much devices on a single PCI bus');
 end;
end;

procedure TPasRISCV.TPCIBusDevice.RemoveBusDevice(const aDevice:TPasRISCV.TPCIDevice);
var Index:TPasRISCVSizeInt;
begin
 if assigned(aDevice) then begin
  for Index:=0 to TPCI.PCI_BUS_DEVS-1 do begin
   if fDevices[Index]=aDevice then begin
    fDevices[Index]:=nil;
    dec(fCountDevices);
    exit;
   end;
  end;
  raise EPasRISCV.Create('Device not found on PCI bus');
 end;
end;

function TPasRISCV.TPCIBusDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Index:TPasRISCVSizeInt;
    Address,BusAddress,BarID,SecondaryBus,CapabilityID:TPasRISCVUInt64;
    BusID,DevID,FuncID,Register:TPasRISCVUInt8;
    Func:TPasRISCV.TPCIFunc;
    BusDevice:TPasRISCV.TBusDevice;
    Device:TPCIDevice;
begin

 Address:=aAddress-fBase;

 BusID:=Address shr BusShift;
 DevID:=(Address shr (BusShift-5)) and 31;
 FuncID:=(Address shr (BusShift-8)) and 7;
 BusAddress:=Address shr (BusShift-8);
 Register:=Address and (((TPasRISCVUInt64(1) shl (BusShift-8))-1) and TPasRISCVUInt64($fffffffffffffffc));

 Func:=GetFunc(BusID,DevID,FuncID);
 if assigned(Func) then begin

  result:=0;

  case Register of
   TPCI.PCI_REG_DEV_VEN_ID:begin
    result:=Func.fVendorID or (TPasRISCVUInt32(Func.fDeviceID) shl 16);
   end;
   TPCI.PCI_REG_STATUS_CMD:begin
    result:=(TPasMPInterlocked.Read(Func.fStatus) shl 16) or TPasMPInterlocked.Read(Func.fCommand);
{$ifdef NewPCI}
    if BusAddress<>0 then begin
     result:=result or (TPasRISCVUInt32(TPCI.PCI_STATUS_CAP) shl 16);
    end;
{$endif}
   end;
   TPCI.PCI_REG_CLASS_REV:begin
    result:=(Func.fClassCode shl 16) or (TPasRISCVUInt32(Func.fProgIF) shl 8) or Func.fRevisionID;
   end;
   TPCI.PCI_REG_BIST_HDR_LATENCY_CACHE:begin
    result:=16;
{$ifdef NewPCI}
    if DevID<TPCI.PCI_BUS_DEVS then begin
     Device:=fDevices[DevID];
     if assigned(Device) then begin
      for Index:=0 to TPCI.PCI_DEV_FUNCS-1 do begin
       if assigned(Device.fFuncs[Index]) and (Index<>FuncID) then begin
        result:=result or (TPasRISCVUInt32(TPCI.PCI_HEADER_MULTIFUNC) shl 16);
        break;
       end;
      end;
     end;
    end;
    if Func.fClassCode=$0604 then begin
     result:=result or (TPasRISCVUInt32(TPCI.PCI_HEADER_PCI_PCI) shl 16);
    end;
{$endif}
   end;
   TPCI.PCI_REG_IRQ_PIN_LINE:begin
    result:=(TPasMPInterlocked.Read(Func.fIRQLine) or (TPasRISCVUInt32(Func.fIRQPin) shl 8));
   end;
   TPCI.PCI_REG_BAR0..TPCI.PCI_REG_BAR5:begin
{$ifdef NewPCI}
    BarID:=(Register-TPCI.PCI_REG_BAR0) shr 2;
    if (Func.fClassCode<>$0604) or (BarID<2) then begin
     BusDevice:=Func.GetEffectiveBar(BarID);
     if assigned(BusDevice) then begin
      if Func.IsUpperHalf(BarID) then begin
       result:=BusDevice.fBase shr 32;
      end else begin
       result:=TPasRISCVUInt32(BusDevice.fBase);
       if Func.Is64Bit(BarID) then begin
        result:=result or TPCI.PCI_BAR_64_BIT;
       end;
       if BusDevice.fSize>=$10000000 then begin
        result:=result or TPCI.PCI_BAR_PREFETCH;
       end;
      end;
     end else begin
      result:=0;
     end;
    end else begin
     SecondaryBus:=(BusAddress shr 3) or (BusAddress and 7);
     case BarID of
      $02:begin
       result:=(SecondaryBus shl 16) or (SecondaryBus shl 8);
      end;
      $03:begin
       result:=TPasMPInterlocked.Read(Func.fBridgeIO);
      end;
      $04:begin
       result:=TPasMPInterlocked.Read(Func.fBridgeMem);
      end;
      else begin
       result:=0;
      end;
     end;
    end;
{$else}
    BusDevice:=Func.fBARMemoryDevices[(Register-TPCI.PCI_REG_BAR0) shr 2];
    if assigned(BusDevice) then begin
     result:=BusDevice.fBase;
    end else begin
     result:=0;
    end;
{$endif}
   end;
   TPCI.PCI_REG_SSID_SVID:begin
    result:=$eba110dc;
   end;
{$ifdef NewPCI}
   TPCI.PCI_REG_EXPANSION_ROM:begin
    if assigned(Func.fExpansionROM) then begin
     result:=Func.fExpansionROM.fBase or TPCI.PCI_EXPANSION_ROM_ENABLED;
    end else begin
     result:=0;
    end;
   end;
   TPCI.PCI_REG_CAP_PTR:begin
    if BusAddress<>0 then begin
     result:=TPCI.PCI_CAP_LIST_OFF;
    end else begin
     result:=0;
    end;
   end;
   else begin
    if BusAddress<>0 then begin
     CapabilityID:=(Register-TPCI.PCI_CAP_LIST_OFF) shr 2;
     if CapabilityID<Length(TPCI.PCIExpressCapabilities) then begin
      result:=TPCI.PCIExpressCapabilities[CapabilityID];
     end else begin
      result:=0;
     end;
     if CapabilityID=0 then begin
      if Func.fClassCode=$0604 then begin
       result:=result or (TPCI.PCIE_CAP_ROOT_PORT shl 20);
      end else if (BusAddress shr 8)=0 then begin
       result:=result or (TPCI.PCIE_CAP_INTEGRATED_ENDPOINT shl 20);
      end;
     end;
    end;
   end;
{$else}
   TPCI.PCI_REG_EXPANSION_ROM,
   TPCI.PCI_REG_CAP_PTR:begin
    result:=0;
   end;
{$endif}
  end;

//writeln('PCI Read: ',LowerCase(IntToHex(Address,8)),' ',LowerCase(IntToHex(BusID,2)),':',LowerCase(IntToHex(DevID,2)),'.',LowerCase(IntToHex(FuncID,1)),' ',LowerCase(IntToHex(Register,2)),' = ',LowerCase(IntToHex(result,8)));

 end else begin

  result:=$ffffffff;

 end;

end;

procedure TPasRISCV.TPCIBusDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address,BusAddress,BarID,BarAddress,BarSize,ROMAddress,ROMSize:TPasRISCVUInt64;
    Old,IRQ:TPasRISCVUInt32;
    BusID,DevID,FuncID,Register:TPasRISCVUInt8;
    Func:TPasRISCV.TPCIFunc;
    BusDevice:TPasRISCV.TBusDevice;
begin

 Address:=aAddress-fBase;

 BusID:=Address shr BusShift;
 DevID:=(Address shr (BusShift-5)) and 31;
 FuncID:=(Address shr (BusShift-8)) and 7;
 BusAddress:=Address shr (BusShift-8);
 Register:=Address and (((TPasRISCVUInt64(1) shl (BusShift-8))-1) and TPasRISCVUInt64($fffffffffffffffc));

//writeln('PCI Write: ',LowerCase(IntToHex(Address,8)),' ',LowerCase(IntToHex(BusID,2)),':',LowerCase(IntToHex(DevID,2)),'.',LowerCase(IntToHex(FuncID,1)),' ',LowerCase(IntToHex(Register,2)),' = ',LowerCase(IntToHex(aValue,8)));

 Func:=GetFunc(BusID,DevID,FuncID);
 if assigned(Func) then begin
  case Register of
   TPCI.PCI_REG_STATUS_CMD:begin
{$ifdef NewPCI}
    Old:=TPasMPInterlocked.Exchange(Func.fCommand,aValue and TPCI.PCI_CMD_MASK);
    if ((Old and TPCI.PCI_CMD_INTX_DISABLE)=0) and ((aValue and TPCI.PCI_CMD_INTX_DISABLE)<>0) then begin
     Func.LowerIRQ;
    end;
{$else}
    TPasMPInterlocked.Write(Func.fCommand,aValue and $ffff);
{$endif}
   end;
   TPCI.PCI_REG_BAR0..TPCI.PCI_REG_BAR5:begin
{$ifdef NewPCI}
    BarID:=(Register-TPCI.PCI_REG_BAR0) shr 2;
    if (Func.fClassCode<>$0604) or (BarID<2) then begin
     BusDevice:=Func.GetEffectiveBar(BarID);
     if assigned(BusDevice) then begin
      BarAddress:=BusDevice.fBase;
      BarSize:=RoundUpToPowerOfTwo64(BusDevice.fSize);
      if Func.IsUpperHalf(BarID) then begin
       BarAddress:=(BarAddress and TPasRISCVUInt64($00000000ffffffff)) or (TPasRISCVUInt64(aValue) shl 32);
      end else begin
       BarAddress:=(BarAddress and TPasRISCVUInt64($ffffffff00000000)) or (TPasRISCVUInt64(aValue) and TPasRISCVUInt64($00000000fffff000));
      end;
      BarAddress:=BarAddress and TPasRISCVUInt64(not TPasRISCVUInt64(BarSize-1));
      TPasMPInterlocked.Write(BusDevice.fBase,BarAddress);
      TPasMPMemoryBarrier.ReadWrite;
     end;
    end else begin
     case BarID of
      $3:begin
       TPasMPInterlocked.Write(Func.fBridgeIO,TPasRISCVUInt32(aValue));
      end;
      $4:begin
       TPasMPInterlocked.Write(Func.fBridgeMem,TPasRISCVUInt32(aValue));
      end;
     end;
    end;
{$else}
    BusDevice:=Func.fBARMemoryDevices[(Register-TPCI.PCI_REG_BAR0) shr 2];
    if assigned(BusDevice) then begin
     Address:=aValue and not TPasRISCVUInt64(15);
     if TPasRISCVUInt32(TPasRISCVUInt32($ffffffff)-Address)<TPasRISCVUInt32(BusDevice.fSize) then begin
      Address:=TPasRISCVUInt32(-BusDevice.fSize);
     end;
     Address:=Address and not TPasRISCVUInt64(15);
     TPasMPInterlocked.Write(BusDevice.fBase,Address);
    end;
{$endif}
   end;
   TPCI.PCI_REG_IRQ_PIN_LINE:begin
    TPasMPInterlocked.Write(Func.fIRQLine,aValue and $ff);
   end;
   TPCI.PCI_REG_EXPANSION_ROM:begin
{$ifdef NewPCI}
    if assigned(Func.fExpansionROM) then begin
     ROMAddress:=aValue and TPasRISCVUInt64($fffffffffffff000);
     ROMSize:=RoundUpToPowerOfTwo64(Func.fExpansionROM.fSize);
     ROMAddress:=ROMAddress and TPasRISCVUInt64(not TPasRISCVUInt64(ROMSize-1));
     TPasMPInterlocked.Write(Func.fExpansionROM.fBase,ROMAddress);
     TPasMPMemoryBarrier.ReadWrite;
    end;
{$endif}
   end;
  end;
 end;

end;

{ TPasRISCV.TPCIDevice }

constructor TPasRISCV.TPCIDevice.Create(const aBus:TPasRISCV.TPCIBusDevice);
begin
 inherited Create;
 fBus:=aBus;
end;

destructor TPasRISCV.TPCIDevice.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV.TPCIDevice.Reset;
begin
end;

procedure TPasRISCV.TPCIDevice.SendIRQ(const aFuncID,aMSIID:TPasRISCVUInt32);
var Func:TPasRISCV.TPCIFunc;
begin
 Func:=fFuncs[aFuncID];
 if assigned(Func) then begin
  Func.SendIRQ(aMSIID,false);
 end;
end;

procedure TPasRISCV.TPCIDevice.RaiseIRQ(const aFuncID,aMSIID:TPasRISCVUInt32);
var Func:TPasRISCV.TPCIFunc;
begin
 Func:=fFuncs[aFuncID];
 if assigned(Func) then begin
  Func.SendIRQ(aMSIID,true);
 end;
end;

procedure TPasRISCV.TPCIDevice.LowerIRQ(const aFuncID:TPasRISCVUInt32);
var Func:TPasRISCV.TPCIFunc;
begin
 Func:=fFuncs[aFuncID];
 if assigned(Func) then begin
  Func.LowerIRQ;
 end;
end;

function TPasRISCV.TPCIDevice.GetGlobalDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
begin
 result:=fBus.fMachine.fBus.GetDirectMemoryAccessPointer(aAddress,aSize,aWrite,aBounce);
end;

{ TPasRISCV.TPCIHostBridgeDevice }

constructor TPasRISCV.TPCIHostBridgeDevice.Create(const aBus:TPasRISCV.TPCIBusDevice);
var FuncDesc:TPasRISCV.TPCIFuncDescriptor;
begin
 inherited Create(aBus);
 FillChar(FuncDesc,SizeOf(FuncDesc),#0);
 FuncDesc.fVendorID:=$f15e;
 FuncDesc.fDeviceID:=$0000;
 FuncDesc.fClassCode:=$0600;
 fFuncs[0]:=TPasRISCV.TPCIFunc.Create(aBus,self,FuncDesc);
end;

destructor TPasRISCV.TPCIHostBridgeDevice.Destroy;
begin
 FreeAndNil(fFuncs[0]);
 inherited Destroy;
end;

{ TPasRISCV.TJobWorkerThread }

constructor TPasRISCV.TJobWorkerThread.Create(const aJobManager:TPasRISCV.TJobManager);
begin
 fJobManager:=aJobManager;
 inherited Create(false);
end;

destructor TPasRISCV.TJobWorkerThread.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV.TJobWorkerThread.Execute;
var Item:TJobQueueItem;
begin

 NameThreadForDebugging('TPasRISCV.TJobWorkerThread');

 while not Terminated do begin

  // Wait until there is something to do
  fJobManager.WaitForWakeUp;

  // Check if the thread is terminated
  if Terminated then begin

   break;

  end else begin

   // Loop until the queue is empty or the thread is terminated
   while not Terminated do begin

    // Dequeue the next item
    if fJobManager.fQueue.TryDequeue(Item) then begin

     case Item.fJobType of

      TPasRISCV.TJobQueueItem.TJobType.VirtIODeviceQueue:begin
       TPasRISCV.TVirtIODevice(Item.fObject).ProcessQueue(Item.fVirtIODeviceQueue,Item.fVirtIODeviceAvailableIndex);
      end;

      TPasRISCV.TJobQueueItem.TJobType.NVMeDeviceQueue:begin
       TPasRISCV.TNVMeDevice(Item.fObject).ProcessQueue(Item.fNVMeDeviceQueue,Item.fNVMeDeviceQueueValue,true);
      end;

      TPasRISCV.TJobQueueItem.TJobType.NVMeDeviceCommand:begin
       TPasRISCV.TNVMeDevice(Item.fObject).ProcessCommand(Item.fNVMeDeviceCommand);
      end;

      else begin
      end;

     end;

    end else begin

     // Queue is empty, wait for the next event
     break;

    end;

   end;

  end;

 end;

end;

{ TPasRISCV.TJobManager }

constructor TPasRISCV.TJobManager.Create(const aCountWorkerThreads:TPasRISCVSizeInt);
var Index:TPasRISCVSizeInt;
    JobWorkerThread:TPasRISCV.TJobWorkerThread;
begin

 fQueue:=TJobQueue.Create;

 fCountWorkerThreads:=aCountWorkerThreads;

 SetLength(fWorkerThreads,fCountWorkerThreads);

 fSleepingOnIdle:=true;

 fSleepingJobWorkerThreads:=0;

 fWakeUpCounter:=0;

 fWakeUpConditionVariableLock:=TPasMPConditionVariableLock.Create;

 fWakeUpConditionVariable:=TPasMPConditionVariable.Create;

 for Index:=0 to fCountWorkerThreads-1 do begin
  JobWorkerThread:=TPasRISCV.TJobWorkerThread.Create(self);
  fWorkerThreads[Index]:=JobWorkerThread;
 end;

 fSequence:=0;

end;

destructor TPasRISCV.TJobManager.Destroy;
var Item:TJobQueueItem;
    Index:TPasRISCVSizeInt;
begin

 Shutdown;

 while fQueue.TryDequeue(Item) do begin
  case Item.fJobType of
   TPasRISCV.TJobQueueItem.TJobType.VirtIODeviceQueue:begin
   end;
   TPasRISCV.TJobQueueItem.TJobType.NVMeDeviceCommand:begin
   end;
   else begin
   end;
  end;
 end;

 FreeAndNil(fQueue);

 for Index:=0 to fCountWorkerThreads-1 do begin
  FreeAndNil(fWorkerThreads[Index]);
 end;

 FreeAndNil(fWakeUpConditionVariable);
 FreeAndNil(fWakeUpConditionVariableLock);

 inherited Destroy;

end;

procedure TPasRISCV.TJobManager.Shutdown;
var Index:TPasRISCVSizeInt;
    JobWorkerThread:TPasRISCV.TJobWorkerThread;
begin
 for Index:=0 to fCountWorkerThreads-1 do begin
  JobWorkerThread:=fWorkerThreads[Index];
  if assigned(JobWorkerThread) then begin
   JobWorkerThread.Terminate;
  end;
 end;
 WakeUpAllWorkerThreads;
 for Index:=0 to fCountWorkerThreads-1 do begin
  JobWorkerThread:=fWorkerThreads[Index];
  if assigned(JobWorkerThread) then begin
   JobWorkerThread.WaitFor;
  end;
 end;
end;

procedure TPasRISCV.TJobManager.WaitForWakeUp;
var SavedWakeUpCounter:TPasMPInt32;
begin
 if fSleepingOnIdle then begin
  fWakeUpConditionVariableLock.Acquire;
  try
   TPasMPInterlocked.Increment(fSleepingJobWorkerThreads);
   TPasMPMemoryBarrier.Read;
   SavedWakeUpCounter:=fWakeUpCounter;
   TPasMPMemoryBarrier.ReadDependency;
   repeat
    fWakeUpConditionVariable.Wait(fWakeUpConditionVariableLock);
   until SavedWakeUpCounter<>fWakeUpCounter;
   TPasMPInterlocked.Decrement(fSleepingJobWorkerThreads);
  finally
   fWakeUpConditionVariableLock.Release;
  end;
 end else begin
  TPasMP.Yield;
 end;
end;

procedure TPasRISCV.TJobManager.WakeUpAllWorkerThreads;
begin
 if fSleepingJobWorkerThreads>0 then begin
  fWakeUpConditionVariableLock.Acquire;
  try
   inc(fWakeUpCounter);
   TPasMPMemoryBarrier.Write;
   fWakeUpConditionVariable.Broadcast;
  finally
   fWakeUpConditionVariableLock.Release;
  end;
 end;
end;

function TPasRISCV.TJobManager.EnqueueVirtIODeviceQueue(const aVirtIODevice:TVirtIODevice;const aVirtIODeviceQueue:TPasRISCVUInt32;const aVirtIODeviceAvailableIndex:TPasRISCVInt32):Boolean;
var Item:TJobQueueItem;
begin

 Item.fJobType:=TPasRISCV.TJobQueueItem.TJobType.VirtIODeviceQueue;
 Item.fObject:=aVirtIODevice;
 Item.fVirtIODeviceQueue:=aVirtIODeviceQueue;
 Item.fVirtIODeviceAvailableIndex:=aVirtIODeviceAvailableIndex;

 fQueue.Enqueue(Item);

 WakeUpAllWorkerThreads;

 result:=true;

end;

function TPasRISCV.TJobManager.EnqueueNVMeDeviceQueue(const aNVMeDevice:TNVMeDevice;const aNVMeDeviceQueue,aNVMeDeviceQueueValue:TPasRISCVUInt32):Boolean;
var Item:TJobQueueItem;
begin

 Item.fJobType:=TPasRISCV.TJobQueueItem.TJobType.NVMeDeviceQueue;
 Item.fObject:=aNVMeDevice;
 Item.fNVMeDeviceQueue:=aNVMeDeviceQueue;
 Item.fNVMeDeviceQueueValue:=aNVMeDeviceQueueValue;

 fQueue.Enqueue(Item);

 WakeUpAllWorkerThreads;

 result:=true;

end;

function TPasRISCV.TJobManager.EnqueueNVMeDeviceCommand(const aNVMeDevice:TNVMeDevice;const aNVMeDeviceCommand:TNVMeDeviceCommand):Boolean;
var Item:TJobQueueItem;
begin

 Item.fJobType:=TPasRISCV.TJobQueueItem.TJobType.NVMeDeviceCommand;
 Item.fObject:=aNVMeDevice;
 Item.fNVMeDeviceCommand:=aNVMeDeviceCommand;

 fQueue.Enqueue(Item);

 WakeUpAllWorkerThreads;

 result:=true;

end;

function TPasRISCV.TJobManager.EnqueueNVMeDeviceCommands(const aNVMeDevice:TNVMeDevice;const aNVMeDeviceCommands:TNVMeDeviceCommandDynamicArray;const aCount:TPasRISCVSizeInt):Boolean;
var Item:TJobQueueItem;
    Index:TPasRISCVSizeInt;
begin

 if aCount>0 then begin

  Item.fJobType:=TPasRISCV.TJobQueueItem.TJobType.NVMeDeviceCommand;
  Item.fObject:=aNVMeDevice;

  for Index:=0 to aCount-1 do begin

   Item.fNVMeDeviceCommand:=aNVMeDeviceCommands[Index];

   fQueue.Enqueue(Item);

  end;

  WakeUpAllWorkerThreads;

 end;

 result:=true;

end;

{ TPasRISCV.TNVMeDevice.TNVMeQueue }

class function TPasRISCV.TNVMeDevice.TNVMeQueue.GetNext(var aHeadOrTail:TPasRISCVUInt32;const aSize:TPasRISCVUInt32):TPasRISCVUInt32;
var Next:TPasRISCVUInt32;
begin
 result:=0;
 Next:=0;
 repeat
  TPasMPMemoryBarrier.ReadDependency;
  result:=TPasMPInterlocked.Read(aHeadOrTail);
  if result>=aSize then begin
   Next:=0;
  end else begin
   Next:=result+1;
  end;
 until TPasMPInterlocked.CompareExchange(aHeadOrTail,Next,result)=result;
end;

function TPasRISCV.TNVMeDevice.TNVMeQueue.GetAddress:TPasRISCVUInt64;
begin
 TPasMPMemoryBarrier.ReadDependency;
 result:=TPasMPInterlocked.Read(AddressLow);
 TPasMPMemoryBarrier.ReadDependency;
 result:=result or (TPasRISCVUInt64(TPasMPInterlocked.Read(AddressHigh)) shl 32);
end;

procedure TPasRISCV.TNVMeDevice.TNVMeQueue.RaiseIRQ(const aNVMEDevice:TNVMEDevice);
var IRQRegister,IRQVector,IRQMask:TPasRISCVUInt32;
begin
 IRQRegister:=TPasMPInterlocked.Read(IRQ);
 IRQVector:=(IRQRegister shr 16) and $1f;
 IRQMask:=TPasRISCVUInt32(1) shl (IRQVector and $1f);
 if ((IRQRegister and CQ_FLAGS_IEN)<>0) and ((TPasMPInterlocked.Read(aNVMEDevice.fIRQMask) and IRQMask)=0) then begin
  aNVMEDevice.fFuncs[0].RaiseIRQ(IRQVector);
 end;
end;

procedure TPasRISCV.TNVMeDevice.TNVMeQueue.LowerIRQ(const aNVMEDevice:TNVMEDevice);
var IRQRegister,IRQVector:TPasRISCVUInt32;
begin
 IRQRegister:=TPasMPInterlocked.Read(IRQ);
 IRQVector:=(IRQRegister shr 16) and $1f;
 aNVMEDevice.fFuncs[0].LowerIRQ(IRQVector);
end;

procedure TPasRISCV.TNVMeDevice.TNVMeQueue.Setup(const aNVMEDevice:TNVMEDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt32);
begin
 TPasMPInterlocked.Write(Head,0);
 TPasMPInterlocked.Write(Tail,0);
 TPasMPInterlocked.Write(AddressLow,TPasRISCVUInt32(aAddress and not NVME_PAGE_MASK));
 TPasMPInterlocked.Write(AddressHigh,TPasRISCVUInt32(aAddress shr 32));
 TPasMPInterlocked.Write(Size,aSize);
{$ifdef NVMELevelTriggeredPCIEInterrupts}
 LowerIRQ(aNVMEDevice);
{$endif}
end;

{ TPasRISCV.TNVMeDevice }

constructor TPasRISCV.TNVMeDevice.Create(const aBus:TPasRISCV.TPCIBusDevice);
var FuncDesc:TPasRISCV.TPCIFuncDescriptor;
    BARRegion:TPasRISCV.PPCIBARRegion;
    PCG32:TPCG32;
    Index:TPasRISCVSizeInt;
begin
 inherited Create(aBus);

 FillChar(FuncDesc,SizeOf(FuncDesc),#0);
 FuncDesc.fVendorID:=SSD_VendorID;
 FuncDesc.fDeviceID:=SSD_DeviceID;
 FuncDesc.fClassCode:=$0108; // Mass Storage Controller, Non-Volatile Memory Controller
 FuncDesc.fProgIF:=$02; // NVMHCI
 FuncDesc.fRevisionID:=0;
 FuncDesc.fIRQPin:=TPCI.PCI_IRQ_PIN_INTA;

 BARRegion:=@FuncDesc.fBARRegions[0];
{$ifdef NewPCI}
 BARRegion^.fAddress:=0;
{$else}
 BARRegion^.fAddress:=TPCI.PCI_BAR_ADDR_64;
{$endif}
 BARRegion^.fSize:=$4000;
 BARRegion^.fOnLoad:=OnLoad;
 BARRegion^.fOnStore:=OnStore;

 fFuncs[0]:=TPasRISCV.TPCIFunc.Create(aBus,self,FuncDesc);

{$ifdef NVMELevelTriggeredPCIEInterrupts}
 // Enable IEN on Admin Completion Queue
 fQueues[ADMIN_COMPLETION_QUEUE].IRQ:=CQ_FLAGS_IEN;
{$endif}

 // Random serial number
 PCG32.Init(GetCurrentTime xor TPasRISCVPtrUInt(self));
 for Index:=0 to 11 do begin
  fSerial[Index]:=TPasRISCV.SerialChars[PCG32.GetUnbiasedBounded(36) mod 36];
 end;

 fStreamLock:=TPasMPSlimReaderWriterLock.Create;

 fStream:=TMemoryStream.Create;

end;

destructor TPasRISCV.TNVMeDevice.Destroy;
begin
 FreeAndNil(fStream);
 FreeAndNil(fStreamLock);
 FreeAndNil(fFuncs[0]);
 inherited Destroy;
end;

procedure TPasRISCV.TNVMeDevice.ResetDevice;
var Index:TPasRISCVSizeInt;
    Queue:PNVMeQueue;
begin
 while TPasMPInterlocked.Read(fThreads)<>0 do begin
  sleep(1);
 end;
 for Index:=0 to length(fQueues)-1 do begin
  Queue:=@fQueues[Index];
  case Index of
   ADMIN_SUBMISSION_QUEUE,ADMIN_COMPLETION_QUEUE:begin
    Queue.Setup(self,Queue^.GetAddress,TPasMPInterlocked.Read(Queue^.Size));
   end;
   else begin
    Queue.Setup(self,0,0);
   end;
  end;
 end;
end;

procedure TPasRISCV.TNVMeDevice.CompleteCommand(const aCommand:PNVMeCommand;const aStatusField:TPasRISCVUInt32);
var Queue:PNVMeQueue;
    QueueSize,QueueTail,Phase{$ifndef NVMELevelTriggeredPCIEInterrupts},IRQVector,IRQMask{$endif}:TPasRISCVUInt32;
    Address:TPasRISCVUInt64;
    Ptr:PPasRISCVUInt8;
begin

 Queue:=@fQueues[(aCommand^.CompletionQueueID shl 1) or 1];

 TPasMPMemoryBarrier.ReadDependency;
 QueueSize:=Queue^.Size;

 QueueTail:=TNVMeQueue.GetNext(Queue^.Tail,QueueSize);

 Address:=Queue^.GetAddress+(QueueTail shl 4);

 Ptr:=GetGlobalDirectMemoryAccessPointer(Address,16,true,nil);
 if assigned(Ptr) then begin
  Phase:=(not PPasRISCVUInt32(@PPasRISCVUInt8Array(Ptr)[12])^) and $10000;
  PPasRISCVUInt32(@PPasRISCVUInt8Array(Ptr)[0])^:=aCommand^.CommandSpecificStatus;
  PPasRISCVUInt32(@PPasRISCVUInt8Array(Ptr)[4])^:=0;
  PPasRISCVUInt32(@PPasRISCVUInt8Array(Ptr)[8])^:=aCommand^.SqHeadID;
  PPasRISCVUInt32(@PPasRISCVUInt8Array(Ptr)[12])^:=aCommand^.CmdID or (aStatusField shl 17) or Phase;
 end;

{$ifdef NVMELevelTriggeredPCIEInterrupts}
 Queue^.RaiseIRQ(self);
{$else}
 IRQVector:=Queue^.IRQ shr 16;
 IRQMask:=TPasRISCVUInt32(1) shl (IRQVector and $1f);
 if (fIRQMask and IRQMask)=0 then begin
  SendIRQ(0,IRQMask);
 end;
{$endif}

end;

procedure TPasRISCV.TNVMeDevice.CompleteCommand(const aCommand:PNVMeCommand;const aStatusField,aCommandSpecificStatus:TPasRISCVUInt32);
begin
 aCommand^.CommandSpecificStatus:=aCommandSpecificStatus;
 CompleteCommand(aCommand,aStatusField);
end;

function TPasRISCV.TNVMeDevice.ProcessPRPChunk(const aCommand:PNVMeCommand):TPasRISCVUInt64;
var PRP:PNVMePRPCtx;
    Address:TPasRISCVUInt64;
    Size:TPasRISCVUInt64;
begin

 PRP:=@aCommand^.PRP;
 Address:=PRP^.PRP1;
 Size:=NVME_PAGE_SIZE;

 if PRP^.Current>=PRP^.Size then begin
  result:=0;
 end else begin

  if PRP^.Current=0 then begin
   Size:=NVME_PAGE_SIZE-(PRP^.PRP1 and NVME_PAGE_MASK);
   if (Size<PRP^.Size) and (PRP^.Size<=(NVME_PAGE_SIZE+Size)) then begin
    PRP^.PRP1:=PRP^.PRP2;
    if PRP^.PRP1=(Address+Size) then begin
     inc(Size,NVME_PAGE_SIZE);
    end;
    if Size>=PRP^.Size then begin
     Size:=PRP^.Size;
    end;
    PRP^.Current:=Size;
    result:=Size;
    exit;
   end else if Size>=PRP^.Size then begin
    PRP^.Current:=PRP^.Size;
    result:=PRP^.Size;
    exit;
   end;
  end;

  while (PRP^.Current+Size)<PRP^.Size do begin
   if not assigned(PRP^.PRP2DMA) then begin
    PRP^.PRP2DMA:=GetGlobalDirectMemoryAccessPointer(PRP^.PRP2,NVME_PAGE_SIZE,true,nil);
   end;
   if assigned(PRP^.PRP2DMA) then begin
    PRP^.PRP1:=PPasRISCVUInt64(TPasRISCVPtrUInt(TPasRISCVPtrUInt(PRP^.PRP2DMA)+PRP^.PRP2Offset))^;
    inc(PRP^.PRP2Offset,8);
    if PRP^.PRP2Offset>=NVME_PRP2_END then begin
     PRP^.PRP2:=PPasRISCVUInt64(TPasRISCVPtrUInt(TPasRISCVPtrUInt(PRP^.PRP2DMA)+NVME_PRP2_END))^;
     PRP^.PRP2Offset:=0;
     PRP^.PRP2DMA:=GetGlobalDirectMemoryAccessPointer(PRP^.PRP2,NVME_PAGE_SIZE,true,nil);
    end;
   end else begin
    // DMA error
    CompleteCommand(aCommand,SC_DATA_ERR);
    result:=0;
    exit;
   end;

   // Non-continuous page, split the chunk
   if PRP^.PRP1<>(Address+Size) then begin
    break;
   end;
   inc(Size,NVME_PAGE_SIZE);
  end;

  if (PRP^.Current+Size)>PRP^.Size then begin
   Size:=PRP^.Size-PRP^.Current;
  end;

  inc(PRP^.Current,Size);
  result:=Size;

 end;

end;

function TPasRISCV.TNVMeDevice.GetPRPChunk(const aCommand:PNVMeCommand;out aSize:TPasRISCVUInt64):Pointer;
var PRP:PNVMePRPCtx;
    Address:TPasRISCVUInt64;
    Size:TPasRISCVUInt64;
begin
 PRP:=@aCommand^.PRP;
 Address:=PRP^.PRP1;
 Size:=ProcessPRPChunk(aCommand);
 if Size=0 then begin
  result:=nil;
 end else begin
  aSize:=Size;
  result:=GetGlobalDirectMemoryAccessPointer(Address,Size,true,nil);
  if not assigned(result) then begin
   CompleteCommand(aCommand,SC_DATA_ERR);
  end;
 end;
end;

function TPasRISCV.TNVMeDevice.WritePRP(const aCommand:PNVMeCommand;const aData:Pointer;const aSize:TPasRISCVUInt64):Boolean;
var Src:PPasRISCVUInt8;
    Dest:PPasRISCVUInt8;
    Size:TPasRISCVUInt64;
begin
 Src:=aData;
 aCommand^.PRP.Size:=aSize;
 while aCommand^.PRP.Current<aCommand^.PRP.Size do begin
  Dest:=GetPRPChunk(aCommand,Size);
  if assigned(Dest) then begin
   Move(Src^,Dest^,Size);
   inc(Src,Size);
  end else begin
   result:=false;
   exit;
  end;
 end;
 result:=true;
end;

procedure TPasRISCV.TNVMeDevice.Identify(const aCommand:PNVMeCommand);
const ID:RawByteString='nqn.2024-12.pasriscv:nvme:';
      NVMeStr:RawByteString='NVMe Storage';
      R947Str:RawByteString='R947';
var Ptr:PPasRISCVUInt8;
    LBASize:TPasRISCVUInt64;
    OK:Boolean;
    s:TPasRISCVRawByteString;
begin
 GetMem(Ptr,NVME_PAGE_SIZE);
 try
  FillChar(Ptr^,NVME_PAGE_SIZE,#0);
//writeln('Admin command identify: ',LowerCase(IntToHex(PPasRISCVUInt8Array(aCommand^.Ptr)^[40])));
  case PPasRISCVUInt8Array(aCommand^.Ptr)^[40] of
   IDENT_NS:begin
    LBASize:=fStream.Size shr NVME_LBAS;
    PPasRISCVUInt64(@PPasRISCVUInt8Array(Ptr)^[0])^:=LBASize;
    PPasRISCVUInt64(@PPasRISCVUInt8Array(Ptr)^[8])^:=LBASize;
    PPasRISCVUInt64(@PPasRISCVUInt8Array(Ptr)^[16])^:=LBASize;
    PPasRISCVUInt8Array(Ptr)^[33]:=$8;
    PPasRISCVUInt8Array(Ptr)^[130]:=NVME_LBAS;
    OK:=true;
   end;
   IDENT_CTRL:begin
    PPasRISCVUInt16(@PPasRISCVUInt8Array(Ptr)^[0])^:=SSD_VendorID; // PCI Vendor ID
    PPasRISCVUInt16(@PPasRISCVUInt8Array(Ptr)^[2])^:=SSD_VendorID; // PCI Vendor ID
    Move(fSerial,PPasRISCVUInt8Array(Ptr)^[4],SizeOf(fSerial)); // Serial Number
    Move(NVMeStr[1],PPasRISCVUInt8Array(Ptr)^[24],Length(NVMeStr)); // Model Number
    Move(R947Str[1],PPasRISCVUInt8Array(Ptr)^[64],Length(R947Str)); // Firmware Revision
    PPasRISCVUInt32(@PPasRISCVUInt8Array(Ptr)^[80])^:=NVME_VERSION; // Version
    PPasRISCVUInt8Array(Ptr)^[111]:=$1; // Controller Type: I/O Controller
    PPasRISCVUInt8Array(Ptr)^[512]:=$66; // Submission Queue Max/Cur Entry Size
    PPasRISCVUInt8Array(Ptr)^[513]:=$44; // Completion Queue Max/Cur Entry Size
    PPasRISCVUInt8Array(Ptr)^[516]:=$1; // Number of Namespaces
    PPasRISCVUInt8Array(Ptr)^[520]:=$c; // Supports Write Zeroes, Dataset Management
    // NVMe Qualified Name including serial to distinguish targets
    s:=ID;
    SetLength(s,length(s)+SizeOf(fSerial));
    Move(fSerial[0],s[length(s)-SizeOf(fSerial)],SizeOf(fSerial));
    Move(s[1],PPasRISCVUInt8Array(Ptr)[768],length(s));
    OK:=true;
   end;
   IDENT_NSLS:begin
    PPasRISCVUInt32(@PPasRISCVUInt8Array(Ptr)^[0])^:=$1;
    OK:=true;
   end;
   IDENT_NIDS:begin
    PPasRISCVUInt8Array(Ptr)^[0]:=$3;
    PPasRISCVUInt8Array(Ptr)^[1]:=$10;
    OK:=true;
   end;
   else begin
    OK:=false;
   end;
  end;
  if OK then begin
   if WritePRP(aCommand,Ptr,NVME_PAGE_SIZE) then begin
    CompleteCommand(aCommand,SC_SUCCESS);
   end;
  end else begin
   CompleteCommand(aCommand,SC_BAD_FIELD);
  end;
 finally
  FreeMem(Ptr);
 end;
end;

procedure TPasRISCV.TNVMeDevice.CreateIOSubmissionQueue(const aCommand:PNVMeCommand);
var Address:TPasRISCVUInt64;
    SubmissionQueueID,SubmissionQueueSize,CompletionQueueFlag,CompletionQueueID:TPasRISCVUInt32;
    Queue:PNVMeQueue;
begin
 Address:=aCommand^.PRP.PRP1;
 SubmissionQueueID:=PPasRISCVUInt16(@PPasRISCVUInt8Array(aCommand^.Ptr)[40])^;
 SubmissionQueueSize:=PPasRISCVUInt16(@PPasRISCVUInt8Array(aCommand^.Ptr)[42])^;
 CompletionQueueFlag:=PPasRISCVUInt32(@PPasRISCVUInt8Array(aCommand^.Ptr)[44])^;
 CompletionQueueID:=CompletionQueueFlag shr 16;
 if (SubmissionQueueID=0) or (SubmissionQueueID>NVME_MAX_QUEUES) then begin
  CompleteCommand(aCommand,SC_BAD_FIELD,CS_ID_INVALID);
 end else if (CompletionQueueID=0) or (CompletionQueueID>NVME_MAX_QUEUES) then begin
  CompleteCommand(aCommand,SC_BAD_FIELD,CS_CQ_INVALID);
 end else if SubmissionQueueSize=0 then begin
  CompleteCommand(aCommand,SC_BAD_FIELD,CS_SIZE_INVALID);
{$ifdef NVMELevelTriggeredPCIEInterrupts}
 end else if (CompletionQueueFlag and CQ_FLAGS_PC)=0 then begin
  CompleteCommand(aCommand,SC_BAD_FIELD);
{$endif}
 end else begin
  Queue:=@fQueues[SubmissionQueueID shl 1];
  Queue^.Setup(self,Address,SubmissionQueueSize);
  TPasMPInterlocked.Write(Queue^.CompletionQueueID,CompletionQueueID);
  CompleteCommand(aCommand,SC_SUCCESS);
 end;
end;

procedure TPasRISCV.TNVMeDevice.CreateIOCompletionQueue(const aCommand:PNVMeCommand);
var Address:TPasRISCVUInt64;
    CompletionQueueID,CompletionQueueSize,CompletionQueueFlag:TPasRISCVUInt32;
    Queue:PNVMeQueue;
begin
 Address:=aCommand^.PRP.PRP1;
 CompletionQueueID:=PPasRISCVUInt16(@PPasRISCVUInt8Array(aCommand^.Ptr)[40])^;
 CompletionQueueSize:=PPasRISCVUInt16(@PPasRISCVUInt8Array(aCommand^.Ptr)[42])^;
 CompletionQueueFlag:=PPasRISCVUInt32(@PPasRISCVUInt8Array(aCommand^.Ptr)[44])^;
 if (CompletionQueueID=0) or (CompletionQueueID>NVME_MAX_QUEUES) then begin
  CompleteCommand(aCommand,SC_BAD_FIELD,CS_ID_INVALID);
 end else if CompletionQueueSize=0 then begin
  CompleteCommand(aCommand,SC_BAD_FIELD,CS_SIZE_INVALID);
{$ifdef NVMELevelTriggeredPCIEInterrupts}
 end else if (CompletionQueueFlag and CQ_FLAGS_PC)=0 then begin
  CompleteCommand(aCommand,SC_BAD_FIELD);
{$endif}
 end else begin
  Queue:=@fQueues[(CompletionQueueID shl 1) or 1];
  Queue^.Setup(self,Address,CompletionQueueSize);
  TPasMPInterlocked.Write(Queue^.IRQ,CompletionQueueFlag);
  CompleteCommand(aCommand,SC_SUCCESS);
 end;
end;

procedure TPasRISCV.TNVMeDevice.DeleteIOQueue(const aCommand:PNVMeCommand;const aIsCompletionQueue:Boolean);
var QueueID:TPasRISCVUInt32;
    Queue:PNVMeQueue;
begin
 QueueID:=PPasRISCVUInt16(@PPasRISCVUInt8Array(aCommand^.Ptr)[40])^;
 if (QueueID=0) or (QueueID>NVME_MAX_QUEUES) then begin
  CompleteCommand(aCommand,SC_BAD_FIELD,CS_ID_INVALID);
 end else begin
  Queue:=@fQueues[(QueueID shl 1) or (ord(aIsCompletionQueue) and 1)];
  Queue^.Setup(self,0,0);
  CompleteCommand(aCommand,SC_SUCCESS);
 end;
end;

procedure TPasRISCV.TNVMeDevice.AdminCommand(const aCommand:PNVMeCommand);
begin
//writeln('Admin command opcode: ',LowerCase(IntToHex(PPasRISCVUInt8Array(aCommand^.Ptr)^[0],8)));
 case PPasRISCVUInt8Array(aCommand^.Ptr)^[0] of
  ADMIN_IDENTIFY:begin
   Identify(aCommand);
  end;
  ADMIN_CREATE_IO_SQ:begin
   CreateIOSubmissionQueue(aCommand);
  end;
  ADMIN_CREATE_IO_CQ:begin
   CreateIOCompletionQueue(aCommand);
  end;
  ADMIN_DELETE_IO_SQ:begin
   DeleteIOQueue(aCommand,false);
  end;
  ADMIN_DELETE_IO_CQ:begin
   DeleteIOQueue(aCommand,true);
  end;
  ADMIN_SET_FEATURES,ADMIN_GET_FEATURES:begin
   case PPasRISCVUInt8Array(aCommand^.Ptr)^[40] of
    FEAT_NUM_QUEUES:begin
     CompleteCommand(aCommand,SC_SUCCESS,NVME_FEAT_NQES);
    end;
    FEAT_TEMP_THRESH:begin
     CompleteCommand(aCommand,SC_SUCCESS,0);
    end;
    FEAT_WR_ATOMIC:begin
     CompleteCommand(aCommand,SC_SUCCESS,0);
    end;
    FEAT_IRQ_COALESC:begin
     CompleteCommand(aCommand,SC_SUCCESS,0);
    end;
    FEAT_IRQ_VECTOR:begin
     CompleteCommand(aCommand,SC_SUCCESS,0);
    end;
    else begin
     CompleteCommand(aCommand,SC_BAD_FIELD);
    end;
   end;
  end;
  ADMIN_ABORT:begin
   CompleteCommand(aCommand,SC_SUCCESS);
  end;
  else begin
   CompleteCommand(aCommand,SC_BAD_OPCODE);
  end;
 end;
end;

procedure TPasRISCV.TNVMeDevice.IOCommand(const aCommand:PNVMeCommand);
var Opcode:TPasRISCVUInt8;
    Pos:TPasRISCVUInt64;
    Buffer:Pointer;
    Size,ToDo,Temporary:TPasRISCVUInt64;
begin
 Opcode:=PPasRISCVUInt8Array(aCommand^.Ptr)^[0];
 Pos:=PPasRISCVUInt64(@PPasRISCVUInt8Array(aCommand^.Ptr)^[40])^ shl NVME_LBAS;
 case Opcode of
  NVM_READ,NVM_WRITE:begin
   while aCommand^.PRP.Current<aCommand^.PRP.Size do begin
    Buffer:=GetPRPChunk(aCommand,Size);
    if assigned(Buffer) then begin
     fStreamLock.Acquire;
     try
      fStream.Seek(Pos,soBeginning);
      if Opcode=NVM_WRITE then begin
       Temporary:=fStream.Write(Buffer^,Size);
      end else begin
       Temporary:=fStream.Read(Buffer^,Size);
      end;
     finally
      fStreamLock.Release;
     end;
     if Temporary<>Size then begin
      CompleteCommand(aCommand,SC_DATA_ERR);
      exit;
     end;
     inc(Pos,Size);
    end else begin
     exit;
    end;
   end;
   CompleteCommand(aCommand,SC_SUCCESS);
  end;
  NVM_FLUSH:begin
   fStreamLock.Acquire;
   try
    if FlushStream(fStream) then begin
     CompleteCommand(aCommand,SC_SUCCESS);
    end else begin
     CompleteCommand(aCommand,SC_DATA_ERR);
    end;
   finally
    fStreamLock.Release;
   end;
  end;
  NVM_WRITEZ:begin
   Size:=aCommand^.PRP.Size;
   if Size>0 then begin
    fStreamLock.Acquire;
    try
     fStream.Seek(Pos,soBeginning);
     while Size>0 do begin
      if Size<SizeOf(TZeroBuffer) then begin
       ToDo:=Size;
      end else begin
       ToDo:=SizeOf(TZeroBuffer);
      end;
      fStream.Write(ZeroBuffer[0],ToDo);
      dec(Size,ToDo);
     end;
    finally
     fStreamLock.Release;
    end;
   end;
  end;
  NVM_DTSM:begin
   if (PPasRISCVUInt8Array(aCommand^.Ptr)^[44] and 4)<>0 then begin
    aCommand^.PRP.Size:=((TPasRISCVUInt64(PPasRISCVUInt8Array(aCommand^.Ptr)^[40]))+1) shl 4;
    while aCommand^.PRP.Current<aCommand^.PRP.Size do begin
     Buffer:=GetPRPChunk(aCommand,Size);
     if assigned(Buffer) then begin
      Temporary:=0;
      while (Temporary+16)<=Size do begin
       Pos:=TPasRISCVUInt64(PPasRISCVUInt32(@PPasRISCVUInt8Array(Buffer)^[4])^) shl NVME_LBAS;
       Size:=PPasRISCVUInt64(@PPasRISCVUInt8Array(Buffer)^[8])^ shl NVME_LBAS;
       if Size>0 then begin
        fStreamLock.Acquire;
        try
         fStream.Seek(Pos,soBeginning);
         while Size>0 do begin
          if Size<SizeOf(TZeroBuffer) then begin
           ToDo:=Size;
          end else begin
           ToDo:=SizeOf(TZeroBuffer);
          end;
          fStream.Write(ZeroBuffer[0],ToDo);
          dec(Size,ToDo);
         end;
        finally
         fStreamLock.Release;
        end;
       end;
       inc(Temporary,16);
      end;
     end else begin
      exit;
     end;
    end;
   end;
   CompleteCommand(aCommand,SC_SUCCESS);
  end;
  else begin
   CompleteCommand(aCommand,SC_BAD_OPCODE);
  end;
 end;
end;

procedure TPasRISCV.TNVMeDevice.ProcessCommand(const aCommand:TNVMeDeviceCommand);
var SubmissionQueue:PNVMeQueue;
    SubmissionQueueAddress:TPasRISCVUInt64;
    Ptr:Pointer;
    Command:TNVMeCommand;
begin

 SubmissionQueue:=@fQueues[aCommand.SubmissionQueueID shl 1];

 SubmissionQueueAddress:=SubmissionQueue^.GetAddress;

 Ptr:=GetGlobalDirectMemoryAccessPointer(SubmissionQueueAddress+(aCommand.SubmissionQueueHead shl 6),64,false,nil);
 if assigned(Ptr) then begin

  FillChar(Command,SizeOf(TNVMeCommand),#0);
  Command.Ptr:=Ptr;
  Command.PRP.PRP1:=PPasRISCVUInt64(@PPasRISCVUInt8Array(Ptr)[24])^;
  Command.PRP.PRP2:=PPasRISCVUInt64(@PPasRISCVUInt8Array(Ptr)[32])^;
  Command.PRP.PRP2DMA:=nil;
  Command.PRP.PRP2Offset:=0;
  Command.PRP.Size:=(PPasRISCVUInt16(@PPasRISCVUInt8Array(Ptr)[48])^+1) shl NVME_LBAS;
  Command.PRP.Current:=0;
  Command.CmdID:=PPasRISCVUInt16(@PPasRISCVUInt8Array(Ptr)[2])^;
  Command.SqHeadID:=aCommand.SubmissionQueueHead or (TPasRISCVUInt32(aCommand.SubmissionQueueID) shl 16);
  Command.CompletionQueueID:=SubmissionQueue^.CompletionQueueID;
  Command.CommandSpecificStatus:=0;

  case aCommand.SubmissionQueueID of
   ADMIN_SUBMISSION_QUEUE:begin
    AdminCommand(@Command);
   end;
   else begin
    IOCommand(@Command);
   end;
  end;

 end;

 TPasMPInterlocked.Decrement(fThreads);

end;

procedure TPasRISCV.TNVMeDevice.ProcessQueue(const aSubmissionQueueID:TPasRISCVUInt32;const aValue:TPasRISCVUInt16;const aLocking:Boolean);
var Queue:PNVMeQueue;
    QueueSize,QueueTail,QueueHead:TPasRISCVUInt32;
    Command:TNVMeDeviceCommand;
begin

 Queue:=@fQueues[aSubmissionQueueID shl 1];

 TPasMPMemoryBarrier.ReadDependency;
 QueueSize:=Queue^.Size;

 TPasMPMemoryBarrier.ReadDependency;
 QueueTail:=Queue^.Tail;

 repeat
  TPasMPMemoryBarrier.ReadDependency;
  if Queue^.Head<>QueueTail then begin
   QueueHead:=TNVMeQueue.GetNext(Queue^.Head,QueueSize);
   Command.SubmissionQueueID:=aSubmissionQueueID;
   Command.SubmissionQueueHead:=QueueHead;
   TPasMPInterlocked.Increment(fThreads);
   if aSubmissionQueueID<>0 then begin
    if not fBus.fMachine.fJobManager.EnqueueNVMeDeviceCommand(self,Command) then begin
     ProcessCommand(Command);
    end;
   end else begin
    ProcessCommand(Command);
   end;
  end else begin
   break;
  end;
 until false;

end;

procedure TPasRISCV.TNVMeDevice.Doorbell(const aQueueID:TPasRISCVUInt32;const aValue:TPasRISCVUInt16);
var Queue:PNVMeQueue;
    QueueSize:TPasRISCVUInt32;
begin

 Queue:=@fQueues[aQueueID];

 TPasMPMemoryBarrier.ReadDependency;
 QueueSize:=Queue^.Size;

 if aValue<=QueueSize then begin

  if (aQueueID and 1)<>0 then begin

   TPasMPMemoryBarrier.ReadWrite;
   Queue^.Head:=aValue;

{$ifdef NVMELevelTriggeredPCIEInterrupts}
   TPasMPMemoryBarrier.ReadDependency;
   if Queue^.Tail=aValue then begin
    Queue^.LowerIRQ(self);
   end;
{$endif}

  end else begin

   TPasMPMemoryBarrier.ReadWrite;
   Queue^.Tail:=aValue;
   TPasMPMemoryBarrier.ReadDependency;

// ProcessQueue(aQueueID shr 1,aValue,false);
   if not fBus.fMachine.fJobManager.EnqueueNVMeDeviceQueue(self,aQueueID shr 1,aValue) then begin
    ProcessQueue(aQueueID shr 1,aValue,false);
   end;

  end;

 end;

end;

function TPasRISCV.TNVMeDevice.OnLoad(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address,Conf:TPasRISCVUInt64;
begin
 Address:=aAddress-aPCIMemoryDevice.fBase;
 if aSize=4 then begin
  case Address of
   NVME_REG_CAP1:begin
    result:=NVME_CAP1_MQES or NVME_CAP1_CQR0 or NVME_CAP1_TO;
   end;
   NVME_REG_CAP2:begin
    result:=NVME_CAP2_CSS;
   end;
   NVME_REG_VS:begin
    result:=NVME_VERSION;
   end;
   NVME_REG_INTMS,NVME_REG_INTMC:begin
    TPasMPMemoryBarrier.ReadDependency;
    result:=fIRQMask;
   end;
   NVME_REG_CC:begin
    TPasMPMemoryBarrier.ReadDependency;
    Conf:=fConf;
    result:=(Conf and NVME_CC_EN) or NVME_CC_IOQES;
   end;
   NVME_REG_CSTS:begin
    TPasMPMemoryBarrier.ReadDependency;
    Conf:=fConf;
    result:=Conf and NVME_CSTS_RDY;
    if (Conf and NVME_CC_SHN)<>0 then begin
     result:=result or NVME_CSTS_SHST;
    end;
   end;
   NVME_REG_AQA:begin
    TPasMPMemoryBarrier.ReadDependency;
    result:=fQueues[ADMIN_SUBMISSION_QUEUE].Size or (fQueues[ADMIN_COMPLETION_QUEUE].Size shl 16);
    TPasMPMemoryBarrier.ReadDependency;
    result:=result or (fQueues[ADMIN_COMPLETION_QUEUE].Size shl 16);
   end;
   NVME_REG_ASQ1:begin
    TPasMPMemoryBarrier.ReadDependency;
    result:=fQueues[ADMIN_SUBMISSION_QUEUE].AddressLow;
   end;
   NVME_REG_ASQ2:begin
    TPasMPMemoryBarrier.ReadDependency;
    result:=fQueues[ADMIN_SUBMISSION_QUEUE].AddressHigh;
   end;
   NVME_REG_ACQ1:begin
    TPasMPMemoryBarrier.ReadDependency;
    result:=fQueues[ADMIN_COMPLETION_QUEUE].AddressLow;
   end;
   NVME_REG_ACQ2:begin
    TPasMPMemoryBarrier.ReadDependency;
    result:=fQueues[ADMIN_COMPLETION_QUEUE].AddressHigh;
   end;
   else begin
    result:=0;
   end;
  end;
//writeln('NVMe Read ',LowerCase(IntToHex(Address,8)),' ',LowerCase(IntToHex(result,8)));
 end else begin
  result:=0;
 end;
end;

procedure TPasRISCV.TNVMeDevice.OnStore(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address,QueueID:TPasRISCVUInt64;
begin
 Address:=aAddress-aPCIMemoryDevice.fBase;
 if aSize=4 then begin
//writeln('NVMe Write ',LowerCase(IntToHex(Address,8)),' ',LowerCase(IntToHex(aValue,8)));
  if Address>=$1000 then begin
   QueueID:=(Address-$1000) shr 2;
   if QueueID<NVME_NQUEUES then begin
    Doorbell(QueueID,aValue);
   end;
  end else begin
   case Address of
    NVME_REG_INTMS:begin
     TPasMPInterlocked.BitwiseOr(fIRQMask,TPasRISCVUInt32(aValue));
    end;
    NVME_REG_INTMC:begin
     TPasMPInterlocked.BitwiseAnd(fIRQMask,TPasRISCVUInt32(not TPasRISCVUInt32(aValue)));
    end;
    NVME_REG_CC:begin
     TPasMPInterlocked.Write(fConf,TPasRISCVUInt32(aValue));
     if ((aValue and NVME_CC_SHN)<>0) or ((aValue and NVME_CC_EN)=0) then begin
      ResetDevice;
     end;
    end;
    NVME_REG_AQA:begin
     TPasMPInterlocked.Write(fQueues[ADMIN_SUBMISSION_QUEUE].Size,TPasRISCVUInt32(aValue and $fff));
     TPasMPInterlocked.Write(fQueues[ADMIN_COMPLETION_QUEUE].Size,TPasRISCVUInt32((aValue shr 16) and $fff));
    end;
    NVME_REG_ASQ1:begin
     TPasMPInterlocked.Write(fQueues[ADMIN_SUBMISSION_QUEUE].AddressLow,TPasRISCVUInt32(aValue) and TPasRISCVUInt32($fffff000));
    end;
    NVME_REG_ASQ2:begin
     TPasMPInterlocked.Write(fQueues[ADMIN_SUBMISSION_QUEUE].AddressHigh,TPasRISCVUInt32(aValue));
    end;
    NVME_REG_ACQ1:begin
     TPasMPInterlocked.Write(fQueues[ADMIN_COMPLETION_QUEUE].AddressLow,TPasRISCVUInt32(aValue) and TPasRISCVUInt32($fffff000));
    end;
    NVME_REG_ACQ2:begin
     TPasMPInterlocked.Write(fQueues[ADMIN_COMPLETION_QUEUE].AddressHigh,TPasRISCVUInt32(aValue));
    end;
   end;
  end;
 end;
end;

procedure TPasRISCV.TNVMeDevice.AttachStream(const aStream:TStream);
begin
 FreeAndNil(fStream);
 if assigned(aStream) then begin
  fStream:=aStream;
 end else begin
  fStream:=TMemoryStream.Create;
  TMemoryStream(fStream).SetSize(1 shl 20);
 end;
end;

procedure TPasRISCV.TNVMeDevice.LoadFromStream(const aStream:TStream);
begin
 if fStream is TMemoryStream then begin
  TMemoryStream(fStream).Clear;
 end;
 aStream.Seek(0,soBeginning);
 fStream.CopyFrom(aStream,aStream.Size);
end;

procedure TPasRISCV.TNVMeDevice.LoadFromFile(const aFileName:TPasRISCVUTF8String);
var Stream:TFileStream;
begin
 Stream:=TFileStream.Create(aFileName,fmOpenRead); // or fmShareDenyWrite);
 try
  LoadFromStream(Stream);
 finally
  Stream.Free;
 end;
end;

procedure TPasRISCV.TNVMeDevice.SaveToStream(const aStream:TStream);
begin
 fStream.Seek(0,soBeginning);
 aStream.Seek(0,soBeginning);
 aStream.CopyFrom(fStream,fStream.Size);
end;

procedure TPasRISCV.TNVMeDevice.SaveToFile(const aFileName:TPasRISCVUTF8String);
var Stream:TFileStream;
begin
 Stream:=TFileStream.Create(aFileName,fmCreate); // or fmShareDenyWrite);
 try
  SaveToStream(Stream);
 finally
  Stream.Free;
 end;
end;

{ TPasRISCV.TVirtIODevice }

constructor TPasRISCV.TVirtIODevice.Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64;const aKind:TVirtIODevice.TKind);
var Index:TPasRISCVSizeInt;
    Queue:PQueue;
begin
 inherited Create(aMachine,aBase,aSize);
 fKind:=aKind;
 fUseQueueDescriptorCaching:=false;
 fIRQ:=0;
 fIntStatus:=0;
 fStatus:=0;
 fDriverOK:=false;
 fDeviceFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1 or
                  //TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX or
                  0;
 fDriverFeatures:=0;
 fActiveFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1;
 fDeviceFeaturesSelected:=0;
 fDriverFeaturesSelected:=0;
 fSelectedQueue:=0;
 for Index:=0 to MAXIMUM_COUNT_QUEUES-1 do begin
  Queue:=@fQueues[Index];
  Queue^.Ready:=false;
  Queue^.Lock:=0;
  Queue^.Size:=MAXIMUM_QUEUE_SIZE;
  Queue^.UsedRingEvent:=false;
  Queue^.ShadowAvailableIndex:=0;
  Queue^.ShadowUsedIndex:=0;
  Queue^.DescriptorAddress:=0;
  Queue^.AvailableAddress:=0;
  Queue^.UsedAddress:=0;
  Queue^.ManualRecv:=false;
  Queue^.Asynchronous:=false;
  Queue^.ReadDescriptors:=nil;
  Queue^.WriteDescriptors:=nil;
  Queue^.CountReadDescriptors:=0;
  Queue^.CountWriteDescriptors:=0;
 end;
 fDeviceID:=0;
 fVendorID:=$ffff;
 fConfigSpaceSize:=0;
 FillChar(fConfigSpace,SizeOf(fConfigSpace),#0);
 DeviceReset;
end;

destructor TPasRISCV.TVirtIODevice.Destroy;
var Index:TPasRISCVSizeInt;
    Queue:PQueue;
begin
 for Index:=0 to MAXIMUM_COUNT_QUEUES-1 do begin
  Queue:=@fQueues[Index];
  Queue^.ReadDescriptors:=nil;
  Queue^.WriteDescriptors:=nil;
 end;
 inherited Destroy;
end;

procedure TPasRISCV.TVirtIODevice.DeviceReset;
var Index:TPasRISCVSizeInt;
    Queue:PQueue;
begin
 fDriverOK:=false;
 fStatus:=0;
 fSelectedQueue:=0;
 fActiveFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1;
 fDeviceFeaturesSelected:=0;
 fDriverFeaturesSelected:=0;
 TPasMPInterlocked.Write(fIntStatus,0);
 UpdateIRQ;
 for Index:=0 to MAXIMUM_COUNT_QUEUES-1 do begin
  Queue:=@fQueues[Index];
  Queue^.Ready:=false;
  Queue^.Size:=MAXIMUM_QUEUE_SIZE;
  Queue^.ShadowAvailableIndex:=0;
  Queue^.ShadowUsedIndex:=0;
  Queue^.UsedRingEvent:=false;
  Queue^.DescriptorAddress:=0;
  Queue^.AvailableAddress:=0;
  Queue^.UsedAddress:=0;
 end;
end;

procedure TPasRISCV.TVirtIODevice.DeviceDriverOK;
begin
end;

procedure TPasRISCV.TVirtIODevice.DeviceConfigWrite;
begin
end;

procedure TPasRISCV.TVirtIODevice.DeviceInitialize;
begin
end;

function TPasRISCV.TVirtIODevice.DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean;
begin
 result:=false;
end;

function TPasRISCV.TVirtIODevice.Read8(const aPhysicalAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt8):Boolean;
var p:Pointer;
begin
 p:=GetGlobalDirectMemoryAccessPointer(aPhysicalAddress,SizeOf(TPasRISCVUInt8),false,nil);
 result:=assigned(p);
 if result then begin
  aValue:=PPasRISCVUInt8(p)^;
 end else begin
  aValue:=0;
 end;
end;

function TPasRISCV.TVirtIODevice.Write8(const aPhysicalAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt8):Boolean;
var p:Pointer;
begin
 p:=GetGlobalDirectMemoryAccessPointer(aPhysicalAddress,SizeOf(TPasRISCVUInt8),true,nil);
 result:=assigned(p);
 if result then begin
  PPasRISCVUInt8(p)^:=aValue;
 end;
end;

function TPasRISCV.TVirtIODevice.Read16(const aPhysicalAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt16):Boolean;
var p:Pointer;
begin
 result:=false;
 if (aPhysicalAddress and 1)<>0 then begin
  aValue:=0;
 end else begin
  p:=GetGlobalDirectMemoryAccessPointer(aPhysicalAddress,SizeOf(TPasRISCVUInt16),false,nil);
  if assigned(p) then begin
   aValue:=PPasRISCVUInt16(p)^;
   result:=true;
  end else begin
   aValue:=0;
  end;
 end;
end;

function TPasRISCV.TVirtIODevice.Write16(const aPhysicalAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt16):Boolean;
var p:Pointer;
begin
 result:=false;
 if (aPhysicalAddress and 1)=0 then begin
  p:=GetGlobalDirectMemoryAccessPointer(aPhysicalAddress,SizeOf(TPasRISCVUInt16),true,nil);
  if assigned(p) then begin
   PPasRISCVUInt16(p)^:=aValue;
   result:=true;
  end;
 end;
end;

function TPasRISCV.TVirtIODevice.Read32(const aPhysicalAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt32):Boolean;
var p:Pointer;
begin
 result:=false;
 if (aPhysicalAddress and 3)<>0 then begin
  aValue:=0;
 end else begin
  p:=GetGlobalDirectMemoryAccessPointer(aPhysicalAddress,SizeOf(TPasRISCVUInt32),false,nil);
  if assigned(p) then begin
   aValue:=PPasRISCVUInt32(p)^;
   result:=true;
  end else begin
   aValue:=0;
  end;
 end;
end;

function TPasRISCV.TVirtIODevice.Write32(const aPhysicalAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt32):Boolean;
var p:Pointer;
begin
 result:=false;
 if (aPhysicalAddress and 3)=0 then begin
  p:=GetGlobalDirectMemoryAccessPointer(aPhysicalAddress,SizeOf(TPasRISCVUInt32),true,nil);
  if assigned(p) then begin
   PPasRISCVUInt32(p)^:=aValue;
   result:=true;
  end;
 end;
end;

function TPasRISCV.TVirtIODevice.Read64(const aPhysicalAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt64):Boolean;
var p:Pointer;
begin
 result:=false;
 if (aPhysicalAddress and 7)<>0 then begin
  aValue:=0;
 end else begin
  p:=GetGlobalDirectMemoryAccessPointer(aPhysicalAddress,SizeOf(TPasRISCVUInt64),false,nil);
  if assigned(p) then begin
   aValue:=PPasRISCVUInt64(p)^;
   result:=true;
  end else begin
   aValue:=0;
  end;
 end;
end;

function TPasRISCV.TVirtIODevice.Write64(const aPhysicalAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64):Boolean;
var p:Pointer;
begin
 result:=false;
 if (aPhysicalAddress and 7)=0 then begin
  p:=GetGlobalDirectMemoryAccessPointer(aPhysicalAddress,SizeOf(TPasRISCVUInt64),true,nil);
  if assigned(p) then begin
   PPasRISCVUInt64(p)^:=aValue;
   result:=true;
  end;
 end;
end;

function TPasRISCV.TVirtIODevice.CopyMemoryFromRAM(const aBuf:Pointer;const aPhysicalAddress:TPasRISCVUInt64;const aCount:TPasRISCVUInt64):Boolean;
var p,Buf:PPasRISCVUInt8;
    Len,Count:TPasRISCVUInt64;
    PhysicalAddress:TPasRISCVUInt64;
begin
 Count:=aCount;
 PhysicalAddress:=aPhysicalAddress;
 Buf:=aBuf;
 while Count>0 do begin
  Len:=VIRTIO_PAGE_SIZE-(PhysicalAddress and (VIRTIO_PAGE_SIZE-1));
  if Len>Count then begin
   Len:=Count;
  end;
  p:=GetGlobalDirectMemoryAccessPointer(PhysicalAddress,Len,false,nil);
  if assigned(p) then begin
   Move(p^,Buf^,Len);
   inc(PhysicalAddress,Len);
   inc(Buf,Len);
   dec(Count,Len);
  end else begin
   result:=false;
   exit;
  end;
 end;
 result:=true;
end;

function TPasRISCV.TVirtIODevice.CopyMemoryToRAM(const aPhysicalAddress:TPasRISCVUInt64;const aBuf:Pointer;const aCount:TPasRISCVUInt64):Boolean;
var p,Buf:PPasRISCVUInt8;
    Len,Count:TPasRISCVUInt64;
    PhysicalAddress:TPasRISCVUInt64;
begin
 Count:=aCount;
 PhysicalAddress:=aPhysicalAddress;
 Buf:=aBuf;
 while Count>0 do begin
  Len:=VIRTIO_PAGE_SIZE-(PhysicalAddress and (VIRTIO_PAGE_SIZE-1));
  if Len>Count then begin
   Len:=Count;
  end;
  p:=GetGlobalDirectMemoryAccessPointer(PhysicalAddress,Len,true,nil);
  if assigned(p) then begin
   Move(Buf^,p^,Len);
   inc(PhysicalAddress,Len);
   inc(Buf,Len);
   dec(Count,Len);
  end else begin
   result:=false;
   exit;
  end;
 end;
 result:=true;
end;

function TPasRISCV.TVirtIODevice.GetDescriptor(const aDescriptor:PVirtIODescriptor;const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64):Boolean;
var QueueState:PQueue;
begin
 QueueState:=@fQueues[aQueueIndex];
 result:=CopyMemoryFromRAM(aDescriptor,QueueState^.DescriptorAddress+(aDescriptorIndex*SizeOf(TVirtIODescriptor)),SizeOf(TVirtIODescriptor));
end;

function TPasRISCV.TVirtIODevice.CopyMemoryFromToQueue(const aBuf:Pointer;const aQueueIndex,aDescriptorIndex,aOffset,aCount:TPasRISCVUInt64;const aToQueue:Boolean):Boolean;
var Descriptor:TVirtIODescriptor;
    Len,WriteFlag,Count,Offset,QueueIndex,DescriptorIndex,NextDescriptorIndex:TPasRISCVUInt64;
    Buf:PPasRISCVUInt8;
begin

 Count:=aCount;

 Offset:=aOffset;

 QueueIndex:=aQueueIndex;

 DescriptorIndex:=aDescriptorIndex;

 Buf:=aBuf;

 if Count=0 then begin
  result:=true;
  exit;
 end;

 if not GetDescriptor(@Descriptor,QueueIndex,DescriptorIndex) then begin
  result:=false;
  exit;
 end;

 if aToQueue then begin

  WriteFlag:=VRING_DESC_F_WRITE;

  // Find the first write descriptor
  repeat
   if (Descriptor.Flags and VRING_DESC_F_WRITE)=WriteFlag then begin
    break;
   end;
   if (Descriptor.Flags and VRING_DESC_F_NEXT)=0 then begin
    result:=false;
    exit;
   end;
   DescriptorIndex:=Descriptor.Next;
   if not GetDescriptor(@Descriptor,QueueIndex,DescriptorIndex) then begin
    result:=false;
    exit;
   end;
  until false;
 end else begin
  WriteFlag:=0;
 end;

 // Find the descriptor at offset
 repeat
  if (Descriptor.Flags and VRING_DESC_F_WRITE)<>WriteFlag then begin
   result:=false;
   exit;
  end;
  if Offset>=Descriptor.Len then begin
   if (Descriptor.Flags and VRING_DESC_F_NEXT)=0 then begin
    result:=false;
    exit;
   end;
   DescriptorIndex:=Descriptor.Next;
   dec(Offset,Descriptor.Len);
   if not GetDescriptor(@Descriptor,QueueIndex,DescriptorIndex) then begin
    result:=false;
    exit;
   end;
  end else begin
   break;
  end;
 until false;

 // Copy data
 repeat
  if Offset<Descriptor.Len then begin
   Len:=Descriptor.Len-Offset;
  end else begin
   Len:=0;
  end;
  if Len>Count then begin
   Len:=Count;
  end;
  if aToQueue then begin
   CopyMemoryToRAM(Descriptor.Address+Offset,Buf,Len);
  end else begin
   CopyMemoryFromRAM(Buf,Descriptor.Address+Offset,Len);
  end;
  dec(Count,Len);
  if Count>0 then begin
   inc(Offset,Len);
   inc(Buf,Len);
   if Offset=Descriptor.Len then begin
    if (Descriptor.Flags and VRING_DESC_F_NEXT)=0 then begin
     result:=false;
     exit;
    end;
    NextDescriptorIndex:=Descriptor.Next;
    if not GetDescriptor(@Descriptor,QueueIndex,NextDescriptorIndex) then begin
     result:=false;
     exit;
    end;
    if (Descriptor.Flags and VRING_DESC_F_WRITE)<>WriteFlag then begin
     result:=false;
     exit;
    end;
    Offset:=0;
   end;
  end else begin
   break;
  end;
 until false;

 result:=true;

end;

function TPasRISCV.TVirtIODevice.CopyMemoryFromQueue(const aBuf:Pointer;const aQueueIndex,aDescriptorIndex,aOffset,aCount:TPasRISCVUInt64):Boolean;
begin
 result:=CopyMemoryFromToQueue(aBuf,aQueueIndex,aDescriptorIndex,aOffset,aCount,false);
end;

function TPasRISCV.TVirtIODevice.CopyMemoryToQueue(const aQueueIndex,aDescriptorIndex,aOffset:TPasRISCVUInt64;const aBuf:Pointer;const aCount:TPasRISCVUInt64):Boolean;
begin
 result:=CopyMemoryFromToQueue(aBuf,aQueueIndex,aDescriptorIndex,aOffset,aCount,true);
end;

function TPasRISCV.TVirtIODevice.ConsumeDescriptor(const aQueueIndex,aDescriptorIndex,aDescriptorLength:TPasRISCVUInt64):Boolean;
var Queue:PQueue;
    UsedElementAddress:TPasRISCVUInt64;
    VirtQAvailRingPtr:pointer;
    UsedIndex:TPasRISCVUInt16;
begin

 result:=false;

 Queue:=@fQueues[aQueueIndex];

 UsedElementAddress:=(Queue^.UsedAddress+4)+((Queue^.ShadowUsedIndex and (Queue^.Size-1)) shl 3);

 VirtQAvailRingPtr:=GetGlobalDirectMemoryAccessPointer(UsedElementAddress,SizeOf(TPasRISCVUInt64),true,nil);
 if assigned(VirtQAvailRingPtr) then begin
  TPasMPInterlocked.Write(PPasRISCVUInt64(VirtQAvailRingPtr)^,TPasRISCVUInt64(TPasRISCVUInt64(TPasRISCVUInt32(aDescriptorIndex)) or (TPasRISCVUInt64(TPasRISCVUInt32(aDescriptorLength)) shl 32)));
 end else begin
  if not Write32(UsedElementAddress,aDescriptorIndex) then begin
   exit;
  end;
  if not Write32(UsedElementAddress+4,aDescriptorLength) then begin
   exit;
  end;
 end;

 TPasMPMemoryBarrier.ReadWrite;

 if (fActiveFeatures and TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX)<>0 then begin
  if Read16((Queue^.AvailableAddress+4)+(Queue^.Size shl 1),UsedIndex) then begin
   if Queue^.ShadowUsedIndex=UsedIndex then begin
    TPasMPInterlocked.Write(Queue^.UsedRingEvent,TPasMPBool32(true));
   end;
  end else begin
   exit;
  end;
 end;

 inc(Queue^.ShadowUsedIndex);

 result:=true;

end;

function TPasRISCV.TVirtIODevice.UsedRingSync(const aQueueIndex:TPasRISCVUInt64):Boolean;
var Queue:PQueue;
    VirtQAvailPtr:Pointer;
    NewValue,OldValue:TPasRISCVUInt32;
    Flags:TPasRISCVUInt16;
    UseEventIndex:Boolean;
begin

 result:=false;

 Queue:=@fQueues[aQueueIndex];

 VirtQAvailPtr:=GetGlobalDirectMemoryAccessPointer(Queue^.UsedAddress,SizeOf(TPasRISCVUInt32),true,nil);

 if assigned(VirtQAvailPtr) then begin

  repeat
   OldValue:=PPasRISCVUInt32(VirtQAvailPtr)^;
   NewValue:=(OldValue and $ffff) or (TPasRISCVUInt32(Queue^.ShadowUsedIndex) shl 16);
  until TPasMPInterlocked.CompareExchange(PPasRISCVUInt32(VirtQAvailPtr)^,NewValue,OldValue)=OldValue;

  Flags:=OldValue and $ffff;

 end else begin

  if Read16(Queue^.UsedAddress,Flags) then begin
   Write16(Queue^.UsedAddress+2,Queue^.ShadowUsedIndex);
  end else begin
   exit;
  end;

 end;

 TPasMPMemoryBarrier.ReadWrite;

 UseEventIndex:=(fActiveFeatures and TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX)<>0;
 if (UseEventIndex and TPasMPInterlocked.CompareExchange(Queue^.UsedRingEvent,TPasMPBool32(false),TPasMPBool32(true))) or
    ((not UseEventIndex) and ((Flags and VIRTQ_AVAIL_F_NO_INTERRUPT)=0)) then begin
  NotifyQueueUsed;
 end;

 result:=true;

//Sleep(1);

end;

function TPasRISCV.TVirtIODevice.GetDescriptors(out aReadSize,aWriteSize:TPasRISCVUInt64;const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64):Boolean;
var Queue:PQueue;
    QueueDescriptor:PQueueDescriptor;
    Descriptor:TVirtIODescriptor;
    DescriptorIndex:TPasRISCVUInt64;
begin

 Queue:=@fQueues[aQueueIndex];

 Queue^.CountReadDescriptors:=0;
 Queue^.CountWriteDescriptors:=0;

 aReadSize:=0;
 aWriteSize:=0;

 DescriptorIndex:=aDescriptorIndex;

 GetDescriptor(@Descriptor,aQueueIndex,DescriptorIndex);

 repeat
  if (Descriptor.Flags and VRING_DESC_F_WRITE)<>0 then begin
   break;
  end;
  if length(Queue^.ReadDescriptors)<=Queue^.CountReadDescriptors then begin
   SetLength(Queue^.ReadDescriptors,(Queue^.CountReadDescriptors+1)+((Queue^.CountReadDescriptors+2) shr 1));
  end;
  if fUseQueueDescriptorCaching then begin
   QueueDescriptor:=@Queue^.ReadDescriptors[Queue^.CountReadDescriptors];
   inc(Queue^.CountReadDescriptors);
   QueueDescriptor^.DescriptorIndex:=DescriptorIndex;
   QueueDescriptor^.Offset:=aReadSize;
   QueueDescriptor^.Size:=Descriptor.Len;
  end;
  inc(aReadSize,Descriptor.Len);
  if (Descriptor.Flags and VRING_DESC_F_NEXT)=0 then begin
   result:=true;
   exit;
  end;
  DescriptorIndex:=Descriptor.Next;
  GetDescriptor(@Descriptor,aQueueIndex,DescriptorIndex);
 until false;

 repeat
  if (Descriptor.Flags and VRING_DESC_F_WRITE)=0 then begin
   result:=false;
   exit;
  end;
  if fUseQueueDescriptorCaching then begin
   if length(Queue^.WriteDescriptors)<=Queue^.CountWriteDescriptors then begin
    SetLength(Queue^.WriteDescriptors,(Queue^.CountWriteDescriptors+1)+((Queue^.CountWriteDescriptors+2) shr 1));
   end;
   QueueDescriptor:=@Queue^.WriteDescriptors[Queue^.CountWriteDescriptors];
   inc(Queue^.CountWriteDescriptors);
   QueueDescriptor^.DescriptorIndex:=DescriptorIndex;
   QueueDescriptor^.Offset:=aWriteSize;
   QueueDescriptor^.Size:=Descriptor.Len;
  end;
  inc(aWriteSize,Descriptor.Len);
  if (Descriptor.Flags and VRING_DESC_F_NEXT)=0 then begin
   break;
  end;
  DescriptorIndex:=Descriptor.Next;
  GetDescriptor(@Descriptor,aQueueIndex,DescriptorIndex);
 until false;

 result:=true;

end;

function TPasRISCV.TVirtIODevice.AdvanceShadowAvailableIndex(const aQueueIndex:TPasRISCVUInt64):Boolean;
var Queue:PQueue;
begin
 Queue:=@fQueues[aQueueIndex];
 if (fActiveFeatures and TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX)<>0 then begin
  result:=Write16((Queue^.UsedAddress+4)+(Queue^.Size shl 3),Queue^.ShadowAvailableIndex+1);
 end else begin
  result:=true;
 end;
 if result then begin
  inc(Queue^.ShadowAvailableIndex);
 end;
end;

procedure TPasRISCV.TVirtIODevice.ProcessQueue(const aQueueIndex:TPasRISCVUInt64;const aAvailableIndex:TPasRISCVInt64);
var Queue:PQueue;
    AvailableIndex,DescriptorIndex:TPasRISCVUInt16;
    ReadSize,WriteSize:TPasRISCVUInt64;
    OK:Boolean;
begin
 if fDriverOK then begin
  Queue:=@fQueues[aQueueIndex];
  if not Queue^.ManualRecv then begin
   if TPasMPInterlocked.CompareExchange(Queue^.Lock,-1,0)=0 then begin
    try
     if aAvailableIndex>=0 then begin
      AvailableIndex:=aAvailableIndex;
      OK:=true;
     end else begin
      OK:=Read16(Queue^.AvailableAddress+2,AvailableIndex);
     end;
     if OK then begin
      while Queue^.ShadowAvailableIndex<>AvailableIndex do begin
       if Read16((Queue^.AvailableAddress+4)+((Queue^.ShadowAvailableIndex and (Queue^.Size-1)) shl 1),DescriptorIndex) then begin
        if GetDescriptors(ReadSize,WriteSize,aQueueIndex,DescriptorIndex) then begin
         if DeviceRecv(aQueueIndex,DescriptorIndex,ReadSize,WriteSize) then begin
          if AdvanceShadowAvailableIndex(aQueueIndex) then begin
           if (fStatus and VIRTIO_STATUS_DEVICE_NEEDS_RESET)<>0 then begin
            break;
           end else begin
            continue;
           end;
          end;
         end else begin
          break;
         end;
        end;
       end;
       NotifyDeviceNeedsReset;
       break;
      end;
     end;
    finally
     TPasMPInterlocked.Write(Queue^.Lock,0);
    end;
   end;
  end;
 end;
end;

procedure TPasRISCV.TVirtIODevice.QueueNotify(const aQueueIndex:TPasRISCVUInt64);
var Queue:PQueue;
    AvailableIndex:TPasRISCVUInt16;
begin
 if fDriverOK then begin
  Queue:=@fQueues[aQueueIndex];
  if not Queue^.ManualRecv then begin
   if Read16(Queue^.AvailableAddress+2,AvailableIndex) then begin
    if Queue^.Asynchronous then begin
     if not fMachine.fJobManager.EnqueueVirtIODeviceQueue(self,aQueueIndex,AvailableIndex) then begin
      ProcessQueue(aQueueIndex,AvailableIndex);
     end;
    end else begin
     ProcessQueue(aQueueIndex,AvailableIndex);
    end;
   end;
  end;
 end;
end;

procedure TPasRISCV.TVirtIODevice.UpdateIRQ;
begin
 if TPasMPInterlocked.Read(fIntStatus)<>0 then begin
  fMachine.fInterrupts.RaiseIRQ(fIRQ);
 end else begin
  fMachine.fInterrupts.LowerIRQ(fIRQ);
 end;
end;

procedure TPasRISCV.TVirtIODevice.SetIRQ(const aValue:TPasRISCVUInt32);
begin
 TPasMPInterlocked.BitwiseOr(fIntStatus,TPasMPUInt32(aValue));
 UpdateIRQ;
end;

procedure TPasRISCV.TVirtIODevice.NotifyQueueUsed;
begin
 if fDriverOK then begin
  SetIRQ(VIRTIO_INT_STATUS_USED_BUFFER);
 end;
end;

procedure TPasRISCV.TVirtIODevice.NotifyDeviceNeedsReset;
begin
 TPasMPInterlocked.BitwiseOr(TPasMPUInt32(fStatus),TPasMPUInt32(VIRTIO_STATUS_DEVICE_NEEDS_RESET));
 NotifyConfigChange;
end;

procedure TPasRISCV.TVirtIODevice.NotifyConfigChange;
begin
 if fDriverOK then begin
  SetIRQ(VIRTIO_INT_STATUS_CONFIG_CHANGE);
 end;
end;

function TPasRISCV.TVirtIODevice.ConfigRead(const aOffset:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 case aSize of
  1:begin
   if aOffset<fConfigSpaceSize then begin
    result:=fConfigSpace[aOffset];
   end else begin
    result:=0;
   end;
  end;
  2:begin
   if (aOffset+1)<fConfigSpaceSize then begin
    result:=TPasRISCVUInt16(fConfigSpace[aOffset]) or (TPasRISCVUInt16(fConfigSpace[aOffset+1]) shl 8);
   end else begin
    result:=0;
   end;
  end;
  4:begin
   if (aOffset+3)<fConfigSpaceSize then begin
    result:=TPasRISCVUInt32(fConfigSpace[aOffset]) or (TPasRISCVUInt32(fConfigSpace[aOffset+1]) shl 8) or (TPasRISCVUInt32(fConfigSpace[aOffset+2]) shl 16) or (TPasRISCVUInt32(fConfigSpace[aOffset+3]) shl 24);
   end else begin
    result:=0;
   end;
  end;
  8:begin
   if (aOffset+7)<fConfigSpaceSize then begin
    result:=TPasRISCVUInt64(fConfigSpace[aOffset]) or (TPasRISCVUInt64(fConfigSpace[aOffset+1]) shl 8) or (TPasRISCVUInt64(fConfigSpace[aOffset+2]) shl 16) or (TPasRISCVUInt64(fConfigSpace[aOffset+3]) shl 24) or (TPasRISCVUInt64(fConfigSpace[aOffset+4]) shl 32) or (TPasRISCVUInt64(fConfigSpace[aOffset+5]) shl 40) or (TPasRISCVUInt64(fConfigSpace[aOffset+6]) shl 48) or (TPasRISCVUInt64(fConfigSpace[aOffset+7]) shl 56);
   end else begin
    result:=0;
   end;
  end;
  else begin
   result:=0;
  end;
 end;
end;

procedure TPasRISCV.TVirtIODevice.ConfigWrite(const aOffset:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
begin
 case aSize of
  1:begin
   if aOffset<fConfigSpaceSize then begin
    fConfigSpace[aOffset]:=aValue;
    DeviceConfigWrite;
   end;
  end;
  2:begin
   if (aOffset+1)<fConfigSpaceSize then begin
    fConfigSpace[aOffset]:=aValue and $ff;
    fConfigSpace[aOffset+1]:=(aValue shr 8) and $ff;
    DeviceConfigWrite;
   end;
  end;
  4:begin
   if (aOffset+3)<fConfigSpaceSize then begin
    fConfigSpace[aOffset]:=aValue and $ff;
    fConfigSpace[aOffset+1]:=(aValue shr 8) and $ff;
    fConfigSpace[aOffset+2]:=(aValue shr 16) and $ff;
    fConfigSpace[aOffset+3]:=(aValue shr 24) and $ff;
    DeviceConfigWrite;
   end;
  end;
  8:begin
   if (aOffset+7)<fConfigSpaceSize then begin
    fConfigSpace[aOffset]:=aValue and $ff;
    fConfigSpace[aOffset+1]:=(aValue shr 8) and $ff;
    fConfigSpace[aOffset+2]:=(aValue shr 16) and $ff;
    fConfigSpace[aOffset+3]:=(aValue shr 24) and $ff;
    fConfigSpace[aOffset+4]:=(aValue shr 32) and $ff;
    fConfigSpace[aOffset+5]:=(aValue shr 40) and $ff;
    fConfigSpace[aOffset+6]:=(aValue shr 48) and $ff;
    fConfigSpace[aOffset+7]:=(aValue shr 56) and $ff;
    DeviceConfigWrite;
   end;
  end;
 end;
end;

procedure TPasRISCV.TVirtIODevice.SetStatus(const aStatus:TPasRISCVUInt32);
var NewStatus,OldStatus,EnablingStatus:TPasRISCVUInt32;
begin

 if aStatus=0 then begin

  fDriverOK:=false;
  fStatus:=0;
  fMachine.fInterrupts.LowerIRQ(fIRQ);
  DeviceReset;

 end else begin

  NewStatus:=aStatus;

  OldStatus:=fStatus;

  EnablingStatus:=(OldStatus xor NewStatus) and NewStatus;

  if (NewStatus and VIRTIO_STATUS_DRIVER_OK)=0 then begin
   fDriverOK:=false;
  end;

  if (EnablingStatus and VIRTIO_STATUS_FEATURES_OK)<>0 then begin
   fActiveFeatures:=fDeviceFeatures and fDriverFeatures;
   if (fActiveFeatures and TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1)=0 then begin
    NewStatus:=NewStatus and not VIRTIO_STATUS_FEATURES_OK;
   end;
  end;

  fStatus:=NewStatus and $ff;

  if (OldStatus and VIRTIO_STATUS_DEVICE_NEEDS_RESET)<>0 then begin
   SetIRQ(VIRTIO_INT_STATUS_CONFIG_CHANGE);
  end else begin
   if (EnablingStatus and VIRTIO_STATUS_DRIVER_OK)<>0 then begin
    fDriverOK:=true;
    DeviceDriverOK;
   end;
  end;

 end;

end;

function TPasRISCV.TVirtIODevice.MMIORead(const aOffset:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 if aOffset>=VIRTIO_MMIO_CONFIG then begin
  result:=ConfigRead(aOffset-VIRTIO_MMIO_CONFIG,aSize);
 end else begin
  case aSize of
   4:begin
    case aOffset of
     VIRTIO_MMIO_MAGIC_VALUE:begin
      result:=$74726976;
     end;
     VIRTIO_MMIO_VERSION:begin
      result:=2;
     end;
     VIRTIO_MMIO_DEVICE_ID:begin
      result:=fDeviceID;
     end;
     VIRTIO_MMIO_VENDOR_ID:begin
      result:=fVendorID;
     end;
     VIRTIO_MMIO_DEVICE_FEATURES:begin
      case fDeviceFeaturesSelected of
       0:begin
        result:=fDeviceFeatures and TPasRISCVUInt64($ffffffff);
       end;
       1:begin
        result:=(fDeviceFeatures shr 32) and TPasRISCVUInt64($ffffffff);
       end;
       else begin
        result:=0;
       end;
      end;
     end;
     VIRTIO_MMIO_DEVICE_FEATURES_SEL:begin
      result:=fDeviceFeaturesSelected;
     end;
     VIRTIO_MMIO_DRIVER_FEATURES:begin
      case fDriverFeaturesSelected of
       0:begin
        result:=fDriverFeatures and TPasRISCVUInt64($ffffffff);
       end;
       1:begin
        result:=(fDriverFeatures shr 32) and TPasRISCVUInt64($ffffffff);
       end;
       else begin
        result:=0;
       end;
      end;
     end;
     VIRTIO_MMIO_DRIVER_FEATURES_SEL:begin
      result:=fDriverFeaturesSelected;
     end;
     VIRTIO_MMIO_QUEUE_SEL:begin
      result:=fSelectedQueue;
     end;
     VIRTIO_MMIO_QUEUE_NUM_MAX:begin
      result:=MAXIMUM_QUEUE_SIZE;
     end;
     VIRTIO_MMIO_QUEUE_NUM:begin
      result:=fQueues[fSelectedQueue].Size;
     end;
     VIRTIO_MMIO_QUEUE_DESC_LOW:begin
      result:=fQueues[fSelectedQueue].DescriptorAddress and TPasRISCVUInt64($ffffffff);
     end;
     VIRTIO_MMIO_QUEUE_AVAIL_LOW:begin
      result:=fQueues[fSelectedQueue].AvailableAddress and TPasRISCVUInt64($ffffffff);
     end;
     VIRTIO_MMIO_QUEUE_USED_LOW:begin
      result:=fQueues[fSelectedQueue].UsedAddress and TPasRISCVUInt64($ffffffff);
     end;
     VIRTIO_MMIO_QUEUE_DESC_HIGH:begin
      result:=fQueues[fSelectedQueue].DescriptorAddress shr 32;
     end;
     VIRTIO_MMIO_QUEUE_AVAIL_HIGH:begin
      result:=fQueues[fSelectedQueue].AvailableAddress shr 32;
     end;
     VIRTIO_MMIO_QUEUE_USED_HIGH:begin
      result:=fQueues[fSelectedQueue].UsedAddress shr 32;
     end;
     VIRTIO_MMIO_QUEUE_READY:begin
      result:=ord(fQueues[fSelectedQueue].Ready) and 1;
     end;
     VIRTIO_MMIO_INTERRUPT_STATUS:begin
      result:=TPasMPInterlocked.Read(fIntStatus);
     end;
     VIRTIO_MMIO_STATUS:begin
      result:=fStatus;
     end;
     VIRTIO_MMIO_CONFIG_GENERATION:begin
      result:=0;
     end;
     else begin
      result:=0;
     end;
    end;
   end;
   else begin
    result:=0;
   end;
  end;
 end;
//writeln('virtio_mmio_read: ',IntToHex(aOffset),' ',aSize,' ',IntToHex(result));
end;

procedure TPasRISCV.TVirtIODevice.MMIOWrite(const aOffset:TPasRISCVUInt64;const aValue:TPasRISCVUInt32;const aSize:TPasRISCVUInt64);
begin
//writeln('virtio_mmio_write: ',IntToHex(aOffset),' ',aSize,' ',IntToHex(aValue));
 if aOffset>=VIRTIO_MMIO_CONFIG then begin
  ConfigWrite(aOffset-VIRTIO_MMIO_CONFIG,aValue,aSize);
 end else begin
  case aSize of
   4:begin
    case aOffset of
     VIRTIO_MMIO_DEVICE_FEATURES_SEL:begin
      fDeviceFeaturesSelected:=aValue;
     end;
     VIRTIO_MMIO_DRIVER_FEATURES:begin
      case fDriverFeaturesSelected of
       0:begin
        fDriverFeatures:=(fDriverFeatures and TPasRISCVUInt64($ffffffff00000000)) or (TPasRISCVUInt64(TPasRISCVUInt32(aValue)) shl 0);
       end;
       1:begin
        fDriverFeatures:=(fDriverFeatures and TPasRISCVUInt64($00000000ffffffff)) or (TPasRISCVUInt64(TPasRISCVUInt32(aValue)) shl 32);
       end;
       else begin
       end;
      end;
     end;
     VIRTIO_MMIO_DRIVER_FEATURES_SEL:begin
      fDriverFeaturesSelected:=aValue;
     end;
     VIRTIO_MMIO_QUEUE_SEL:begin
      if aValue<MAXIMUM_COUNT_QUEUES then begin
       fSelectedQueue:=aValue;
      end;
     end;
     VIRTIO_MMIO_QUEUE_NUM:begin
      if ((aValue and (aValue-1))=0) and (aValue>0) then begin
       fQueues[fSelectedQueue].Size:=aValue;
      end;
     end;
     VIRTIO_MMIO_QUEUE_DESC_LOW:begin
      fQueues[fSelectedQueue].DescriptorAddress:=(fQueues[fSelectedQueue].DescriptorAddress and TPasRISCVUInt64($ffffffff00000000)) or (aValue and TPasRISCVUInt64($00000000ffffffff));
     end;
     VIRTIO_MMIO_QUEUE_AVAIL_LOW:begin
      fQueues[fSelectedQueue].AvailableAddress:=(fQueues[fSelectedQueue].AvailableAddress and TPasRISCVUInt64($ffffffff00000000)) or (aValue and TPasRISCVUInt64($00000000ffffffff));
     end;
     VIRTIO_MMIO_QUEUE_USED_LOW:begin
      fQueues[fSelectedQueue].UsedAddress:=(fQueues[fSelectedQueue].UsedAddress and TPasRISCVUInt64($ffffffff00000000)) or (aValue and TPasRISCVUInt64($00000000ffffffff));
     end;
     VIRTIO_MMIO_QUEUE_DESC_HIGH:begin
      fQueues[fSelectedQueue].DescriptorAddress:=(fQueues[fSelectedQueue].DescriptorAddress and TPasRISCVUInt64($00000000ffffffff)) or (TPasRISCVUInt64(aValue) shl 32);
     end;
     VIRTIO_MMIO_QUEUE_AVAIL_HIGH:begin
      fQueues[fSelectedQueue].AvailableAddress:=(fQueues[fSelectedQueue].AvailableAddress and TPasRISCVUInt64($00000000ffffffff)) or (TPasRISCVUInt64(aValue) shl 32);
     end;
     VIRTIO_MMIO_QUEUE_USED_HIGH:begin
      fQueues[fSelectedQueue].UsedAddress:=(fQueues[fSelectedQueue].UsedAddress and TPasRISCVUInt64($00000000ffffffff)) or (TPasRISCVUInt64(aValue) shl 32);
     end;
     VIRTIO_MMIO_STATUS:begin
      SetStatus(aValue);
     end;
     VIRTIO_MMIO_QUEUE_READY:begin
      fQueues[fSelectedQueue].Ready:=(aValue and 1)<>0;
      if (aValue and 1)<>0 then begin
       DeviceInitialize;
      end;
     end;
     VIRTIO_MMIO_QUEUE_NOTIFY:begin
      if aValue<MAXIMUM_COUNT_QUEUES then begin
       QueueNotify(aValue);
      end;
     end;
     VIRTIO_MMIO_INTERRUPT_ACK:begin
      TPasMPInterlocked.BitwiseAnd(fIntStatus,not TPasMPUInt32(aValue));
      UpdateIRQ;
     end;
    end;
   end;
  end;
 end;
end;

function TPasRISCV.TVirtIODevice.PCIRead(const aOffset:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Offset:TPasRISCVUInt64;
begin
 Offset:=aOffset and $fff;
 case aOffset shr 12 of
  VIRTIO_PCI_CFG_OFFSET shr 12:begin
   case aSize of
    1:begin
     case Offset of
      VIRTIO_PCI_DEVICE_STATUS:begin
       result:=fStatus;
      end;
      else begin
       result:=0;
      end;
     end;
    end;
    2:begin
     case Offset of
      VIRTIO_PCI_NUM_QUEUES:begin
       result:=MAXIMUM_QUEUE_SIZE;
      end;
      VIRTIO_PCI_QUEUE_SEL:begin
       result:=fSelectedQueue;
      end;
      VIRTIO_PCI_QUEUE_SIZE:begin
       result:=fQueues[fSelectedQueue].Size;
      end;
      VIRTIO_PCI_QUEUE_ENABLE:begin
       result:=ord(fQueues[fSelectedQueue].Ready) and 1;
      end;
      VIRTIO_PCI_QUEUE_NOTIFY_OFF:begin
       result:=0;
      end;
      else begin
       result:=0;
      end;
     end;
    end;
    4:begin
     case Offset of
      VIRTIO_PCI_DEVICE_FEATURE:begin
       case fDeviceFeaturesSelected of
        0:begin
         result:=fDeviceFeatures and TPasRISCVUInt64($ffffffff);
        end;
        1:begin
         result:=(fDeviceFeatures shr 32) and TPasRISCVUInt64($ffffffff);
        end;
        else begin
         result:=0;
        end;
       end;
      end;
      VIRTIO_PCI_DEVICE_FEATURE_SEL:begin
       result:=fDeviceFeaturesSelected;
      end;
      VIRTIO_PCI_DRIVER_FEATURE:begin
       case fDriverFeaturesSelected of
        0:begin
         result:=fDriverFeatures and TPasRISCVUInt64($ffffffff);
        end;
        1:begin
         result:=(fDriverFeatures shr 32) and TPasRISCVUInt64($ffffffff);
        end;
        else begin
         result:=0;
        end;
       end;
      end;
      VIRTIO_PCI_DRIVER_FEATURE_SEL:begin
       result:=fDriverFeaturesSelected;
      end;
      VIRTIO_PCI_QUEUE_DESC_LOW:begin
       result:=fQueues[fSelectedQueue].DescriptorAddress and $ffffffff;
      end;
      VIRTIO_PCI_QUEUE_AVAIL_LOW:begin
       result:=fQueues[fSelectedQueue].AvailableAddress and $ffffffff;
      end;
      VIRTIO_PCI_QUEUE_USED_LOW:begin
       result:=fQueues[fSelectedQueue].UsedAddress and $ffffffff;
      end;
      VIRTIO_PCI_QUEUE_DESC_HIGH:begin
       result:=fQueues[fSelectedQueue].DescriptorAddress shr 32;
      end;
      VIRTIO_PCI_QUEUE_AVAIL_HIGH:begin
       result:=fQueues[fSelectedQueue].AvailableAddress shr 32;
      end;
      VIRTIO_PCI_QUEUE_USED_HIGH:begin
       result:=fQueues[fSelectedQueue].UsedAddress shr 32;
      end;
      else begin
       result:=0;
      end;
     end;
    end;
    else begin
     result:=0;
    end;
   end;
  end;
  VIRTIO_PCI_ISR_OFFSET shr 12:begin
   case aSize of
    1:begin
     case Offset of
      0:begin
       result:=fIntStatus;
       fIntStatus:=0;
       fMachine.fInterrupts.LowerIRQ(fIRQ);
      end;
      else begin
       result:=0;
      end;
     end;
    end;
    else begin
     result:=0;
    end;
   end;
  end;
  VIRTIO_PCI_CONFIG_OFFSET shr 12:begin
   result:=ConfigRead(Offset,aSize);
  end;
  else begin
   result:=0;
  end;
 end;
end;

procedure TPasRISCV.TVirtIODevice.PCIWrite(const aOffset:TPasRISCVUInt64;const aValue:TPasRISCVUInt32;const aSize:TPasRISCVUInt64);
var Offset:TPasRISCVUInt64;
begin
 Offset:=aOffset and $fff;
 case aOffset shr 12 of
  VIRTIO_PCI_CFG_OFFSET shr 12:begin
   case aSize of
    1:begin
     case Offset of
      VIRTIO_PCI_DEVICE_STATUS:begin
       SetStatus(aValue);
      end;
      else begin
      end;
     end;
    end;
    2:begin
     case Offset of
      VIRTIO_PCI_QUEUE_SEL:begin
       if aValue<MAXIMUM_COUNT_QUEUES then begin
        fSelectedQueue:=aValue;
       end;
      end;
      VIRTIO_PCI_QUEUE_SIZE:begin
       if ((aValue and (aValue-1))=0) and (aValue>0) then begin
        fQueues[fSelectedQueue].Size:=aValue;
       end;
      end;
      VIRTIO_PCI_QUEUE_ENABLE:begin
       fQueues[fSelectedQueue].Ready:=(aValue and 1)<>0;
       if (aValue and 1)<>0 then begin
        DeviceInitialize;
       end;
      end;
      else begin
      end;
     end;
    end;
    4:begin
     case Offset of
      VIRTIO_PCI_DEVICE_FEATURE_SEL:begin
       fDeviceFeaturesSelected:=aValue;
      end;
      VIRTIO_PCI_DRIVER_FEATURE:begin
       case fDriverFeaturesSelected of
        0:begin
         fDriverFeatures:=(fDriverFeatures and TPasRISCVUInt64($ffffffff00000000)) or (TPasRISCVUInt64(TPasRISCVUInt32(aValue)) shl 0);
        end;
        1:begin
         fDriverFeatures:=(fDriverFeatures and TPasRISCVUInt64($00000000ffffffff)) or (TPasRISCVUInt64(TPasRISCVUInt32(aValue)) shl 32);
        end;
        else begin
        end;
       end;
      end;
      VIRTIO_PCI_DRIVER_FEATURE_SEL:begin
       fDriverFeaturesSelected:=aValue;
      end;
      VIRTIO_PCI_QUEUE_DESC_LOW:begin
       fQueues[fSelectedQueue].DescriptorAddress:=(fQueues[fSelectedQueue].DescriptorAddress and $ffffffff00000000) or (aValue and $00000000ffffffff);
      end;
      VIRTIO_PCI_QUEUE_AVAIL_LOW:begin
       fQueues[fSelectedQueue].AvailableAddress:=(fQueues[fSelectedQueue].AvailableAddress and $ffffffff00000000) or (aValue and $00000000ffffffff);
      end;
      VIRTIO_PCI_QUEUE_USED_LOW:begin
       fQueues[fSelectedQueue].UsedAddress:=(fQueues[fSelectedQueue].UsedAddress and $ffffffff00000000) or (aValue and $00000000ffffffff);
      end;
      VIRTIO_PCI_QUEUE_DESC_HIGH:begin
       fQueues[fSelectedQueue].DescriptorAddress:=(fQueues[fSelectedQueue].DescriptorAddress and $00000000ffffffff) or (TPasRISCVUInt64(aValue) shl 32);
      end;
      VIRTIO_PCI_QUEUE_AVAIL_HIGH:begin
       fQueues[fSelectedQueue].AvailableAddress:=(fQueues[fSelectedQueue].AvailableAddress and $00000000ffffffff) or (TPasRISCVUInt64(aValue) shl 32);
      end;
      VIRTIO_PCI_QUEUE_USED_HIGH:begin
       fQueues[fSelectedQueue].UsedAddress:=(fQueues[fSelectedQueue].UsedAddress and $00000000ffffffff) or (TPasRISCVUInt64(aValue) shl 32);
      end;
      else begin
      end;
     end;
    end;
    else begin
    end;
   end;
  end;
  VIRTIO_PCI_CONFIG_OFFSET shr 12:begin
   ConfigWrite(Offset,aValue,aSize);
  end;
  VIRTIO_PCI_NOTIFY_OFFSET shr 12:begin
   if aValue<MAXIMUM_COUNT_QUEUES then begin
    QueueNotify(aValue);
   end;
  end;
  else begin
  end;
 end;
end;

procedure TPasRISCV.TVirtIODevice.Reset;
begin
 inherited Reset;
 DeviceReset;
end;

function TPasRISCV.TVirtIODevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case fKind of
  TPasRISCV.TVirtIODevice.TKind.MMIO:begin
   result:=MMIORead(Address,aSize);
  end;
  TPasRISCV.TVirtIODevice.TKind.PCI:begin
   result:=PCIRead(Address,aSize);
  end;
  else begin
   result:=0;
  end;
 end;
end;

procedure TPasRISCV.TVirtIODevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case fKind of
  TPasRISCV.TVirtIODevice.TKind.MMIO:begin
   MMIOWrite(Address,aValue,aSize);
  end;
  TPasRISCV.TVirtIODevice.TKind.PCI:begin
   PCIWrite(Address,aValue,aSize);
  end;
 end;
end;

{ TPasRISCV.TVirtIOBlockDevice }

constructor TPasRISCV.TVirtIOBlockDevice.Create(const aMachine:TPasRISCV);
var Index:TPasRISCVSizeInt;
begin

 inherited Create(aMachine,aMachine.fConfiguration.fVirtIOBlockBase,aMachine.fConfiguration.fVirtIOBlockSize,TPasRISCV.TVirtIODevice.TKind.MMIO);

 fIRQ:=aMachine.fConfiguration.fVirtIOBlockIRQ;

//fVendorID:=Vendor;

 fDeviceID:=DeviceID;

 for Index:=0 to MAXIMUM_COUNT_QUEUES-1 do begin
  fQueues[Index].Asynchronous:=false;
 end;

 fDeviceFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1 or
//                TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX or
//                TPasRISCV.TVirtIODevice.VIRTIO_F_IN_ORDER or
                  VIRTIO_BLK_F_MQ or
                  VIRTIO_BLK_F_FLUSH;

 fStreamLock:=TPasMPSlimReaderWriterLock.Create;

 fStream:=TMemoryStream.Create;

 FillChar(fConfig,Sizeof(TVirtIOBlkConfig),#0);

 fConfig.NumQueues:=MAXIMUM_COUNT_QUEUES;

 fConfig.MaxDiscardSectors:=128;
 fConfig.MaxDiscardSeg:=1;
 fConfig.DiscardSectorAlignment:=1;

 fConfig.MaxSecureEraseSectors:=128;
 fConfig.MaxSecureEraseSectors:=1;
 fConfig.SecureEraseSectorAlignment:=1;

 fConfig.MaxWriteZeroesSectors:=128;
 fConfig.MaxWriteZeroesSectors:=1;

 fConfigSpaceSize:=SizeOf(TVirtIOBlkConfig);

 fCountSectors:=(fStream.Size+(SECTOR_SIZE-1)) div SECTOR_SIZE;

 fConfig.Capacity:=fCountSectors;
 Move(fConfig,fConfigSpace[0],SizeOf(TVirtIOBlkConfig));

end;

destructor TPasRISCV.TVirtIOBlockDevice.Destroy;
begin
 FreeAndNil(fStream);
 FreeAndNil(fStreamLock);
 inherited Destroy;
end;

procedure TPasRISCV.TVirtIOBlockDevice.DeviceReset;
begin
 inherited DeviceReset;
 if assigned(fStream) then begin
  fStreamLock.Acquire;
  try
   FlushStream(fStream);
  finally
   fStreamLock.Release;
  end;
 end;
end;

procedure TPasRISCV.TVirtIOBlockDevice.DeviceConfigWrite;
begin
 inherited DeviceConfigWrite;
end;

function TPasRISCV.TVirtIOBlockDevice.ImageRead(const aSectorIndex:TPasRISCVUInt64;const aBuf:Pointer;const aCount:TPasRISCVUInt64):Boolean;
var Offset,Size,Remain:TPasRISCVInt64;
    Buf:PPasRISCVUInt8;
begin
 Offset:=aSectorIndex*SECTOR_SIZE;
 Size:=aCount*SECTOR_SIZE;
 if (Offset+Size)<=(fCountSectors*SECTOR_SIZE) then begin
  Remain:=(fCountSectors*SECTOR_SIZE)-Offset;
  if Remain>Size then begin
   Remain:=Size;
  end;
  Buf:=aBuf;
  if Remain>0 then begin
   fStreamLock.Acquire;
   try
    result:=fStream.Seek(Offset,soBeginning)=Offset;
    if result then begin
     result:=fStream.Read(Buf^,Remain)=Remain;
    end;
   finally
    fStreamLock.Release;
   end;
  end else begin
   result:=true;
  end;
  if result then begin
   inc(Buf,Remain);
   if Remain<Size then begin
    FillChar(Buf^,Size-Remain,#0);
   end;
  end;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TVirtIOBlockDevice.ImageWrite(const aSectorIndex:TPasRISCVUInt64;const aBuf:Pointer;const aCount:TPasRISCVUInt64):Boolean;
var Offset,Size,Remain:TPasRISCVInt64;
    Buf:PPasRISCVUInt8;
begin
 Offset:=aSectorIndex*SECTOR_SIZE;
 Size:=aCount*SECTOR_SIZE;
 if (Offset+Size)<=(fCountSectors*SECTOR_SIZE) then begin
  Remain:=(fCountSectors*SECTOR_SIZE)-Offset;
  if Remain>Size then begin
   Remain:=Size;
  end;
  Buf:=aBuf;
  if Remain>0 then begin
   fStreamLock.Acquire;
   try
    result:=fStream.Seek(Offset,soBeginning)=Offset;
    if result then begin
     result:=fStream.Write(Buf^,Remain)=Remain;
    end;
   finally
    fStreamLock.Release;
   end;
  end else begin
   result:=true;
  end;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TVirtIOBlockDevice.DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean;
var Len,Count,WriteSize,Size,ToDo:TPasRISCVUInt64;
    BlockRequestHeader:TVirtIOBlockDevice.TBlockRequestHeader;
    Value:TPasRISCVUInt8;
    Buf:Pointer;
    VirtIOBlkDiscardWriteZeroes:TVirtIOBlkDiscardWriteZeroes;
begin

 if CopyMemoryFromQueue(@BlockRequestHeader,aQueueIndex,aDescriptorIndex,0,SizeOf(BlockRequestHeader)) then begin

  case BlockRequestHeader.Type_ of

   TVirtIOBlockDevice.VIRTIO_BLK_T_IN:begin

    Count:=(aWriteSize-1) div SECTOR_SIZE;
    WriteSize:=aWriteSize;

    GetMem(Buf,WriteSize);
    try

//   writeln(BlockRequestHeader.SectorIndex);

     if ImageRead(BlockRequestHeader.SectorIndex,Buf,Count) then begin
      PPasRISCVUInt8Array(Buf)^[WriteSize-1]:=VIRTIO_BLK_S_OK;
     end else begin
      PPasRISCVUInt8Array(Buf)^[WriteSize-1]:=VIRTIO_BLK_S_IOERR;
     end;
     if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Buf,WriteSize) and
             ConsumeDescriptor(aQueueIndex,aDescriptorIndex,WriteSize) and
             UsedRingSync(aQueueIndex)) then begin
      NotifyDeviceNeedsReset;
     end;

    finally
     if assigned(Buf) then begin
      try
       FreeMem(Buf);
      finally
       Buf:=nil;
      end;
     end;
    end;

   end;

   TVirtIOBlockDevice.VIRTIO_BLK_T_OUT:begin

    Len:=aReadSize-SizeOf(BlockRequestHeader);
    if Len>0 then begin
     Count:=Len div SECTOR_SIZE;
     WriteSize:=Len;
    end else begin
     Count:=0;
     WriteSize:=0;
    end;

    GetMem(Buf,WriteSize);
    try

     if CopyMemoryFromQueue(Buf,aQueueIndex,aDescriptorIndex,SizeOf(TBlockRequestHeader),WriteSize) then begin
      if ImageWrite(BlockRequestHeader.SectorIndex,Buf,Count) then begin
       Value:=VIRTIO_BLK_S_OK;
      end else begin
       Value:=VIRTIO_BLK_S_IOERR;
      end;
     end else begin
      NotifyDeviceNeedsReset;
      Value:=VIRTIO_BLK_S_IOERR;
     end;
     if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,@Value,SizeOf(TPasRISCVUInt8)) and
             ConsumeDescriptor(aQueueIndex,aDescriptorIndex,1) and
             UsedRingSync(aQueueIndex)) then begin
      NotifyDeviceNeedsReset;
     end;

    finally
     if assigned(Buf) then begin
      try
       FreeMem(Buf);
      finally
       Buf:=nil;
      end;
     end;
    end;

   end;

   TVirtIOBlockDevice.VIRTIO_BLK_T_SCSI:begin
   end;

   TVirtIOBlockDevice.VIRTIO_BLK_T_FLUSH,
   TVirtIOBlockDevice.VIRTIO_BLK_T_FLUSH_OUT:begin
    fStreamLock.Acquire;
    try
     if assigned(fStream) and FlushStream(fStream) then begin
      Value:=VIRTIO_BLK_S_OK;
     end else begin
      Value:=VIRTIO_BLK_S_IOERR;
     end;
    finally
     fStreamLock.Release;
    end;
    if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,@Value,SizeOf(TPasRISCVUInt8)) and
            ConsumeDescriptor(aQueueIndex,aDescriptorIndex,1) and
            UsedRingSync(aQueueIndex)) then begin
     NotifyDeviceNeedsReset;
    end;
   end;

   TVirtIOBlockDevice.VIRTIO_BLK_T_GET_ID:begin
   end;

   TVirtIOBlockDevice.VIRTIO_BLK_T_GET_LIFETIME:begin
   end;

   TVirtIOBlockDevice.VIRTIO_BLK_T_DISCARD,
   TVirtIOBlockDevice.VIRTIO_BLK_T_WRITE_ZEROES,
   TVirtIOBlockDevice.VIRTIO_BLK_T_SECURE_ERASE:begin
    if CopyMemoryFromQueue(@VirtIOBlkDiscardWriteZeroes,aQueueIndex,aDescriptorIndex,SizeOf(TBlockRequestHeader),SizeOf(TVirtIOBlkDiscardWriteZeroes)) then begin
     Value:=VIRTIO_BLK_S_OK;
     fStreamLock.Acquire;
     try
      fStream.Seek(VirtIOBlkDiscardWriteZeroes.Sector*512,soBeginning);
      Size:=VirtIOBlkDiscardWriteZeroes.CountSectors*512;
      while Size>0 do begin
       if Size<SizeOf(TZeroBuffer) then begin
        ToDo:=Size;
       end else begin
        ToDo:=SizeOf(TZeroBuffer);
       end;
       if fStream.Write(ZeroBuffer[0],ToDo)<>ToDo then begin
        Value:=VIRTIO_BLK_S_IOERR;
        break;
       end;
       dec(Size,ToDo);
      end;
     finally
      fStreamLock.Release;
     end;
    end else begin
     NotifyDeviceNeedsReset;
     Value:=VIRTIO_BLK_S_IOERR;
    end;
    if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,@Value,SizeOf(TPasRISCVUInt8)) and
            ConsumeDescriptor(aQueueIndex,aDescriptorIndex,1) and
            UsedRingSync(aQueueIndex)) then begin
     NotifyDeviceNeedsReset;
    end;
   end;
  end;

 end else begin

  NotifyDeviceNeedsReset;

 end;

 result:=true;

end;

procedure TPasRISCV.TVirtIOBlockDevice.AttachStream(const aStream:TStream);
begin
 FreeAndNil(fStream);
 if assigned(aStream) then begin
  fStream:=aStream;
 end else begin
  fStream:=TMemoryStream.Create;
  TMemoryStream(fStream).SetSize(1 shl 20);
 end;
 fCountSectors:=(fStream.Size+(SECTOR_SIZE-1)) div SECTOR_SIZE;
 fConfig.Capacity:=fCountSectors;
 Move(fConfig,fConfigSpace[0],SizeOf(TVirtIOBlkConfig));
end;

procedure TPasRISCV.TVirtIOBlockDevice.LoadFromStream(const aStream:TStream);
begin
 if fStream is TMemoryStream then begin
  TMemoryStream(fStream).Clear;
 end;
 aStream.Seek(0,soBeginning);
 fStream.CopyFrom(aStream,aStream.Size);
 fCountSectors:=(fStream.Size+(SECTOR_SIZE-1)) div SECTOR_SIZE;
 fConfig.Capacity:=fCountSectors;
 Move(fConfig,fConfigSpace[0],SizeOf(TVirtIOBlkConfig));
end;

procedure TPasRISCV.TVirtIOBlockDevice.LoadFromFile(const aFileName:TPasRISCVUTF8String);
var Stream:TFileStream;
begin
 Stream:=TFileStream.Create(aFileName,fmOpenRead); // or fmShareDenyWrite);
 try
  LoadFromStream(Stream);
 finally
  Stream.Free;
 end;
end;

procedure TPasRISCV.TVirtIOBlockDevice.SaveToStream(const aStream:TStream);
begin
 fStream.Seek(0,soBeginning);
 aStream.Seek(0,soBeginning);
 aStream.CopyFrom(fStream,fStream.Size);
end;

procedure TPasRISCV.TVirtIOBlockDevice.SaveToFile(const aFileName:TPasRISCVUTF8String);
var Stream:TFileStream;
begin
 Stream:=TFileStream.Create(aFileName,fmCreate); // or fmShareDenyWrite);
 try
  SaveToStream(Stream);
 finally
  Stream.Free;
 end;
end;

{ TPasRISCV.TVirtIOInputDevice }

constructor TPasRISCV.TVirtIOInputDevice.Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64;const aKind:TVirtIOInputDevice.TKind);
begin
 inherited Create(aMachine,aBase,aSize,TPasRISCV.TVirtIODevice.TKind.MMIO);
 fKind:=aKind;
 fButtonState:=0;
 fVendorID:=Vendor;
 fDeviceID:=DeviceID;
 fQueues[0].ManualRecv:=true;
 fConfigSpaceSize:=256;
 fDeviceFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1 or
                  //TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX or
                  0;
end;

destructor TPasRISCV.TVirtIOInputDevice.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV.TVirtIOInputDevice.DeviceReset;
begin
 inherited DeviceReset;
 fButtonState:=0;
end;

function TPasRISCV.TVirtIOInputDevice.DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean;
begin
 if aQueueIndex=1 then begin
  ConsumeDescriptor(aQueueIndex,aDescriptorIndex,0);
  UsedRingSync(aQueueIndex);
 end;
 result:=true;
end;

function TPasRISCV.TVirtIOInputDevice.QueueEvent(const aType,aCode:TPasRISCVUInt16;const aValue:TPasRISCVUInt32):Boolean;
var QueueIndex,BufferLength:TPasRISCVUInt64;
    AvailableIndex,DescriptorIndex:TPasRISCVUInt16;
//  Value:TPasRISCVUInt8;
    Queue:PQueue;
    Buffer:array[0..7] of TPasRISCVUInt8;
begin

 result:=false;

 QueueIndex:=0;
 Queue:=@fQueues[QueueIndex];

 DescriptorIndex:=0;

 if fDriverOK and Queue^.Ready then begin

  TPasMPMultipleReaderSingleWriterSpinLock.AcquireWrite(Queue^.Lock);
  try

   Buffer[0]:=TPasRISCVUInt8(aType and $ff);
   Buffer[1]:=TPasRISCVUInt8((aType shr 8) and $ff);

   Buffer[2]:=TPasRISCVUInt8(aCode and $ff);
   Buffer[3]:=TPasRISCVUInt8((aCode shr 8) and $ff);

   Buffer[4]:=TPasRISCVUInt8(aValue and $ff);
   Buffer[5]:=TPasRISCVUInt8((aValue shr 8) and $ff);
   Buffer[6]:=TPasRISCVUInt8((aValue shr 16) and $ff);
   Buffer[7]:=TPasRISCVUInt8((aValue shr 24) and $ff);

   BufferLength:=8;

   if Read16(Queue^.AvailableAddress+2,AvailableIndex) then begin

    if Queue^.ShadowAvailableIndex<>AvailableIndex then begin

     if Read16((Queue^.AvailableAddress+4)+((Queue.ShadowAvailableIndex and (Queue^.Size-1)) shl 1),DescriptorIndex) then begin

      if CopyMemoryToQueue(QueueIndex,DescriptorIndex,0,@Buffer[0],BufferLength) and
         ConsumeDescriptor(QueueIndex,DescriptorIndex,BufferLength) and
         UsedRingSync(QueueIndex) and
         AdvanceShadowAvailableIndex(QueueIndex) then begin
       result:=true;
      end else begin
       NotifyDeviceNeedsReset;
      end;

     end else begin
      NotifyDeviceNeedsReset;
     end;

    end;

   end else begin
    NotifyDeviceNeedsReset;
   end;

  finally
   TPasMPMultipleReaderSingleWriterSpinLock.ReleaseWrite(Queue^.Lock);
  end;

 end;

end;

function TPasRISCV.TVirtIOInputDevice.HandleKeyboard(const aKeyCode:TPasRISCVUInt16;const aDown:Boolean):Boolean;
begin
 result:=QueueEvent(VIRTIO_INPUT_EV_KEY,aKeyCode,ord(aDown) and 1);
 if result then begin
  result:=QueueEvent(VIRTIO_INPUT_EV_SYN,0,0);
 end;
end;

function TPasRISCV.TVirtIOInputDevice.HandleMouse(const aDX,aDY,aDZ:TPasRISCVInt32;const aButtons:TPasRISCVUInt32):Boolean;
var Index:TPasRISCVSizeInt;
    Button,LastButton:Boolean;
begin
 if (fKind=TPasRISCV.TVirtIOInputDevice.TKind.Mouse) or (fKind=TPasRISCV.TVirtIOInputDevice.TKind.Tablet) then begin
  if fKind=TPasRISCV.TVirtIOInputDevice.TKind.Mouse then begin
   result:=QueueEvent(VIRTIO_INPUT_EV_REL,REL_X,aDX);
   if result then begin
    result:=QueueEvent(VIRTIO_INPUT_EV_REL,REL_Y,aDY);
   end;
  end else begin
   result:=QueueEvent(VIRTIO_INPUT_EV_ABS,ABS_X,aDX);
   if result then begin
    result:=QueueEvent(VIRTIO_INPUT_EV_ABS,ABS_Y,aDY);
   end;
  end;
  if result and (aDZ<>0) then begin
   result:=QueueEvent(VIRTIO_INPUT_EV_REL,REL_WHEEL,aDZ);
  end;
  if result and (aButtons<>fButtonState) then begin
   for Index:=0 to 2 do begin
    Button:=(aButtons and (1 shl Index))<>0;
    LastButton:=(fButtonState and (1 shl Index))<>0;
    if Button<>LastButton then begin
     result:=QueueEvent(VIRTIO_INPUT_EV_KEY,ButtonList[Index],ord(Button) and 1);
     if not result then begin
      break;
     end;
    end;
   end;
   fButtonState:=aButtons;
  end;
  if result then begin
   result:=QueueEvent(VIRTIO_INPUT_EV_SYN,0,0);
  end;
 end else begin
  result:=false;
 end;
end;

procedure TPasRISCV.TVirtIOInputDevice.DeviceConfigWrite;
var Name:TPasRISCVRawByteString;
    Index,Len:TPasRISCVSizeInt;
begin
 case fConfigSpace[0] of
  VIRTIO_INPUT_CFG_UNSET:begin
  end;
  VIRTIO_INPUT_CFG_ID_NAME:begin
   case fKind of
    TPasRISCV.TVirtIOInputDevice.TKind.Keyboard:begin
     Name:='virtio_keyboard';
    end;
    TPasRISCV.TVirtIOInputDevice.TKind.Mouse:begin
     Name:='virtio_mouse';
    end;
    TPasRISCV.TVirtIOInputDevice.TKind.Tablet:begin
     Name:='virtio_tablet';
    end;
    else begin
     Name:='';
    end;
   end;
   Len:=length(Name);
   fConfigSpace[2]:=Len;
   for Index:=0 to Len-1 do begin
    fConfigSpace[8+Index]:=TPasRISCVUInt8(Name[Index+1]);
   end;
  end;
  VIRTIO_INPUT_CFG_ID_SERIAL,
  VIRTIO_INPUT_CFG_ID_DEVIDS,
  VIRTIO_INPUT_CFG_PROP_BITS:begin
   fConfigSpace[2]:=0;
  end;
  VIRTIO_INPUT_CFG_EV_BITS:begin
   fConfigSpace[2]:=0;
   case fKind of
    TPasRISCV.TVirtIOInputDevice.TKind.Keyboard:begin
     case fConfigSpace[1] of
      VIRTIO_INPUT_EV_KEY:begin
       fConfigSpace[2]:=128 div 8;
       FillChar(fConfigSpace[8],128 div 8,#$ff);
      end;
      VIRTIO_INPUT_EV_REP:begin
       fConfigSpace[2]:=1;
      end;
      else begin
       fConfigSpace[2]:=0;
      end;
     end;
    end;
    TPasRISCV.TVirtIOInputDevice.TKind.Mouse:begin
     case fConfigSpace[1] of
      VIRTIO_INPUT_EV_KEY:begin
       fConfigSpace[2]:=512 div 8;
       FillChar(fConfigSpace[8],512 div 8,#0);
       for Index:=0 to 2 do begin
        fConfigSpace[8+(ButtonList[Index] shr 3)]:=fConfigSpace[8+(ButtonList[Index] shr 3)] or (1 shl (ButtonList[Index] and 7));
       end;
      end;
      VIRTIO_INPUT_EV_REL:begin
       fConfigSpace[2]:=2;
       fConfigSpace[8]:=0;
       fConfigSpace[9]:=0;
       PPasRISCVUInt32(Pointer(@fConfigSpace[8]))^:=(1 shl REL_X) or (1 shl REL_Y) or (1 shl REL_WHEEL);
      end;
      else begin
       fConfigSpace[2]:=0;
      end;
     end;
    end;
    TPasRISCV.TVirtIOInputDevice.TKind.Tablet:begin
     case fConfigSpace[1] of
      VIRTIO_INPUT_EV_KEY:begin
       fConfigSpace[2]:=512 div 8;
       FillChar(fConfigSpace[8],512 div 8,#0);
       for Index:=0 to 2 do begin
        fConfigSpace[8+(ButtonList[Index] shr 3)]:=fConfigSpace[8+(ButtonList[Index] shr 3)] or (1 shl (ButtonList[Index] and 7));
       end;
      end;
      VIRTIO_INPUT_EV_REL:begin
       fConfigSpace[2]:=2;
       fConfigSpace[8]:=0;
       fConfigSpace[9]:=0;
       PPasRISCVUInt32(Pointer(@fConfigSpace[8]))^:=1 shl REL_WHEEL;
      end;
      VIRTIO_INPUT_EV_ABS:begin
       fConfigSpace[2]:=1;
       PPasRISCVUInt32(Pointer(@fConfigSpace[8]))^:=(1 shl ABS_X) or (1 shl ABS_Y);
      end;
      else begin
       fConfigSpace[2]:=0;
      end;
     end;
    end;
    else begin
     fConfigSpace[2]:=0;
    end;
   end;
  end;
  VIRTIO_INPUT_CFG_ABS_INFO:begin
   if (fKind=TPasRISCV.TVirtIOInputDevice.TKind.Tablet) and (fConfigSpace[1]<=1) then begin
    fConfigSpace[2]:=5*4;
    PPasRISCVUInt32(Pointer(@fConfigSpace[8]))^:=0; // min
    PPasRISCVUInt32(Pointer(@fConfigSpace[12]))^:=VIRTIO_INPUT_ABS_SCALE-1; // max
    PPasRISCVUInt32(Pointer(@fConfigSpace[16]))^:=0; // fuzz
    PPasRISCVUInt32(Pointer(@fConfigSpace[20]))^:=0; // flat
    PPasRISCVUInt32(Pointer(@fConfigSpace[24]))^:=0; // res
   end;
  end;
  else begin
   fConfigSpace[2]:=0;
  end;
 end;
end;

{ TPasRISCV.TVirtIOInputKeyboardDevice }

constructor TPasRISCV.TVirtIOInputKeyboardDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fVirtIOInputKeyboardBase,aMachine.fConfiguration.fVirtIOInputKeyboardSize,TVirtIOInputDevice.TKind.Keyboard);
 fIRQ:=aMachine.fConfiguration.fVirtIOInputKeyboardIRQ;
end;

procedure TPasRISCV.TVirtIOInputKeyboardDevice.DeviceInitialize;
begin
 if assigned(fMachine) and assigned(fMachine.fPS2KeyboardDevice) and fMachine.fPS2KeyboardDevice.fActive then begin
  fMachine.fPS2KeyboardDevice.fActive:=false;
 end;
end;

{ TPasRISCV.TVirtIOInputMouseDevice }

constructor TPasRISCV.TVirtIOInputMouseDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fVirtIOInputMouseBase,aMachine.fConfiguration.fVirtIOInputMouseSize,TVirtIOInputDevice.TKind.Mouse);
 fIRQ:=aMachine.fConfiguration.fVirtIOInputMouseIRQ;
end;

procedure TPasRISCV.TVirtIOInputMouseDevice.DeviceInitialize;
begin
 if assigned(fMachine) and assigned(fMachine.fPS2MouseDevice) and fMachine.fPS2MouseDevice.fActive then begin
  fMachine.fPS2MouseDevice.fActive:=false;
 end;
end;

{ TPasRISCV.TVirtIOInputTabletDevice }

// TODO

{ TPasRISCV.TVirtIOSoundDevice.TPCMBuffer }

constructor TPasRISCV.TVirtIOSoundDevice.TPCMBuffer.Create(const aDevice:TVirtIOSoundDevice);
begin
 inherited Create;
 fDevice:=aDevice;
 fData:=nil;
 fFloatData:=nil;
 fResampledFloatData:=nil;
end;

destructor TPasRISCV.TVirtIOSoundDevice.TPCMBuffer.Destroy;
begin
 fData:=nil;
 fFloatData:=nil;
 fResampledFloatData:=nil;
 inherited Destroy;
end;

procedure TPasRISCV.TVirtIOSoundDevice.TPCMBuffer.Clear;
begin
 fData:=nil;
 fFloatData:=nil;
 fResampledFloatData:=nil;
end;

{ TPasRISCV.TVirtIOSoundDevice.TPCMStream }

procedure TPasRISCV.TVirtIOSoundDevice.TPCMStream.ReturnBuffer(const aPCMBuffer:TPCMBuffer;const aLock:Boolean);
begin
 if assigned(aPCMBuffer) then begin
  if aLock then begin
   fBufferQueueLock.Acquire;
  end;
  try
   fBufferFreeQueue.Enqueue(aPCMBuffer);
  finally
   if aLock then begin
    fBufferQueueLock.Leave;
   end;
  end;
 end;
end;

{ TPasRISCV.TVirtIOSoundDevice }

constructor TPasRISCV.TVirtIOSoundDevice.Create(const aMachine:TPasRISCV);
var Index:TPasRISCVSizeInt;
    Stream:TPCMStream;
    DefaultParams:TVirtIOSoundPCMSetParams;
begin

 inherited Create(aMachine,aMachine.fConfiguration.fVirtIOSoundBase,aMachine.fConfiguration.fVirtIOSoundSize,TVirtIODevice.TKind.MMIO);

 fIRQ:=aMachine.fConfiguration.fVirtIOSoundIRQ;

 fUseQueueDescriptorCaching:=true;

 fDeviceID:=TVirtIOSoundDevice.DeviceID;

 fSampleRate:=48000;

 fSoundConfig.Jacks:=2;
 fSoundConfig.Streams:=2;
 fSoundConfig.ChannelMaps:=1;
 fSoundConfig.Controls:=0;

 fConfigSpaceSize:=SizeOf(TVirtIOSoundConfig);
 Move(fSoundConfig,fConfigSpace[0],SizeOf(TVirtIOSoundConfig));

 fDeviceFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1 or
                  //TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX or
                  0;

 fQueues[VIRTIO_SND_VQ_CONTROL].ManualRecv:=false;
 fQueues[VIRTIO_SND_VQ_CONTROL].Asynchronous:=false;

 fQueues[VIRTIO_SND_VQ_EVENT].ManualRecv:=false;
 fQueues[VIRTIO_SND_VQ_EVENT].Asynchronous:=false;

 fQueues[VIRTIO_SND_VQ_TX].ManualRecv:=false;
 fQueues[VIRTIO_SND_VQ_TX].Asynchronous:=true;

 fQueues[VIRTIO_SND_VQ_RX].ManualRecv:=false;
 fQueues[VIRTIO_SND_VQ_RX].Asynchronous:=true;

 fCommandQueueLock:=TPasMPCriticalSection.Create;

 fPCMStreams:=nil;

 SetLength(fPCMStreams,fSoundConfig.Streams);

 DefaultParams.Header.Header.Code:=0;
 DefaultParams.Header.StreamID:=0;
 DefaultParams.BufferBytes:=8192;
 DefaultParams.PeriodBytes:=2048;
 DefaultParams.Features:=0;
 DefaultParams.Channels:=2;
 DefaultParams.Format:=VIRTIO_SND_PCM_FMT_S16;
 DefaultParams.Rate:=VIRTIO_SND_PCM_RATE_48000;

 for Index:=0 to fSoundConfig.Streams-1 do begin
  Stream:=TPCMStream.Create;
  try
   Stream.fDevice:=self;
   Stream.fCommand:=TPCMStream.TCommand.None;
   Stream.fActive:=false;
   Stream.fParams:=DefaultParams;
   Stream.fCurrentBuffer:=nil;
   Stream.fLock:=TPasMPCriticalSection.Create;
   Stream.fBufferQueueLock:=TPasMPCriticalSection.Create;
   Stream.fBufferQueue.Initialize;
   Stream.fBufferFreeQueue.Initialize;
   Stream.fPCMRingBuffer:=TPCMRingBuffer.Create(192000);
  finally
   fPCMStreams[Index]:=Stream;
  end;
  SetParams(Index,DefaultParams);
 end;

 fTXScratchBuffer:=nil;
 fRXScratchBuffer:=nil;

 fOutputWAVStreamDump:=nil;
//fOutputWAVStreamDump:=TPasRISCVAudioWAVStreamDump.Create(fSampleRate,TFileStream.Create('a.wav',fmCreate),true);

end;

destructor TPasRISCV.TVirtIOSoundDevice.Destroy;
var Index:TPasRISCVSizeInt;
    Stream:TPCMStream;
begin

 FlushTX;

 FlushRX;

 fTXScratchBuffer:=nil;
 fRXScratchBuffer:=nil;

 for Index:=0 to fSoundConfig.Streams-1 do begin
  Stream:=fPCMStreams[Index];
  try
   FreeAndNil(Stream.fCurrentBuffer);
   FreeBufferQueue(Stream.fBufferQueue);
   Stream.fBufferQueue.Finalize;
   Stream.fBufferFreeQueue.Finalize;
   FreeAndNil(Stream.fBufferQueueLock);
   FreeAndNil(Stream.fLock);
   FreeAndNil(Stream.fPCMRingBuffer);
  finally
   try
    FreeAndNil(Stream);
   finally
    fPCMStreams[Index]:=nil;
   end;
  end;
 end;

 fPCMStreams:=nil;

 FreeAndNil(fCommandQueueLock);

 FreeAndNil(fOutputWAVStreamDump);

 inherited Destroy;
end;

function TPasRISCV.TVirtIOSoundDevice.SetParams(const aStreamID:TPasRISCVUInt32;const aParams:TVirtIOSoundPCMSetParams):TPasRISCVUInt32;
var Params:PVirtIOSoundPCMSetParams;
begin
 if (aParams.Channels<1) or (aParams.Channels>2) then begin
  result:=VIRTIO_SND_S_NOT_SUPP;
 end else if (SupportedFormats and (TPasRISCVUInt64(1) shl aParams.Format))=0 then begin
  result:=VIRTIO_SND_S_NOT_SUPP;
 end else if (SupportedRates and (TPasRISCVUInt64(1) shl aParams.Rate))=0 then begin
  result:=VIRTIO_SND_S_NOT_SUPP;
 end else begin
  Params:=@fPCMStreams[aStreamID].fParams;
  Params^.BufferBytes:=aParams.BufferBytes;
  Params^.PeriodBytes:=aParams.PeriodBytes;
  Params^.Features:=aParams.Features;
  Params^.Channels:=aParams.Channels;
  Params^.Format:=aParams.Format;
  Params^.Rate:=aParams.Rate;
//writeln(aParams.BufferBytes,' ',aParams.PeriodBytes);
  result:=VIRTIO_SND_S_OK;
 end;
end;

procedure TPasRISCV.TVirtIOSoundDevice.DeviceReset;
begin
 inherited DeviceReset;
end;

function TPasRISCV.TVirtIOSoundDevice.DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean;
var Index:TPasRISCVSizeInt;
    SoundHeader:PVirtIOSoundHeader;
    SoundQueryInfo:PVirtIOSoundQueryInfo;
    SoundJackInfo:PVirtIOSoundJackInfo;
    SoundPCMInfo:PVirtIOSoundPCMInfo;
    SoundChMapInfo:PVirtIOSoundChMapInfo;
    SoundPCMSetParams:PVirtIOSoundPCMSetParams;
    SoundPCMHeader:PVirtIOSoundPCMHeader;
    SoundPCMXfer:PVirtIOSoundPCMXfer;
    SoundPCMStatus:TVirtIOSoundPCMStatus;
    Size,Offset:TPasRISCVUInt64;
    Input,Output:PPasRISCVUInt8Array;
    PCMStream:TPCMStream;
    PCMBuffer:TPCMBuffer;
begin

 case aQueueIndex of

  VIRTIO_SND_VQ_CONTROL:begin

   fCommandQueueLock.Acquire;
   try

    if aReadSize>=SizeOf(TVirtIOSoundHeader) then begin

     GetMem(Input,aReadSize);
     try

      if CopyMemoryFromQueue(Input,aQueueIndex,aDescriptorIndex,0,aReadSize) then begin

       SoundHeader:=PVirtIOSoundHeader(@Input[0]);

       case SoundHeader^.Code of

        VIRTIO_SND_R_JACK_INFO:begin
         if aReadSize>=SizeOf(TVirtIOSoundHeader) then begin
          SoundQueryInfo:=PVirtIOSoundQueryInfo(@Input[0]);
          Size:=SizeOf(TVirtIOSoundHeader)+(SizeOf(TVirtIOSoundJackInfo)*SoundQueryInfo^.Count);
          if aWriteSize>=Size then begin
           GetMem(Output,Size);
           try
            Offset:=0;
            PVirtIOSoundHeader(@Output^[Offset])^.Code:=VIRTIO_SND_S_OK;
            inc(Offset,SizeOf(TVirtIOSoundHeader));
            for Index:=0 to SoundQueryInfo^.Count-1 do begin
             SoundJackInfo:=PVirtIOSoundJackInfo(@Output^[Offset]);
             inc(Offset,SizeOf(TVirtIOSoundJackInfo));
             SoundJackInfo^.Header.HDAFunctionGroupNodeID:=0;
             SoundJackInfo^.Features:=0;
             SoundJackInfo^.HDARegDefConfig:=0;
             SoundJackInfo^.HDARegCaps:=0;
             SoundJackInfo^.Connected:=1;
             FillChar(SoundJackInfo^.Padding,SizeOf(SoundJackInfo^.Padding),#0);
            end;
            if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                    ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                    UsedRingSync(aQueueIndex)) then begin
             NotifyDeviceNeedsReset;
            end;
           finally
            FreeMem(Output);
           end;
           result:=true;
          end else begin
           result:=false;
          end;
         end else begin
          result:=false;
         end;
        end;

        VIRTIO_SND_R_JACK_REMAP:begin
         Size:=SizeOf(TVirtIOSoundHeader);
         if Size<aWriteSize then begin
          Size:=aWriteSize;
         end;
         if aWriteSize>=Size then begin
          GetMem(Output,Size);
          try
           FillChar(Output^,Size,#0);
           PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_NOT_SUPP;
           if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                   ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                  UsedRingSync(aQueueIndex)) then begin
            NotifyDeviceNeedsReset;
           end;
          finally
           FreeMem(Output);
          end;
          result:=true;
         end else begin
          result:=false;
         end;
        end;

        VIRTIO_SND_R_PCM_INFO:begin
         if aReadSize>=SizeOf(TVirtIOSoundHeader) then begin
          SoundQueryInfo:=PVirtIOSoundQueryInfo(@Input[0]);
          Size:=SizeOf(TVirtIOSoundHeader)+(SizeOf(TVirtIOSoundPCMInfo)*SoundQueryInfo^.Count);
          if aWriteSize>=Size then begin
           GetMem(Output,Size);
           try
            Offset:=0;
            PVirtIOSoundHeader(@Output^[Offset])^.Code:=VIRTIO_SND_S_OK;
            inc(Offset,SizeOf(TVirtIOSoundHeader));
            for Index:=0 to SoundQueryInfo^.Count-1 do begin
             SoundPCMInfo:=PVirtIOSoundPCMInfo(@Output^[Offset]);
             inc(Offset,SizeOf(TVirtIOSoundPCMInfo));
             SoundPCMInfo^.Header.HDAFunctionGroupNodeID:=0;
             SoundPCMInfo^.Features:=0;
             SoundPCMInfo^.Formats:=SupportedFormats;
             SoundPCMInfo^.Rates:=SupportedRates;
             if Index=0 then begin
              SoundPCMInfo^.Direction:=VIRTIO_SND_D_OUTPUT;
             end else begin
              SoundPCMInfo^.Direction:=VIRTIO_SND_D_INPUT;
             end;
             SoundPCMInfo^.ChannelsMin:=1;
             SoundPCMInfo^.ChannelsMax:=2;
             FillChar(SoundPCMInfo^.Padding,SizeOf(SoundPCMInfo^.Padding),#0);
            end;
            if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                    ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                    UsedRingSync(aQueueIndex)) then begin
             NotifyDeviceNeedsReset;
            end;
           finally
            FreeMem(Output);
           end;
           result:=true;
          end else begin
           result:=false;
          end;
         end else begin
          result:=false;
         end;
        end;

        VIRTIO_SND_R_PCM_SET_PARAMS:begin
         if aReadSize>=SizeOf(TVirtIOSoundPCMSetParams) then begin
          SoundPCMSetParams:=PVirtIOSoundPCMSetParams(@Input[0]);
          Size:=SizeOf(TVirtIOSoundHeader);
          if aWriteSize>=Size then begin
           GetMem(Output,Size);
           try
            PCMStream:=fPCMStreams[SoundPCMSetParams^.Header.StreamID];
            case PCMStream.fCommand of
             TPCMStream.TCommand.None,
             TPCMStream.TCommand.Prepare,
             TPCMStream.TCommand.SetParameters,
             TPCMStream.TCommand.Release:begin
              if not PCMStream.fActive then begin
               PCMStream.fCommand:=TPCMStream.TCommand.SetParameters;
               PVirtIOSoundHeader(@Output^[0])^.Code:=SetParams(SoundPCMSetParams^.Header.StreamID,SoundPCMSetParams^);
              end else begin
               PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_IO_ERR;
              end;
             end;
             else begin
              PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_IO_ERR;
             end;
            end;
            if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                    ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                    UsedRingSync(aQueueIndex)) then begin
             NotifyDeviceNeedsReset;
            end;
           finally
            FreeMem(Output);
           end;
           result:=true;
          end else begin
           result:=false;
          end;
         end else begin
          result:=false;
         end;
        end;

        VIRTIO_SND_R_PCM_PREPARE:begin
         if aReadSize>=SizeOf(TVirtIOSoundPCMHeader) then begin
          SoundPCMHeader:=PVirtIOSoundPCMHeader(@Input[0]);
          Size:=SizeOf(TVirtIOSoundHeader);
          if aWriteSize>=Size then begin
           GetMem(Output,Size);
           try
            PCMStream:=fPCMStreams[SoundPCMHeader.StreamID];
            case PCMStream.fCommand of
             TPCMStream.TCommand.None,
             TPCMStream.TCommand.Prepare,
             TPCMStream.TCommand.SetParameters,
             TPCMStream.TCommand.Release:begin
              PCMStream.fCommand:=TPCMStream.TCommand.Prepare;
              if not PCMStream.fActive then begin
               PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_OK;
              end else begin
               PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_IO_ERR;
              end;
             end;
             else begin
              PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_IO_ERR;
             end;
            end;
            if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                    ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                    UsedRingSync(aQueueIndex)) then begin
             NotifyDeviceNeedsReset;
            end;
           finally
            FreeMem(Output);
           end;
           result:=true;
          end else begin
           result:=false;
          end;
         end else begin
          result:=false;
         end;
        end;

        VIRTIO_SND_R_PCM_RELEASE:begin
         if aReadSize>=SizeOf(TVirtIOSoundPCMHeader) then begin
          SoundPCMHeader:=PVirtIOSoundPCMHeader(@Input[0]);
          Size:=SizeOf(TVirtIOSoundHeader);
          if aWriteSize>=Size then begin
           GetMem(Output,Size);
           try
            PCMStream:=fPCMStreams[SoundPCMHeader.StreamID];
            case PCMStream.fCommand of
             TPCMStream.TCommand.Prepare,
             TPCMStream.TCommand.Stop:begin
              PCMStream.fCommand:=TPCMStream.TCommand.Release;
              if not PCMStream.fActive then begin
               if SoundPCMHeader.StreamID=0 then begin
                FlushTX;
               end else begin
                FlushRX;
               end;
               PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_OK;
              end else begin
               PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_IO_ERR;
              end;
             end;
             else begin
              PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_IO_ERR;
             end;
            end;
            if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                    ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                    UsedRingSync(aQueueIndex)) then begin
             NotifyDeviceNeedsReset;
            end;
           finally
            FreeMem(Output);
           end;
           result:=true;
          end else begin
           result:=false;
          end;
         end else begin
          result:=false;
         end;
        end;

        VIRTIO_SND_R_PCM_START:begin
         if aReadSize>=SizeOf(TVirtIOSoundPCMHeader) then begin
          SoundPCMHeader:=PVirtIOSoundPCMHeader(@Input[0]);
          Size:=SizeOf(TVirtIOSoundHeader);
          if aWriteSize>=Size then begin
           GetMem(Output,Size);
           try
            PCMStream:=fPCMStreams[SoundPCMHeader.StreamID];
            case PCMStream.fCommand of
             TPCMStream.TCommand.Prepare,
             TPCMStream.TCommand.Stop:begin
              PCMStream.fCommand:=TPCMStream.TCommand.Start;
              if not TPasMPInterlocked.CompareExchange(PCMStream.fActive,TPasMPBool32(true),TPasMPBool32(false)) then begin
               PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_OK;
              end else begin
               PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_IO_ERR;
              end;
             end;
             else begin
              PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_IO_ERR;
             end;
            end;
            if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                    ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                    UsedRingSync(aQueueIndex)) then begin
             NotifyDeviceNeedsReset;
            end;
           finally
            FreeMem(Output);
           end;
           result:=true;
          end else begin
           result:=false;
          end;
         end else begin
          result:=false;
         end;
        end;

        VIRTIO_SND_R_PCM_STOP:begin
         if aReadSize>=SizeOf(TVirtIOSoundPCMHeader) then begin
          SoundPCMHeader:=PVirtIOSoundPCMHeader(@Input[0]);
          Size:=SizeOf(TVirtIOSoundHeader);
          if aWriteSize>=Size then begin
           GetMem(Output,Size);
           try
            PCMStream:=fPCMStreams[SoundPCMHeader.StreamID];
            case PCMStream.fCommand of
             TPCMStream.TCommand.Start:begin
              PCMStream.fCommand:=TPCMStream.TCommand.Stop;
              if TPasMPInterlocked.CompareExchange(PCMStream.fActive,TPasMPBool32(false),TPasMPBool32(true)) then begin
               PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_OK;
              end else begin
               PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_IO_ERR;
              end;
             end;
             else begin
              PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_IO_ERR;
             end;
            end;
            if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                    ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                    UsedRingSync(aQueueIndex)) then begin
             NotifyDeviceNeedsReset;
            end;
           finally
            FreeMem(Output);
           end;
           result:=true;
          end else begin
           result:=false;
          end;
         end else begin
          result:=false;
         end;
        end;

        VIRTIO_SND_R_CHMAP_INFO:begin
         if aReadSize>=SizeOf(TVirtIOSoundHeader) then begin
          SoundQueryInfo:=PVirtIOSoundQueryInfo(@Input[0]);
          Size:=SizeOf(TVirtIOSoundHeader)+(SizeOf(TVirtIOSoundChMapInfo)*SoundQueryInfo^.Count);
          if aWriteSize>=Size then begin
           GetMem(Output,Size);
           try
            Offset:=0;
            PVirtIOSoundHeader(@Output^[Offset])^.Code:=VIRTIO_SND_S_OK;
            inc(Offset,SizeOf(TVirtIOSoundHeader));
            for Index:=0 to SoundQueryInfo^.Count-1 do begin
             SoundChMapInfo:=PVirtIOSoundChMapInfo(@Output^[Offset]);
             inc(Offset,SizeOf(TVirtIOSoundChMapInfo));
             SoundChMapInfo^.Header.HDAFunctionGroupNodeID:=0;
             if Index=0 then begin
              SoundChMapInfo^.Direction:=VIRTIO_SND_D_OUTPUT;
             end else begin
              SoundChMapInfo^.Direction:=VIRTIO_SND_D_INPUT;
             end;
             SoundChMapInfo^.Channels:=2;
             FillChar(SoundChMapInfo^.Positions,SizeOf(SoundChMapInfo^.Positions),#0);
             SoundChMapInfo^.Positions[0]:=VIRTIO_SND_CHMAP_FL;
             SoundChMapInfo^.Positions[1]:=VIRTIO_SND_CHMAP_FR;
            end;
            if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                    ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                    UsedRingSync(aQueueIndex)) then begin
             NotifyDeviceNeedsReset;
            end;
           finally
            FreeMem(Output);
           end;
           result:=true;
          end else begin
           result:=false;
          end;
         end else begin
          result:=false;
         end;
        end;

        else begin
         Size:=SizeOf(TVirtIOSoundHeader);
         if Size<aWriteSize then begin
          Size:=aWriteSize;
         end;
         if aWriteSize>=Size then begin
          GetMem(Output,Size);
          try
           FillChar(Output^,Size,#0);
           PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_NOT_SUPP;
           if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                   ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                   UsedRingSync(aQueueIndex)) then begin
            NotifyDeviceNeedsReset;
           end;
          finally
           FreeMem(Output);
          end;
          result:=true;
         end else begin
          result:=false;
         end;
        end;

       end;

      end else begin
       NotifyDeviceNeedsReset;
       result:=false;
      end;

     finally
      FreeMem(Input);
     end;

    end else begin
     result:=false;
    end;

   finally
    fCommandQueueLock.Release;
   end;

  end;

  VIRTIO_SND_VQ_EVENT:begin
   if aReadSize>0 then begin
    if ConsumeDescriptor(aQueueIndex,aDescriptorIndex,0) and UsedRingSync(aQueueIndex) then begin
     result:=true;
    end else begin
     NotifyDeviceNeedsReset;
    end;
   end else begin
    result:=false;
   end;
  end;

  VIRTIO_SND_VQ_TX:begin

   if aReadSize>=SizeOf(TVirtIOSoundPCMXfer) then begin

    GetMem(Input,aReadSize);
    try

     if CopyMemoryFromQueue(Input,aQueueIndex,aDescriptorIndex,0,aReadSize) then begin

      SoundPCMXfer:=PVirtIOSoundPCMXfer(@Input[0]);

      Size:=SizeOf(TVirtIOSoundPCMStatus);
      if aWriteSize>=Size then begin

       PCMStream:=fPCMStreams[SoundPCMXfer.StreamID];

       PCMBuffer:=nil;

       PCMStream.fBufferQueueLock.Acquire;
       try
        if not PCMStream.fBufferFreeQueue.Dequeue(PCMBuffer) then begin
         PCMBuffer:=TPCMBuffer.Create(self);
        end;
       finally
        PCMStream.fBufferQueueLock.Release;
       end;

       PCMBuffer.fPopulated:=false;
       PCMBuffer.fRawSize:=aReadSize-SizeOf(TVirtIOSoundPCMXfer);
       if length(PCMBuffer.fData)<PCMBuffer.fRawSize then begin
        SetLength(PCMBuffer.fData,PCMBuffer.fRawSize*2);
       end;
       if PCMBuffer.fRawSize>0 then begin
        Move(Input^[SizeOf(TVirtIOSoundPCMXfer)],PCMBuffer.fData[0],PCMBuffer.fRawSize);
       end;
       PCMBuffer.fRemainingSize:=PCMBuffer.fRawSize;
       PCMBuffer.fOffset:=0;
       PCMBuffer.fAvailableIndex:=fQueues[aQueueIndex].ShadowAvailableIndex;

       PCMStream.fBufferQueueLock.Acquire;
       try
        PCMStream.fBufferQueue.Enqueue(PCMBuffer);
       finally
        PCMStream.fBufferQueueLock.Release;
       end;

       result:=true;

      end else begin

       result:=false;

      end;

     end else begin
      NotifyDeviceNeedsReset;
      result:=false;
     end;

    finally
     FreeMem(Input);
    end;

   end else begin
    result:=false;
   end;

  end;

  VIRTIO_SND_VQ_RX:begin
   if aReadSize>0 then begin
    if ConsumeDescriptor(aQueueIndex,aDescriptorIndex,0) and UsedRingSync(aQueueIndex) then begin
     result:=true;
    end else begin
     NotifyDeviceNeedsReset;
     result:=false;
    end;
   end else begin
    result:=false;
   end;
  end;

  else begin
   result:=false;
  end;

 end;

end;

procedure TPasRISCV.TVirtIOSoundDevice.FreeBufferQueue(var aBufferQueue:TPCMBufferQueue);
var PCMBuffer:TPCMBuffer;
begin
 while aBufferQueue.Dequeue(PCMBuffer) do begin
  FreeAndNil(PCMBuffer);
 end;
end;

procedure TPasRISCV.TVirtIOSoundDevice.NotifyTXBuffer(const aPCMBuffer:TPCMBuffer);
var QueueIndex:TPasRISCVUInt64;
    DescriptorIndex:TPasRISCVUInt16;
    Queue:PQueue;
    SoundPCMStatus:TVirtIOSoundPCMStatus;
begin

 if assigned(aPCMBuffer) and (aPCMBuffer.fAvailableIndex>=0) then begin

  QueueIndex:=VIRTIO_SND_VQ_TX;
  Queue:=@fQueues[QueueIndex];

  DescriptorIndex:=0;

  if Queue^.Ready then begin

   TPasMPMultipleReaderSingleWriterSpinLock.AcquireWrite(Queue^.Lock);
   try

    SoundPCMStatus.Status:=VIRTIO_SND_S_OK;
    SoundPCMStatus.LatencyBytes:=0;//aPCMBuffer.fRawSize;

    if Read16((Queue^.AvailableAddress+4)+((aPCMBuffer.fAvailableIndex and (Queue^.Size-1)) shl 1),DescriptorIndex) then begin

     if not (CopyMemoryToQueue(QueueIndex,DescriptorIndex,0,@SoundPCMStatus,SizeOf(TVirtIOSoundPCMStatus)) and
             ConsumeDescriptor(QueueIndex,DescriptorIndex,SizeOf(TVirtIOSoundPCMStatus)) and
             UsedRingSync(QueueIndex)) then begin
      NotifyDeviceNeedsReset;
     end;

    end else begin
     NotifyDeviceNeedsReset;
    end;

    aPCMBuffer.fAvailableIndex:=-1;

   finally
    TPasMPMultipleReaderSingleWriterSpinLock.ReleaseWrite(Queue^.Lock);
   end;

  end;

 end;

end;

procedure TPasRISCV.TVirtIOSoundDevice.FlushTX;
var PCMStream:TPCMStream;
begin
 PCMStream:=fPCMStreams[0];
 PCMStream.fLock.Acquire;
 try
  PCMStream.fBufferQueueLock.Acquire;
  try
   repeat
    if assigned(PCMStream.fCurrentBuffer) then begin
//   NotifyTXBuffer(PCMStream.fCurrentBuffer);
     PCMStream.ReturnBuffer(PCMStream.fCurrentBuffer,false);
    end;
    if PCMStream.fBufferQueue.Dequeue(PCMStream.fCurrentBuffer) then begin
     if assigned(PCMStream.fCurrentBuffer) then begin
      NotifyTXBuffer(PCMStream.fCurrentBuffer);
     end;
    end else begin
     PCMStream.fCurrentBuffer:=nil;
    end;
   until not assigned(PCMStream.fCurrentBuffer);
  finally
   PCMStream.fBufferQueueLock.Leave;
  end;
 finally
  PCMStream.fLock.Leave;
 end;
end;

procedure TPasRISCV.TVirtIOSoundDevice.FlushRX;
begin
end;

procedure TPasRISCV.TVirtIOSoundDevice.OutputAudioFillBufferCallback(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
var Remain,ToDo,Size:TPasRISCVSizeInt;
    PCMStream:TPCMStream;
    PCMBuffer:TPCMBuffer;
    Dest:PPasRISCVUInt8;
    CountAudioSamples,CountResampledAudioSamples:TPasRISCVSizeInt;
begin

 Remain:=aCount*2*SizeOf(TPasRISCVFloat);

 FillChar(aBuffer^,Remain,#0);

 Dest:=aBuffer;

 PCMStream:=fPCMStreams[0];

 PCMStream.fLock.Acquire;
 try

  while (Remain>0) and fQueues[VIRTIO_SND_VQ_TX].Ready do begin

   if not assigned(PCMStream.fCurrentBuffer) then begin
    PCMStream.fBufferQueueLock.Acquire;
    try
     if not PCMStream.fBufferQueue.Dequeue(PCMStream.fCurrentBuffer) then begin
      PCMStream.fCurrentBuffer:=nil;
     end;
    finally
     PCMStream.fBufferQueueLock.Release;
    end;
    if assigned(PCMStream.fCurrentBuffer) then begin
     NotifyTXBuffer(PCMStream.fCurrentBuffer);
    end;
   end;

   PCMBuffer:=PCMStream.fCurrentBuffer;

   if assigned(PCMBuffer) and (PCMBuffer.fRemainingSize>0) then begin

    if PCMStream.fActive then begin

     if not PCMBuffer.fPopulated then begin
      CountAudioSamples:=GetCountAudioSamples(PCMBuffer.fRawSize,PCMStream.fParams.Channels,PCMStream.fParams.Format);
      begin
       if PCMStream.fParams.Channels<2 then begin
        Size:=CountAudioSamples*2;
       end else begin
        Size:=CountAudioSamples*PCMStream.fParams.Channels;
       end;
       inc(Size,Size);
       if length(fTXScratchBuffer)<Size then begin
        SetLength(fTXScratchBuffer,Size*2);
       end;
      end;
      begin
       Size:=CountAudioSamples*2;
       if length(PCMBuffer.fFloatData)<Size then begin
        SetLength(PCMBuffer.fFloatData,Size*2);
       end;
      end;
      ConvertAudio(@PCMBuffer.fData[0],
                   PCMStream.fParams.Channels,
                   PCMStream.fParams.Format,
                   @PCMBuffer.fFloatData[0],
                   2,
                   TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT,
                   @fTXScratchBuffer[0],
                   CountAudioSamples
                  );
      if SampleRates[PCMStream.fParams.Rate]<>fSampleRate then begin
       CountResampledAudioSamples:=ConvertScale(CountAudioSamples,SampleRates[PCMStream.fParams.Rate],fSampleRate);
       Size:=CountResampledAudioSamples*2;
       if length(PCMBuffer.fResampledFloatData)<Size then begin
        SetLength(PCMBuffer.fResampledFloatData,Size*2);
       end;
       if length(PCMBuffer.fFloatData)<Size then begin
        SetLength(PCMBuffer.fFloatData,Size*2);
       end;
       ResampleLinear(@PCMBuffer.fFloatData[0],
                      CountAudioSamples,
                      @PCMBuffer.fResampledFloatData[0],
                      CountResampledAudioSamples,
                      2,
                      pointer(@PCMStream.fPreviousFrameEndValues[0]),
                      PCMStream.fResamplerPosition,
                      ConvertScale(TPasRISCVUInt64($100000000),fSampleRate,SampleRates[PCMStream.fParams.Rate]));
       Move(PCMBuffer.fResampledFloatData[0],PCMBuffer.fFloatData[0],CountResampledAudioSamples*2*SizeOf(TPasRISCVFloat));
       CountAudioSamples:=CountResampledAudioSamples;
      end else begin
       PCMBuffer.fResampledFloatData:=nil;
      end;
      PCMBuffer.fOffset:=0;
      PCMBuffer.fRemainingSize:=CountAudioSamples*2*SizeOf(TPasRISCVFloat);
      PCMBuffer.fPopulated:=true;
      if assigned(fOutputWAVStreamDump) then begin
       fOutputWAVStreamDump.Dump(@PCMBuffer.fFloatData[0],PCMBuffer.fRemainingSize,true);
       fOutputWAVStreamDump.Flush;
      end;
     end;

     if PCMBuffer.fRemainingSize>0 then begin
      repeat
       ToDo:=Remain;
       if ToDo>PCMBuffer.fRemainingSize then begin
        ToDo:=PCMBuffer.fRemainingSize;
       end;
       Move(PPasRISCVUInt8Array(Pointer(@PCMBuffer.fFloatData[0]))^[PCMBuffer.fOffset],Dest^,ToDo);
       inc(Dest,ToDo);
       inc(PCMBuffer.fOffset,ToDo);
       dec(PCMBuffer.fRemainingSize,ToDo);
       dec(Remain,ToDo);
      until (Remain=0) or (PCMBuffer.fRemainingSize=0);
     end;

    end else begin

     PCMBuffer.fRemainingSize:=0;

    end;

    if PCMBuffer.fRemainingSize=0 then begin
//   NotifyTXBuffer(PCMStream.fCurrentBuffer);
     PCMStream.ReturnBuffer(PCMStream.fCurrentBuffer,false);
     PCMStream.fCurrentBuffer:=nil;
    end;

   end else begin
    break;
   end;

  end;

{ if PCMStream.fActive and (Remain>0) then begin
   writeln('!');
  end;}

 finally
  PCMStream.fLock.Leave;
 end;

end;

procedure TPasRISCV.TVirtIOSoundDevice.InputAudioFillBufferCallback(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
begin
 FillChar(aBuffer^,aCount*2*SizeOf(TPasRISCVFloat),#0);
end;

{ TPasRISCV.TVirtIO9PDevice.TFIDDescriptors }

constructor TPasRISCV.TVirtIO9PDevice.TFIDDescriptors.Create(const aDevice:TVirtIO9PDevice);
begin
 inherited Create;
 fDevice:=aDevice;
 fHashMap:=TFIDDescriptorHashMap.Create(nil);
 fLock:=TPasMPMultipleReaderSingleWriterLock.Create;
 fFirst:=nil;
 fLast:=nil;
end;

destructor TPasRISCV.TVirtIO9PDevice.TFIDDescriptors.Destroy;
var Current,Next:TFIDDescriptor;
begin
 fLock.AcquireWrite;
 try
  Current:=fFirst;
  while assigned(Current) do begin
   Next:=Current.fNext;
   FreeAndNil(Current);
   Current:=Next;
  end;
  fFirst:=nil;
  fLast:=nil;
 finally
  fLock.ReleaseWrite;
 end;
 FreeAndNil(fLock);
 FreeAndNil(fHashMap);
 inherited Destroy;
end;

function TPasRISCV.TVirtIO9PDevice.TFIDDescriptors.Add(const aFID:TPasRISCVUInt32;const aFile:TPasRISCV9PFileSystem.TFSFile):TFIDDescriptor;
begin
 result:=TFIDDescriptor.Create;
 result.fDevice:=fDevice;
 result.fFID:=aFID;
 result.fFile:=aFile;
 fLock.AcquireWrite;
 try
  if assigned(fLast) then begin
   fLast.fNext:=result;
   result.fPrevious:=fLast;
   fLast:=result;
  end else begin
   fFirst:=result;
   fLast:=result;
  end;
  fHashMap.Add(aFID,result);
 finally
  fLock.ReleaseWrite;
 end;
end;

function TPasRISCV.TVirtIO9PDevice.TFIDDescriptors.Remove(const aFID:TPasRISCVUInt32):TFIDDescriptor;
begin
 fLock.AcquireWrite;
 try
  result:=fHashMap[aFID];
  if assigned(result) then begin
   fHashMap.Delete(aFID);
   if assigned(result.fPrevious) then begin
    result.fPrevious.fNext:=result.fNext;
   end else begin
    fFirst:=result.fNext;
   end;
   if assigned(result.fNext) then begin
    result.fNext.fPrevious:=result.fPrevious;
   end else begin
    fLast:=result.fPrevious;
   end;
  end;
 finally
  fLock.ReleaseWrite;
 end;
end;

function TPasRISCV.TVirtIO9PDevice.TFIDDescriptors.Find(const aFID:TPasRISCVUInt32):TFIDDescriptor;
begin
 fLock.AcquireRead;
 try
  result:=fHashMap[aFID];
 finally
  fLock.ReleaseRead;
 end;
end;

{ TPasRISCV.TVirtIO9PDevice }

constructor TPasRISCV.TVirtIO9PDevice.Create(const aMachine:TPasRISCV);
const MountTag:TPasRISCVRawByteString='extern';
begin

 inherited Create(aMachine,aMachine.fConfiguration.fVirtIO9PBase,aMachine.fConfiguration.fVirtIO9PSize,TVirtIODevice.TKind.MMIO);

 fIRQ:=aMachine.fConfiguration.fVirtIO9PIRQ;

 fFileSystem:=nil;

 fMaximumMessageSize:=8192;

 fDeviceID:=DeviceID;

 fDeviceFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1 or
                  //TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX or
//                TPasRISCV.TVirtIODevice.VIRTIO_F_IN_ORDER or
                  (1 shl 0);

 fQueues[0].ManualRecv:=false;
 fQueues[0].Asynchronous:=false;

 fFIDDescriptors:=TFIDDescriptors.Create(self);

 fRequestInProcess:=false;

 fConfigSpaceSize:=length(MountTag)+2;

 fConfigSpace[0]:=length(MountTag) and $ff;
 fConfigSpace[1]:=(length(MountTag) shr 8) and $ff;
 Move(MountTag[1],fConfigSpace[2],length(MountTag));

 fRecvBuffer:=nil;
 SetLength(fRecvBuffer,65536);

 fSendBuffer:=nil;
 SetLength(fSendBuffer,65536);

 fTempBuffer:=nil;
 SetLength(fTempBuffer,65536);

 fLock:=TPasMPCriticalSection.Create;

end;

destructor TPasRISCV.TVirtIO9PDevice.Destroy;
begin
 FreeAndNil(fFIDDescriptors);
 FreeAndNiL(fLock);
//FreeAndNil(fFileSystem);
 fRecvBuffer:=nil;
 fSendBuffer:=nil;
 fTempBuffer:=nil;
 inherited Destroy;
end;

class function TPasRISCV.TVirtIO9PDevice.Get9POperationName(const aOperation:TPasRISCVUInt32):TPasRISCVRawByteString;
begin
 case aOperation of
  VIRTIO_9P_STATFS:begin
   result:='statfs';
  end;
  VIRTIO_9P_LOPEN:begin
   result:='lopen';
  end;
  VIRTIO_9P_LCREATE:begin
   result:='lcreate';
  end;
  VIRTIO_9P_SYMLINK:begin
   result:='symlink';
  end;
  VIRTIO_9P_MKNOD:begin
   result:='mknod';
  end;
  VIRTIO_9P_READLINK:begin
   result:='readlink';
  end;
  VIRTIO_9P_GETATTR:begin
   result:='getattr';
  end;
  VIRTIO_9P_SETATTR:begin
   result:='setattr';
  end;
  VIRTIO_9P_XATTRWALK:begin
   result:='xattrwalk';
  end;
  VIRTIO_9P_READDIR:begin
   result:='readdir';
  end;
  VIRTIO_9P_FSYNC:begin
   result:='fsync';
  end;
  VIRTIO_9P_LOCK:begin
   result:='lock';
  end;
  VIRTIO_9P_GETLOCK:begin
   result:='getlock';
  end;
  VIRTIO_9P_LINK:begin
   result:='link';
  end;
  VIRTIO_9P_MKDIR:begin
   result:='mkdir';
  end;
  VIRTIO_9P_RENAMEAT:begin
   result:='renameat';
  end;
  VIRTIO_9P_UNLINKAT:begin
   result:='unlinkat';
  end;
  VIRTIO_9P_VERSION:begin
   result:='version';
  end;
  VIRTIO_9P_ATTACH:begin
   result:='attach';
  end;
  VIRTIO_9P_FLUSH:begin
   result:='flush';
  end;
  VIRTIO_9P_WALK:begin
   result:='walk';
  end;
  VIRTIO_9P_READ:begin
   result:='read';
  end;
  VIRTIO_9P_WRITE:begin
   result:='write';
  end;
  VIRTIO_9P_CLUNK:begin
   result:='clunk';
  end;
  else begin
   result:='unknown';
  end;
 end;
end;

procedure TPasRISCV.TVirtIO9PDevice.SendReply(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aID:TPasRISCVUInt8;const aTag:TPasRISCVUInt16;const aPayload:Pointer;const aPayloadSize:TPasRISCVUInt32);
var Buffer:Pointer;
    Size:TPasRISCVSizeUInt;
begin
{$ifdef PasRISCVDebugVirtIO9P}
{if (fMachine.fDebug and VIRTIO_DEBUG_9P)<>0 then}begin
  if aID=6 then begin
   write(' (error)');
  end;
  writeln;
 end;
{$endif}
 if fDriverOK then begin
  Size:=aPayloadSize+7;
  GetMem(Buffer,Size);
  try
   PPasRISCVUInt32(@PPasRISCVUInt8Array(Buffer)^[0])^:=Size;
   PPasRISCVUInt8(@PPasRISCVUInt8Array(Buffer)^[4])^:=aID+1;
   PPasRISCVUInt16(@PPasRISCVUInt8Array(Buffer)^[5])^:=aTag;
   Move(aPayload^,PPasRISCVUInt8Array(Buffer)^[7],aPayloadSize);
   if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Buffer,Size) and
           ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
           UsedRingSync(aQueueIndex)) then begin
    NotifyDeviceNeedsReset;
   end;
  finally
   FreeMem(Buffer);
  end;
 end;
end;

procedure TPasRISCV.TVirtIO9PDevice.SendError(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aTag:TPasRISCVUInt16;const aError:TPasRISCVInt32);
var Buffer:array[0..3] of TPasRISCVUInt8;
    Size:TPasRISCVSizeInt;
    Val32:TPasRISCVUInt32;
begin
 Val32:=-aError;
 Size:=0;
 Marshall(@Buffer[0],SizeOf(Buffer),Size,'w',[@Val32]);
 SendReply(aQueueIndex,aDescriptorIndex,6,aTag,@Buffer[0],Size);
end;

procedure TPasRISCV.TVirtIO9PDevice.OpenReply(const aQID:TPasRISCV9PFileSystem.PFSQID;const aError:TPasRISCVInt32;const aOpenInfo:POpenInfo);
var Buffer:array[0..31] of TPasRISCVUInt8;
    Size:TPasRISCVSizeInt;
    Val32:TPasRISCVUInt32;
begin
 try
  if aError<0 then begin
   SendError(aOpenInfo^.QueueIndex,aOpenInfo^.DescriptorIndex,aOpenInfo^.Tag,aError);
  end else begin
   Val32:=fMaximumMessageSize-24;
   Size:=0;
   Marshall(@Buffer[0],SizeOf(Buffer),Size,'Qw',[aQID,@Val32]);
   SendReply(aOpenInfo^.QueueIndex,aOpenInfo^.DescriptorIndex,12,aOpenInfo^.Tag,@Buffer[0],Size);
  end;
 finally
  FreeMem(aOpenInfo);
 end;
end;

procedure TPasRISCV.TVirtIO9PDevice.OpenCallback(const aFileSystem:TPasRISCV9PFileSystem;const aQID:TPasRISCV9PFileSystem.PFSQID;const aError:TPasRISCVUInt32;const aOpaque:Pointer);
var OpenInfo:POpenInfo;
begin
 OpenInfo:=POpenInfo(aOpaque);
 OpenReply(aQID,aError,OpenInfo);
 fRequestInProcess:=false;
//DeviceNotify(OpenInfo^.QueueIndex);
end;

procedure TPasRISCV.TVirtIO9PDevice.DeviceReset;
begin
 inherited DeviceReset;
 fRequestInProcess:=false;
end;

function TPasRISCV.TVirtIO9PDevice.DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean;
const Val32Zero:TPasRISCVUInt32=0;
      Val64Zero:TPasRISCVUInt64=0;
      Val32MaxFileNameLength:TPasRISCVUInt32=256;
      HeaderLength=4+1+2;
var Index,RecvBufferOffset,SendBufferLength:TPasRISCVSizeInt;
    FID,AFID,NewFID,Flags,Mode,UID,GID,Val32,Major,Minor:TPasRISCVUInt32;
    Mask,ATimeSec,ATimeNSec,MTimeSec,MTimeNSec,CTimeSec,CTimeNSec,Size:TPasRISCVUInt64;
    StatData:TPasRISCV9PFileSystem.TFSStat;
    Error:TPasRISCVInt32;
    Count:TPasRISCVInt64;
    FSOffset:TPasRISCVUInt64;
    Val8,ID:TPasRISCVUInt8;
    Val16:TPasRISCVUInt16;
    Tag,OldTag,NWName:TPasRISCVUInt16;
    StatFS:TPasRISCV9PFileSystem.TFSStatFS;
    FIDDescriptor,OtherFIDDescriptor:TFIDDescriptor;
    OpenInfo:POpenInfo;
    QID:TPasRISCV9PFileSystem.TFSQID;
    QIDs:array of TPasRISCV9PFileSystem.TFSQID;
    Lock:TPasRISCV9PFileSystem.TFSLock;
    File_:TPasRISCV9PFileSystem.TFSFile;
    NameString,OtherNameString,VersionString,UserNameString,AuthNameString:TPasRISCVRawByteString;
    Names:array of TPasRISCVRawByteString;
begin

 result:=false;

 if aQueueIndex<>0 then begin

  result:=true;

 end else if not fRequestInProcess then begin

  if aReadSize>=HeaderLength then begin

   fLock.Acquire;
   try

    if length(fRecvBuffer)<aReadSize then begin
     SetLength(fRecvBuffer,aReadSize);
    end;

    if CopyMemoryFromQueue(@fRecvBuffer[0],aQueueIndex,aDescriptorIndex,0,aReadSize) then begin

     ID:=PPasRISCVUInt8(Pointer(@fRecvBuffer[4]))^;
     Tag:=PPasRISCVUInt16(Pointer(@fRecvBuffer[5]))^;
     RecvBufferOffset:=HeaderLength;

  {$ifdef PasRISCVDebugVirtIO9P}
 {   if (fMachine.fDebug and VIRTIO_DEBUG_9P)<>0 then}begin
      write('9p: op=',Get9POperationName(ID));
     end;
  {$endif}

     case ID of

      VIRTIO_9P_STATFS:begin
       if assigned(fFileSystem) then begin
        fFileSystem.StatFS(StatFS);
        SendBufferLength:=0;
        Marshall(@fSendBuffer[0],
                 length(fSendBuffer),
                 SendBufferLength,
                 'wwddddddw',
                 [@Val32Zero,
                  @StatFS.BSize,
                  @StatFS.Blocks,
                  @StatFS.BFree,
                  @StatFS.BAvail,
                  @StatFS.Files,
                  @StatFS.FFree,
                  @Val64Zero,
                  @Val32MaxFileNameLength]);
        SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_LOPEN:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'ww',[@FID,@Flags]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         GetMem(OpenInfo,SizeOf(TOpenInfo));
         OpenInfo^.QueueIndex:=aQueueIndex;
         OpenInfo^.DescriptorIndex:=aDescriptorIndex;
         OpenInfo^.Tag:=Tag;
         Error:=fFileSystem.Open(@QID,FIDDescriptor.fFile,Flags,OpenCallback,OpenInfo);
         if Error<=0 then begin
          OpenReply(@QID,Error,OpenInfo);
         end else begin
          fRequestInProcess:=true;
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_LCREATE:begin
       NameString:='';
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wswww',[@FID,@NameString,@Mode,@Flags,@GID]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Error:=fFileSystem.Create_(@QID,FIDDescriptor.fFile,NameString,Flags,Mode,GID);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          Val32:=fMaximumMessageSize-24;
          SendBufferLength:=0;
          Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'Qw',[@QID,@Val32]);
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_SYMLINK:begin
       NameString:='';
       OtherNameString:='';
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wssw',[@FID,@NameString,@OtherNameString,@GID]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Error:=fFileSystem.Symlink(@QID,FIDDescriptor.fFile,NameString,OtherNameString,GID);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          SendBufferLength:=0;
          Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'Q',[@QID]);
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_MKNOD:begin
       NameString:='';
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wswwww',[@FID,@NameString,@Mode,@Major,@Minor,@GID]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Error:=fFileSystem.Mknod(@QID,FIDDescriptor.fFile,NameString,Mode,Major,Minor,GID);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          SendBufferLength:=0;
          Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'Q',[@QID]);
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_READLINK:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'w',[@FID]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         FillChar(fTempBuffer[0],1025,#0);
         Error:=fFileSystem.ReadLink(@fTempBuffer[0],1024,FIDDescriptor.fFile);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          NameString:=TPasRISCVRawByteString(PAnsiChar(Pointer(@fTempBuffer[0])));
          try
           SendBufferLength:=0;
           Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'s',[@NameString]);
          finally
           NameString:='';
          end;
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_GETATTR:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wd',[@FID,@Mask]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         FillChar(StatData,SizeOf(StatData),#0);
         Error:=fFileSystem.Stat(FIDDescriptor.fFile,StatData);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          ATimeNSec:=StatData.ATimeNSec;
          MTImeNSec:=StatData.MTimeNSec;
          CTimeNSec:=StatData.CTimeNSec;
          SendBufferLength:=0;
          Marshall(@fSendBuffer[0],
                   length(fSendBuffer),
                   SendBufferLength,
                   'dQwwwddddddddddddddd',
                   [@Mask,
                    @StatData.QID,
                    @StatData.Mode,
                    @StatData.UID,
                    @StatData.GID,
                    @StatData.NLink,
                    @StatData.RDev,
                    @StatData.Size,
                    @StatData.BlkSize,
                    @StatData.Blocks,
                    @StatData.ATimeSec,
                    @ATimeNSec,
                    @StatData.MTimeSec,
                    @MTimeNSec,
                    @StatData.CTimeSec,
                    @CTimeNSec,
                    @Val64Zero,
                    @Val64Zero,
                    @Val64Zero,
                    @Val64Zero]);
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_SETATTR:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wwwwwddddd',[@FID,@Mask,@Mode,@UID,@GID,@Size,@ATimeSec,@ATimeNSec,@MTimeSec,@MTimeNSec]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         CTimeSec:=MTimeSec;
         CTimeNSec:=MTimeNSec;
         Error:=fFileSystem.SetAttr(FIDDescriptor.fFile,Mask,Mode,UID,GID,Size,ATimeSec,ATimeNSec,MTimeSec,MTimeNSec,CTimeSec,CTimeNSec);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,nil,0);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_XATTRWALK:begin
       SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_ENOTSUP);
      end;

      VIRTIO_9P_READDIR:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wdw',[@FID,@FSOffset,@Val32]) then begin
        Size:=Val32;
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         if length(fSendBuffer)<Size+4 then begin
          SetLength(fSendBuffer,(Size+4)*2);
         end;
         FillChar(fSendBuffer[0],Size+4,#0);
         Count:=fFileSystem.ReadDir(FIDDescriptor.fFile,FSOffset,@fSendBuffer[4],Size);
         if Count<0 then begin
          Error:=Count;
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          PPasRISCVUInt32(Pointer(@fSendBuffer[0]))^:=Count;
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],Count+4);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_FSYNC:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'w',[@FID]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         // Ignored for now
         SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,nil,0);
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_LOCK:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wbwddws',[@FID,@Lock.Type_,@Lock.Flags,@Lock.Start,@Lock.Length,@Lock.ProcID,@Lock.ClientID]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Lock.ClientID:=nil;
         try
          Error:=fFileSystem.Lock(FIDDescriptor.fFile,@Lock);
          if Error<0 then begin
           SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
          end else begin
           Val8:=Error;
           SendBufferLength:=0;
           Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'b',[@Val8]);
           SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
          end;
         finally
          if assigned(Lock.ClientID) then begin
           try
            FreeMem(Lock.ClientID);
           finally
            Lock.ClientID:=nil;
           end;
          end;
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_GETLOCK:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wbddws',[@FID,@Lock.Type_,@Lock.Start,@Lock.Length,@Lock.ProcID,@Lock.ClientID]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Lock.ClientID:=nil;
         try
          Error:=fFileSystem.GetLock(FIDDescriptor.fFile,@Lock);
          if Error<0 then begin
           SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
          end else begin
           SendBufferLength:=0;
           Marshall(@fSendBuffer[0],
                    length(fSendBuffer),
                    SendBufferLength,
                    'bddws',
                    [@Lock.Type_,
                     @Lock.Start,
                     @Lock.Length,
                     @Lock.ProcID,
                     @Lock.ClientID]);
           SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
          end;
         finally
          if assigned(Lock.ClientID) then begin
           try
            FreeMem(Lock.ClientID);
           finally
            Lock.ClientID:=nil;
           end;
          end;
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_LINK:begin
       NameString:='';
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wws',[@FID,@FID,@NameString]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Error:=fFileSystem.Link(FIDDescriptor.fFile,FIDDescriptor.fFile,NameString);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,nil,0);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_MKDIR:begin
       NameString:='';
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wsww',[@FID,@NameString,@Mode,@GID]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Error:=fFileSystem.MkDir(@QID,FIDDescriptor.fFile,NameString,Mode,GID);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          SendBufferLength:=0;
          Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'Q',[@QID]);
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_RENAMEAT:begin
       NameString:='';
       OtherNameString:='';
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wsws',[@FID,@NameString,@NewFID,@OtherNameString]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        OtherFIDDescriptor:=fFIDDescriptors.Find(NewFID);
        if assigned(FIDDescriptor) and assigned(OtherFIDDescriptor) then begin
         Error:=fFileSystem.RenameAt(FIDDescriptor.fFile,NameString,OtherFIDDescriptor.fFile,OtherNameString);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,nil,0);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_UNLINKAT:begin
       NameString:='';
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wsw',[@FID,@NameString,@Flags]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Error:=fFileSystem.UnlinkAt(FIDDescriptor.fFile,NameString);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,nil,0);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_VERSION:begin
       VersionString:='';
       if Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'ws',[@Val32,@VersionString]) then begin
        fMaximumMessageSize:=Val32;
        VersionString:='9P2000.L';
        SendBufferLength:=0;
        Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'ws',[@fMaximumMessageSize,@VersionString]);
        SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_ATTACH:begin
       UserNameString:='';
       AuthNameString:='';
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wwssw',[@FID,@AFID,@UserNameString,@AuthNameString,@UID]) then begin
        Error:=fFileSystem.Attach(File_,@QID,UID,UserNameString,AuthNameString);
        if Error<0 then begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
        end else begin
         fFIDDescriptors.Add(FID,File_);
         SendBufferLength:=0;
         Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'Q',[@QID]);
         SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_FLUSH:begin
       if Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'h',[@OldTag]) then begin
        // Ignored for now
        SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,nil,0);
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_WALK:begin
       FID:=0;
       NewFID:=0;
       NWName:=0;
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wwh',[@FID,@NewFID,@NWName]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         QIDs:=nil;
         try
          SetLength(QIDs,NWName);
          Names:=nil;
          try
           SetLength(Names,NWName);
           Error:=0;
           for Index:=0 to TPasRISCVSizeInt(NWName)-1 do begin
            NameString:='';
            if Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'s',[@NameString]) then begin
             Names[Index]:=NameString;
             NameString:='';
            end else begin
             Error:=-TPasRISCV9PFileSystem.P9_EPROTO;
             break;
            end;
           end;
           if Error=0 then begin
            Count:=fFileSystem.Walk(File_,@QIDs[0],FIDDescriptor.fFile,NWName,Names);
            if Count>=0 then begin
             Val16:=Count;
             SendBufferLength:=0;
             Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'h',[@Val16]);
             for Index:=0 to Count-1 do begin
              Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'Q',[@QIDs[Index]]);
             end;
             fFIDDescriptors.Add(NewFID,File_);
             SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
            end else begin
             Error:=Count;
             SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
            end;
           end else begin
            SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
           end;
          finally
           try
            for Index:=0 to TPasRISCVSizeInt(NWName)-1 do begin
             Names[Index]:='';
            end;
           finally
            Names:=nil;
           end;
          end;
         finally
          QIDs:=nil;
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_READ:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wdw',[@FID,@FSOffset,@Val32]) then begin
        Size:=Val32;
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         if length(fSendBuffer)<Size+4 then begin
          SetLength(fSendBuffer,(Size+4)*2);
         end;
         FillChar(fSendBuffer[0],Size+4,#0);
         Count:=fFileSystem.Read(FIDDescriptor.fFile,FSOffset,@fSendBuffer[4],Size);
         if Count<0 then begin
          Error:=Count;
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          PPasRISCVUInt32(Pointer(@fSendBuffer[0]))^:=Count;
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],Count+4);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_WRITE:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wdw',[@FID,@FSOffset,@Val32]) then begin
        Size:=Val32;
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Count:=fFileSystem.Write(FIDDescriptor.fFile,FSOffset,@fRecvBuffer[RecvBufferOffset],Size);
         if Count<0 then begin
          Error:=Count;
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          Val32:=Count;
          SendBufferLength:=0;
          Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'w',[@Val32]);
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_CLUNK:begin
       if Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'w',[@FID]) then begin
        fFIDDescriptors.Remove(FID);
        SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,nil,0);
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      else begin
       SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
      end;

     end;

    end else begin
     NotifyDeviceNeedsReset;
     SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
    end;

   finally
    fLock.Release;
   end;

  end else begin

   result:=false;

  end;

 end else begin

  result:=false;

 end;

end;

{ TPasRISCV.TVirtIONetDevice }

constructor TPasRISCV.TVirtIONetDevice.Create(const aMachine:TPasRISCV);
begin

 inherited Create(aMachine,aMachine.fConfiguration.fVirtIONetBase,aMachine.fConfiguration.fVirtIONetSize,TVirtIODevice.TKind.MMIO);

 fIRQ:=aMachine.fConfiguration.fVirtIONetIRQ;

 fDeviceID:=DeviceID;

 fDeviceFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1 or
                  //TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX or
                  VIRTIO_NET_F_MAC {or VIRTIO_NET_F_STATUS};

 fQueues[0].ManualRecv:=true;
 fQueues[0].Asynchronous:=false;

 fQueues[1].ManualRecv:=false;
 fQueues[1].Asynchronous:=false;

 FillChar(fConfigSpace[0],8,#0);

 // Initial MAC adresss
 fConfigSpace[0]:=$02;
 fConfigSpace[1]:=$00;
 fConfigSpace[2]:=$00;
 fConfigSpace[3]:=$00;
 fConfigSpace[4]:=$00;
 fConfigSpace[5]:=$01;

 fConfigSpaceSize:=8; // 6 + 2

 fSendBuffer:=nil;
 SetLength(fSendBuffer,65536);

 fReceiveBuffer:=nil;
 SetLength(fReceiveBuffer,65536);

 fEthernetDevice:=nil;

end;

destructor TPasRISCV.TVirtIONetDevice.Destroy;
begin
 fSendBuffer:=nil;
 fReceiveBuffer:=nil;
 fEthernetDevice:=nil;
 inherited Destroy;
end;

procedure TPasRISCV.TVirtIONetDevice.DeviceReset;
begin
 inherited DeviceReset;
end;

function TPasRISCV.TVirtIONetDevice.DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean;
var Header:PVirtIONetHeader;
    Buffer:Pointer;
    Size:TPasRISCVSizeInt;
begin
 case aQueueIndex of
  1:begin
   if length(fReceiveBuffer)<aReadSize then begin
    SetLength(fReceiveBuffer,aReadSize+((aReadSize+1) shr 1));
   end;
   if CopyMemoryFromQueue(fReceiveBuffer,aQueueIndex,aDescriptorIndex,0,aReadSize) then begin
    if aReadSize>=SizeOf(TVirtIONetHeader) then begin
     Header:=pointer(@fReceiveBuffer[0]);
     if (Header^.Flags and VIRTIO_NET_HDR_F_NEEDS_CSUM)<>0 then begin
      // Checksum offload
     end;
     if assigned(fEthernetDevice) then begin
      Size:=aReadSize-SizeOf(TVirtIONetHeader);
      if Size>0 then begin
       Buffer:=@fReceiveBuffer[SizeOf(TVirtIONetHeader)];
       if assigned(fEthernetDevice) then begin
        fEthernetDevice.WritePacket(Buffer,Size);
       end;
      end;
     end;
    end;
    if not (ConsumeDescriptor(aQueueIndex,aDescriptorIndex,0) and
            UsedRingSync(aQueueIndex)) then begin
     NotifyDeviceNeedsReset;
    end;
   end else begin
    NotifyDeviceNeedsReset;
   end;
  end;
  else begin
  end;
 end;
 result:=true;
end;

function TPasRISCV.TVirtIONetDevice.CanWritePacket:Boolean;
var Queue:PQueue;
    AvailableIndex:TPasRISCVUInt16;
begin
 Queue:=@fQueues[0];
 if fDriverOK and Queue^.Ready then begin
  TPasMPMultipleReaderSingleWriterSpinLock.AcquireRead(Queue^.Lock);
  try
   if Read16(Queue^.AvailableAddress+2,AvailableIndex) then begin
    result:=Queue^.ShadowAvailableIndex<>AvailableIndex;
   end else begin
    NotifyDeviceNeedsReset;
    result:=false;
   end;
  finally
   TPasMPMultipleReaderSingleWriterSpinLock.ReleaseRead(Queue^.Lock);
  end;
 end else begin
  result:=false;
 end;
end;

procedure TPasRISCV.TVirtIONetDevice.WritePacket(const aBuffer:Pointer;const aBufferSize:TPasRISCVSizeInt);
var Queue:PQueue;
    Header:PVirtIONetHeader;
    AvailableIndex,DescriptorIndex:TPasRISCVUInt16;
    ReadSize,WriteSize:TPasRISCVUInt64;
    Size:TPasRISCVSizeInt;
begin
 Queue:=@fQueues[0];
 if fDriverOK and Queue^.Ready then begin
  TPasMPMultipleReaderSingleWriterSpinLock.AcquireWrite(Queue^.Lock);
  try
   if Read16(Queue^.AvailableAddress+2,AvailableIndex) then begin
    if Queue^.ShadowAvailableIndex<>AvailableIndex then begin
     if Read16(Queue^.AvailableAddress+4+((Queue^.ShadowAvailableIndex and (Queue^.Size-1)) shl 1),DescriptorIndex) then begin
      if GetDescriptors(ReadSize,WriteSize,0,DescriptorIndex) then begin
       Size:=SizeOf(TVirtIONetHeader)+aBufferSize;
       if Size<=WriteSize then begin
        if length(fSendBuffer)<Size then begin
         SetLength(fSendBuffer,Size+((Size+1) shr 1));
        end;
        Header:=pointer(@fSendBuffer[0]);
        FillChar(Header^,SizeOf(TVirtIONetHeader),#0);
        if aBufferSize>0 then begin
         Move(aBuffer^,fSendBuffer[SizeOf(TVirtIONetHeader)],aBufferSize);
        end;
        if not (CopyMemoryToQueue(0,DescriptorIndex,0,@fSendBuffer[0],Size) and
                ConsumeDescriptor(0,DescriptorIndex,Size) and
                UsedRingSync(0) and
                AdvanceShadowAvailableIndex(0)) then begin
         NotifyDeviceNeedsReset;
        end;
       end;
      end else begin
       NotifyDeviceNeedsReset;
      end;
     end else begin
      NotifyDeviceNeedsReset;
     end;
    end;
   end else begin
    NotifyDeviceNeedsReset;
   end;
  finally
   TPasMPMultipleReaderSingleWriterSpinLock.ReleaseWrite(Queue^.Lock);
  end;
 end;
end;

procedure TPasRISCV.TVirtIONetDevice.SetCarrier(const aCarrierStatus:Boolean);
//var CurrentCarrierStatus:TPasRISCVUInt8;
begin
{CurrentCarrierStatus:=fConfigSpace[6] and 1;
 if CurrentCarrierStatus<>TPasRISCVUInt8(TPasRISCVUInt8(aCarrierStatus) and 1) then begin
  fConfigSpace[6]:=(TPasRISCVUInt8(aCarrierStatus) and 1) shl 0;
  //DeviceChangeNotify;
 end;}
end;

procedure TPasRISCV.TVirtIONetDevice.SetEthernetDevice(const aEthernetDevice:TPasRISCVEthernetDevice);
begin

 if fEthernetDevice<>aEthernetDevice then begin

  // Unassign old Ethernet device callbacks and wipe mac address in config space
  if assigned(fEthernetDevice) then begin

   fEthernetDevice.fOnCanWritePacket:=nil;
   fEthernetDevice.fOnWritePacket:=nil;
   fEthernetDevice.fOnSetCarrier:=nil;

   FillChar(fConfigSpace[0],6,#0);

  end;

  // Assign new Ethernet device
  fEthernetDevice:=aEthernetDevice;

  // Assign new Ethernet device callbacks and copy mac address to config space
  if assigned(fEthernetDevice) then begin

   fEthernetDevice.fOnCanWritePacket:=CanWritePacket;
   fEthernetDevice.fOnWritePacket:=WritePacket;
   fEthernetDevice.fOnSetCarrier:=SetCarrier;

   Move(fEthernetDevice.fMACAddress[0],fConfigSpace[0],SizeOf(TPasRISCVEthernetDevice.TMACAddress));

  end;

 end;

end;

{ TPasRISCV.TVirtIORandomGeneratorDevice }

constructor TPasRISCV.TVirtIORandomGeneratorDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fVirtIORandomGeneratorBase,aMachine.fConfiguration.fVirtIORandomGeneratorSize,TVirtIODevice.TKind.MMIO);

 fIRQ:=aMachine.fConfiguration.fVirtIORandomGeneratorIRQ;

 fDeviceID:=DeviceID;

 fDeviceFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1;

 fQueues[0].ManualRecv:=false;
 fQueues[0].Asynchronous:=false;

 fSendBuffer:=nil;
 SetLength(fSendBuffer,65536);

 fReceiveBuffer:=nil;
 SetLength(fReceiveBuffer,65536);

end;

destructor TPasRISCV.TVirtIORandomGeneratorDevice.Destroy;
begin
 fSendBuffer:=nil;
 fReceiveBuffer:=nil;
 inherited Destroy;
end;

procedure TPasRISCV.TVirtIORandomGeneratorDevice.DeviceReset;
begin
 inherited DeviceReset;
end;

function TPasRISCV.TVirtIORandomGeneratorDevice.DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean;
begin
 if length(fReceiveBuffer)<aReadSize then begin
  SetLength(fReceiveBuffer,aReadSize+((aReadSize+1) shr 1));
 end;
 if CopyMemoryFromQueue(fReceiveBuffer,aQueueIndex,aDescriptorIndex,0,aReadSize) then begin
  if length(fSendBuffer)<aWriteSize then begin
   SetLength(fSendBuffer,aWriteSize+((aWriteSize+1) shr 1));
  end;
  if aWriteSize>0 then begin
   fMachine.fRandomGeneratorLock.Acquire;
   try
    fMachine.fRandomGenerator.GetRandomBytes(fSendBuffer[0],aWriteSize);
   finally
    fMachine.fRandomGeneratorLock.Release;
   end;
  end;
  if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,@fSendBuffer[0],aWriteSize) and
          ConsumeDescriptor(aQueueIndex,aDescriptorIndex,aWriteSize) and
          UsedRingSync(aQueueIndex)) then begin
   NotifyDeviceNeedsReset;
  end;
 end else begin
  NotifyDeviceNeedsReset;
 end;
 result:=true;
end;

{$if defined(PasRISCVUseRealConsole)}

{ TPasRISCV.TUARTDevice.TUARTInputThread }

constructor TPasRISCV.TUARTDevice.TUARTInputThread.Create(const aUARTDevice:TUARTDevice);
begin
{$if defined(Windows) and not defined(fpc)}
 fConsoleInputHandle:=GetStdHandle(STD_INPUT_HANDLE);
{$ifend}
 fUARTDevice:=aUARTDevice;
 fEvent:=TEvent.Create(nil,false,false,'');
 inherited Create(false);
end;

destructor TPasRISCV.TUARTDevice.TUARTInputThread.Destroy;
begin
 Shutdown;
 inherited Destroy;
end;

procedure TPasRISCV.TUARTDevice.TUARTInputThread.Shutdown;
begin
 if not Finished then begin
  Terminate;
  fEvent.SetEvent;
  WaitFor;
 end;
end;

procedure TPasRISCV.TUARTDevice.TUARTInputThread.Execute;
{$if defined(Windows) and not defined(fpc)}
var ReadCount,ResultLen,Index:DWORD;
    InputRecord:_INPUT_RECORD;
    Data:array[0..7] of AnsiChar;
 procedure ReadInput;
 var Surrogate,CharValue:DWORD;
 begin

  ResultLen:=0;

  repeat

   if not ReadConsoleInputW(fConsoleInputHandle,InputRecord,1,ReadCount) then begin
    exit;
   end;

   if (ReadCount=1) and (InputRecord.EventType=KEY_EVENT) and InputRecord.Event.KeyEvent.bKeyDown then begin

    CharValue:=ord(InputRecord.Event.KeyEvent.UnicodeChar);

    while CharValue=0 do begin

     if not ReadConsoleInputW(fConsoleInputHandle,InputRecord,1,ReadCount) then begin
      exit;
     end;

     if (ReadCount=1) and (InputRecord.EventType=KEY_EVENT) then begin
      CharValue:=ord(InputRecord.Event.KeyEvent.UnicodeChar);
      if not InputRecord.Event.KeyEvent.bKeyDown then begin
       break;
      end;
     end;
    end;

    if CharValue>=$80 then begin

     if (CharValue>=$d800) and (CharValue<$e000) then begin
      if not ReadConsoleInputW(fConsoleInputHandle,InputRecord,1,ReadCount) then begin
       exit;
      end;
      if (ReadCount=1) and (InputRecord.EventType=KEY_EVENT) and InputRecord.Event.KeyEvent.bKeyDown then begin
       Surrogate:=ord(InputRecord.Event.KeyEvent.UnicodeChar);
       while Surrogate=0 do begin
        if not ReadConsoleInputW(fConsoleInputHandle,InputRecord,1,ReadCount) then begin
         exit;
        end;
        if (ReadCount=1) and (InputRecord.EventType=KEY_EVENT) then begin
         Surrogate:=ord(InputRecord.Event.KeyEvent.UnicodeChar);
         if not InputRecord.Event.KeyEvent.bKeyDown then begin
          break;
         end;
        end;
       end;
       CharValue:=($010000-$dc00)+((CharValue-$d800) shl 10)+Surrogate;
      end;
     end;

     if CharValue=0 then begin
      exit;
     end else begin
      if CharValue<=$7f then begin
       Data[0]:=AnsiChar(TPasRISCVUInt8(CharValue));
       ResultLen:=1;
      end else if CharValue<=$7ff then begin
       Data[0]:=AnsiChar(TPasRISCVUInt8($c0 or ((CharValue shr 6) and $1f)));
       Data[1]:=AnsiChar(TPasRISCVUInt8($80 or (CharValue and $3f)));
       ResultLen:=2;
{     end else if CharValue<=$d7ff then begin
       Data[0]:=AnsiChar(TPasRISCVUInt8($e0 or ((CharValue shr 12) and $0f)));
       Data[1]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 6) and $3f)));
       Data[2]:=AnsiChar(TPasRISCVUInt8($80 or (CharValue and $3f)));
       ResultLen:=3;
      end else if CharValue<=$dfff then begin
       Data[0]:=#$ef; // $fffd
       Data[1]:=#$bf;
       Data[2]:=#$bd;
       ResultLen:=3;}
      end else if CharValue<=$ffff then begin
       Data[0]:=AnsiChar(TPasRISCVUInt8($e0 or ((CharValue shr 12) and $0f)));
       Data[1]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 6) and $3f)));
       Data[2]:=AnsiChar(TPasRISCVUInt8($80 or (CharValue and $3f)));
       ResultLen:=3;
      end else if CharValue<=$1fffff then begin
       Data[0]:=AnsiChar(TPasRISCVUInt8($f0 or ((CharValue shr 18) and $07)));
       Data[1]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 12) and $3f)));
       Data[2]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 6) and $3f)));
       Data[3]:=AnsiChar(TPasRISCVUInt8($80 or (CharValue and $3f)));
       ResultLen:=4;
//{
      end else if CharValue<=$3ffffff then begin
       Data[0]:=AnsiChar(TPasRISCVUInt8($f8 or ((CharValue shr 24) and $03)));
       Data[1]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 18) and $3f)));
       Data[2]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 12) and $3f)));
       Data[3]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 6) and $3f)));
       Data[4]:=AnsiChar(TPasRISCVUInt8($80 or (CharValue and $3f)));
       ResultLen:=5;
      end else if CharValue<=$7fffffff then begin
       Data[0]:=AnsiChar(TPasRISCVUInt8($fc or ((CharValue shr 30) and $01)));
       Data[1]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 24) and $3f)));
       Data[2]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 18) and $3f)));
       Data[3]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 12) and $3f)));
       Data[4]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 6) and $3f)));
       Data[5]:=AnsiChar(TPasRISCVUInt8($80 or (CharValue and $3f)));
       ResultLen:=6;//}
      end else begin
       Data[0]:=#$ef; // $fffd
       Data[1]:=#$bf;
       Data[2]:=#$bd;
       ResultLen:=3;
      end;

     end;

    end else begin

     Data[0]:=AnsiChar(TPasRISCVUInt8(CharValue));
     ResultLen:=1;

    end;

    break;

   end;

  until false;
 end;
{$elseif defined(fpc) and defined(Unix)}
var InputFD:pollfd;
    InputChar:AnsiChar;
{$else}
var InputChar:AnsiChar;
{$ifend}
begin
 NameThreadForDebugging(' TPasRISCV.TUARTInputThread');
{$if defined(fpc) and defined(Unix)}
 InputFD.fd:=StdInputHandle;
 InputFD.events:=POLLIN;
{$ifend}
 while not Terminated do begin
{$if defined(Windows) and not defined(fpc)}
  ReadCount:=0;
  if PeekConsoleInputW(fConsoleInputHandle,InputRecord,1,ReadCount) and
     (ReadCount=1) and
     (InputRecord.EventType=KEY_EVENT) and
     InputRecord.Event.KeyEvent.bKeyDown then begin
   ReadInput;
   if ResultLen>0 then begin
    repeat
     if fUARTDevice.fInputQueue.AvailableForEnqueue>=ResultLen then begin
      for Index:=1 to ResultLen do begin
       fUARTDevice.fInputQueue.Enqueue(Data[Index-1]);
      end;
      fUARTDevice.fMachine.UARTDevice.Notify;
      fUARTDevice.fMachine.Interrupt;
      fUARTDevice.fMachine.WakeUp;
      break;
     end else begin
      fEvent.WaitFor(1);
     end;
    until Terminated;
   end;
  end else begin
   if ReadCount=1 then begin
    ReadConsoleInputW(fConsoleInputHandle,InputRecord,1,ReadCount);
   end else begin
    fEvent.WaitFor(1);
   end;
  end;
{$elseif defined(fpc)}
{$if defined(Unix)}
  if FpPoll(@InputFD,1,1000)>0 then begin
   if fpRead(StdInputHandle,@InputChar,1)<>0 then begin
    repeat
     if fUARTDevice.fInputQueue.AvailableForEnqueue>0 then begin
      fUARTDevice.fInputQueue.Enqueue(InputChar);
      fUARTDevice.fMachine.UARTDevice.Notify;
      fUARTDevice.fMachine.Interrupt;
      fUARTDevice.fMachine.WakeUp;
      break;
     end else begin
      fEvent.WaitFor(1);
     end;
    until Terminated;
   end;
  end;
{$else}
  if KeyPressed then begin
   InputChar:=ReadKey;
   if InputChar<>#0 then begin
    repeat
     if fUARTDevice.fInputQueue.AvailableForEnqueue>0 then begin
      fUARTDevice.fInputQueue.Enqueue(InputChar);
      fUARTDevice.fMachine.UARTDevice.Notify;
      fUARTDevice.fMachine.Interrupt;
      fUARTDevice.fMachine.WakeUp;
      break;
     end else begin
      fEvent.WaitFor(1);
     end;
    until Terminated;
   end;
  end else begin
   fEvent.WaitFor(1);
  end;
{$ifend}
{$else}
  Read(InputChar);
  if InputChar<>#0 then begin
   repeat
    if fUARTDevice.fInputQueue.AvailableForEnqueue>0 then begin
     fUARTDevice.fInputQueue.Enqueue(InputChar);
     fUARTDevice.fMachine.UARTDevice.Notify;
     fUARTDevice.fMachine.Interrupt;
     fUARTDevice.fMachine.WakeUp;
     break;
    end else begin
     fEvent.WaitFor(1);
    end;
   until Terminated;
  end;
{$ifend}
 end;
end;

{ TPasRISCV.TUARTDevice.TUARTOutputThread }

constructor TPasRISCV.TUARTDevice.TUARTOutputThread.Create(const aUARTDevice:TUARTDevice);
begin
{$if defined(Windows) and not defined(fpc)}
 fConsoleOutputHandle:=GetStdHandle(STD_OUTPUT_HANDLE);
{$ifend}
 fUARTDevice:=aUARTDevice;
 fEvent:=TEvent.Create(nil,false,false,'');
 inherited Create(false);
end;

destructor TPasRISCV.TUARTDevice.TUARTOutputThread.Destroy;
begin
 Shutdown;
 inherited Destroy;
end;

procedure TPasRISCV.TUARTDevice.TUARTOutputThread.Shutdown;
begin
 if not Finished then begin
  Terminate;
  fEvent.SetEvent;
  WaitFor;
 end;
end;

procedure TPasRISCV.TUARTDevice.TUARTOutputThread.Execute;
var Count:TPasMPSizeInt;
{$if defined(Windows) and not defined(fpc)}
    Written:DWORD;
{$ifend}
begin
 NameThreadForDebugging(' TPasRISCV.TUARTOutputThread');
 while not Terminated do begin
{$if defined(Windows) and not defined(fpc)}
  while not Terminated do begin
   fEvent.WaitFor(1000);
   Count:=fUARTDevice.fOutputRingBuffer.ReadAsMuchAsPossible(@fBuffer[0],SizeOf(fBuffer)-1);
   if Count>0 then begin
    fBuffer[Count]:=#0;
    WriteFile(fConsoleOutputHandle,fBuffer,Count,Written,nil);
   end;
  end;
{$elseif defined(fpc) and defined(Unix)}
  while not Terminated do begin
   fEvent.WaitFor(1000);
   Count:=fUARTDevice.fOutputRingBuffer.ReadAsMuchAsPossible(@fBuffer[0],SizeOf(fBuffer));
   if Count>0 then begin
    fpWrite(StdOutputHandle,@fBuffer[0],Count);
   end;
  end;
{$else}
  while not Terminated do begin
   fEvent.WaitFor(1000);
   Count:=fUARTDevice.fOutputRingBuffer.ReadAsMuchAsPossible(@fBuffer[0],SizeOf(fBuffer)-1);
   if Count>0 then begin
    fBuffer[Count]:=#0;
    Write(PAnsiChar(@fBuffer[0]));
   end;
  end;
{$ifend}
 end;
end;

{$ifend}

{ TPasRISCV.TUARTDevice }

constructor TPasRISCV.TUARTDevice.Create(const aMachine:TPasRISCV);
{$if defined(PasRISCVUseRealConsole)}
{$if defined(fpc) and defined(Unix)}
var Term:TTermios;
{$ifend}
{$ifend}
begin
 inherited Create(aMachine,aMachine.fConfiguration.fUARTBase,aMachine.fConfiguration.fUARTSize);

 fIRQ:=aMachine.fConfiguration.fUARTIRQ;

 fDLL:=0;
 fDLM:=0;
 fISR:=0;
 fIER:=0;
 fFCR:=0;
 fLCR:=0;
 fMCR:=0;
 fMSR:=0;
 fSCR:=0;

{$if defined(PasRISCVUseRealConsole)}
{$if defined(fpc) and defined(Unix)}
 Term.c_line:=#0;
 TCGetAttr(0,Term);
 fOriginalTerm:=Term;
 Term.c_lflag:=Term.c_lflag and not (termio.ECHO or termio.ICANON or termio.ISIG or termio.IEXTEN);
 Term.c_iflag:=Term.c_iflag and not (termio.IXON or termio.ICRNL);
 TCSetAttr(0,TCSAFLUSH,Term);
{$ifend}
{$ifend}

 fInputQueue:=TCharQueue.Create(1048576);

 fOutputRingBuffer:=TPasMPSingleProducerSingleConsumerRingBuffer.Create(1048576);

{$if not defined(PasRISCVUseRealConsole)}
 fOutputEvent:=TPasMPEvent.Create(nil,false,false,'');
{$ifend}

{$if defined(PasRISCVUseRealConsole)}
 fUARTInputThread:=TUARTInputThread.Create(self);

 fUARTOutputThread:=TUARTOutputThread.Create(self);
{$ifend}

end;

destructor TPasRISCV.TUARTDevice.Destroy;
begin
{$if defined(PasRISCVUseRealConsole)}
 fUARTInputThread.Shutdown;
 fUARTOutputThread.Shutdown;
 FreeAndNil(fUARTInputThread);
 FreeAndNil(fUARTOutputThread);
{$ifend}
{$if not defined(PasRISCVUseRealConsole)}
 FreeAndNil(fOutputEvent);
{$ifend}
 FreeAndNil(fOutputRingBuffer);
 FreeAndNil(fInputQueue);
{$if defined(PasRISCVUseRealConsole)}
{$if defined(fpc) and defined(Unix)}
 TCSetAttr(0,TCSAFLUSH,fOriginalTerm);
{$ifend}
{$ifend}
inherited Destroy;
end;

function TPasRISCV.TUARTDevice.Poll:TPasRISCVUInt32;
begin
 result:=0;
 if fInputQueue.AvailableForDequeue>0 then begin
  result:=result or POLL_RX;
 end;
 if fInputQueue.AvailableForEnqueue>0 then begin
  result:=result or POLL_TX;
 end;
end;

function TPasRISCV.TUARTDevice.ReadChar:TPasRISCVUInt32;
var c:AnsiChar;
begin
 if fInputQueue.Dequeue(c) then begin
  result:=TPasRISCVUInt8(c);
 end else begin
  result:=0;
 end;
end;

procedure TPasRISCV.TUARTDevice.WriteChar(const aValue:TPasRISCVUInt32);
var c:AnsiChar;
begin
 c:=AnsiChar(TPasRISCVUInt8(aValue and $ff));
 fOutputRingBuffer.Write(@c,SizeOf(AnsiChar));
{$if defined(PasRISCVUseRealConsole)}
 fUARTOutputThread.fEvent.SetEvent;
{$else}
 fOutputEvent.SetEvent;
{$ifend}
end;

function TPasRISCV.TUARTDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address,Flags,IER_:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case Address of
  thr{dll}:begin
   if (TPasMPInterlocked.Read(fLCR) and lcr_dlab)<>0 then begin
    result:=TPasMPInterlocked.Read(fDLL) and $ff;
   end else if (Poll and POLL_RX)<>0 then begin
    result:=ReadChar and $ff;
   end else begin
    result:=0;
   end;
  end;
  ier{dlm}:begin
   if (TPasMPInterlocked.Read(fLCR) and lcr_dlab)<>0 then begin
    result:=TPasMPInterlocked.Read(fDLM) and $ff;
   end else begin
    result:=TPasMPInterlocked.Read(fIER) and $ff;
   end;
  end;
  isr:begin
   Flags:=Poll;
   IER_:=TPasMPInterlocked.Read(fIER) and $ff;
   if ((Flags and POLL_RX)<>0) and ((IER_ and ier_rdi)<>0) then begin
    result:=iir_recv or iir_fifo;
   end else if ((Flags and POLL_TX)<>0) and ((IER_ and ier_thri)<>0) then begin
    result:=iir_thr or iir_fifo;
   end else begin
    result:=iir_none or iir_fifo;
   end;
// result:=TPasMPInterlocked.Read(fISR) and $ff;
  end;
  lcr:begin
   result:=TPasMPInterlocked.Read(fLCR) and $ff;
  end;
  mcr:begin
   result:=TPasMPInterlocked.Read(fMCR) and $ff;
  end;
  lsr:begin
   Flags:=Poll;
   result:=0;
   if (Flags and POLL_RX)<>0 then begin
    result:=result or lsr_dr;
   end;
   if (Flags and POLL_TX)<>0 then begin
    result:=result or (lsr_thre or lsr_temt);
   end;
// result:=TPasMPInterlocked.Read(fLSR) and $ff;
  end;
  msr:begin
   result:=TPasMPInterlocked.Read(fMSR) and $ff;
  end;
  scr:begin
   result:=TPasMPInterlocked.Read(fSCR) and $ff;
  end;
  else begin
   result:=0;
  end;
 end;
end;

procedure TPasRISCV.TUARTDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case Address of
  thr{dll}:begin
   if (TPasMPInterlocked.Read(fLCR) and lcr_dlab)<>0 then begin
    TPasMPInterlocked.Write(fDLL,aValue and $ff);
   end else begin
    WriteChar(aValue);
   end;
  end;
  ier{dlm}:begin
   if (TPasMPInterlocked.Read(fLCR) and lcr_dlab)<>0 then begin
    TPasMPInterlocked.Write(fDLM,aValue and $ff);
   end else begin
    TPasMPInterlocked.Write(fIER,aValue and $ff);
    DispatchInterrupt(Poll);
   end;
  end;
  fcr:begin
   TPasMPInterlocked.Write(fFCR,aValue and $ff);
  end;
  lcr:begin
   TPasMPInterlocked.Write(fLCR,aValue and $ff);
  end;
  mcr:begin
   TPasMPInterlocked.Write(fMCR,aValue and $ff);
  end;
  scr:begin
   TPasMPInterlocked.Write(fSCR,aValue and $ff);
  end;
  else begin
  end;
 end;
end;

procedure TPasRISCV.TUARTDevice.DispatchInterrupt(const aFlags:TPasRISCVUInt32);
var IER_:TPasRISCVUInt32;
begin
 IER_:=TPasMPInterlocked.Read(fIER);
 if (((aFlags and POLL_RX)<>0) and ((IER_ and ier_rdi)<>0)) or
    (((aFlags and POLL_TX)<>0) and ((IER_ and ier_thri)<>0)) then begin
  fMachine.fInterrupts.SendIRQ(fIRQ);
 end;
end;

procedure TPasRISCV.TUARTDevice.Notify;
begin
 DispatchInterrupt(Poll);
end;

{ TPasRISCV.TDS1742Device }

constructor TPasRISCV.TDS1742Device.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fDS1742Base,aMachine.fConfiguration.fDS1742Size);
 fCtl:=0;
 FillChar(fRegisters,SizeOf(fRegisters),#0);
 UpdateRegisters;
end;

destructor TPasRISCV.TDS1742Device.Destroy;
begin
 inherited Destroy;
end;

class function TPasRISCV.TDS1742Device.ConvertBCD(const aValue:TPasRISCVUInt8):TPasRISCVUInt8;
begin
 result:=((aValue div 10) shl 4) or (aValue mod 10);
end;

class function TPasRISCV.TDS1742Device.ConvertFromBCD(const aValue:TPasRISCVUInt8):TPasRISCVUInt8;
begin
 result:=((aValue shr 4)*10)+(aValue and $f);
end;

procedure TPasRISCV.TDS1742Device.UpdateRegisters;
var CurrentTime:TDateTime;
//  UnixTime:TPasRISCVInt64;
    Year,Month,Day,DayOfWeek,Hour,Minute,Second,Millisecond:TPasRISCVUInt16;
begin
//UnixTime:=DateTimeToUnix({$if declared(NowUTC)}NowUTC,true{$else}Now,false{$ifend});
 CurrentTime:={$if declared(NowUTC)}NowUTC{$else}Now{$ifend};
 DecodeDateFully(CurrentTime,Year,Month,Day,DayOfWeek);
 DecodeTime(CurrentTime,Hour,Minute,Second,Millisecond);
 fRegisters[REG_CTL_CENT]:=ConvertBCD(Year div 100);
 fRegisters[REG_SECONDS]:=ConvertBCD(Min(59,Second));
 fRegisters[REG_MINUTES]:=ConvertBCD(Minute);
 fRegisters[REG_HOURS]:=ConvertBCD(Hour);
 fRegisters[REG_DAY]:=ConvertBCD(DayOfWeek);
 fRegisters[REG_DATE]:=ConvertBCD(Day);
 fRegisters[REG_MONTH]:=ConvertBCD(Month);
 fRegisters[REG_YEAR]:=ConvertBCD(Year mod 100);
end;

function TPasRISCV.TDS1742Device.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
//writeln('DS1742: ',Address);
 case Address of
  REG_CTL_CENT:begin
   result:=fRegisters[REG_CTL_CENT] or fCtl;
  end;
  REG_DAY:begin
   result:=fRegisters[REG_DAY] or DAY_BATT;
  end;
  else begin
   if Address<length(fRegisters) then begin
    result:=fRegisters[Address];
   end else begin
    result:=0;
   end;
  end;
 end;
end;

procedure TPasRISCV.TDS1742Device.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address,NewCtl:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case Address of
  REG_CTL_CENT:begin
   NewCtl:=aValue and CTL_MASK;
   if ((fCtl and CTL_READ)=0) and ((NewCtl and CTL_READ)<>0) then begin
    UpdateRegisters;
   end;
   fCtl:=NewCtl;
  end;
  else begin
  end;
 end;
end;

{ TPasRISCV.TFrameBufferDevice }

constructor TPasRISCV.TFrameBufferDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fFrameBufferBase,FrameBufferAddress+aMachine.fConfiguration.fFrameBufferSize);
 fLock:=TPasMPMultipleReaderSingleWriterLock.Create;
 fActive:=false;
 fAutomaticRefresh:=false;
 fWidth:=aMachine.fConfiguration.fFrameBufferWidth;
 fHeight:=aMachine.fConfiguration.fFrameBufferHeight;
 fBytesPerPixel:=aMachine.fConfiguration.fFrameBufferBytesPerPixel;
 fData:=nil;
 SetLength(fData,fWidth*fHeight*fBytesPerPixel);
 ClearFrameBuffer;
end;

destructor TPasRISCV.TFrameBufferDevice.Destroy;
begin
 fData:=nil;
 FreeAndNil(fLock);
 inherited Destroy;
end;

procedure TPasRISCV.TFrameBufferDevice.ResizeFrameBuffer;
var NewData:TPasRISCVUInt8DynamicArray;
begin
 fLock.AcquireRead;
 try
  if length(fData)<(fWidth*fHeight*fBytesPerPixel) then begin
   fLock.ReadToWrite;
   try
    if length(fData)<(fWidth*fHeight*fBytesPerPixel) then begin
     NewData:=nil;
     try
      SetLength(NewData,(fWidth*fHeight*fBytesPerPixel)*2);
      Move(fData[0],NewData[0],length(fData));
     finally
      fData:=NewData;
     end;
    end;
{$ifdef FrameBufferDeviceDirtyMarking}
    fDirty:=true;
{$endif}
   finally
    fLock.WriteToRead;
   end;
  end;
 finally
  fLock.ReleaseRead;
 end;
end;

procedure TPasRISCV.TFrameBufferDevice.ClearFrameBuffer;
var Index:TPasRISCVSizeInt;
    Pixel:PPasRISCVUInt32;
begin
 Pixel:=@fData[0];
 for Index:=1 to fWidth*fHeight do begin
  Pixel^:=$00000000;
  inc(Pixel);
 end;
{$ifdef FrameBufferDeviceDirtyMarking}
 fDirty:=true;
{$endif}
end;

function TPasRISCV.TFrameBufferDevice.CheckDirtyAndFlush:Boolean;
begin
{$ifdef FrameBufferDeviceDirtyMarking}
 result:=TPasMPInterlocked.CompareExchange(fDirty,TPasMPBool32(false),TPasMPBool32(true));
 if result then begin
  fMachine.FlushTLB;
 end;
{$else}
 result:=true;
{$endif}
end;

function TPasRISCV.TFrameBufferDevice.GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
var Address:TPasRISCVUInt64;
begin
 if (aAddress>=fBase) and ((aAddress-fBase)<fSize) then begin
  Address:=aAddress-fBase;
  if (Address>=FrameBufferAddress) and ((Address-FrameBufferAddress)<length(fData)) then begin
{$ifdef FrameBufferDeviceDirtyMarking}
   if aWrite then begin
    fDirty:=true;
   end;
{$endif}
   result:=@fData[Address-FrameBufferAddress];
  end else begin
   result:=aBounce;
  end;
 end else begin
  result:=nil;
 end;
end;

function TPasRISCV.TFrameBufferDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case Address of
  FrameReadyAddress:begin
   result:=0;
  end;
  ActiveAddress:begin
   result:=ord(fActive);
  end;
  ResolutionAddress:begin
   result:=(TPasRISCVUInt64(fWidth) or (TPasRISCVUInt64(fHeight) shl 16));
  end;
  BytesPerPixelAddress:begin
   result:=TPasRISCVUInt64(fBytesPerPixel);
  end;
  WidthAddress:begin
   result:=TPasRISCVUInt64(fWidth);
  end;
  HeightAddress:begin
   result:=TPasRISCVUInt64(fHeight);
  end;
  else begin
   if (Address>=FrameBufferAddress) and ((Address+aSize)<=(FrameBufferAddress+length(fData))) then begin
    dec(Address,FrameBufferAddress);
    case aSize of
     1:begin
      result:=fData[Address];
     end;
     2:begin
      result:=TPasRISCVUInt16(Pointer(@fData[Address])^);
     end;
     4:begin
      result:=TPasRISCVUInt32(Pointer(@fData[Address])^);
     end;
     8:begin
      result:=TPasRISCVUInt64(Pointer(@fData[Address])^);
     end;
     else begin
      result:=0;
     end;
    end;
   end else begin
    result:=0;
   end;
  end;
 end;
end;

procedure TPasRISCV.TFrameBufferDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case Address of
  FrameReadyAddress:begin
   if (aValue<>0) and assigned(fMachine.OnNewFrame) then begin
    fMachine.OnNewFrame();
   end;
  end;
  ActiveAddress:begin
   if fActive<>((aValue and 1)<>0) then begin
    fActive:=(aValue and 1)<>0;
    if (aValue and 2)=0 then begin
     ClearFrameBuffer;
    end;
    if assigned(fMachine.OnNewFrame) then begin
     fMachine.OnNewFrame();
    end;
   end;
   fAutomaticRefresh:=(aValue and 4)<>0;
  end;
  ResolutionAddress:begin
   fWidth:=TPasRISCVUInt32(aValue and $ffff);
   fHeight:=TPasRISCVUInt32((aValue shr 16) and $ffff);
   ResizeFrameBuffer;
  end;
  BytesPerPixelAddress:begin
   fBytesPerPixel:=TPasRISCVUInt32(aValue);
  end;
  WidthAddress:begin
   fWidth:=TPasRISCVUInt32(aValue);
   ResizeFrameBuffer;
  end;
  HeightAddress:begin
   fHeight:=TPasRISCVUInt32(aValue);
   ResizeFrameBuffer;
  end;
  else begin
   if (Address>=FrameBufferAddress) and ((Address+aSize)<=(FrameBufferAddress+length(fData))) then begin
    dec(Address,FrameBufferAddress);
{$ifdef FrameBufferDeviceDirtyMarking}
    fDirty:=true;
{$endif}
    case aSize of
     1:begin
      fData[Address]:=TPasRISCVUInt8(aValue);
     end;
     2:begin
      TPasRISCVUInt16(Pointer(@fData[Address])^):=TPasRISCVUInt16(aValue);
     end;
     4:begin
      TPasRISCVUInt32(Pointer(@fData[Address])^):=TPasRISCVUInt32(aValue);
     end;
     8:begin
      TPasRISCVUInt64(Pointer(@fData[Address])^):=TPasRISCVUInt64(aValue);
     end;
    end;
   end;
  end;
 end;
end;

{ TPasRISCV.TRawKeyboardDevice }

constructor TPasRISCV.TRawKeyboardDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fRawKeyboardBase,aMachine.fConfiguration.fRawKeyboardSize);
 fPointerToData:=@fData;
 FillChar(fData,SizeOf(fData),#0);
end;

destructor TPasRISCV.TRawKeyboardDevice.Destroy;
begin
 inherited Destroy;
end;

function TPasRISCV.TRawKeyboardDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case Address of
  KeyArrayAddress..ModifiersAddress:begin
   case aSize of
    1:begin
     result:=TPasRISCVUInt8(Pointer(@PPasRISCVUInt8Array(fPointerToData)^[Address])^);
    end;
    2:begin
     result:=TPasRISCVUInt16(Pointer(@PPasRISCVUInt8Array(fPointerToData)^[Address])^);
    end;
    4:begin
     result:=TPasRISCVUInt32(Pointer(@PPasRISCVUInt8Array(fPointerToData)^[Address])^);
    end;
    8:begin
     result:=TPasRISCVUInt64(Pointer(@PPasRISCVUInt8Array(fPointerToData)^[Address])^);
    end;
    else begin
     result:=0;
    end;
   end;
  end;
  else begin
   result:=0;
  end;
 end;
end;

procedure TPasRISCV.TRawKeyboardDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case Address of
  KeyArrayAddress..ModifiersAddress:begin
   case aSize of
    1:begin
     TPasRISCVUInt8(Pointer(@PPasRISCVUInt8Array(fPointerToData)^[Address])^):=TPasRISCVUInt8(aValue);
    end;
    2:begin
     TPasRISCVUInt16(Pointer(@PPasRISCVUInt8Array(fPointerToData)^[Address])^):=TPasRISCVUInt16(aValue);
    end;
    4:begin
     TPasRISCVUInt32(Pointer(@PPasRISCVUInt8Array(fPointerToData)^[Address])^):=TPasRISCVUInt32(aValue);
    end;
    8:begin
     TPasRISCVUInt64(Pointer(@PPasRISCVUInt8Array(fPointerToData)^[Address])^):=TPasRISCVUInt64(aValue);
    end;
   end;
  end;
 end;
end;

procedure TPasRISCV.TRawKeyboardDevice.KeyDown(const aKeyCode:TPasRISCVUInt64);
begin
 if (aKeyCode shr 3)<KeyArraySize then begin
  TPasMPInterlocked.BitwiseOr(PPasRISCVUInt32Array(Pointer(fPointerToData))^[aKeyCode shr 5],TPasRISCVUInt32(1) shl TPasRISCVUInt32(aKeyCode and 31));
 end;
end;

procedure TPasRISCV.TRawKeyboardDevice.KeyUp(const aKeyCode:TPasRISCVUInt64);
begin
 if (aKeyCode shr 3)<KeyArraySize then begin
  TPasMPInterlocked.BitwiseAnd(PPasRISCVUInt32Array(Pointer(fPointerToData))^[aKeyCode shr 5],not (TPasRISCVUInt32(1) shl TPasRISCVUInt32(aKeyCode and 31)));
 end;
end;

procedure TPasRISCV.TRawKeyboardDevice.ModifierDown(const aModifier:TPasRISCVUInt64);
begin
 fData[ModifiersAddress]:=fData[ModifiersAddress] or TPasRISCVUInt8(aModifier);
end;

procedure TPasRISCV.TRawKeyboardDevice.ModifierUp(const aModifier:TPasRISCVUInt64);
begin
 fData[ModifiersAddress]:=fData[ModifiersAddress] and not TPasRISCVUInt8(aModifier);
end;

{ TPasRISCV.TI2CBusDevice }

constructor TPasRISCV.TI2CBusDevice.Create(const aI2CDevice:TPasRISCV.TI2CDevice);
begin
 inherited Create;
 fMachine:=aI2CDevice.fMachine;
 fI2CDevice:=aI2CDevice;
 fIndex:=-1;
 fAddress:=0;
end;

destructor TPasRISCV.TI2CBusDevice.Destroy;
begin
 inherited Destroy;
end;

function TPasRISCV.TI2CBusDevice.Start(const aIsWrite:Boolean):Boolean;
begin
 result:=true;
end;

procedure TPasRISCV.TI2CBusDevice.Stop;
begin
end;

function TPasRISCV.TI2CBusDevice.Read(out aValue:TPasRISCVUInt8):Boolean;
begin
 result:=false;
end;

function TPasRISCV.TI2CBusDevice.Write(const aValue:TPasRISCVUInt8):Boolean;
begin
 result:=false;
end;

{ TPasRISCV.TI2CHIDBusDevice.TReportIDQueue }

procedure TPasRISCV.TI2CHIDBusDevice.TReportIDQueue.Initialize;
var Index:TPasRISCVUInt8;
begin
 fFirst:=-1;
 fLast:=-1;
 for Index:=0 to 255 do begin
  fList[Index]:=-1;
 end;
end;

procedure TPasRISCV.TI2CHIDBusDevice.TReportIDQueue.Insert(const aReportID:TPasRISCVUInt8);
begin
 if (aReportID=fLast) or (fList[aReportID]>=0) then begin
  exit;
 end;
 if fFirst<0 then begin
  fFirst:=aReportID;
 end else begin
  fList[fLast]:=aReportID;
 end;
 fLast:=aReportID;
end;

function TPasRISCV.TI2CHIDBusDevice.TReportIDQueue.Get:TPasRISCVInt16;
begin
 result:=fFirst;
end;

procedure TPasRISCV.TI2CHIDBusDevice.TReportIDQueue.RemoveAt(const aReportID:TPasRISCVUInt8);
var Previous:TPasRISCVInt16;
begin
 if fFirst<0 then begin
  exit;
 end;
 if aReportID=fFirst then begin
  fFirst:=fList[aReportID];
  if fFirst<0 then begin
   fLast:=-1;
  end;
 end else begin
  Previous:=fFirst;
  while (Previous>=0) and (fList[Previous]<>aReportID) do begin
   Previous:=fList[Previous];
  end;
  if Previous<0 then begin
   exit;
  end;
  fList[Previous]:=fList[aReportID];
 end;
 fList[aReportID]:=-1;
end;

{ TPasRISCV.TI2CHIDBusDevice }

constructor TPasRISCV.TI2CHIDBusDevice.Create(const aI2CDevice:TPasRISCV.TI2CDevice);
begin
 inherited Create(aI2CDevice);
 fLock:=TPasMPSlimReaderWriterLock.Create;
 fIRQ:=0;
 fReportIDQueue.Initialize;
 fIsWrite:=false;
 fIOOffset:=0;
 fRegister:=0;
 fCommand:=0;
 fReportType:=0;
 fReportID:=0;
 fDataSize:=0;
 fDataValue:=0;
 fIsReset:=false;
 fReportDescriptor:=nil;
 fMaxInputSize:=0;
 fMaxOutputSize:=0;
 fVendorID:=0;
 fProductID:=0;
 fVersionID:=0;
end;

destructor TPasRISCV.TI2CHIDBusDevice.Destroy;
begin
 FreeAndNil(fLock);
 inherited Destroy;
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDReset;
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDInputAvailable(const aReportID:TPasRISCVUInt8);
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDReadReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;out aValue:TPasRISCVUInt8);
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDWriteReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8);
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDGetIdle(const aReportID:TPasRISCVUInt8;out aIdle:TPasRISCVUInt16);
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDSetIdle(const aReportID:TPasRISCVUInt8;const aIdle:TPasRISCVUInt16);
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDGetProtocol(out aProtocol:TPasRISCVUInt16);
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDSetProtocol(const aProtocol:TPasRISCVUInt16);
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDSetPower(const aPower:TPasRISCVUInt16);
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.Reset(const aIsInit:Boolean);
begin
 fReportIDQueue.Initialize;
 fRegister:=INPUT_REG;
 fCommand:=0;
 fReportType:=0;
 fReportID:=0;
 fIsReset:=not aIsInit;
 HIDReset;
 if assigned(fI2CDevice) and assigned(fI2CDevice.fMachine) and assigned(fI2CDevice.fMachine.fINTCDevice) and not aIsInit then begin
  fI2CDevice.fMachine.fInterrupts.RaiseIRQ(fIRQ);
 end;
end;

procedure TPasRISCV.TI2CHIDBusDevice.InputAvailable(const aReportID:TPasRISCVUInt8);
begin
 fLock.Acquire;
 try
  if not fIsReset then begin
   fReportIDQueue.Insert(aReportID);
   if assigned(fI2CDevice) and assigned(fI2CDevice.fMachine) and assigned(fI2CDevice.fMachine.fINTCDevice) then begin
    fI2CDevice.fMachine.fInterrupts.RaiseIRQ(fIRQ);
   end;
  end;
 finally
  fLock.Release;
 end;
end;

function TPasRISCV.TI2CHIDBusDevice.ReadDataSize(const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8):Boolean;
begin
 if aOffset<2 then begin
  fDataSize:=TPasRISCVUInt16(TPasRISCVUInt32(fDataSize) and not (TPasRISCVUInt32($ff) shl (aOffset*8))) or (TPasRISCVUInt16(aValue) shl (aOffset*8));
 end;
 result:=not ((aOffset>=1) and (aOffset>=fDataSize));
end;

procedure TPasRISCV.TI2CHIDBusDevice.ReadReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;out aValue:TPasRISCVUInt8);
begin
 HIDReadReport(aReportType,aReportID,aOffset,aValue);
 if aOffset<2 then begin
  fDataSize:=TPasRISCVUInt16(TPasRISCVUInt32(fDataSize) and not (TPasRISCVUInt32($ff) shl (aOffset shl 3))) or (TPasRISCVUInt16(aValue) shl (aOffset shl 3));
 end;
 if (aReportType=REPORT_TYPE_INPUT) and (aOffset>=1) and (aOffset=TPasRISCVUInt32(IfThen(fDataSize>2,fDataSize-1,1))) then begin
  fLock.Acquire;
  try
   fReportIDQueue.RemoveAt(aReportID);
   if fReportIDQueue.Get>=0 then begin
    if assigned(fI2CDevice) and assigned(fI2CDevice.fMachine) and assigned(fI2CDevice.fMachine.fINTCDevice) then begin
     fI2CDevice.fMachine.fInterrupts.RaiseIRQ(fIRQ);
    end;
   end else begin
    if assigned(fI2CDevice) and assigned(fI2CDevice.fMachine) and assigned(fI2CDevice.fMachine.fINTCDevice) then begin
     fI2CDevice.fMachine.fInterrupts.LowerIRQ(fIRQ);
    end;
   end;
  finally
   fLock.Release;
  end;
 end;
end;

function TPasRISCV.TI2CHIDBusDevice.WriteReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8):Boolean;
begin
 result:=ReadDataSize(aOffset,aValue);
 if result then begin
  HIDWriteReport(aReportType,aReportID,aOffset,aValue);
 end;
end;

function TPasRISCV.TI2CHIDBusDevice.ReadRegister(const aRegister:TPasRISCVUInt16;const aOffset:TPasRISCVUInt32):TPasRISCVUInt8;
var FieldValue:TPasRISCVUInt16;
    ReportID:TPasRISCVInt16;
begin
 case aRegister of
  DESC_REG:begin
   case aOffset shr 1 of
    wHIDDescLength:begin
     FieldValue:=$1e;
    end;
    bcdVersion:begin
     FieldValue:=$0100;
    end;
    wReportDescLength:begin
     FieldValue:=length(fReportDescriptor);
    end;
    wReportDescRegister:begin
     FieldValue:=REPORT_REG;
    end;
    wInputRegister:begin
     FieldValue:=INPUT_REG;
    end;
    wMaxInputLength:begin
     FieldValue:=fMaxInputSize;
    end;
    wOutputRegister:begin
     FieldValue:=OUTPUT_REG;
    end;
    wMaxOutputLength:begin
     FieldValue:=fMaxOutputSize;
    end;
    wCommandRegister:begin
     FieldValue:=COMMAND_REG;
    end;
    wDataRegister:begin
     FieldValue:=DATA_REG;
    end;
    wVendorID:begin
     FieldValue:=fVendorID;
    end;
    wProductID:begin
     FieldValue:=fProductID;
    end;
    wVersionID:begin
     FieldValue:=fVersionID;
    end
    else begin
     FieldValue:=0;
    end;
   end;
   result:=TPasRISCVUInt8((FieldValue shr ((aOffset and 1) shl 3)) and $ff);
  end;
  REPORT_REG:begin
   if aOffset<length(fReportDescriptor) then begin
    result:=fReportDescriptor[aOffset];
   end else begin
    result:=0;
   end;
  end;
  INPUT_REG:begin
   fLock.Acquire;
   try
    ReportID:=fReportIDQueue.Get;
    if ReportID<0 then begin
     if assigned(fI2CDevice) and assigned(fI2CDevice.fMachine) and assigned(fI2CDevice.fMachine.fINTCDevice) then begin
      fI2CDevice.fMachine.fInterrupts.LowerIRQ(fIRQ);
     end;
     result:=0;
    end else begin
     result:=0;
     HIDReadReport(REPORT_TYPE_INPUT,fReportIDQueue.Get,aOffset,result);
    end;
   finally
    fLock.Release;
   end;
  end;
  DATA_REG:begin
   case fCommand of
    COMMAND_GET_REPORT:begin
     HIDReadReport(fReportType,fReportID,aOffset,result);
    end;
    COMMAND_GET_IDLE:begin
     case aOffset shr 1 of
      0:begin
       FieldValue:=4;
      end;
      1:begin
       FieldValue:=0;
       HIDGetIdle(fReportID,FieldValue);
      end;
      else begin
       FieldValue:=0;
      end;
     end;
     result:=TPasRISCVUInt8((FieldValue shr ((aOffset and 1) shl 3)) and $ff);
    end;
    COMMAND_GET_PROTOCOL:begin
     FieldValue:=0;
     case aOffset shr 1 of
      0:begin
       FieldValue:=4;
      end;
      1:begin
       HIDGetProtocol(FieldValue);
      end;
      else begin
       FieldValue:=0;
      end;
     end;
     result:=TPasRISCVUInt8((FieldValue shr ((aOffset and 1) shl 3)) and $ff);
    end;
    else begin
     result:=0;
    end;
   end;
  end;
  else begin
   result:=0;
  end;
 end;
end;

function TPasRISCV.TI2CHIDBusDevice.WriteRegister(const aRegister:TPasRISCVUInt16;const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8):Boolean;
begin
 result:=false;
 case aRegister of
  OUTPUT_REG:begin
   result:=WriteReport(REPORT_TYPE_OUTPUT,0,aOffset,aValue);
  end;
  COMMAND_REG:begin
   case aOffset of
    0:begin
     fReportID:=(aValue and $f);
     fReportType:=(aValue shr 4) and 3;
     result:=true;
     exit;
    end;
    1:begin
     fCommand:=aValue and $f;
     result:=fReportID=$f;
     if result then begin
      exit;
     end;
    end;
    2:begin
     fReportID:=aValue;
     result:=false;
    end;
   end;
   case fCommand of
    COMMAND_SET_IDLE:begin
     if fDataSize=4 then begin
      HIDSetIdle(fReportID,fDataValue);
     end;
    end;
    COMMAND_SET_PROTOCOL:begin
     if fDataSize=4 then begin
      HIDSetProtocol(fDataValue);
     end;
    end;
    COMMAND_SET_POWER:begin
     HIDSetPower(fDataValue and 3);
    end;
   end;
  end;
  DATA_REG:begin
   case fCommand of
    COMMAND_SET_REPORT:begin
     result:=WriteReport(fReportType,fReportID,aOffset,aValue);
    end;
    else begin
     result:=ReadDataSize(aOffset,aValue);
     if result and ((aOffset shr 1)=1) then begin
      fDataValue:=TPasRISCVUInt16(TPasRISCVUInt32(fDataValue) and not (TPasRISCVUInt32($ff) shl (aOffset shl 3))) or (TPasRISCVUInt16(aValue) shl (aOffset shl 3));
     end;
    end;
   end;
  end;
  else begin
   result:=false;
  end;
 end;
end;

function TPasRISCV.TI2CHIDBusDevice.Start(const aIsWrite:Boolean):Boolean;
begin
 fLock.Acquire;
 try
  fIsWrite:=aIsWrite;
  fIOOffset:=0;
  result:=true;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TI2CHIDBusDevice.Stop;
begin
 fLock.Acquire;
 try
  fIsReset:=false;
  if fCommand=COMMAND_RESET then begin
   Reset(false);
  end;
  fRegister:=INPUT_REG;
  fCommand:=0;
  fDataSize:=0;
 finally
  fLock.Release;
 end;
end;

function TPasRISCV.TI2CHIDBusDevice.Read(out aValue:TPasRISCVUInt8):Boolean;
begin
 fLock.Acquire;
 try
  aValue:=ReadRegister(fRegister,fIOOffset);
  inc(fIOOffset);
 finally
  fLock.Release;
 end;
 result:=true;
end;

function TPasRISCV.TI2CHIDBusDevice.Write(const aValue:TPasRISCVUInt8):Boolean;
begin
 fLock.Acquire;
 try
  case fIOOffset of
   0,1:begin
    fRegister:=TPasRISCVUInt16(TPasRISCVUInt32(fRegister) and not (TPasRISCVUInt32($ff) shl (fIOOffset shl 3))) or (TPasRISCVUInt16(aValue) shl (fIOOffset shl 3));
    inc(fIOOffset);
   end;
   else begin
    if WriteRegister(fRegister,fIOOffset-2,aValue) then begin
     inc(fIOOffset);
    end else begin
     fIOOffset:=0;
    end;
   end;
  end;
 finally
  fLock.Release;
 end;
 result:=true;
end;

{ TPasRISCV.TI2CHIDKeyboardBusDevice }

constructor TPasRISCV.TI2CHIDKeyboardBusDevice.Create(const aI2CDevice:TPasRISCV.TI2CDevice);
begin
 inherited Create(aI2CDevice);
 fAddress:=TI2CHIDKeyboardBusDevice.Address;
 fIRQ:=TI2CHIDKeyboardBusDevice.IRQ;
 FillChar(fInputReport,SizeOf(fInputReport),#0);
 FillChar(fOutputReport,SizeOf(fOutputReport),#0);
 FillChar(fKeysPressedRow,SizeOf(fKeysPressedRow),#0);
 FillChar(fKeysPressed,SizeOf(fKeysPressed),#0);
 fLEDs:=0;
 SetLength(fReportDescriptor,SizeOf(ReportDescriptor));
 Move(ReportDescriptor[0],fReportDescriptor[0],SizeOf(ReportDescriptor));
 fVendorID:=1;
 fProductID:=1;
 fVersionID:=1;
end;

destructor TPasRISCV.TI2CHIDKeyboardBusDevice.Destroy;
begin
 fReportDescriptor:=nil;
 inherited Destroy;
end;

procedure TPasRISCV.TI2CHIDKeyboardBusDevice.HIDReset;
begin
 TPasMPInterlocked.Write(fLEDs,0);
end;

procedure TPasRISCV.TI2CHIDKeyboardBusDevice.HIDFillPressedKeys(const aPressed:PPasRISCVUInt8);
var Count,CodeHi,CodeLo,Keys:TPasRISCVUInt32;
    p:PPasRISCVUInt8;
begin
 Count:=0;
 FillChar(aPressed^,CountMaximumPressedKeys,#0);
 p:=aPressed;
 for CodeHi:=0 to 7 do begin
  Keys:=TPasMPInterlocked.Exchange(fKeysPressed[CodeHi],0) or TPasMPInterlocked.Read(fKeysPressedRow[CodeHi]);
  if Keys<>0 then begin
   for CodeLo:=0 to 31 do begin
    if (Keys and (1 shl CodeLo))<>0 then begin
     p^:=(CodeHi shl 5) or CodeLo;
     inc(p);
     inc(Count);
     if Count=CountMaximumPressedKeys then begin
      exit;
     end;
    end;
   end;
  end;
 end;
end;

procedure TPasRISCV.TI2CHIDKeyboardBusDevice.HIDReadReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;out aValue:TPasRISCVUInt8);
begin
 fLock.Acquire;
 try
  if aReportType=REPORT_TYPE_INPUT then begin
   if aOffset=0 then begin
    fInputReport[0]:=(SizeOf(fInputReport) shr 0) and $ff;
    fInputReport[1]:=(SizeOf(fInputReport) shr 8) and $ff;
    fInputReport[2]:=(TPasMPInterlocked.Read(fKeysPressed[7]) or TPasMPInterlocked.Read(fKeysPressedRow[7])) and $ff;
    fInputReport[3]:=0;
    HIDFillPressedKeys(@fInputReport[4]);
   end;
   if aOffset<SizeOf(fInputReport) then begin
    aValue:=fInputReport[aOffset];
   end;
  end else begin
   aValue:=0;
  end;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TI2CHIDKeyboardBusDevice.HIDWriteReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8);
begin
 fLock.Acquire;
 try
  if aReportType=REPORT_TYPE_OUTPUT then begin
   if aOffset<SizeOf(fOutputReport) then begin
    fOutputReport[aOffset]:=aValue;
    if aOffset=(SizeOf(fOutputReport)-1) then begin
     TPasMPInterlocked.Write(fLEDs,fOutputReport[2]);
    end;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TI2CHIDKeyboardBusDevice.HandleKeyboard(const aKey:TPasRISCVUInt32;const aDown:Boolean);
var Offset,Bit,OldPressed:TPasRISCVUInt32;
begin
 if aKey<>THID.KEY_NONE then begin
  Offset:=aKey shr 5;
  Bit:=TPasRISCVUInt32(1) shl (aKey and $1f);
  if aDown then begin
   OldPressed:=TPasMPInterlocked.ExchangeBitwiseOr(fKeysPressed[Offset],Bit);
   if (Bit and not OldPressed)<>0 then begin
    TPasMPInterlocked.BitwiseOr(fKeysPressedRow[Offset],Bit);
    InputAvailable(0);
   end;
  end else begin
   OldPressed:=TPasMPInterlocked.ExchangeBitwiseAnd(fKeysPressed[Offset],not Bit);
   if (OldPressed and Bit)<>0 then begin
    InputAvailable(0);
   end;
  end;
 end;
end;

{ TPasRISCV.TI2CDevice }

constructor TPasRISCV.TI2CDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fI2CBase,aMachine.fConfiguration.fI2CSize);
 fLock:=TPasMPSlimReaderWriterLock.Create;
 fBusDevices:=nil;
 fCountBusDevices:=0;
 FillChar(fBusDeviceAddressMap,SizeOf(fBusDeviceAddressMap),#0);
 fSelectedAddress:=0;
 fClock:=0;
 fControl:=0;
 fStatus:=0;
 fTXByte:=0;
 fRXByte:=0;
end;

destructor TPasRISCV.TI2CDevice.Destroy;
begin
 FreeAndNil(fLock);
 inherited Destroy;
end;

procedure TPasRISCV.TI2CDevice.AttachBusDevice(const aI2CBusDevice:TPasRISCV.TI2CBusDevice);
var Index:TPasRISCVSizeInt;
    Address:TPasRISCVUInt16;
begin
 if assigned(aI2CBusDevice) then begin
  fLock.Acquire;
  try
   Address:=aI2CBusDevice.fAddress;
   if Address=8 then begin
    Address:=8;
    while ((Address+1)<65535) and assigned(fBusDeviceAddressMap[Address]) do begin
     inc(Address);
    end;
   end;
   if assigned(fBusDeviceAddressMap[Address]) then begin
    raise EPasRISCV.Create('No free I2C bus device address');
   end else begin
    Index:=fCountBusDevices;
    inc(fCountBusDevices);
    if length(fBusDevices)<fCountBusDevices then begin
     SetLength(fBusDevices,fCountBusDevices*2);
    end;
    fBusDevices[Index]:=aI2CBusDevice;
    aI2CBusDevice.fIndex:=Index;
    aI2CBusDevice.fAddress:=Address;
    fBusDeviceAddressMap[aI2CBusDevice.fAddress]:=aI2CBusDevice;
   end;
  finally
   fLock.Release;
  end;
 end;
end;

procedure TPasRISCV.TI2CDevice.DetachBusDevice(const aI2CBusDevice:TPasRISCV.TI2CBusDevice);
var Index:TPasRISCVSizeInt;
begin
 if assigned(aI2CBusDevice) then begin
  fLock.Acquire;
  try
   if aI2CBusDevice.fIndex>=0 then begin
    Index:=aI2CBusDevice.fIndex;
    aI2CBusDevice.fIndex:=-1;
    if Index<>(fCountBusDevices-1) then begin
     fBusDevices[Index]:=fBusDevices[fCountBusDevices-1];
     fBusDevices[Index].fIndex:=Index;
    end;
    dec(fCountBusDevices);
    fBusDeviceAddressMap[aI2CBusDevice.fAddress]:=nil;
   end;
  finally
   fLock.Release;
  end;
 end;
end;

function TPasRISCV.TI2CDevice.GetBusDevice(const aAddress:TPasRISCVUInt16):TPasRISCV.TI2CBusDevice;
begin
 result:=fBusDeviceAddressMap[aAddress];
end;

procedure TPasRISCV.TI2CDevice.DispatchInterrupt;
begin
 fStatus:=fStatus or SR_IF;
 if (fControl and CTR_IEN)<>0 then begin
  fMachine.fInterrupts.SendIRQ(IRQ);
 end;
end;

function TPasRISCV.TI2CDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 fLock.Acquire;
 try
  case Address of
   CLKLO:begin
    result:=fClock and $ff;
   end;
   CLKHI:begin
    result:=(fClock shr 8) and $ff;
   end;
   CTR:begin
    result:=fControl;
   end;
   TXRXR:begin
    result:=fRXByte;
   end;
   CRSR:begin
    result:=fStatus;
   end;
   else begin
    result:=0;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TI2CDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address,Cmd:TPasRISCVUInt64;
    I2CBusDevice:TI2CBusDevice;
    IsWrite,TriggerIRQ:Boolean;
begin
 Address:=aAddress-fBase;
 fLock.Acquire;
 try
  case Address of
   CLKLO:begin
    fClock:=(fClock and $ff00) or (TPasRISCVUInt16(aValue) and $ff);
   end;
   CLKHI:begin
    fClock:=(fClock and $ff) or ((TPasRISCVUInt16(aValue) and $ff) shl 8);
   end;
   CTR:begin
    fControl:=TPasRISCVUInt8(aValue) and CTR_MASK;
{   if (fControl and CTR_IEN)=0 then begin
     fMachine.fInterrupts.LowerIRQ(IRQ);
    end;}
   end;
   TXRXR:begin
    fTXByte:=TPasRISCVUInt8(aValue);
   end;
   CRSR:begin

    TriggerIRQ:=false;

    Cmd:=TPasRISCVUInt8(aValue);

    fStatus:=fStatus or SR_ACK;

    if (Cmd and CR_IACK)<>0 then begin
     // Clear a pending interrupt
     fStatus:=fStatus and not SR_IF;
    end;

{   begin
     // Transfer in Progress
     fStatus:=fStatus or SR_TIP;
    end;}

    if (Cmd and CR_STA)<>0 then begin
     // Start the transaction
     fSelectedAddress:=$ffff;
     fStatus:=fStatus or SR_BSY;
    end;

    if (Cmd and CR_WR)<>0 then begin
     // Write byte
     if fSelectedAddress=$ffff then begin

      fSelectedAddress:=(fTXByte shr 1) and $7f; // Get I2CBusDevice address, signal start of transaction

      I2CBusDevice:=GetBusDevice(fSelectedAddress);

      IsWrite:=(fTXByte and 1)=0;

      if assigned(I2CBusDevice) and I2CBusDevice.Start(IsWrite) then begin
       fStatus:=fStatus and not SR_ACK;
{     end else begin
       fStatus:=fStatus or SR_ACK;}
      end;

     end else begin

      I2CBusDevice:=GetBusDevice(fSelectedAddress);
      if assigned(I2CBusDevice) and I2CBusDevice.Write(fTXByte) then begin
       fStatus:=fStatus and not SR_ACK;
{     end else begin
       fStatus:=fStatus or SR_ACK;}
      end;

     end;

     TriggerIRQ:=true;

    end;

    if (Cmd and CR_RD)<>0 then begin
     // Read byte
     I2CBusDevice:=GetBusDevice(fSelectedAddress);
     if assigned(I2CBusDevice) and I2CBusDevice.Read(fRXByte) then begin
      fStatus:=fStatus and not SR_ACK;
{    end else begin
      fStatus:=fStatus or SR_ACK;}
     end;
     TriggerIRQ:=true;
    end;

    if (Cmd and CR_STO)<>0 then begin
     // End of transaction
     I2CBusDevice:=GetBusDevice(fSelectedAddress);
     if assigned(I2CBusDevice) then begin
      I2CBusDevice.Stop;
     end;
     fSelectedAddress:=$ffff;
     fStatus:=fStatus and not SR_BSY;
     TriggerIRQ:=true;
    end;

    if TriggerIRQ then begin
     DispatchInterrupt;
    end;

//  fStatus:=fStatus and not SR_TIP;

   end;

  end;

 finally
  fLock.Release;
 end;

end;

{ TPasRTISCV.TPS2Device }

constructor TPasRISCV.TPS2Device.Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64);
begin
 inherited Create(aMachine,aBase,aSize);
 fLock:=TPasMPSlimReaderWriterLock.Create;
 fIRQ:=0;
 fControl:=0;
end;

destructor TPasRISCV.TPS2Device.Destroy;
begin
 FreeAndNil(fLock);
 inherited Destroy;
end;

function TPasRISCV.TPS2Device.Read(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt;
begin
 result:=0;
end;

function TPasRISCV.TPS2Device.Write(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt;
begin
 result:=0;
end;

function TPasRISCV.TPS2Device.Poll:TPasRISCVSizeInt;
begin
 result:=0;
end;

procedure TPasRISCV.TPS2Device.Notify(const aFlags:TPasRISCVUInt32);
begin
 if assigned(fMachine) and
    assigned(fMachine.fINTCDevice) and
    ((aFlags and POLL_RX)<>0) and
    ((TPasMPInterlocked.ExchangeBitwiseOr(fControl,CTRL_RI) and CTRL_RE)<>0) then begin
  fMachine.fInterrupts.SendIRQ(fIRQ);
 end;
end;

procedure TPasRISCV.TPS2Device.Update;
begin
end;

function TPasRISCV.TPS2Device.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
    Value:TPasRISCVUInt32;
    Available:TPasRISCVUInt32;
begin
 Address:=aAddress-fBase;
 case Address of
  REG_DATA:begin
   Value:=0;
   Available:=Read(@Value,1);
   result:=Value or (TPasRISCVUInt32(ord(Available<>0) and 1) shl 15) or (TPasRISCVUInt32(Available) shl 16);
  end;
  REG_CTRL:begin
   result:=TPasMPInterlocked.Read(fControl);
  end;
  else begin
   result:=0;
  end;
 end;
end;

procedure TPasRISCV.TPS2Device.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
    Value:TPasRISCVUInt32;
    Available:TPasRISCVUInt32;
begin
 Address:=aAddress-fBase;
 case Address of
  REG_DATA:begin
   Value:=aValue and $ff;
   Available:=Write(@Value,1);
   if Available=0 then begin
    TPasMPInterlocked.BitwiseOr(fControl,CTRL_CE);
   end;
  end;
  REG_CTRL:begin
   TPasMPInterlocked.BitwiseOr(fControl,aValue and CTRL_RE);
   TPasMPInterlocked.BitwiseAnd(fControl,CTRL_RI or (aValue and (CTRL_RE or CTRL_CE)));
  end;
 end;
end;

{ TPasRISCV.TPS2KeyboardDevice }

constructor TPasRISCV.TPS2KeyboardDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.PS2KeyboardBase,aMachine.fConfiguration.PS2KeyboardSize);
 fActive:=true;
 fIRQ:=aMachine.fConfiguration.PS2KeyboardIRQ;
 FillChar(fKeyState,SizeOf(fKeyState),#0);
 fState:=STATE_CMD;
 fRate:=$c;
 fDelay:=1;
 fReporting:=false;
 fLastKey:='';
 fRingBuffer:=TPasMPSingleProducerSingleConsumerRingBuffer.Create(65536);
 fTimer.Initialize(CLOCK_FREQUENCY);
 fTimeCmp:=TPasRISCVUInt64($ffffffffffffffff);
 FillChar(fHIDToPS2ByteMap,SizeOf(fHIDToPS2ByteMap),#0);
 fHIDToPS2ByteMap[THID.KEY_NONE]:=$00;
 fHIDToPS2ByteMap[THID.KEY_ERR_ROLLOVER]:=$ff;
 fHIDToPS2ByteMap[THID.KEY_A]:=$1c;
 fHIDToPS2ByteMap[THID.KEY_B]:=$32;
 fHIDToPS2ByteMap[THID.KEY_C]:=$21;
 fHIDToPS2ByteMap[THID.KEY_D]:=$23;
 fHIDToPS2ByteMap[THID.KEY_E]:=$24;
 fHIDToPS2ByteMap[THID.KEY_F]:=$2b;
 fHIDToPS2ByteMap[THID.KEY_G]:=$34;
 fHIDToPS2ByteMap[THID.KEY_H]:=$33;
 fHIDToPS2ByteMap[THID.KEY_I]:=$43;
 fHIDToPS2ByteMap[THID.KEY_J]:=$3b;
 fHIDToPS2ByteMap[THID.KEY_K]:=$42;
 fHIDToPS2ByteMap[THID.KEY_L]:=$4b;
 fHIDToPS2ByteMap[THID.KEY_M]:=$3a;
 fHIDToPS2ByteMap[THID.KEY_N]:=$31;
 fHIDToPS2ByteMap[THID.KEY_O]:=$44;
 fHIDToPS2ByteMap[THID.KEY_P]:=$4d;
 fHIDToPS2ByteMap[THID.KEY_Q]:=$15;
 fHIDToPS2ByteMap[THID.KEY_R]:=$2d;
 fHIDToPS2ByteMap[THID.KEY_S]:=$1b;
 fHIDToPS2ByteMap[THID.KEY_T]:=$2c;
 fHIDToPS2ByteMap[THID.KEY_U]:=$3c;
 fHIDToPS2ByteMap[THID.KEY_V]:=$2a;
 fHIDToPS2ByteMap[THID.KEY_W]:=$1d;
 fHIDToPS2ByteMap[THID.KEY_X]:=$22;
 fHIDToPS2ByteMap[THID.KEY_Y]:=$35;
 fHIDToPS2ByteMap[THID.KEY_Z]:=$1a;
 fHIDToPS2ByteMap[THID.KEY_1]:=$16;
 fHIDToPS2ByteMap[THID.KEY_2]:=$1e;
 fHIDToPS2ByteMap[THID.KEY_3]:=$26;
 fHIDToPS2ByteMap[THID.KEY_4]:=$25;
 fHIDToPS2ByteMap[THID.KEY_5]:=$2e;
 fHIDToPS2ByteMap[THID.KEY_6]:=$36;
 fHIDToPS2ByteMap[THID.KEY_7]:=$3d;
 fHIDToPS2ByteMap[THID.KEY_8]:=$3e;
 fHIDToPS2ByteMap[THID.KEY_9]:=$46;
 fHIDToPS2ByteMap[THID.KEY_0]:=$45;
 fHIDToPS2ByteMap[THID.KEY_RETURN]:=$5a;
 fHIDToPS2ByteMap[THID.KEY_ESCAPE]:=$76;
 fHIDToPS2ByteMap[THID.KEY_BACKSPACE]:=$66;
 fHIDToPS2ByteMap[THID.KEY_TAB]:=$0d;
 fHIDToPS2ByteMap[THID.KEY_SPACE]:=$29;
 fHIDToPS2ByteMap[THID.KEY_MINUS]:=$4e;
 fHIDToPS2ByteMap[THID.KEY_EQUAL]:=$55;
 fHIDToPS2ByteMap[THID.KEY_LEFTBRACE]:=$54;
 fHIDToPS2ByteMap[THID.KEY_RIGHTBRACE]:=$5b;
 fHIDToPS2ByteMap[THID.KEY_BACKSLASH]:=$5d;
 fHIDToPS2ByteMap[THID.KEY_SEMICOLON]:=$4c;
 fHIDToPS2ByteMap[THID.KEY_APOSTROPHE]:=$52;
 fHIDToPS2ByteMap[THID.KEY_GRAVE]:=$0e;
 fHIDToPS2ByteMap[THID.KEY_COMMA]:=$41;
 fHIDToPS2ByteMap[THID.KEY_DOT]:=$49;
 fHIDToPS2ByteMap[THID.KEY_SLASH]:=$4a;
 fHIDToPS2ByteMap[THID.KEY_CAPSLOCK]:=$58;
 fHIDToPS2ByteMap[THID.KEY_LEFTCTRL]:=$14;
 fHIDToPS2ByteMap[THID.KEY_LEFTSHIFT]:=$12;
 fHIDToPS2ByteMap[THID.KEY_LEFTALT]:=$11;
 fHIDToPS2ByteMap[THID.KEY_RIGHTSHIFT]:=$59;
 fHIDToPS2ByteMap[THID.KEY_F1]:=$05;
 fHIDToPS2ByteMap[THID.KEY_F2]:=$06;
 fHIDToPS2ByteMap[THID.KEY_F3]:=$04;
 fHIDToPS2ByteMap[THID.KEY_F4]:=$0c;
 fHIDToPS2ByteMap[THID.KEY_F5]:=$03;
 fHIDToPS2ByteMap[THID.KEY_F6]:=$0b;
 fHIDToPS2ByteMap[THID.KEY_F7]:=$83;
 fHIDToPS2ByteMap[THID.KEY_F8]:=$0a;
 fHIDToPS2ByteMap[THID.KEY_F9]:=$01;
 fHIDToPS2ByteMap[THID.KEY_F10]:=$09;
 fHIDToPS2ByteMap[THID.KEY_F11]:=$78;
 fHIDToPS2ByteMap[THID.KEY_F12]:=$07;
 fHIDToPS2ByteMap[THID.KEY_NUMLOCK]:=$77;
 fHIDToPS2ByteMap[THID.KEY_SYSRQ]:=$7c;
 fHIDToPS2ByteMap[THID.KEY_SCROLLLOCK]:=$7e;
 fHIDToPS2ByteMap[THID.KEY_KPASTERISK]:=$7c;
 fHIDToPS2ByteMap[THID.KEY_KPMINUS]:=$7b;
 fHIDToPS2ByteMap[THID.KEY_KPPLUS]:=$79;
 fHIDToPS2ByteMap[THID.KEY_KP1]:=$69;
 fHIDToPS2ByteMap[THID.KEY_KP2]:=$72;
 fHIDToPS2ByteMap[THID.KEY_KP3]:=$7a;
 fHIDToPS2ByteMap[THID.KEY_KP4]:=$6b;
 fHIDToPS2ByteMap[THID.KEY_KP5]:=$73;
 fHIDToPS2ByteMap[THID.KEY_KP6]:=$74;
 fHIDToPS2ByteMap[THID.KEY_KP7]:=$6c;
 fHIDToPS2ByteMap[THID.KEY_KP8]:=$75;
 fHIDToPS2ByteMap[THID.KEY_KP9]:=$7d;
 fHIDToPS2ByteMap[THID.KEY_KP0]:=$70;
 fHIDToPS2ByteMap[THID.KEY_KPDOT]:=$71;
{fHIDToPS2ByteMap[THID.KEY_PAUSE]:=$77;
 fHIDToPS2ByteMap[THID.KEY_INSERT]:=$70;
 fHIDToPS2ByteMap[THID.KEY_HOME]:=$6c;
 fHIDToPS2ByteMap[THID.KEY_PAGEUP]:=$7d;
 fHIDToPS2ByteMap[THID.KEY_DELETE]:=$71;
 fHIDToPS2ByteMap[THID.KEY_END]:=$69;
 fHIDToPS2ByteMap[THID.KEY_PAGEDOWN]:=$7a;
 fHIDToPS2ByteMap[THID.KEY_RIGHT]:=$74;
 fHIDToPS2ByteMap[THID.KEY_LEFT]:=$6b;
 fHIDToPS2ByteMap[THID.KEY_DOWN]:=$72;
 fHIDToPS2ByteMap[THID.KEY_UP]:=$75;
 fHIDToPS2ByteMap[THID.KEY_KPSLASH]:=$4a;
 fHIDToPS2ByteMap[THID.KEY_KPENTER]:=$5a;
 fHIDToPS2ByteMap[THID.KEY_102ND]:=$61;
 fHIDToPS2ByteMap[THID.KEY_COMPOSE]:=$65;
 fHIDToPS2ByteMap[THID.KEY_POWER]:=$66;
 fHIDToPS2ByteMap[THID.KEY_KPEQUAL]:=$8d;
 fHIDToPS2ByteMap[THID.KEY_F13]:=$68;
 fHIDToPS2ByteMap[THID.KEY_F14]:=$84;
 fHIDToPS2ByteMap[THID.KEY_F15]:=$8c;
 fHIDToPS2ByteMap[THID.KEY_F16]:=$67;
 fHIDToPS2ByteMap[THID.KEY_F17]:=$8f;
 fHIDToPS2ByteMap[THID.KEY_F18]:=$8e;
 fHIDToPS2ByteMap[THID.KEY_F19]:=$8d;
 fHIDToPS2ByteMap[THID.KEY_F20]:=$8b;
 fHIDToPS2ByteMap[THID.KEY_F21]:=$8a;
 fHIDToPS2ByteMap[THID.KEY_F22]:=$89;
 fHIDToPS2ByteMap[THID.KEY_F23]:=$88;
 fHIDToPS2ByteMap[THID.KEY_F24]:=$87;
 fHIDToPS2ByteMap[THID.KEY_OPEN]:=$5d;
 fHIDToPS2ByteMap[THID.KEY_HELP]:=$75;
 fHIDToPS2ByteMap[THID.KEY_PROPS]:=$7e;
 fHIDToPS2ByteMap[THID.KEY_FRONT]:=$6d;
 fHIDToPS2ByteMap[THID.KEY_STOP]:=$6e;
 fHIDToPS2ByteMap[THID.KEY_AGAIN]:=$7c;
 fHIDToPS2ByteMap[THID.KEY_UNDO]:=$7a;
 fHIDToPS2ByteMap[THID.KEY_CUT]:=$7d;
 fHIDToPS2ByteMap[THID.KEY_COPY]:=$7b;
 fHIDToPS2ByteMap[THID.KEY_PASTE]:=$79;
 fHIDToPS2ByteMap[THID.KEY_FIND]:=$78;
 fHIDToPS2ByteMap[THID.KEY_MUTE]:=$7f;
 fHIDToPS2ByteMap[THID.KEY_VOLUMEUP]:=$80;
 fHIDToPS2ByteMap[THID.KEY_VOLUMEDOWN]:=$81;
 fHIDToPS2ByteMap[THID.KEY_KPCOMMA]:=$71;
 fHIDToPS2ByteMap[THID.KEY_RO]:=$61;
 fHIDToPS2ByteMap[THID.KEY_KATAKANAHIRAGANA]:=$8a;
 fHIDToPS2ByteMap[THID.KEY_YEN]:=$89;
 fHIDToPS2ByteMap[THID.KEY_HENKAN]:=$8b;
 fHIDToPS2ByteMap[THID.KEY_MUHENKAN]:=$8a;
 fHIDToPS2ByteMap[THID.KEY_KPJPCOMMA]:=$8c;
 fHIDToPS2ByteMap[THID.KEY_HANGEUL]:=$90;
 fHIDToPS2ByteMap[THID.KEY_HANJA]:=$91;
 fHIDToPS2ByteMap[THID.KEY_KATAKANA]:=$92;
 fHIDToPS2ByteMap[THID.KEY_HIRAGANA]:=$93;
 fHIDToPS2ByteMap[THID.KEY_ZENKAKUHANKAKU]:=$94;
 fHIDToPS2ByteMap[THID.KEY_KPLEFTPAREN]:=$b6;
 fHIDToPS2ByteMap[THID.KEY_KPRIGHTPAREN]:=$b7;
 fHIDToPS2ByteMap[THID.KEY_LEFTALT]:=$11;
 fHIDToPS2ByteMap[THID.KEY_LEFTMETA]:=$e0;
 fHIDToPS2ByteMap[THID.KEY_RIGHTALT]:=$11;
 fHIDToPS2ByteMap[THID.KEY_RIGHTMETA]:=$e7;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_PLAYPAUSE]:=$e8;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_STOPCD]:=$e9;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_PREVIOUSSONG]:=$ea;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_NEXTSONG]:=$eb;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_EJECTCD]:=$ec;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_VOLUMEUP]:=$ed;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_VOLUMEDOWN]:=$ee;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_MUTE]:=$ef;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_WWW]:=$f0;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_BACK]:=$f1;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_FORWARD]:=$f2;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_STOP]:=$f3;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_FIND]:=$f4;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_SCROLLUP]:=$f5;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_SCROLLDOWN]:=$f6;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_EDIT]:=$f7;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_SLEEP]:=$f8;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_COFFEE]:=$f9;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_REFRESH]:=$fa;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_CALC]:=$fb; }
end;

destructor TPasRISCV.TPS2KeyboardDevice.Destroy;
begin
 FreeAndNil(fRingBuffer);
 fLastKey:='';
 inherited Destroy;
end;

procedure TPasRISCV.TPS2KeyboardDevice.Reset;
begin
 fActive:=true;
 inherited Reset;
end;

procedure TPasRISCV.TPS2KeyboardDevice.RingBufferWrite(const aData:TPasRISCVUInt8);
begin
 fRingBuffer.Write(@aData,1);
end;

function TPasRISCV.TPS2KeyboardDevice.RingBufferRead(out aData:TPasRISCVUInt8):Boolean;
begin
 result:=fRingBuffer.TryRead(@aData,1)=1;
end;

procedure TPasRISCV.TPS2KeyboardDevice.SetRate(const aRate:TPasRISCVUInt8);
begin
 fRate:=aRate and $1f;
 fDelay:=(aRate shr 5) and 3;
 fTimer.Initialize(1000);
 fTimeCmp:=(fDelay+1)*250;
end;

procedure TPasRISCV.TPS2KeyboardDevice.ResetToDefaults;
begin
 FillChar(fKeyState,SizeOf(fKeyState),#0);
 fState:=STATE_CMD;
 fRate:=$c;
 fDelay:=1;
end;

function TPasRISCV.TPS2KeyboardDevice.Command(const aCmd:TPasRISCVUInt8):Boolean;
begin
 case aCmd of
  CMD_RESET:begin
   ResetToDefaults;
   RingBufferWrite(RSP_ACK);
   RingBufferWrite($aa);
   result:=true;
  end;
  CMD_RESEND:begin
   result:=false;
  end;
  CMD_SET_DEFAULTS:begin
   ResetToDefaults;
   RingBufferWrite(RSP_ACK);
   result:=true;
  end;
  CMD_DISABLE_DATA_REPORTING:begin
   fReporting:=false;
   ResetToDefaults;
   RingBufferWrite(RSP_ACK);
   result:=true;
  end;
  CMD_ENABLE_DATA_REPORTING:begin
   fReporting:=true;
   RingBufferWrite(RSP_ACK);
   result:=true;
  end;
  CMD_SET_SAMPLE_RATE:begin
   fState:=STATE_SET_SAMPLE_RATE;
   RingBufferWrite(RSP_ACK);
   result:=true;
  end;
  CMD_GET_DEV_ID:begin
   RingBufferWrite(RSP_ACK);
   RingBufferWrite($ab);
   RingBufferWrite($83);
   result:=true;
  end;
  CMD_SET_SCAN_CODE_SET:begin
   fState:=STATE_SET_SCAN_CODE_SET;
   RingBufferWrite(RSP_ACK);
   result:=true;
  end;
  CMD_ECHO:begin
   RingBufferWrite($ee);
   result:=true;
  end;
  CMD_LEDS:begin
   fState:=STATE_SET_LEDS;
   RingBufferWrite(RSP_ACK);
   result:=true;
  end;
  else begin
   RingBufferWrite(RSP_NAK);
   result:=true;
  end;
 end;
end;

function TPasRISCV.TPS2KeyboardDevice.Read(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt;
begin
 fLock.Acquire;
 try
  result:=fRingBuffer.ReadAsMuchAsPossible(aBuffer,aSize);
 finally
  fLock.Release;
 end;
end;

function TPasRISCV.TPS2KeyboardDevice.Write(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt;
var Index:TPasRISCVSizeInt;
    Value:TPasRISCVUInt8;
begin
 fLock.Acquire;
 try
  result:=0;
  for Index:=0 to aSize-1 do begin
   Value:=TPasRISCVUInt8(PPasRISCVUInt8Array(aBuffer)^[Index]);
   case fState of
    STATE_CMD:begin
     Command(Value);
    end;
    STATE_SET_SAMPLE_RATE:begin
     SetRate(Value);
     fState:=STATE_CMD;
     RingBufferWrite(RSP_ACK);
    end;
    STATE_SET_SCAN_CODE_SET:begin
     case Value of
      0:begin
       RingBufferWrite(RSP_ACK);
       RingBufferWrite(2);
      end;
      2:begin
       RingBufferWrite(RSP_ACK);
      end;
      else begin
       RingBufferWrite(RSP_NAK);
      end;
     end;
     fState:=STATE_CMD;
     RingBufferWrite(RSP_ACK);
    end;
    STATE_SET_LEDS:begin
     fState:=STATE_CMD;
     RingBufferWrite(RSP_ACK);
    end;
   end;
  end;
 finally
  fLock.Release;
 end;
 Notify(POLL_RX);
 result:=aSize;
end;

procedure TPasRISCV.TPS2KeyboardDevice.Update;
begin
 fLock.Acquire;
 try
  if fReporting and (length(fLastKey)<>0) and (fTimer.Get>=fTimeCmp) then begin
   fTimer.Initialize(Max(1,RateToRealRate[fRate]));
   fTimeCmp:=10;
   fRingBuffer.Write(@fLastKey[1],length(fLastKey));
   Notify(POLL_RX);
   fMachine.Interrupt;
   fMachine.WakeUp;
  end;
 finally
  fLock.Release;
 end;
end;

function TPasRISCV.TPS2KeyboardDevice.HIDToPS2KeyCode(const aKey:TPasRISCVUInt32):TPasRISCVRawByteString;
begin
 if (aKey<sizeof(fHIDToPS2ByteMap)) and (fHIDToPS2ByteMap[aKey]<>0) then begin
  result:=TPasRISCVRawByteString(TPasRISCVRawByteChar(fHIDToPS2ByteMap[aKey]));
 end else begin
  case aKey of
   THID.KEY_LEFTMETA:begin
    result:=#$e0#$1f;
   end;
   THID.KEY_RIGHTCTRL:begin
    result:=#$e0#$14;
   end;
   THID.KEY_RIGHTALT:begin
    result:=#$e0#$11;
   end;
   THID.KEY_RIGHTMETA:begin
    result:=#$e0#$27;
   end;
   THID.KEY_SYSRQ:begin
    result:=#$e0#$12#$e0#$7c;
   end;
   THID.KEY_PAUSE:begin
    result:=#$e1#$14#$77#$e1#$f0#$14#$f0#$77;
   end;
   THID.KEY_INSERT:begin
    result:=#$e0#$70;
   end;
   THID.KEY_HOME:begin
    result:=#$e0#$6c;
   end;
   THID.KEY_PAGEUP:begin
    result:=#$e0#$7d;
   end;
   THID.KEY_DELETE:begin
    result:=#$e0#$71;
   end;
   THID.KEY_END:begin
    result:=#$e0#$69;
   end;
   THID.KEY_PAGEDOWN:begin
    result:=#$e0#$7a;
   end;
   THID.KEY_RIGHT:begin
    result:=#$e0#$74;
   end;
   THID.KEY_LEFT:begin
    result:=#$e0#$6b;
   end;
   THID.KEY_DOWN:begin
    result:=#$e0#$72;
   end;
   THID.KEY_UP:begin
    result:=#$e0#$75;
   end;
   THID.KEY_MENU:begin
    result:=#$e0#$2f;
   end;
   THID.KEY_KPSLASH:begin
    result:=#$e0#$4a;
   end;
   THID.KEY_KPENTER:begin
    result:=#$e0#$5a;
   end;
   else begin
    result:='';
   end;
  end;
 end;
end;

procedure TPasRISCV.TPS2KeyboardDevice.HandleKeyboard(const aKey:TPasRISCVUInt32;const aPressed:Boolean);
var KeyState:Boolean;
    KeyCode:TPasRISCVRawByteString;
    KeyBuf:array[0..7] of TPasRISCVUInt8;
    KeyLen:TPasRISCVSizeInt;
begin
 if fActive then begin
  fLock.Acquire;
  try
   KeyState:=(fKeyState[aKey shr 3] and (1 shl (aKey and 7)))<>0;
   if (aKey<>THID.KEY_NONE) and (KeyState<>aPressed) and fReporting then begin
    KeyCode:=HIDToPS2KeyCode(aKey);
    if length(KeyCode)<>0 then begin
     if aPressed then begin
      fKeyState[aKey shr 3]:=fKeyState[aKey shr 3] or (1 shl (aKey and 7));
      fLastKey:=KeyCode;
      fRingBuffer.Write(@KeyCode[1],length(KeyCode));
      fTimer.Initialize(1000);
      fTimeCmp:=(fDelay+1)*250;
     end else begin
      fKeyState[aKey shr 3]:=fKeyState[aKey shr 3] and not (1 shl (aKey and 7));
      if fLastKey=KeyCode then begin
       fLastKey:='';
      end;
      if length(KeyCode)=1 then begin
       KeyBuf[0]:=$f0;
       KeyBuf[1]:=TPasRISCVUInt8(KeyCode[1]);
       KeyLen:=2;
      end else if (length(KeyCode)=2) and (KeyCode[1]=#$e0) then begin
       KeyBuf[0]:=$e0;
       KeyBuf[1]:=$f0;
       KeyBuf[2]:=TPasRISCVUInt8(KeyCode[2]);
       KeyLen:=3;
      end else if (length(KeyCode)=4) and (KeyCode[1]=#$e0) and (KeyCode[3]=#$e0) then begin
       KeyBuf[0]:=$e0;
       KeyBuf[1]:=$f0;
       KeyBuf[2]:=TPasRISCVUInt8(KeyCode[4]);
       KeyBuf[3]:=$e0;
       KeyBuf[4]:=$f0;
       KeyBuf[5]:=TPasRISCVUInt8(KeyCode[2]);
       KeyLen:=6;
      end;
      fRingBuffer.Write(@KeyBuf,KeyLen);
     end;
     Notify(POLL_RX);
    end;
   end;
  finally
   fLock.Release;
  end;
 end;
end;

{ TPasRISCV.TPS2MouseDevice }

constructor TPasRISCV.TPS2MouseDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.PS2MouseBase,aMachine.fConfiguration.PS2MouseSize);
 fIRQ:=aMachine.fConfiguration.PS2MouseIRQ;
 fActive:=true;
 fButtons:=0;
 fResolutionInitialized:=false;
 fX:=0;
 fY:=0;
 fXMovementCounter:=0;
 fYMovementCounter:=0;
 fXOverflow:=false;
 fYOverflow:=false;
 fScroll:=0;
 fMode:=MODE_STREAM;
 fState:=STATE_CMD;
 fResolution:=0;
 fRate:=0;
 fWheelDetect:=0;
 fReporting:=false;
 fRingBuffer:=TPasMPSingleProducerSingleConsumerRingBuffer.Create(65536);
end;

destructor TPasRISCV.TPS2MouseDevice.Destroy;
begin
 FreeAndNil(fRingBuffer);
 inherited Destroy;
end;

procedure TPasRISCV.TPS2MouseDevice.ResetToDefaults;
begin
 fMode:=MODE_STREAM;
 fState:=STATE_CMD;
 fReporting:=false;
 fResolution:=2;
end;

procedure TPasRISCV.TPS2MouseDevice.Reset;
begin
 fActive:=true;
 ResetToDefaults;
 inherited Reset;
end;

procedure TPasRISCV.TPS2MouseDevice.Flush;
begin
 fXMovementCounter:=0;
 fYMovementCounter:=0;
 fXOverflow:=false;
 fYOverflow:=false;
 fScroll:=0;
end;

procedure TPasRISCV.TPS2MouseDevice.MovePacket;
var Value:TPasRISCVUInt8;
    MousePacket:array[0..3] of TPasRISCVUInt8;
begin

 Value:=(fButtons and (1 or 2 or 4)) or
        (1 shl 3) or
        ((ord(fXMovementCounter<0) and 1) shl 4) or
        ((ord(fYMovementCounter<0) and 1) shl 5) or
        ((ord(fXOverflow) and 1) shl 6) or
        ((ord(fYOverflow) and 1) shl 7);

 MousePacket[0]:=Value;
 MousePacket[1]:=fXMovementCounter and $ff;
 MousePacket[2]:=fYMovementCounter and $ff;
 if fWheelDetect=3 then begin
  MousePacket[3]:=fScroll;
 end;

 fRingBuffer.Write(@MousePacket[0],3+(ord(fWheelDetect=3) and 1));

 Flush;

 Notify(POLL_RX);

end;

function TPasRISCV.TPS2MouseDevice.Command(const aCmd:TPasRISCVUInt8):Boolean;
var SendBuffer:array[0..3] of TPasRISCVUInt8;
begin
 case aCmd of
  CMD_RESET:begin
   ResetToDefaults;
   SendBuffer[0]:=RSP_ACK;
   SendBuffer[1]:=$aa;
   SendBuffer[2]:=$00;
   fRingBuffer.Write(@SendBuffer[0],3);
   result:=true;
  end;
  CMD_RESEND:begin
   result:=false;
  end;
  CMD_SET_DEFAULTS:begin
   ResetToDefaults;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_DISABLE_DATA_REPORTING:begin
   fReporting:=false;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_ENABLE_DATA_REPORTING:begin
   fReporting:=true;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_SET_SAMPLE_RATE:begin
   fState:=STATE_SET_SAMPLE_RATE;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_GET_DEV_ID:begin
   SendBuffer[0]:=RSP_ACK;
   if fWheelDetect=3 then begin
    SendBuffer[1]:=MOUSE_WHEEL;
   end else begin
    SendBuffer[1]:=MOUSE_GENERIC;
   end;
   fRingBuffer.Write(@SendBuffer[0],2);
   result:=true;
  end;
  CMD_SET_REMOTE_MODE:begin
   Flush;
   fMode:=MODE_REMOTE;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_SET_WRAP_MODE:begin
   Flush;
   fState:=STATE_WRAP;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_RESET_WRAP_MODE:begin
   Flush;
   fState:=STATE_CMD;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_READ_DATA:begin
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   MovePacket;
   result:=true;
  end;
  CMD_SET_STREAM_MODE:begin
   Flush;
   fMode:=MODE_STREAM;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_STATUS_REQ:begin
   SendBuffer[0]:=RSP_ACK;
   SendBuffer[1]:=(fButtons and (1 or 2 or 4)) or
                  (ord(fReporting) shl 5) or
                  ((ord(fMode=MODE_REMOTE) and 1) shl 6);
   SendBuffer[2]:=fResolution;
   SendBuffer[3]:=fRate;
   fRingBuffer.Write(@SendBuffer[0],4);
   result:=true;
  end;
  CMD_SET_RESOLUTION:begin
   fState:=STATE_SET_RESOLUTION;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_SET_SCALING_1_1,
  CMD_SET_SCALING_2_1:begin
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  else begin
   SendBuffer[0]:=RSP_NAK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
 end;
end;

function TPasRISCV.TPS2MouseDevice.Read(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt;
begin
 fLock.Acquire;
 try
  result:=fRingBuffer.ReadAsMuchAsPossible(aBuffer,aSize);
 finally
  fLock.Release;
 end;
end;

function TPasRISCV.TPS2MouseDevice.Write(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt;
var Index:TPasRISCVSizeInt;
    Value:TPasRISCVUInt8;
    SendBuffer:array[0..3] of TPasRISCVUInt8;
begin
 fLock.Acquire;
 try
  result:=0;
  for Index:=0 to aSize-1 do begin
   Value:=PPasRISCVUInt8Array(aBuffer)^[Index];
   case fState of
    STATE_CMD:begin
     Command(Value);
    end;
    STATE_SET_SAMPLE_RATE:begin
     fRate:=Value;
     if fWheelDetect=0 then begin // Magical sequence for detecting Intellimouse extension
      if fRate=200 then begin
       fWheelDetect:=1;
      end else begin
       fWheelDetect:=0;
      end;
     end else if fWheelDetect=1 then begin
      if fRate=100 then begin
       fWheelDetect:=2;
      end else begin
       fWheelDetect:=0;
      end;
     end else if fWheelDetect=2 then begin
      if fRate=80 then begin
       fWheelDetect:=3;
      end else begin
       fWheelDetect:=0;
      end;
     end else if fWheelDetect<3 then begin
      fWheelDetect:=0;
     end;
     fState:=STATE_CMD;
     SendBuffer[0]:=RSP_ACK;
     fRingBuffer.Write(@SendBuffer[0],1);
    end;
    STATE_WRAP:begin
     if (Value<>CMD_RESET_WRAP_MODE) and (Value<>CMD_RESET) then begin
      fRingBuffer.Write(@Value,1);
     end;
    end;
    STATE_SET_RESOLUTION:begin
     fResolution:=Value;
     fState:=STATE_CMD;
     SendBuffer[0]:=RSP_ACK;
     fRingBuffer.Write(@SendBuffer[0],1);
    end;
   end;
  end;
 finally
  fLock.Release;
 end;
 Notify(POLL_RX);
 result:=aSize;
end;

procedure TPasRISCV.TPS2MouseDevice.ButtonPress(const aButtons:TPasRISCVUInt32);
begin
 fLock.Acquire;
 try
  if fActive then begin
   if (fButtons and aButtons)<>aButtons then begin
    fButtons:=fButtons or aButtons;
    if (fMode=MODE_STREAM) and fReporting then begin
     MovePacket;
    end;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TPS2MouseDevice.ButtonRelease(const aButtons:TPasRISCVUInt32);
begin
 fLock.Acquire;
 try
  if fActive then begin
   if (fButtons and aButtons)<>0 then begin
    fButtons:=fButtons and not aButtons;
    if (fMode=MODE_STREAM) and fReporting then begin
     MovePacket;
    end;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TPS2MouseDevice.Scroll(const aOffset:TPasRISCVInt32);
begin
 fLock.Acquire;
 try
  if fActive then begin
   fScroll:=fScroll+aOffset;
   if (fMode=MODE_STREAM) and fReporting then begin
    MovePacket;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TPS2MouseDevice.RelativeMove(const aDeltaX,aDeltaY:TPasRISCVInt32);
var Shift:TPasRISCVInt32;
    NewX,NewY:TPasRISCVInt32;
begin
 fLock.Acquire;
 try
  if fActive then begin
   Shift:=3-fResolution;
   inc(fX,aDeltaX);
   inc(fY,aDeltaY);
   if Shift>=0 then begin
    NewX:=fXMovementCounter+(aDeltaX shr Shift);
    NewY:=fYMovementCounter-(aDeltaY shr Shift);
   end else begin
    NewX:=fXMovementCounter+(aDeltaX shl (-Shift));
    NewY:=fYMovementCounter-(aDeltaY shl (-Shift));
   end;
   if (NewX>255) or (NewX<-512) then begin
    fXOverflow:=true;
    NewX:=TPasRISCVInt8(NewX);
   end;
   if (NewY>255) or (NewY<-512) then begin
    fYOverflow:=true;
    NewY:=TPasRISCVInt8(NewY);
   end;
   fXMovementCounter:=NewX;
   fYMovementCounter:=NewY;
   if (fMode=MODE_STREAM) and fReporting then begin
    MovePacket;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TPS2MouseDevice.AbsoluteMove(const aX,aY:TPasRISCVInt32);
begin
 fLock.Acquire;
 try
  if fActive then begin
   fX:=aX;
   fY:=aY;
   if (fMode=MODE_STREAM) and fReporting then begin
    MovePacket;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

{ TPasRISCV.TMemoryDevice }

constructor TPasRISCV.TMemoryDevice.Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64;const aData:Pointer;const aOwnData:Boolean);
begin
 fOwnData:=aOwnData;
 if aOwnData then begin
  fData:=aData;
 end else begin
  fData:=nil;
  if aSize>0 then begin
   GetMem(fData,aSize);
   FillChar(fData^,aSize,#0);
  end;
 end;
 inherited Create(aMachine,aBase,aSize);
end;

destructor TPasRISCV.TMemoryDevice.Destroy;
begin
 if (not fOwnData) and assigned(fData) then begin
  FreeMem(Data);
 end;
 fData:=nil;
 inherited Destroy;
end;

procedure TPasRISCV.TMemoryDevice.SetSize(const aValue:TPasRISCVUInt64);
var OldSize:TPasRISCVUInt64;
begin
 if not fOwnData then begin
  OldSize:=fSize;
  inherited SetSize(aValue);
  if OldSize<>aValue then begin
   ReallocMem(fData,aValue);
  end;
 end;
end;

function TPasRISCV.TMemoryDevice.GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
begin
 if (aAddress>=fBase) and ((aAddress-fBase)<fSize) then begin
  result:=@PPasRISCVUInt8Array(fData)^[aAddress-fBase];
 end else begin
  result:=nil;
 end;
end;

function TPasRISCV.TMemoryDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Offset:TPasRISCVUInt64;
begin
 Offset:=aAddress-fBase;
 if (Offset+aSize)<=fSize then begin
{$ifdef LITTLE_ENDIAN}
  if aSize=8 then begin
   result:=TPasRISCVUInt64(Pointer(@PPasRISCVUInt8Array(fData)^[Offset])^);
  end else begin
   result:=TPasRISCVUInt64(Pointer(@PPasRISCVUInt8Array(fData)^[Offset])^) and ((TPasRISCVUInt64(1) shl (aSize shl 3))-1);
  end;
{$else}
  case aSize of
   1:begin
    result:=TPasRISCVUInt64(fData[Offset]) and $ff;
   end;
   2:begin
    result:=(TPasRISCVUInt64(fData[Offset]) and $ff) or ((TPasRISCVUInt64(fData[Offset+1]) and $ff) shl 8);
   end;
   4:begin
    result:=(TPasRISCVUInt64(fData[Offset]) and $ff) or ((TPasRISCVUInt64(fData[Offset+1]) and $ff) shl 8) or ((TPasRISCVUInt64(fData[Offset+2]) and $ff) shl 16) or ((TPasRISCVUInt64(fData[Offset+3]) and $ff) shl 24);
   end;
   8:begin
    result:=(TPasRISCVUInt64(fData[Offset]) and $ff) or ((TPasRISCVUInt64(fData[Offset+1]) and $ff) shl 8) or ((TPasRISCVUInt64(fData[Offset+2]) and $ff) shl 16) or ((TPasRISCVUInt64(fData[Offset+3]) and $ff) shl 24) or ((TPasRISCVUInt64(fData[Offset+4]) and $ff) shl 32) or ((TPasRISCVUInt64(fData[Offset+5]) and $ff) shl 40) or ((TPasRISCVUInt64(fData[Offset+6]) and $ff) shl 48) or ((TPasRISCVUInt64(fData[Offset+7]) and $ff) shl 56);
   end;
   else begin
    result:=0;
   end;
  end;
{$endif}
 end else begin
  result:=0;
 end;
end;

procedure TPasRISCV.TMemoryDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Offset{$ifdef LITTLE_ENDIAN},Mask{$endif}:TPasRISCVUInt64;
begin
 Offset:=aAddress-fBase;
 if (Offset+aSize)<=fSize then begin
{$ifdef LITTLE_ENDIAN}
  if aSize=8 then begin
   TPasRISCVUInt64(Pointer(@PPasRISCVUInt8Array(fData)^[Offset])^):=aValue;
  end else begin
   Mask:=(TPasRISCVUInt64(1) shl (aSize shl 3))-1;
   TPasRISCVUInt64(Pointer(@PPasRISCVUInt8Array(fData)^[Offset])^):=(TPasRISCVUInt64(Pointer(@PPasRISCVUInt8Array(fData)^[Offset])^) and not Mask) or (aValue and Mask);
  end;
{$else}
  case aSize of
   1:begin
    fData[Offset]:=aValue and $ff;
   end;
   2:begin
    fData[Offset]:=aValue and $ff;
    fData[Offset+1]:=(aValue shr 8) and $ff;
   end;
   4:begin
    fData[Offset]:=aValue and $ff;
    fData[Offset+1]:=(aValue shr 8) and $ff;
    fData[Offset+2]:=(aValue shr 16) and $ff;
    fData[Offset+3]:=(aValue shr 24) and $ff;
   end;
   8:begin
    fData[Offset]:=aValue and $ff;
    fData[Offset+1]:=(aValue shr 8) and $ff;
    fData[Offset+2]:=(aValue shr 16) and $ff;
    fData[Offset+3]:=(aValue shr 24) and $ff;
    fData[Offset+4]:=(aValue shr 32) and $ff;
    fData[Offset+5]:=(aValue shr 40) and $ff;
    fData[Offset+6]:=(aValue shr 48) and $ff;
    fData[Offset+7]:=(aValue shr 56) and $ff;
   end;
  end;
{$endif}
 end;
end;

procedure TPasRISCV.TMemoryDevice.LoadFromStream(const aStream:TStream);
begin
 if fSize>0 then begin
  aStream.Seek(0,soBeginning);
  aStream.ReadBuffer(fData^,Min(TPasRISCVInt64(fSize),TPasRISCVInt64(aStream.Size)));
 end;
end;

procedure TPasRISCV.TMemoryDevice.LoadFromFile(const aFileName:TPasRISCVUTF8String);
var FileStream:TFileStream;
begin
 FileStream:=TFileStream.Create(aFileName,fmOpenRead);
 try
  LoadFromStream(FileStream);
 finally
  FileStream.Free;
 end;
end;

procedure TPasRISCV.TMemoryDevice.SaveToStream(const aStream:TStream);
begin
 if fSize>0 then begin
  aStream.Seek(0,soBeginning);
  aStream.WriteBuffer(fData^,fSize);
 end;
end;

procedure TPasRISCV.TMemoryDevice.SaveToFile(const aFileName:TPasRISCVUTF8String);
var FileStream:TFileStream;
begin
 FileStream:=TFileStream.Create(aFileName,fmCreate);
 try
  SaveToStream(FileStream);
 finally
  FileStream.Free;
 end;
end;

{ TPasRISCV.TBus }

constructor TPasRISCV.TBus.Create(const aMachine:TPasRISCV);
begin
 inherited Create;
 fMachine:=aMachine;
 fBusDevices:=nil;
 fCountBusDevices:=0;
end;

destructor TPasRISCV.TBus.Destroy;
begin
 fBusDevices:=nil;
 fCountBusDevices:=0;
 inherited Destroy;
end;

function TPasRISCV.TBus.GetAutoMemoryAddress(const aAddress,aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Index:TPasRISCVSizeInt;
    OK:Boolean;
    BusDevice:TBusDevice;
begin
 result:=aAddress;
 if aSize<>0 then begin
  repeat
   OK:=true;
   for Index:=0 to fCountBusDevices-1 do begin
    BusDevice:=fBusDevices[Index];
    if (result<(BusDevice.fBase+BusDevice.fSize)) and (BusDevice.fBase<(result+aSize)) then begin
     result:=((BusDevice.fBase+BusDevice.fSize)+TPasRISCVUInt64($fff)) and TPasRISCVUInt64($fffffffffffff000);
     OK:=false;
    end;
   end;
  until OK;
 end;
end;

procedure TPasRISCV.TBus.AddBusDevice(const aBusDevice:TBusDevice);
var Index:TPasRISCVSizeInt;
begin
 Index:=fCountBusDevices;
 inc(fCountBusDevices);
 if length(fBusDevices)<fCountBusDevices then begin
  SetLength(fBusDevices,fCountBusDevices+((fCountBusDevices+1) shr 1)); // Grow by 1.5
 end;
 fBusDevices[Index]:=aBusDevice;
end;

procedure TPasRISCV.TBus.RemoveBusDevice(const aBusDevice:TBusDevice);
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to fCountBusDevices-1 do begin
  if fBusDevices[Index]=aBusDevice then begin
   if (Index+1)<fCountBusDevices then begin
    fBusDevices[Index]:=fBusDevices[fCountBusDevices-1];
    fBusDevices[fCountBusDevices-1]:=nil;
   end else begin
    fBusDevices[Index]:=nil;
   end;
   dec(fCountBusDevices);
   break;
  end;
 end;
end;

function TPasRISCV.TBus.FindBusDevice(const aAddress:TPasRISCVUInt64):TBusDevice;
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to fCountBusDevices-1 do begin
  result:=fBusDevices[Index];
  if assigned(result) and (aAddress>=result.fBase) and ((aAddress-result.fBase)<result.fSize) then begin
   if result.fCountSubBusDevices>0 then begin
    result:=result.FindSubBusDevice(aAddress);
   end;
   exit;
  end;
 end;
 result:=nil;
end;

function TPasRISCV.TBus.GetDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
var BusDevice:TBusDevice;
begin
 result:=fMachine.fMemoryDevice.GetDeviceDirectMemoryAccessPointer(aAddress,aSize,aWrite,aBounce);
 if not assigned(result) then begin
  BusDevice:=FindBusDevice(aAddress);
  if assigned(BusDevice) then begin
   result:=BusDevice.GetDeviceDirectMemoryAccessPointer(aAddress,aSize,aWrite,aBounce);
  end else begin
   result:=nil;
  end;
 end;
end;

function TPasRISCV.TBus.Fetch(const aHART:THART;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var BusDevice:TBusDevice;
begin
 BusDevice:=FindBusDevice(aAddress);
 if assigned(BusDevice) then begin
  result:=BusDevice.Load(aAddress,aSize);
 end else begin
  if {((aAddress and THART.TMMU.PHYSICAL_INVERSE_MASK)=0) and} assigned(aHART) then begin
   aHART.SetException(THART.TExceptionValue.InstructionAccessFault,aAddress,aHART.fState.PC);
  end;
  result:=0;
 end;
end;

function TPasRISCV.TBus.LoadUnaligned(const aBusDevice:TBusDevice;const aAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
var Temp,Dest:array[0..15] of TPasRISCVUInt8;
    Align,OffsetAlign,OffsetDiff,OffsetDest,SizeDest,Value,Size:TPasRISCVUInt64;
begin

//writeln(aBusDevice.ClassName);

 if aSize<aBusDevice.fMinOpSize then begin
  Align:=aBusDevice.fMinOpSize;
 end else if aSize>aBusDevice.fMaxOpSize then begin
  Align:=aBusDevice.fMaxOpSize;
 end else begin
  Align:=aSize;
 end;

 if Align>SizeOf(Temp) then begin
  aValue:=0;
  result:=false;
  exit;
 end;

 FillChar(Temp[0],SizeOf(Temp),#0);
 FillChar(Dest[0],SizeOf(Dest),#0);

 OffsetAlign:=aAddress and not TPasRISCVUInt64(Align-1);
 OffsetDiff:=aAddress-OffsetAlign;
 OffsetDest:=0;
 SizeDest:=0;

 Size:=aSize;
 while Size>0 do begin

  // Calculate amount of bytes to read
  if (Align-OffsetDiff)>Size then begin
   SizeDest:=Size;
  end else begin
   SizeDest:=Align-OffsetDiff;
  end;

  // Read the aligned bytes
  Value:=aBusDevice.Load(OffsetAlign,Align);
  case Align of
   1:begin
    TPasRISCVUInt8(Pointer(@Temp[0])^):=Value;
   end;
   2:begin
    TPasRISCVUInt16(Pointer(@Temp[0])^):=Value;
   end;
   3:begin
    TPasRISCVUInt16(Pointer(@Temp[0])^):=Value and $ffff;
    TPasRISCVUInt8(Pointer(@Temp[2])^):=(Value shr 16) and $ff;
   end;
   4:begin
    TPasRISCVUInt32(Pointer(@Temp[0])^):=Value;
   end;
   5:begin
    TPasRISCVUInt32(Pointer(@Temp[0])^):=Value and $ffffffff;
    TPasRISCVUInt8(Pointer(@Temp[4])^):=(Value shr 32) and $ff;
   end;
   6:begin
    TPasRISCVUInt32(Pointer(@Temp[OffsetDest])^):=Value and $ffff;
    TPasRISCVUInt16(Pointer(@Temp[OffsetDest+4])^):=(Value shr 32) and $ffff;
   end;
   7:begin
    TPasRISCVUInt32(Pointer(@Temp[OffsetDest])^):=Value and $ffff;
    TPasRISCVUInt16(Pointer(@Temp[OffsetDest+4])^):=(Value shr 32) and $ffff;
    TPasRISCVUInt8(Pointer(@Temp[OffsetDest+6])^):=(Value shr 48) and $ff;
   end;
   8:begin
    TPasRISCVUInt64(Pointer(@Temp[OffsetDest])^):=Value;
   end;
   else begin
    aValue:=0;
    result:=false;
    exit;
   end;
  end;

  // Copy the read bytes to the aligned destination offset
  Move(Temp[OffsetDiff],Dest[OffsetDest],SizeDest);

  // Advance the pointers
  inc(OffsetDest,SizeDest);
  inc(OffsetAlign,Align);
  dec(Size,SizeDest);

  // Reset the unaligned offset
  OffsetDiff:=0;

 end;

 // Return the aligned value
 case aSize of
  1:begin
   aValue:=TPasRISCVUInt8(Pointer(@Dest[0])^);
  end;
  2:begin
   aValue:=TPasRISCVUInt16(Pointer(@Dest[0])^);
  end;
  4:begin
   aValue:=TPasRISCVUInt32(Pointer(@Dest[0])^);
  end;
  8:begin
   aValue:=TPasRISCVUInt64(Pointer(@Dest[0])^);
  end;
  else begin
   aValue:=0;
   result:=false;
   exit;
  end;
 end;

 result:=true;

end;

function TPasRISCV.TBus.StoreUnaligned(const aBusDevice:TBusDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
var Temp,Dest:array[0..15] of TPasRISCVUInt8;
    Align,OffsetAlign,OffsetDiff,OffsetDest,SizeDest,Value,Size:TPasRISCVUInt64;
begin

//writeln(aBusDevice.ClassName);

 if aSize<aBusDevice.fMinOpSize then begin
  Align:=aBusDevice.fMinOpSize;
 end else if aSize>aBusDevice.fMaxOpSize then begin
  Align:=aBusDevice.fMaxOpSize;
 end else begin
  Align:=aSize;
 end;

 if Align>SizeOf(Temp) then begin
  result:=false;
  exit;
 end;

 FillChar(Temp[0],SizeOf(Temp),#0);
 FillChar(Dest[0],SizeOf(Dest),#0);

 case aSize of
  1:begin
   TPasRISCVUInt8(Pointer(@Dest[0])^):=aValue;
  end;
  2:begin
   TPasRISCVUInt16(Pointer(@Dest[0])^):=aValue;
  end;
  4:begin
   TPasRISCVUInt32(Pointer(@Dest[0])^):=aValue;
  end;
  8:begin
   TPasRISCVUInt64(Pointer(@Dest[0])^):=aValue;
  end;
  else begin
   result:=false;
   exit;
  end;
 end;

 OffsetAlign:=aAddress and not TPasRISCVUInt64(Align-1);
 OffsetDiff:=aAddress-OffsetAlign;
 OffsetDest:=0;
 SizeDest:=0;

 Size:=aSize;
 while Size>0 do begin

   // Calculate amount of bytes to read
  if (Align-OffsetDiff)>Size then begin
   SizeDest:=Size;
  end else begin
   SizeDest:=Align-OffsetDiff;
  end;

  // Load the aligned value for RMW operation, if needed
  if (OffsetDiff<>0) or (SizeDest<>Align) then begin
   Value:=aBusDevice.Load(OffsetAlign,Align);
   case Align of
    1:begin
     TPasRISCVUInt8(Pointer(@Temp[0])^):=Value;
    end;
    2:begin
     TPasRISCVUInt16(Pointer(@Temp[0])^):=Value;
    end;
    3:begin
     TPasRISCVUInt16(Pointer(@Temp[0])^):=Value and $ffff;
     TPasRISCVUInt8(Pointer(@Temp[2])^):=(Value shr 16) and $ff;
    end;
    4:begin
     TPasRISCVUInt32(Pointer(@Temp[0])^):=Value;
    end;
    5:begin
     TPasRISCVUInt32(Pointer(@Temp[0])^):=Value and $ffffffff;
     TPasRISCVUInt8(Pointer(@Temp[4])^):=(Value shr 32) and $ff;
    end;
    6:begin
     TPasRISCVUInt32(Pointer(@Temp[0])^):=Value and $ffff;
     TPasRISCVUInt16(Pointer(@Temp[4])^):=(Value shr 32) and $ffff;
    end;
    7:begin
     TPasRISCVUInt32(Pointer(@Temp[0])^):=Value and $ffff;
     TPasRISCVUInt16(Pointer(@Temp[4])^):=(Value shr 32) and $ffff;
     TPasRISCVUInt8(Pointer(@Temp[6])^):=(Value shr 48) and $ff;
    end;
    8:begin
     TPasRISCVUInt64(Pointer(@Temp[0])^):=Value;
    end;
    else begin
     result:=false;
     exit;
    end;
   end;
  end;

  // Carry the changed bytes from the RMW operation
  Move(Dest[OffsetDest],Temp[OffsetDiff],SizeDest);

  // Get the aligned value for aligned store
  case Align of
   1:begin
    Value:=TPasRISCVUInt8(Pointer(@Temp[0])^);
   end;
   2:begin
    Value:=TPasRISCVUInt16(Pointer(@Temp[0])^);
   end;
   4:begin
    Value:=TPasRISCVUInt32(Pointer(@Temp[0])^);
   end;
   8:begin
    Value:=TPasRISCVUInt64(Pointer(@Temp[0])^);
   end;
   else begin
    result:=false;
    exit;
   end;
  end;

  // Write the aligned value back
  aBusDevice.Store(OffsetAlign,Value,Align);

  // Advance the pointers
  inc(OffsetDest,SizeDest);
  inc(OffsetAlign,Align);
  dec(Size,SizeDest);

  // Reset the unaligned offset
  OffsetDiff:=0;

 end;

 result:=true;

end;

function TPasRISCV.TBus.Load(const aHART:THART;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var BusDevice:TBusDevice;
begin
 BusDevice:=FindBusDevice(aAddress);
 if assigned(BusDevice) then begin
  if (aSize>=BusDevice.fMinOpSize) and (aSize<=BusDevice.fMaxOpSize) and (BusDevice.fUnalignedAccessSupport or ((aAddress and (aSize-1))=0)) then begin
   result:=BusDevice.Load(aAddress,aSize);
  end else begin
   if not LoadUnaligned(BusDevice,aAddress,result,aSize) then begin
    if assigned(aHART) then begin
     aHART.SetException(THART.TExceptionValue.LoadAccessFault,aAddress,aHART.fState.PC);
    end;
   end;
  end;
 end else begin
  if {((aAddress and THART.TMMU.PHYSICAL_INVERSE_MASK)=0) and} assigned(aHART) then begin
   aHART.SetException(THART.TExceptionValue.LoadAccessFault,aAddress,aHART.fState.PC);
  end;
  result:=0;
 end;
end;

procedure TPasRISCV.TBus.Store(const aHART:THART;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var BusDevice:TBusDevice;
begin
 BusDevice:=FindBusDevice(aAddress);
 if assigned(BusDevice) then begin
  if (aSize>=BusDevice.fMinOpSize) and (aSize<=BusDevice.fMaxOpSize) and (BusDevice.fUnalignedAccessSupport or ((aAddress and (aSize-1))=0)) then begin
   BusDevice.Store(aAddress,aValue,aSize);
  end else begin
   if not StoreUnaligned(BusDevice,aAddress,aValue,aSize) then begin
    if assigned(aHART) then begin
     aHART.SetException(THART.TExceptionValue.StoreAccessFault,aAddress,aHART.fState.PC);
    end;
   end;
  end;
 end else begin
  if {((aAddress and THART.TMMU.PHYSICAL_INVERSE_MASK)=0) and} assigned(aHART) then begin
   aHART.SetException(THART.TExceptionValue.StoreAccessFault,aAddress,aHART.fState.PC);
  end;
 end;
end;

function TPasRISCV.TBus.LoadEx(const aAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
var BusDevice:TBusDevice;
begin
 BusDevice:=FindBusDevice(aAddress);
 if assigned(BusDevice) then begin
  if (aSize>=BusDevice.fMinOpSize) and (aSize<=BusDevice.fMaxOpSize) and (BusDevice.fUnalignedAccessSupport or ((aAddress and (aSize-1))=0)) then begin
   aValue:=BusDevice.Load(aAddress,aSize);
   result:=true;
  end else begin
   result:=LoadUnaligned(BusDevice,aAddress,aValue,aSize);
  end;
 end else begin
  aValue:=0;
  result:=false;
 end;
end;

function TPasRISCV.TBus.StoreEx(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
var BusDevice:TBusDevice;
begin
 BusDevice:=FindBusDevice(aAddress);
 if assigned(BusDevice) then begin
  if (aSize>=BusDevice.fMinOpSize) and (aSize<=BusDevice.fMaxOpSize) and (BusDevice.fUnalignedAccessSupport or ((aAddress and (aSize-1))=0)) then begin
   BusDevice.Store(aAddress,aValue,aSize);
   result:=true;
  end else begin
   result:=StoreUnaligned(BusDevice,aAddress,aValue,aSize);
  end;
 end else begin
  result:=false;
 end;
end;

procedure TPasRISCV.TBus.Step;
begin
end;

{ TPasRISCV.THART.TException }

constructor TPasRISCV.THART.TException.Create(const aExceptionValue:TExceptionValue;const aExceptionData,aExceptionPC:TPasRISCVUInt64);
begin
 fExceptionValue:=aExceptionValue;
 fExceptionData:=aExceptionData;
 fExceptionPC:=aExceptionPC;
 inherited Create(TPasRISCV.THART.ExceptionNames[aExceptionValue]+' at '+IntToStr(aExceptionPC)+' with data '+IntToStr(aExceptionData));
end;

destructor TPasRISCV.THART.TException.Destroy;
begin
 inherited Destroy;
end;

{ TPasRISCV.THART.TCSR }

procedure TPasRISCV.THART.TCSR.Init(const aHART:THART);
begin

 fHART:=aHART;

 FillChar(fData,SizeOf(fData),#0);

 fData[TAddress.MISA]:=TMISA.TExtension.XLEN_64 or
                       TMISA.TExtension.A_EXT or
                       TMISA.TExtension.C_EXT or
                       TMISA.TExtension.F_EXT or
                       TMISA.TExtension.D_EXT or
                       TMISA.TExtension.RV32I_64I_128I or
                       TMISA.TExtension.M_EXT or
                       TMISA.TExtension.SUPERVISOR or
                       TMISA.TExtension.USER;

 fData[TAddress.MHARTID]:=fHART.fHARTID;

 fData[TAddress.MARCHID]:=(TPasRISCVUInt32(Ord('P')) shl 0) or
                          (TPasRISCVUInt32(Ord('A')) shl 8) or
                          (TPasRISCVUInt32(Ord('S')) shl 16) or
                          (TPasRISCVUInt32(Ord('R')) shl 24);

 fData[TAddress.MIMPID]:=0;

 fData[TAddress.MVENDORID]:=0;

 fData[TAddress.MSTATUS]:=TPasRISCVUInt64($200000000);

 fData[TAddress.MENVCFG]:=TPasRISCVUInt64($a0000000000000d0); // $e
 fData[TAddress.MENVCFGH]:=fData[TAddress.MENVCFG] shr 32;

 fData[TAddress.SENVCFG]:=TPasRISCVUInt64($00000000000000d0);

 fData[TAddress.STIMECMP]:=TPasRISCVUInt64($ffffffffffffffff);

end;

function TPasRISCV.THART.TCSR.Load(const aAddress:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 case aAddress of
  TAddress.SEED:begin // Seed (Zkr)
   // A fast per-HART PCG32 random generator, initialized with a ChaCha20-based random source.
   // The generator draws initial entropy from an arc4random-like mechanism, which relies on
   // ChaCha20 instead of RC4. If a more robust and direct entropy source is needed, the guest
   // system should use virtio-rng. Note, however, that virtio-rng may block when its entropy
   // pool is exhausted, causing delays as the pool is rekeyed.
   result:=(fHART.fPCG32.Get32 shr 16) and TPasRISCVUInt64($ffff); // limited to 16 physical entropy bits
  end;
  TAddress.SSTATUS:begin
   result:=fData[TAddress.MSTATUS] and TMask.SSTATUS;
  end;
  TAddress.MSTATUS:begin
   result:=fData[TAddress.MSTATUS];
  end;
  TAddress.TIME:begin
   result:=fHART.fMachine.fACLINTDevice.GetTime;
  end;
  TAddress.TIMEH:begin
   result:=fHART.fMachine.fACLINTDevice.GetTime shr 32;
  end;
  TAddress.MCYCLE:begin
   result:=fHART.fState.Cycle;
  end;
  TAddress.MCYCLEH:begin
   result:=fHART.fState.Cycle shr 32;
  end;
  TAddress.CYCLE:begin
   result:=fHART.fState.Cycle;
  end;
  TAddress.CYCLEH:begin
   result:=fHART.fState.Cycle shr 32;
  end;
  TAddress.MINSTRET:begin
   result:=fHART.fState.Cycle;
  end;
  TAddress.MINSTRETH:begin
   result:=fHART.fState.Cycle shr 32;
  end;
  TAddress.INSTRET:begin
   result:=fHART.fState.Cycle;
  end;
  TAddress.INSTRETH:begin
   result:=fHART.fState.Cycle shr 32;
  end;
  TAddress.MENVCFG:begin
   result:=TPasRISCVUInt64(TPasRISCVUInt64(fData[TAddress.MENVCFG] and TPasRISCVUInt64($80000000000000d0)));
  end;
{ TAddress.MENVCFGH:begin
   result:=TPasRISCVUInt32(TPasRISCVUInt64(fData[TAddress.MENVCFG] and TPasRISCVUInt64($80000000000000d0)) shr 32);
  end;}
  TAddress.SENVCFG:begin
   result:=TPasRISCVUInt64(TPasRISCVUInt64(fData[TAddress.SENVCFG] and TPasRISCVUInt64($00000000000000d0)));
  end;
  TAddress.STIMECMP:begin
   result:=fHART.fSTIMECMP;
  end;
{TAddress.STIMECMPH:begin
   result:=TPasRISCVUInt32(TPasRISCVUInt64(fData[TAddress.STIMECMP] shr 32));
  end}
  else begin
   result:=fData[aAddress];
  end;
 end;
end;

procedure TPasRISCV.THART.TCSR.Store(const aAddress,aValue:TPasRISCVUInt64);
var Value,Mask:TPasRISCVUInt64;
begin
 case aAddress of
  TAddress.SSTATUS:begin
   Value:=(fData[TAddress.MSTATUS] and not TPasRISCVUInt64(TMask.SSTATUS)) or (aValue and TPasRISCVUInt64(TMask.SSTATUS));
   fData[TAddress.MSTATUS]:=Value;
  end;
  TAddress.MENVCFG:begin
   fData[TAddress.MENVCFG]:=aValue and TPasRISCVUInt64($80000000000000d0);
  end;
{ TAddress.MENVCFG:begin
   fData[TAddress.MENVCFG]:=((fData[TAddress.MENVCFG] and TPasRISCVUInt64($ffffffff00000000)) or
                             (TPasRISCVUInt64(aValue) and TPasRISCVUInt64($00000000ffffffff))) and TPasRISCVUInt64($80000000000000d0);
  end;
  TAddress.MENVCFGH:begin
   fData[TAddress.MENVCFG]:=((fData[TAddress.MENVCFG] and TPasRISCVUInt64($00000000ffffffff)) or
                              ((TPasRISCVUInt64(aValue) shl 32) and TPasRISCVUInt64($ffffffff00000000))) and TPasRISCVUInt64($80000000000000d0);
   fData[TAddress.MENVCFGH]:=fData[TAddress.MENVCFG] shr 32;
  end;}
  TAddress.SENVCFG:begin
   fData[TAddress.SENVCFG]:=aValue and TPasRISCVUInt64($00000000000000d0);
  end;
  TAddress.STIMECMP:begin
   fHART.fSTIMECMP:=aValue;
   fData[TAddress.STIMECMP]:=aValue;
  end;
{ TAddress.STIMECMPH:begin
   fData[TAddress.STIMECMP]:=((TPasRISCVUInt64(aValue) shl 32) and TPasRISCVUInt64($ffffffff00000000)) or
                             (fData[TAddress.STIMECMP] and TPasRISCVUInt64($00000000ffffffff));
  end;}
  else begin
   fData[aAddress]:=aValue;
  end;
 end;
end;

procedure TPasRISCV.THART.TCSR.SetFPUException(const aValue:TPasRISCVUInt64);
begin
 fData[TAddress.FFLAGS]:=(fData[TAddress.FFLAGS] and not TFPUExceptionMasks.Mask) or (aValue and TPasRISCVUInt64(TFPUExceptionMasks.Mask));
end;

procedure TPasRISCV.THART.TCSR.ClearFPUExceptions;
begin
 fData[TAddress.FFLAGS]:=fData[TAddress.FFLAGS] and not TPasRISCVUInt64(TFPUExceptionMasks.Mask);
end;

procedure TPasRISCV.THART.TCSR.SetFPURM(const aValue:TPasRISCVUInt64);
begin
 fData[TAddress.FRM]:=(fData[TAddress.FRM] and not TPasRISCVUInt64(TFloatingPointRoundingModes.Mask)) or (aValue and TPasRISCVUInt64(TFloatingPointRoundingModes.Mask));
 case TFloatingPointRoundingModes(aValue and TPasRISCVUInt64(TFloatingPointRoundingModes.Mask)) of
  TFloatingPointRoundingModes.RoundToNearestEven:begin
{$ifdef fpc}
   SetRoundMode(TFPURoundingMode.rmNearest);
{$else}
   SetRoundMode(rmNearest);
{$endif}
  end;
  TFloatingPointRoundingModes.RoundToZero:begin
{$ifdef fpc}
   SetRoundMode(TFPURoundingMode.rmTruncate);
{$else}
   SetRoundMode(rmTruncate);
{$endif}
  end;
  TFloatingPointRoundingModes.RoundDown:begin
{$ifdef fpc}
   SetRoundMode(TFPURoundingMode.rmDown);
{$else}
   SetRoundMode(rmDown);
{$endif}
  end;
  TFloatingPointRoundingModes.RoundUp:begin
{$ifdef fpc}
   SetRoundMode(TFPURoundingMode.rmUp);
{$else}
   SetRoundMode(rmUp);
{$endif}
  end;
  TFloatingPointRoundingModes.RoundNearestMaxMagnitude:begin
{$ifdef fpc}
   SetRoundMode(TFPURoundingMode.rmNearest);
{$else}
   SetRoundMode(rmNearest);
{$endif}
  end;
  TFloatingPointRoundingModes.RoundDynamic:begin
{$ifdef fpc}
   SetRoundMode(TFPURoundingMode.rmNearest);
{$else}
   SetRoundMode(rmNearest);
{$endif}
  end;
  else {TFloatingPointRoundingModes.RoundToNearest:}begin
  end;
 end;
end;

procedure TPasRISCV.THART.TCSR.ClearFPURM;
begin
 fData[TAddress.FRM]:=fData[TAddress.FRM] and not TPasRISCVUInt64(TFloatingPointRoundingModes.Mask);
end;

procedure TPasRISCV.THART.TCSR.SetFS(const aValue:TPasRISCVUInt64);
begin
 fData[TAddress.MSTATUS]:=(fData[TAddress.MSTATUS] and not (TPasRISCVUInt64(3) shl 13)) or (TPasRISCVUInt64(TPasRISCVUInt64(aValue) and 3) shl 13);
end;

function TPasRISCV.THART.TCSR.GetFS:TPasRISCVUInt64;
begin
 result:=(fData[TAddress.MSTATUS] shr 13) and 3;
end;

procedure TPasRISCV.THART.TCSR.ClearFS;
begin
 fData[TAddress.MSTATUS]:=fData[TAddress.MSTATUS] and not (TPasRISCVUInt64(3) shl 13);
end;

procedure TPasRISCV.THART.TCSR.SetFSDirty;
begin
 if ((fData[TCSR.TAddress.MSTATUS] shr 13) and 3)<>TCSR.TFS.Dirty then begin
  fData[TCSR.TAddress.MSTATUS]:=fData[TCSR.TAddress.MSTATUS] or (TCSR.TFS.Dirty shl 13);
 end;
end;

function TPasRISCV.THART.TCSR.IsFPUEnabled:Boolean;
begin
 result:=((fData[TAddress.MSTATUS] shr 13) and 3)<>TFS.Off;
end;

{ TPasRISCV.THART.TAIARegFile }

constructor TPasRISCV.THART.TAIARegFile.Create(const aMachine:TPasRISCV;const aHART:THART);
begin
 inherited Create;
 fMachine:=aMachine;
 fHART:=aHART;
 Reset;
end;

destructor TPasRISCV.THART.TAIARegFile.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV.THART.TAIARegFile.Reset;
begin
 fEIDelivery:=0;
 fEIThreshold:=0;
 FillChar(fEIP,ARRAY_LENGTH*SizeOf(TPasRISCVUInt32),#0);
 FillChar(fEIE,ARRAY_LENGTH*SizeOf(TPasRISCVUInt32),#0);
end;

{ TPasRISCV.THART.TExecutionThread }

constructor TPasRISCV.THART.TExecutionThread.Create(const aHART:THART);
begin
 fHART:=aHART;
 fHART.fExecutionThread:=self;
 inherited Create(false);
end;

destructor TPasRISCV.THART.TExecutionThread.Destroy;
begin
 if assigned(fHART) then begin
  fHART.fExecutionThread:=nil;
 end;
 inherited Destroy;
end;

procedure TPasRISCV.THART.TExecutionThread.Execute;
begin
 if assigned(fHART) then begin
  NameThreadForDebugging('THART['+IntToStr(fHART.fHARTID)+'].TExecutionThread');
  fHART.ThreadProc;
 end else begin
  NameThreadForDebugging('THART.TExecutionThread');
 end;
end;

procedure TPasRISCV.THART.TExecutionThread.Shutdown;
begin
 if not Finished then begin
  Terminate;
  WaitFor;
 end;
end;

{ TPasRISCV.THART }

constructor TPasRISCV.THART.Create(const aMachine:TPasRISCV;const aHARTID:TPasRISCVUInt32);
var CSRIndex:TPasRISCVSizeInt;
    AIARegFileMode:TAIARegFileMode;
begin
 inherited Create;

 fMachine:=aMachine;

 fPHandle:=fMachine.AllocatePHandle;

 fHARTID:=aHARTID;

 fHARTMask:=TPasRISCVUInt32(1) shl fHARTID;

 fMachine.fAllHARTMask:=fMachine.fAllHARTMask or fHARTMask;

 fPointerToState:=@fState;

 if fMachine.fConfiguration.fAIA then begin
  for AIARegFileMode:=Low(TAIARegFileMode) to High(TAIARegFileMode) do begin
   fAIARegFiles[AIARegFileMode]:=TAIARegFile.Create(self.fMachine,self);
  end;
 end else begin
  for AIARegFileMode:=Low(TAIARegFileMode) to High(TAIARegFileMode) do begin
   fAIARegFiles[AIARegFileMode]:=nil;
  end;
 end;

 fACLINTDevice:=fMachine.fACLINTDevice;

 fMTIMECMP:=TPasRISCVUInt64($ffffffffffffffff);

 fSTIMECMP:=TPasRISCVUInt64($ffffffffffffffff);

 fBus:=fMachine.fBus;

 fMMUMode:=TMMU.TMMUMode.SV39;
 fRootPageTable:=0;
 FlushTLB(false);

 for CSRIndex:=Low(TCSRHandlerMap) to High(TCSRHandlerMap) do begin

  case CSRIndex of

   TCSR.TAddress.FFLAGS,
   TCSR.TAddress.FRM,
   TCSR.TAddress.FCSR,

   TCSR.TAddress.SEED,

   TCSR.TAddress.CYCLE,
// TCSR.TAddress.CYCLEH,
   TCSR.TAddress.TIME,
// TCSR.TAddress.TIMEH,
   TCSR.TAddress.INSTRET,
// TCSR.TAddress.INSTRETH,

   TCSR.TAddress.SSTATUS,
   TCSR.TAddress.SEDELEG,
   TCSR.TAddress.SIDELEG,
// TCSR.TAddress.SIE,
   TCSR.TAddress.STVEC,
   TCSR.TAddress.SCOUNTEREN,

   TCSR.TAddress.SENVCFG,

   TCSR.TAddress.SSCRATCH,
   TCSR.TAddress.SEPC,
   TCSR.TAddress.SCAUSE,
   TCSR.TAddress.STVAL,
// TCSR.TAddress.SIP,
// TCSR.TAddress.STIMECMP,
// TCSR.TAddress.STIMECMPH,

   TCSR.TAddress.SATP,

   TCSR.TAddress.MVENDORID,
   TCSR.TAddress.MARCHID,
   TCSR.TAddress.MIMPID,
   TCSR.TAddress.MHARTID,
   TCSR.TAddress.MCONFIGPTR,

   TCSR.TAddress.MSTATUS,
// TCSR.TAddress.MSTATUSH,
   TCSR.TAddress.MISA,
   TCSR.TAddress.MEDELEG,
// TCSR.TAddress.MEDELEGH,
   TCSR.TAddress.MIDELEG,
// TCSR.TAddress.MIE,
   TCSR.TAddress.MTVEC,
   TCSR.TAddress.MCOUNTEREN,

   TCSR.TAddress.MSCRATCH,
   TCSR.TAddress.MEPC,
   TCSR.TAddress.MCAUSE,
   TCSR.TAddress.MTVAL,
// TCSR.TAddress.MIP,

   TCSR.TAddress.MCYCLE,
// TCSR.TAddress.MCYCLEH,
   TCSR.TAddress.MINSTRET,
// TCSR.TAddress.MINSTRETH,

   TCSR.TAddress.MNSCRATCH,
   TCSR.TAddress.MNEPC,
   TCSR.TAddress.MNCAUSE,
   TCSR.TAddress.MNSTATUS,

   TCSR.TAddress.MENVCFG,
// TCSR.TAddress.MENVCFGH,
   TCSR.TAddress.MSECCFG,
// TCSR.TAddress.MSECCFGH,

   TCSR.TAddress.TSELECT,
   TCSR.TAddress.TDATA1,
   TCSR.TAddress.TDATA2,
   TCSR.TAddress.TINFO,
   TCSR.TAddress.DCSR,
   TCSR.TAddress.DPC,
   TCSR.TAddress.DSCRATCH0,
   TCSR.TAddress.DSCRATCH2,

   $3a0..$3a3, // pmpcfg0 .. pmpcfg3
   $3b0..$3bf, // pmpaddr0 .. pmpaddr15

   $321..$33f, // mhpmevent1 - mhpmevent31
   $b03..$b1f, // mhpmcounter3..mhpmcounter31
   $b83..$b9f, // mhpmcounter3h..mhpmcounter31h

   TCSR.TAddress.MCOUNTINHIBIT:begin

    if ((CSRIndex shr 8) and 3)<>0 then begin
     if ((CSRIndex shr 10) and 3)=3 then begin
      fCSRHandlerMap[CSRIndex]:=CSRHandlerPrivilegedReadOnly;
     end else begin
      fCSRHandlerMap[CSRIndex]:=CSRHandlerPrivileged;
     end;
    end else begin
     if ((CSRIndex shr 10) and 3)=3 then begin
      fCSRHandlerMap[CSRIndex]:=CSRHandlerDefaultReadOnly;
     end else begin
      fCSRHandlerMap[CSRIndex]:=CSRHandlerDefault;
     end;
    end;
   end
   else begin
    fCSRHandlerMap[CSRIndex]:=CSRHandlerIllegal;
   end;
  end;

  //fCSRHandlerMap[CSRIndex]:=CSRHandlerDefault;

 end;

 fCSRHandlerMap[TCSR.TAddress.FFLAGS]:=CSRHandlerFFLAGS; /// FFLAGS
 fCSRHandlerMap[TCSR.TAddress.FRM]:=CSRHandlerFRM; // FRM
 fCSRHandlerMap[TCSR.TAddress.FCSR]:=CSRHandlerFCSR; // FCSR

 fCSRHandlerMap[TCSR.TAddress.STIMECMP]:=CSRHandlerSTIMECMP; // STIMECMP

 fCSRHandlerMap[TCSR.TAddress.SATP]:=CSRHandlerSATP; // SATP

 fCSRHandlerMap[TCSR.TAddress.SSTATUS]:=CSRHandlerSTATUS; // SSTATUS
 fCSRHandlerMap[TCSR.TAddress.MSTATUS]:=CSRHandlerSTATUS; // MSTATUS
 fCSRHandlerMap[TCSR.TAddress.MISA]:=CSRHandlerDefaultReadOnly; // MISA
 fCSRHandlerMap[TCSR.TAddress.TDATA1]:=CSRHandlerDefaultReadOnly; // TDATA1
 fCSRHandlerMap[TCSR.TAddress.CYCLE]:=CSRHandlerEnforcedReadOnly; // CYCLE
//CSRHandlerMap[TCSR.TAddress.CYCLEH]:=CSRHandlerEnforcedReadOnly; // CYCLE
 fCSRHandlerMap[TCSR.TAddress.MVENDORID]:=CSRHandlerDefaultReadOnly; // MVENDORID
 fCSRHandlerMap[TCSR.TAddress.MARCHID]:=CSRHandlerDefaultReadOnly; // MARCHID
 fCSRHandlerMap[TCSR.TAddress.MIMPID]:=CSRHandlerDefaultReadOnly; // MIMPID
 fCSRHandlerMap[TCSR.TAddress.MHARTID]:=CSRHandlerDefaultReadOnly; // MHARTID

 fCSRHandlerMap[TCSR.TAddress.MIE]:=CSRHandlerMIE; // MIE
 fCSRHandlerMap[TCSR.TAddress.SIE]:=CSRHandlerSIE; // SIE

 fCSRHandlerMap[TCSR.TAddress.MIP]:=CSRHandlerMIP; // MIP
 fCSRHandlerMap[TCSR.TAddress.SIP]:=CSRHandlerSIP; // SIP

 if fMachine.fConfiguration.fAIA then begin

  fCSRHandlerMap[TCSR.TAddress.STOPEI]:=CSRHandlerSTOPEI; // MTOPEI
  fCSRHandlerMap[TCSR.TAddress.STOPI]:=CSRHandlerSTOPI; // MTOPI

  fCSRHandlerMap[TCSR.TAddress.MTOPEI]:=CSRHandlerMTOPEI; // MTOPEI
  fCSRHandlerMap[TCSR.TAddress.MTOPI]:=CSRHandlerMTOPI; // MTOPI

  fCSRHandlerMap[TCSR.TAddress.MISELECT]:=CSRHandlerPrivileged; // MISELECT
  fCSRHandlerMap[TCSR.TAddress.SISELECT]:=CSRHandlerPrivileged; // SISELECT

  fCSRHandlerMap[TCSR.TAddress.MIREG]:=CSRHandlerIndirect; // MIREG
  fCSRHandlerMap[TCSR.TAddress.SIREG]:=CSRHandlerIndirect; // SIREG

 end else begin

  fCSRHandlerMap[TCSR.TAddress.STOPEI]:=CSRHandlerIllegal; // STOPEI
  fCSRHandlerMap[TCSR.TAddress.STOPI]:=CSRHandlerIllegal; // STOPI

  fCSRHandlerMap[TCSR.TAddress.MTOPEI]:=CSRHandlerIllegal; // MTOPEI
  fCSRHandlerMap[TCSR.TAddress.MTOPI]:=CSRHandlerIllegal; // MTOPI

  fCSRHandlerMap[TCSR.TAddress.MISELECT]:=CSRHandlerIllegal; // MISELECT
  fCSRHandlerMap[TCSR.TAddress.SISELECT]:=CSRHandlerIllegal; // SISELECT

  fCSRHandlerMap[TCSR.TAddress.MIREG]:=CSRHandlerIllegal; // MIREG
  fCSRHandlerMap[TCSR.TAddress.SIREG]:=CSRHandlerIllegal; // SIREG

 end;

 fExecutionThread:=TExecutionThread.Create(self);

end;

destructor TPasRISCV.THART.Destroy;
var AIARegFileMode:TAIARegFileMode;
begin
 fExecutionThread.Shutdown;
 FreeAndNil(fExecutionThread);
 if fMachine.fConfiguration.fAIA then begin
  for AIARegFileMode:=Low(TAIARegFileMode) to High(TAIARegFileMode) do begin
   FreeAndNil(fAIARegFiles[AIARegFileMode]);
  end;
 end;
 inherited Destroy;
end;

procedure TPasRISCV.THART.Init;
var AIARegFileMode:TAIARegFileMode;
begin

 if fMachine.fConfiguration.fAIA then begin
  for AIARegFileMode:=Low(TAIARegFileMode) to High(TAIARegFileMode) do begin
   fAIARegFiles[AIARegFileMode].Reset;
  end;
 end;

 FillChar(fState,SizeOf(TState),#0);
 fState.CSR.Init(self);
 fState.Mode:=TPasRISCV.THART.TMode.Machine;
 fState.Registers[TRegister.Zero]:=0;
 fState.Registers[TRegister.SP]:=fMachine.fStartStackPointer-(fHARTID shl 16);
 fState.Registers[TRegister.A0]:=fHARTID;
 fState.Registers[TRegister.A1]:=fMachine.fFDTMemoryOffset;
 fState.PC:=$80000000; //-$1000;
 fState.PendingIRQs:=0;
 fState.ExceptionValue:=TExceptionValue.None;
 fState.ExceptionData:=0;
 fState.ExceptionPC:=0;
 fState.LSRC:=false;
 fState.LSRCAddress:=0;
 fState.LSRCCAS:=0;

 fMTIMECMP:=TPasRISCVUInt64($ffffffffffffffff);

 fSTIMECMP:=TPasRISCVUInt64($ffffffffffffffff);

 fMachine.fRandomGeneratorLock.Acquire;
 try
  fPCG32.Init((fMachine.fRandomGenerator.GetUInt64 xor TPasRISCVPtrUInt(self)) xor GetCurrentTime);
 finally
  fMachine.fRandomGeneratorLock.Release;
 end;

end;

procedure TPasRISCV.THART.SetMode(const aMode:TMode);
begin
 if fState.Mode<>aMode then begin
  fState.Mode:=aMode;
  FlushTLB(true);
 end;
end;

procedure TPasRISCV.THART.SetException(const aExceptionValue:TExceptionValue;
                                          const aExceptionData:TPasRISCVUInt64;
                                          const aExceptionPC:TPasRISCVUInt64);
begin
 if not (assigned(fMachine.fOnCPUException) and fMachine.fOnCPUException(self,aExceptionValue,aExceptionData,aExceptionPC)) then begin
  fState.ExceptionValue:=aExceptionValue;
  fState.ExceptionData:=aExceptionData;
  fState.ExceptionPC:=aExceptionPC;
  TPasMPInterlocked.BitwiseOr(fMachine.fRunState,fHARTMask);
 end;
end;

procedure TPasRISCV.THART.ClearException;
begin
 fState.ExceptionValue:=TExceptionValue.None;
 fState.ExceptionData:=0;
 fState.ExceptionPC:=0;
end;

procedure TPasRISCV.THART.UpdateMMU;
var SATP:TPasRISCVUInt64;
begin
 SATP:=fState.CSR.Load(THART.TCSR.TAddress.SATP);
 fMMUMode:=TMMU.TMMUMode(SATP shr 60);
 fRootPageTable:=(SATP and ((TPasRISCVUInt64(1) shl 44)-1)) shl 12;
 FlushTLB(true);
end;

procedure TPasRISCV.THART.RaisePhysicalFault(const aAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType);
begin
 case aAccessType of
  TMMU.TAccessType.LoadInstruction,
  TMMU.TAccessType.Load:begin
   SetException(TExceptionValue.LoadAccessFault,aAddress,fState.PC);
  end;
  TMMU.TAccessType.Store:begin
   SetException(TExceptionValue.StoreAccessFault,aAddress,fState.PC);
  end;
  TMMU.TAccessType.Instruction:begin
   SetException(TExceptionValue.InstructionAccessFault,aAddress,fState.PC);
  end;
 end;
end;

procedure TPasRISCV.THART.RaisePageFault(const aAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType);
begin
 case aAccessType of
  TMMU.TAccessType.LoadInstruction,
  TMMU.TAccessType.Load:begin
   SetException(TExceptionValue.LoadPageFault,aAddress,fState.PC);
  end;
  TMMU.TAccessType.Store:begin
   SetException(TExceptionValue.StorePageFault,aAddress,fState.PC);
  end;
  TMMU.TAccessType.Instruction:begin
   SetException(TExceptionValue.InstructionPageFault,aAddress,fState.PC);
  end;
 end;
 FlushTLB(true);
end;

procedure TPasRISCV.THART.FlushTLB(const aInterrupt:Boolean);
var DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin
 FillChar(fDirectAccessTLBCache,SizeOf(TMMU.TDirectAccessTLBEntries),#0);
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[0];
 DirectAccessTLBEntry^.Read:=TPasRISCVUInt64($ffffffffffffffff);
 DirectAccessTLBEntry^.Write:=TPasRISCVUInt64($ffffffffffffffff);
 DirectAccessTLBEntry^.Execute:=TPasRISCVUInt64($ffffffffffffffff);
 if aInterrupt then begin
  TPasMPInterlocked.BitwiseOr(fMachine.fRunState,fHARTMask);
 end;
end;

procedure TPasRISCV.THART.FlushTLBPage(const aInterrupt:Boolean;const aAddress:TPasRISCVUInt64);
var VPN:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin
 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
{$ifdef CombinedDirectAccessTLBCache}
 DirectAccessTLBEntry^.Read:=VPN-1;
 DirectAccessTLBEntry^.Write:=VPN-1;
 DirectAccessTLBEntry^.Execute:=VPN-1;
{$else}
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[(aAddress shr PAGE_SHIFT) and TMMU.DIRECT_ACCESS_TLB_MASK];
 if DirectAccessTLBEntry^.Read=VPN then begin
  DirectAccessTLBEntry^.Read:=VPN-1;
 end;
 if DirectAccessTLBEntry^.Write=VPN then begin
  DirectAccessTLBEntry^.Write:=VPN-1;
 end;
 if DEntry^.Execute=VPN then begin
  DirectAccessTLBEntry^.Execute:=VPN-1;
 end;
{$endif}
 if aInterrupt then begin
  TPasMPInterlocked.BitwiseOr(fMachine.fRunState,fHARTMask);
 end;
end;

procedure TPasRISCV.THART.TLBPut(const aVirtualAddress:TPasRISCVUInt64;const aTarget:TPasRISCVPtrUInt;const aAccessType:TMMU.TAccessType);
var VPN:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin
 VPN:=aVirtualAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
{$ifdef CombinedDirectAccessTLBCache}
 case aAccessType of
  TMMU.TAccessType.LoadInstruction,
  TMMU.TAccessType.Load:begin
   DirectAccessTLBEntry^.Read:=VPN;
   if DirectAccessTLBEntry^.Write<>VPN then begin
    DirectAccessTLBEntry^.Write:=VPN-1;
   end;
   if DirectAccessTLBEntry^.Execute<>VPN then begin
    DirectAccessTLBEntry^.Execute:=VPN-1;
   end;
  end;
  TMMU.TAccessType.Store:begin
   DirectAccessTLBEntry^.Read:=VPN;
   DirectAccessTLBEntry^.Write:=VPN;
   if DirectAccessTLBEntry^.Execute<>VPN then begin
    DirectAccessTLBEntry^.Execute:=VPN-1;
   end;
  end;
  TMMU.TAccessType.Instruction:begin
   if DirectAccessTLBEntry^.Read<>VPN then begin
    DirectAccessTLBEntry^.Read:=VPN-1;
   end;
   DirectAccessTLBEntry^.Write:=VPN-1;
   DirectAccessTLBEntry^.Execute:=VPN;
  end;
  else begin
   DirectAccessTLBEntry^.Read:=VPN-1;
   DirectAccessTLBEntry^.Write:=VPN-1;
   DirectAccessTLBEntry^.Execute:=VPN-1;
  end;
 end;
 DirectAccessTLBEntry^.RelativeMemory:=aTarget-TPasRISCVPtrUInt(aVirtualAddress and PAGE_ADDRESS_MASK);
{$else}
 case aAccessType of
  TMMU.TAccessType.LoadInstruction,
  TMMU.TAccessType.Load:begin
   DirectAccessTLBEntry^.Read:=VPN;
   DirectAccessTLBEntry^.RelativeMemoryRead:=aTarget-TPasRISCVPtrUInt(aVirtualAddress and PAGE_ADDRESS_MASK);
  end;
  TMMU.TAccessType.Store:begin
   DirectAccessTLBEntry^.Write:=VPN;
{  if DirectAccessTLBEntry^.Execute=VPN then begin
    DirectAccessTLBEntry^.Execute:=VPN-1;
   end;}
   DirectAccessTLBEntry^.RelativeMemoryWrite:=aTarget-TPasRISCVPtrUInt(aVirtualAddress and PAGE_ADDRESS_MASK);
  end;
  TMMU.TAccessType.Instruction:begin
{  if DirectAccessTLBEntry^.Write=VPN then begin
    DirectAccessTLBEntry^.Write:=VPN-1;
   end;}
   DirectAccessTLBEntry^.Execute:=VPN;
   DirectAccessTLBEntry^.RelativeMemoryExecute:=aTarget-TPasRISCVPtrUInt(aVirtualAddress and PAGE_ADDRESS_MASK);
  end;
  else begin
   DirectAccessTLBEntry^.Read:=VPN-1;
   DirectAccessTLBEntry^.Write:=VPN-1;
   DirectAccessTLBEntry^.Execute:=VPN-1;
  end;
 end;
{$endif}
end;

procedure TPasRISCV.THART.TLBPutBusDevice(const aVirtualAddress,aPhysicalAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType);
var Target:Pointer;
begin
 Target:=fBus.GetDirectMemoryAccessPointer(aPhysicalAddress and PAGE_ADDRESS_MASK,PAGE_SIZE,TMMU.AccessWrite[aAccessType],nil);
 if assigned(Target) then begin
  TLBPut(aVirtualAddress and PAGE_ADDRESS_MASK,TPasRISCVPtrUInt(Target),aAccessType);
 end;
end;

function TPasRISCV.THART.CheckPrivilege(const aCPUMode:THART.TMode;const aAccessType:TMMU.TAccessType):Boolean;
begin
 if aAccessType=TMMU.TAccessType.Instruction then begin
  // Disallow allow executing user pages in supervisor mode and vice versa, but not in the MXR case (TMMU.TAccessType.LoadInstruction)
  result:=false;
 end else if (aCPUMode<>THART.TMode.Supervisor) or ((fState.CSR.fData[TCSR.TAddress.MSTATUS] and TCSR.TMask.TStatus.SUM)=0) then begin
  // RW operations on user pages are allowed in supervisor mode when the SUM bit is set
  result:=false;
 end else begin
  result:=true;
 end;
end;

function TPasRISCV.THART.AddressTranslate(const aVirtualAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType;const aAccessFlags:TMMU.TAccessFlags):TPasRISCVUInt64;
var Index:TPasRISCVSizeInt;
    CPUMode:THART.TMode;
    MSTATUS,Levels:TPasRISCVUInt64;
    EffectiveAccessType:TMMU.TAccessType;
    PageTable,BitOffset,PageTableOffset,PageTableEntry,VirtualMask,PhysicalMask,
    PageTableEntryShift,PageTableEntryAccessDirty,PhysicalAddress,PPN,
    NAPOTBits,NAPOTMask:TPasRISCVUInt64;
    PageTableEntryPointer:Pointer;
    PBMTE,ADUE,NAPOT:boolean;
begin

 CPUMode:=fState.Mode;

 MSTATUS:=fState.CSR.fData[THART.TCSR.TAddress.MSTATUS];

 PBMTE:=IsCSRENVCFGEnabled(THART.TCSR.ENVCFG_PBMTE);

 ADUE:=IsCSRENVCFGEnabled(THART.TCSR.ENVCFG_ADUE);

 NAPOT:=true;

 EffectiveAccessType:=aAccessType;

 if (EffectiveAccessType<>TMMU.TAccessType.Instruction) and
    ((MSTATUS and (TPasRISCVUInt64(1) shl THART.TCSR.TMask.TMSTATUSBit.MPRV))<>0) then begin
  CPUMode:=TPasRISCV.THART.TMode(TPasRISCVUInt64((fState.CSR.fData[TCSR.TAddress.MSTATUS] shr 11) and 3));
 end;

 if (EffectiveAccessType=TMMU.TAccessType.Load) and
    ((MSTATUS and (TPasRISCVUInt64(1) shl THART.TCSR.TMask.TMSTATUSBit.MXR))<>0) then begin
  EffectiveAccessType:=TMMU.TAccessType.LoadInstruction;
 end;

 case CPUMode of

  THART.TMode.User,
  THART.TMode.Supervisor,
  THART.TMode.Hypervisor:begin

   case fMMUMode of
    TMMU.TMMUMode.SV39:begin
     Levels:=3;
    end;
    TMMU.TMMUMode.SV48:begin
     Levels:=4;
    end;
    TMMU.TMMUMode.SV57:begin
     Levels:=5;
    end;
    else {TMMU.TMMUMode.None:}begin
     if not (TMMU.TAccessFlag.NoTLBUpdate in aAccessFlags) then begin
      TLBPutBusDevice(aVirtualAddress and PAGE_ADDRESS_MASK,aVirtualAddress and PAGE_ADDRESS_MASK,aAccessType);
     end;
     result:=aVirtualAddress;
     exit;
    end;
   end;

   PageTable:=fRootPageTable;
   BitOffset:=(Levels*TMMU.VPN_BITS)+(TMMU.PAGE_SHIFT-TMMU.VPN_BITS);

   // Check for canonical virtual address
   if aVirtualAddress<>TPasRISCVUInt64(SignExtend(aVirtualAddress,BitOffset+TMMU.VPN_BITS)) then begin
    if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
     RaisePageFault(aVirtualAddress,aAccessType);
    end;
    result:=0;
    exit;
   end;

   for Index:=0 to Levels-1 do begin

    PageTableOffset:=((aVirtualAddress shr BitOffset) and TMMU.VPN_MASK) shl 3;

    PageTableEntryPointer:=fBus.GetDirectMemoryAccessPointer(PageTable+PageTableOffset,SizeOf(TPasRISCVUInt64),true,nil);
    if not assigned(PageTableEntryPointer) then begin
     // Physical fault
     if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
      RaisePageFault(aVirtualAddress,aAccessType);
     end;
     result:=0;
     exit;
    end;

    repeat

     PageTableEntry:=PPasRISCVUInt64(PageTableEntryPointer)^;

     if (PageTableEntry and TMMU.TPTEMasks.Reserved)<>0 then begin
      // Reserved
      if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
       RaisePageFault(aVirtualAddress,aAccessType);
      end;
      result:=0;
      exit;
     end;

     if (not PBMTE) and ((PageTableEntry and TMMU.TPTEMasks.PBMT)<>0) then begin
      // Reserved without Svpbmt
      if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
       RaisePageFault(aVirtualAddress,aAccessType);
      end;
      result:=0;
      exit;
     end;

     if (not NAPOT) and ((PageTableEntry and TMMU.TPTEMasks.N)<>0) then begin
      // Reserved without Svnapot
      if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
       RaisePageFault(aVirtualAddress,aAccessType);
      end;
      result:=0;
      exit;
     end;

     if (PageTableEntry and TMMU.TPTEMasks.Valid)<>0 then begin

      if (PageTableEntry and TMMU.TPTEMasks.Leaf)<>0 then begin

       if ((PageTableEntry and TMMU.TPTEMasks.User)<>0)=(CPUMode<>THART.TMode.User) then begin
        if not (TMMU.TAccessFlag.IgnoreMMUProtection in aAccessFlags) then begin
         if not CheckPrivilege(CPUMode,EffectiveAccessType) then begin
          if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
           RaisePageFault(aVirtualAddress,aAccessType);
          end;
          result:=0;
          exit;
         end;
        end;
       end;

       if (PageTableEntry and TMMU.AccessMasks[EffectiveAccessType])<>0 then begin

        VirtualMask:=(TPasRISCVUInt64(1) shl BitOffset)-1;
        PhysicalMask:=((TPasRISCVUInt64(1) shl (TMMU.PHYSICAL_BITS-BitOffset))-1) shl BitOffset;
        PageTableEntryShift:=PageTableEntry shl 2;

        if ADUE then begin
         PageTableEntryAccessDirty:=PageTableEntry or TMMU.TPTEMasks.Accessed;
         if EffectiveAccessType=TMMU.TAccessType.Store then begin
          PageTableEntryAccessDirty:=PageTableEntryAccessDirty or TMMU.TPTEMasks.Dirty;
         end;
        end else begin
         if ((PageTableEntry and TMMU.TPTEMasks.Accessed)=0) or
            ((EffectiveAccessType=TMMU.TAccessType.Store) and ((PageTableEntry and TMMU.TPTEMasks.Dirty)=0)) then begin
          if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
           RaisePageFault(aVirtualAddress,aAccessType);
          end;
          result:=0;
          exit;
         end else begin
          PageTableEntryAccessDirty:=PageTableEntry;
         end;
        end;

        if ((PageTableEntryShift and VirtualMask) and TMMU.PAGE_PNMASK)<>0 then begin
         // Misaligned
         if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
          RaisePageFault(aVirtualAddress,aAccessType);
         end;
         result:=0;
         exit;
        end;

        if PageTableEntry<>PageTableEntryAccessDirty then begin
         if (not ADUE) and (not (TMMU.TAccessFlag.IgnoreMMUProtection in aAccessFlags)) then begin
          if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
           RaisePageFault(aVirtualAddress,aAccessType);
          end;
          result:=0;
          exit;
         end;

         if TPasMPInterlocked.CompareExchange(TPasMPUInt64(PageTableEntryPointer^),PageTableEntryAccessDirty,PageTableEntry)<>PageTableEntry then begin
          continue;
         end;
        end;

        if NAPOT and ((PageTableEntry and TMMU.TPTEMasks.N)<>0) then begin

         PPN:=(PageTableEntry and TMMU.TPTEMasks.PPN_MASK) shr TMMU.PPN_BITS;

         NAPOTBits:=CTZQWord(PPN)+1;
         if (Index<>(Levels-1)) or (NAPOTBits<>4) then begin
          if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
           RaisePageFault(aVirtualAddress,aAccessType);
          end;
          result:=0;
          exit;
         end;

         NAPOTMask:=(TPasRISCVUInt64(1) shl NAPOTBits)-1;

         PhysicalAddress:=(((PPN and not NAPOTMask) or
                            ((aVirtualAddress shr TMMU.PAGE_SHIFT) and (NAPOTMask or ((TPasRISCVUInt64(1) shl (BitOffset-(TMMU.PAGE_VPN_DIFF+TMMU.VPN_BITS)))-1)))) shl TMMU.PAGE_SHIFT) or
                           (aVirtualAddress and PAGE_MASK);

        end else begin

         PhysicalAddress:=(PageTableEntryShift and PhysicalMask) or (aVirtualAddress and VirtualMask);

        end;

        if not (TMMU.TAccessFlag.NoTLBUpdate in aAccessFlags) then begin
         TLBPutBusDevice(aVirtualAddress and PAGE_ADDRESS_MASK,PhysicalAddress and PAGE_ADDRESS_MASK,aAccessType);
        end;
        result:=PhysicalAddress;
        exit;

       end;

      end else if (PageTableEntry and TMMU.TPTEMasks.Write_)=0 then begin
       PageTable:=((PageTableEntry shr 10) shl TMMU.PAGE_SHIFT) and TMMU.PHYSICAL_MASK;
       dec(BitOffset,TMMU.VPN_BITS);
      end;

     end;

     break;

    until false;

   end;

   if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
    RaisePageFault(aVirtualAddress,aAccessType);
   end;
   result:=0;
   exit;

  end;

  else {THART.TMode.Machine:}begin

   if not (TMMU.TAccessFlag.NoTLBUpdate in aAccessFlags) then begin
    TLBPutBusDevice(aVirtualAddress and PAGE_ADDRESS_MASK,aVirtualAddress and PAGE_ADDRESS_MASK,aAccessType);
   end;
   result:=aVirtualAddress;

  end;

 end;

end;

function TPasRISCV.THART.Load8(const aAddress:TPasRISCVUInt64):TPasRISCVUInt8;
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if DirectAccessTLBEntry^.Read=VPN then begin
  result:=PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
  exit;
 end;

 TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
 if fState.ExceptionValue<>TExceptionValue.None then begin
  result:=0;
{$ifdef PreferDirectMemoryAccess}
 end else if DirectAccessTLBEntry^.Read=VPN then begin
  result:=PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$endif}
 end else begin
  result:=TPasRISCVUInt8(fBus.Load(self,TranslatedAddress,1));
 end;

end;

procedure TPasRISCV.THART.LoadRegisterS8(const aRegister:TRegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if DirectAccessTLBEntry^.Read=VPN then begin
  Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^)));
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
   fState.Registers[aRegister]:=Value;
  end;
  exit;
 end;

 TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
 if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
  if DirectAccessTLBEntry^.Read=VPN then begin
   Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^)));
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
    fState.Registers[aRegister]:=Value;
   end;
  end else{$endif}begin
   Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(TPasRISCVUInt8(fBus.Load(self,TranslatedAddress,1)))));
   if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
    fState.Registers[aRegister]:=Value;
   end;
  end;
 end;

end;

procedure TPasRISCV.THART.LoadRegisterU8(const aRegister:TRegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if DirectAccessTLBEntry^.Read=VPN then begin
  Value:=PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
   fState.Registers[aRegister]:=Value;
  end;
  exit;
 end;

 TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
 if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
  if DirectAccessTLBEntry^.Read=VPN then begin
   Value:=PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
    fState.Registers[aRegister]:=Value;
   end;
  end else{$endif}begin
   Value:=TPasRISCVUInt8(fBus.Load(self,TranslatedAddress,1));
   if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
    fState.Registers[aRegister]:=Value;
   end;
  end;
 end;

end;

procedure TPasRISCV.THART.Store8(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt8);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if DirectAccessTLBEntry^.Write=VPN then begin
  PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=aValue;
  exit;
 end;

 TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
 if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
  if DirectAccessTLBEntry^.Write=VPN then begin
   PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=aValue;
  end else{$endif}begin
   fBus.Store(self,TranslatedAddress,aValue,1);
  end;
 end;

end;

procedure TPasRISCV.THART.StoreRegisterU8(const aAddress:TPasRISCVUInt64;const aRegister:TRegister);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt8;
begin

 Value:=fState.Registers[aRegister];

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if DirectAccessTLBEntry^.Write=VPN then begin
  PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
  exit;
 end;

 TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
 if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
  if DirectAccessTLBEntry^.Write=VPN then begin
   PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
  end else{$endif}begin
   fBus.Store(self,TranslatedAddress,Value,1);
  end;
 end;

end;

function TPasRISCV.THART.Load16(const aAddress:TPasRISCVUInt64):TPasRISCVUInt16;
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+1)<PAGE_SIZE) then begin
  result:=PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+1)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue<>TExceptionValue.None then begin
   result:=0;
{$ifdef PreferDirectMemoryAccess}
  end else if DirectAccessTLBEntry^.Read=VPN then begin
   result:=PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$endif}
  end else begin
   result:=TPasRISCVUInt16(fBus.Load(self,TranslatedAddress,2));
  end;
 end else begin
  result:=TPasRISCVUInt8(Load(aAddress,1));
  if fState.ExceptionValue=TExceptionValue.None then begin
   result:=result or (TPasRISCVUInt16(TPasRISCVUInt8(Load(aAddress+1,1))) shl 8);
  end;
 end;

end;

procedure TPasRISCV.THART.LoadRegisterS16(const aRegister:TRegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+1)<PAGE_SIZE) then begin
  Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^)));
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
   fState.Registers[aRegister]:=Value;
  end;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+1)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Read=VPN then begin
    Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^)));
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
    fState.Registers[aRegister]:=Value;
    end;
   end else {$endif}begin
    Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(TPasRISCVUInt16(fBus.Load(self,TranslatedAddress,2)))));
    if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
     fState.Registers[aRegister]:=Value;
    end;
   end;
  end;
 end else begin
  Value:=TPasRISCVUInt8(Load(aAddress,1));
  if fState.ExceptionValue=TExceptionValue.None then begin
   Value:=Value or (TPasRISCVUInt16(TPasRISCVUInt8(Load(aAddress+1,1))) shl 8);
   if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
    fState.Registers[aRegister]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(TPasRISCVUInt16(Value))));
   end;
  end;
 end;

end;

procedure TPasRISCV.THART.LoadRegisterU16(const aRegister:TRegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+1)<PAGE_SIZE) then begin
  Value:=PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
   fState.Registers[aRegister]:=Value;
  end;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+1)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Read=VPN then begin
    Value:=PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
     fState.Registers[aRegister]:=Value;
    end;
   end else{$endif}begin
    Value:=TPasRISCVUInt16(fBus.Load(self,TranslatedAddress,2));
    if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
     fState.Registers[aRegister]:=Value;
    end;
   end;
  end;
 end else begin
  Value:=TPasRISCVUInt8(Load(aAddress,1));
  if fState.ExceptionValue=TExceptionValue.None then begin
   Value:=Value or (TPasRISCVUInt16(TPasRISCVUInt8(Load(aAddress+1,1))) shl 8);
   if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
    fState.Registers[aRegister]:=Value;
   end;
  end;
 end;

end;

procedure TPasRISCV.THART.Store16(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt16);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+1)<PAGE_SIZE) then begin
  PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=aValue;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+1)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Write=VPN then begin
    PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=aValue;
   end else{$endif}begin
    fBus.Store(self,TranslatedAddress,aValue,2);
   end;
  end;
 end else begin
  Store(aAddress,(aValue shr 0) and $ff,1);
  if fState.ExceptionValue=TExceptionValue.None then begin
   Store(aAddress+1,(aValue shr 8) and $ff,1);
  end;
 end;

end;

procedure TPasRISCV.THART.StoreRegisterU16(const aAddress:TPasRISCVUInt64;const aRegister:TRegister);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt16;
begin

 Value:=fState.Registers[aRegister];

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+1)<PAGE_SIZE) then begin
  PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+1)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Write=VPN then begin
    PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
   end else{$endif}begin
    fBus.Store(self,TranslatedAddress,Value,2);
   end;
  end;
 end else begin
  Store(aAddress,(Value shr 0) and $ff,1);
  if fState.ExceptionValue=TExceptionValue.None then begin
   Store(aAddress+1,(Value shr 8) and $ff,1);
  end;
 end;

end;

function TPasRISCV.THART.Load32(const aAddress:TPasRISCVUInt64):TPasRISCVUInt32;
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
  result:=PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+3)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue<>TExceptionValue.None then begin
   result:=0;
{$ifdef PreferDirectMemoryAccess}
  end else if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
   result:=PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$endif}
  end else begin
   result:=TPasRISCVUInt32(fBus.Load(self,TranslatedAddress,4));
  end;
 end else begin
  result:=Load(aAddress,4);
 end;

end;

procedure TPasRISCV.THART.LoadRegisterS32(const aRegister:TRegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
  Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^)));
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
   fState.Registers[aRegister]:=Value;
  end;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+3)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Read=VPN then begin
    Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^)));
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
     fState.Registers[aRegister]:=Value;
    end;
   end else{$endif}begin
    Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(fBus.Load(self,TranslatedAddress,4)))));
    if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
     fState.Registers[aRegister]:=Value;
    end;
   end;
  end;
 end else begin
  Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Load(aAddress,4))));
  if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
   fState.Registers[aRegister]:=Value;
  end;
 end;

end;

procedure TPasRISCV.THART.LoadRegisterU32(const aRegister:TRegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
  Value:=PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
   fState.Registers[aRegister]:=Value;
  end;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+3)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Read=VPN then begin
    Value:=PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
     fState.Registers[aRegister]:=Value;
    end;
   end else{$endif}begin
    Value:=TPasRISCVUInt32(fBus.Load(self,TranslatedAddress,4));
    if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
     fState.Registers[aRegister]:=Value;
    end;
   end;
  end;
 end else begin
  Value:=TPasRISCVUInt32(Load(aAddress,4));
  if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
   fState.Registers[aRegister]:=Value;
  end;
 end;

end;

procedure TPasRISCV.THART.LoadRegisterF32(const aRegister:TFPURegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
  Value:=PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
  fState.FPURegisters[aRegister].ui64:=TPasRISCVUInt64(TPasRISCVUInt32(Value)) or TPasRISCVUInt64($ffffffff00000000);
  fState.CSR.SetFSDirty;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+3)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Read=VPN then begin
    Value:=PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
    fState.FPURegisters[aRegister].ui64:=TPasRISCVUInt64(TPasRISCVUInt32(Value)) or TPasRISCVUInt64($ffffffff00000000);
    fState.CSR.SetFSDirty;
   end else{$endif}begin
    Value:=TPasRISCVUInt32(fBus.Load(self,TranslatedAddress,4));
    if fState.ExceptionValue=TExceptionValue.None then begin
     fState.FPURegisters[aRegister].ui64:=TPasRISCVUInt64(TPasRISCVUInt32(Value)) or TPasRISCVUInt64($ffffffff00000000);
     fState.CSR.SetFSDirty;
    end;
   end;
  end;
 end else begin
  Value:=TPasRISCVUInt32(Load(aAddress,4));
  if fState.ExceptionValue=TExceptionValue.None then begin
   fState.FPURegisters[aRegister].ui64:=TPasRISCVUInt64(TPasRISCVUInt32(Value)) or TPasRISCVUInt64($ffffffff00000000);
   fState.CSR.SetFSDirty;
  end;
 end;

end;

procedure TPasRISCV.THART.Store32(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt32);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
  PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=aValue;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+3)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
    PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=aValue;
   end else{$endif} begin
    fBus.Store(self,TranslatedAddress,aValue,4);
   end;
  end;
 end else begin
  Store(aAddress,aValue,4);
 end;

end;

procedure TPasRISCV.THART.StoreRegisterU32(const aAddress:TPasRISCVUInt64;const aRegister:TRegister);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt32;
begin

 Value:=fState.Registers[aRegister];

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
  PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+3)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
    PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
   end else{$endif} begin
    fBus.Store(self,TranslatedAddress,Value,4);
   end;
  end;
 end else begin
  Store(aAddress,Value,4);
 end;

end;

procedure TPasRISCV.THART.StoreRegisterF32(const aAddress:TPasRISCVUInt64;const aRegister:TFPURegister);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt32;
begin

 Value:=fState.FPURegisters[aRegister].ui32;

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
  PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+3)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
    PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
   end else{$endif} begin
    fBus.Store(self,TranslatedAddress,Value,4);
   end;
  end;
 end else begin
  Store(aAddress,Value,4);
 end;

end;

function TPasRISCV.THART.Load64(const aAddress:TPasRISCVUInt64):TPasRISCVUInt64;
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+7)<PAGE_SIZE) then begin
  result:=PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+7)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue<>TExceptionValue.None then begin
   result:=0;
{$ifdef PreferDirectMemoryAccess}
  end else if DirectAccessTLBEntry^.Read=VPN then begin
   result:=PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$endif}
  end else begin
   result:=fBus.Load(self,TranslatedAddress,8);
  end;
 end else begin
  result:=Load(aAddress,8);
 end;

end;

procedure TPasRISCV.THART.LoadRegisterS64(const aRegister:TRegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+7)<PAGE_SIZE) then begin
  Value:=TPasRISCVUInt64(TPasRISCVInt64(PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^));
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
   fState.Registers[aRegister]:=Value;
  end;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+7)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Read=VPN then begin
    Value:=TPasRISCVUInt64(TPasRISCVInt64(PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^)));
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
     fState.Registers[aRegister]:=Value;
    end;
   end else{$endif}begin
    Value:=TPasRISCVUInt64(TPasRISCVInt64(fBus.Load(self,TranslatedAddress,8)));
    if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
     fState.Registers[aRegister]:=Value;
    end;
   end;
  end;
 end else begin
  Value:=TPasRISCVUInt64(TPasRISCVInt64(Load(aAddress,8)));
  if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
   fState.Registers[aRegister]:=Value;
  end;
 end;

end;

procedure TPasRISCV.THART.LoadRegisterU64(const aRegister:TRegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+7)<PAGE_SIZE) then begin
  Value:=PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
   fState.Registers[aRegister]:=Value;
  end;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+7)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Read=VPN then begin
    Value:=PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
     fState.Registers[aRegister]:=Value;
    end;
   end else{$endif}begin
    Value:=TPasRISCVUInt64(fBus.Load(self,TranslatedAddress,8));
    if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
     fState.Registers[aRegister]:=Value;
    end;
   end;
  end;
 end else begin
  Value:=Load(aAddress,8);
  if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
   fState.Registers[aRegister]:=Value;
  end;
 end;

end;

procedure TPasRISCV.THART.LoadRegisterF64(const aRegister:TFPURegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+7)<PAGE_SIZE) then begin
  Value:=PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
  fState.FPURegisters[aRegister].ui64:=Value;
  fState.CSR.SetFSDirty;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+7)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Read=VPN then begin
    Value:=PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
    fState.FPURegisters[aRegister].ui64:=Value;
    fState.CSR.SetFSDirty;
   end else{$endif}begin
    Value:=TPasRISCVUInt64(fBus.Load(self,TranslatedAddress,8));
    if fState.ExceptionValue=TExceptionValue.None then begin
     fState.FPURegisters[aRegister].ui64:=Value;
     fState.CSR.SetFSDirty;
    end;
   end;
  end;
 end else begin
  Value:=Load(aAddress,8);
  if fState.ExceptionValue=TExceptionValue.None then begin
   fState.FPURegisters[aRegister].ui64:=Value;
   fState.CSR.SetFSDirty;
  end;
 end;

end;

procedure TPasRISCV.THART.Store64(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+7)<PAGE_SIZE) then begin
  PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=aValue;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+7)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Write=VPN then begin
    PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=aValue;
   end else{$endif}begin
    fBus.Store(self,TranslatedAddress,aValue,8);
   end;
  end;
 end else begin
  Store(aAddress,aValue,8);
 end;

end;

procedure TPasRISCV.THART.StoreRegisterU64(const aAddress:TPasRISCVUInt64;const aRegister:TRegister);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 Value:=fState.Registers[aRegister];

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+7)<PAGE_SIZE) then begin
  PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+7)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Write=VPN then begin
    PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
   end else{$endif}begin
    fBus.Store(self,TranslatedAddress,Value,8);
   end;
  end;
 end else begin
  Store(aAddress,Value,8);
 end;

end;

procedure TPasRISCV.THART.StoreRegisterF64(const aAddress:TPasRISCVUInt64;const aRegister:TFPURegister);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 Value:=fState.FPURegisters[aRegister].ui64;

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+7)<PAGE_SIZE) then begin
  PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+7)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Write=VPN then begin
    PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
   end else{$endif}begin
    fBus.Store(self,TranslatedAddress,Value,8);
   end;
  end;
 end else begin
  Store(aAddress,Value,8);
 end;

end;

function TPasRISCV.THART.RMWTranslate(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aBounce:Pointer;const aReadOnly:Boolean):Pointer;
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if aReadOnly then begin
  if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE) then begin
   result:=Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress));
   exit;
  end;
 end else begin
  if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE) then begin
   result:=Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress));
   exit;
  end;
 end;

 if ((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE then begin
  if aReadOnly then begin
   TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[TMMU.TAccessFlag.TranslateIntoPhysicalAddress,TMMU.TAccessFlag.ReadModifyWrite]);
  end else begin
   TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[TMMU.TAccessFlag.TranslateIntoPhysicalAddress,TMMU.TAccessFlag.ReadModifyWrite]);
  end;
  if fState.ExceptionValue<>TExceptionValue.None then begin
   result:=nil;
  end else begin
   result:=fBus.GetDirectMemoryAccessPointer(TranslatedAddress,aSize,true,aBounce);
   if result=@aBounce then begin
    case aSize of
     4:begin
      PPasRISCVUInt32(aBounce)^:=fBus.Load(self,aAddress,aSize);
     end;
     8:begin
      PPasRISCVUInt64(aBounce)^:=fBus.Load(self,aAddress,aSize);
     end;
     16:begin
      PPasMPInt128Record(aBounce)^.Lo:=fBus.Load(self,aAddress,8);
      PPasMPInt128Record(aBounce)^.Hi:=fBus.Load(self,aAddress+8,8);
     end;
     else begin
      SetException(TExceptionValue.StoreAddressMisaligned,aAddress,fState.PC);
     end;
    end;
   end;
  end;
 end else begin
  SetException(TExceptionValue.StoreAddressMisaligned,aAddress,fState.PC);
  result:=nil;
 end;

end;

procedure TPasRISCV.THART.RMWStore(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aBounce:Pointer);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE) then begin
  if assigned(aBounce) then begin
   case aSize of
    4:begin
     PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=PPasRISCVUInt32(aBounce)^;
    end;
    8:begin
     PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=PPasRISCVUInt64(aBounce)^;
    end;
    16:begin
     PPasMPInt128Record(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=PPasMPInt128Record(aBounce)^;
    end;
    else begin
     SetException(TExceptionValue.StoreAddressMisaligned,aAddress,fState.PC);
    end;
   end;
  end;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[TMMU.TAccessFlag.NoTrap,TMMU.TAccessFlag.ReadModifyWrite]);
  if (fState.ExceptionValue=TExceptionValue.None) and assigned(aBounce) then begin
   case aSize of
    1,2,4,8:begin
     fBus.Store(self,TranslatedAddress,PPasRISCVUInt32(aBounce)^,aSize);
    end;
    16:begin
     fBus.Store(self,TranslatedAddress,PPasMPInt128Record(aBounce)^.Lo,8);
     fBus.Store(self,TranslatedAddress+8,PPasMPInt128Record(aBounce)^.Hi,8);
    end;
    else begin
     SetException(TExceptionValue.StoreAddressMisaligned,aAddress,fState.PC);
    end;
   end;
  end;
 end else begin
  SetException(TExceptionValue.StoreAddressMisaligned,aAddress,fState.PC);
 end;

end;

function TPasRISCV.THART.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var TranslatedAddress,PartSize:TPasRISCVUInt64;
begin
 if ((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue<>TExceptionValue.None then begin
   result:=0;
  end else begin
   case aSize of
    3:begin
     result:=TPasRISCVUInt64(fBus.Load(self,TranslatedAddress,2));
     if fState.ExceptionValue=TExceptionValue.None then begin
      result:=result or (TPasRISCVUInt64(TPasRISCVUInt8(fBus.Load(self,TranslatedAddress+2,1))) shl 16);
     end;
    end;
    5:begin
     result:=TPasRISCVUInt32(fBus.Load(self,TranslatedAddress,4));
     if fState.ExceptionValue=TExceptionValue.None then begin
      result:=result or (TPasRISCVUInt64(TPasRISCVUInt8(fBus.Load(self,TranslatedAddress+4,1))) shl 32);
     end;
    end;
    6:begin
     result:=TPasRISCVUInt32(fBus.Load(self,TranslatedAddress,4));
     if fState.ExceptionValue=TExceptionValue.None then begin
      result:=result or (TPasRISCVUInt64(TPasRISCVUInt16(fBus.Load(self,TranslatedAddress+4,2))) shl 32);
     end;
    end;
    7:begin
     result:=TPasRISCVUInt32(fBus.Load(self,TranslatedAddress,4));
     if fState.ExceptionValue=TExceptionValue.None then begin
      result:=result or (TPasRISCVUInt64(TPasRISCVUInt16(fBus.Load(self,TranslatedAddress+4,2))) shl 32);
      if fState.ExceptionValue=TExceptionValue.None then begin
       result:=result or (TPasRISCVUInt64(TPasRISCVUInt8(fBus.Load(self,TranslatedAddress+6,1))) shl 48);
      end;
     end;
    end;
    else begin
     result:=fBus.Load(self,TranslatedAddress,aSize);
    end;
   end;
  end;
 end else begin
  PartSize:=PAGE_SIZE-(aAddress and PAGE_MASK);
  result:=Load(aAddress,PartSize) and ((TPasRISCVUInt64(1) shl (PartSize shl 3))-1);
  if fState.ExceptionValue=TExceptionValue.None then begin
   result:=result or ((Load(aAddress+PartSize,aSize-PartSize) and ((TPasRISCVUInt64(1) shl ((aSize-PartSize) shl 3))-1)) shl (PartSize shl 3));
  end;
 end;
end;

procedure TPasRISCV.THART.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var TranslatedAddress,PartSize:TPasRISCVUInt64;
begin
 if ((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
   case aSize of
    3:begin
     fBus.Store(self,TranslatedAddress,(aValue shr 0) and TPasRISCVUInt64($ffff),2);
     if fState.ExceptionValue=TExceptionValue.None then begin
      fBus.Store(self,TranslatedAddress+2,(aValue shr 16) and TPasRISCVUInt64($ff),1);
     end;
    end;
    5:begin
     fBus.Store(self,TranslatedAddress,(aValue shr 0) and TPasRISCVUInt64($ffffffff),4);
     if fState.ExceptionValue=TExceptionValue.None then begin
      fBus.Store(self,TranslatedAddress+4,(aValue shr 32) and TPasRISCVUInt64($ff),1);
     end;
    end;
    6:begin
     fBus.Store(self,TranslatedAddress,(aValue shr 0) and TPasRISCVUInt64($ffffffff),4);
     if fState.ExceptionValue=TExceptionValue.None then begin
      fBus.Store(self,TranslatedAddress+4,(aValue shr 32) and TPasRISCVUInt64($ffff),2);
     end;
    end;
    7:begin
     fBus.Store(self,TranslatedAddress,(aValue shr 0) and TPasRISCVUInt64($ffffffff),4);
     if fState.ExceptionValue=TExceptionValue.None then begin
      fBus.Store(self,TranslatedAddress+4,(aValue shr 32) and TPasRISCVUInt64($ffff),2);
      if fState.ExceptionValue=TExceptionValue.None then begin
       fBus.Store(self,TranslatedAddress+6,(aValue shr 48) and TPasRISCVUInt64($ff),1);
      end;
     end;
    end;
    else begin
     fBus.Store(self,TranslatedAddress,aValue,aSize);
    end;
   end;
  end;
 end else begin
  PartSize:=PAGE_SIZE-(aAddress and PAGE_MASK);
  Store(aAddress,aValue and ((TPasRISCVUInt64(1) shl (PartSize shl 3))-1),PartSize);
  if fState.ExceptionValue=TExceptionValue.None then begin
   Store(aAddress,(aValue shr PartSize) and ((TPasRISCVUInt64(1) shl ((aSize-PartSize) shl 3))-1),aSize-PartSize);
  end;
 end;
end;

function TPasRISCV.THART.LoadEx(const aAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
var TranslatedAddress,PartSize,PartValue:TPasRISCVUInt64;
begin
 result:=false;
 if ((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.DebuggerLoad,[TMMU.TAccessFlag.IgnoreMMUProtection,TMMU.TAccessFlag.NoTrap]);
  if TranslatedAddress<>0 then begin
   case aSize of
    3:begin
     if not fBus.LoadEx(TranslatedAddress,PartValue,2) then begin
      aValue:=0;
      exit;
     end;
     aValue:=PartValue and TPasRISCVUInt64($ffff);
     if not fBus.LoadEx(TranslatedAddress+2,PartValue,1) then begin
      aValue:=0;
      exit;
     end;
     aValue:=aValue or ((PartValue and TPasRISCVUInt64($ff)) shl 16);
    end;
    5:begin
     if not fBus.LoadEx(TranslatedAddress,PartValue,4) then begin
      aValue:=0;
      exit;
     end;
     aValue:=PartValue and TPasRISCVUInt64($ffffffff);
     if not fBus.LoadEx(TranslatedAddress+4,PartValue,1) then begin
      aValue:=0;
      exit;
     end;
     aValue:=aValue or ((PartValue and TPasRISCVUInt64($ff)) shl 32);
    end;
    6:begin
     if not fBus.LoadEx(TranslatedAddress,PartValue,4) then begin
      aValue:=0;
      exit;
     end;
     aValue:=PartValue and TPasRISCVUInt64($ffffffff);
     if not fBus.LoadEx(TranslatedAddress+4,PartValue,2) then begin
      aValue:=0;
      exit;
     end;
     aValue:=aValue or ((PartValue and TPasRISCVUInt64($ffff)) shl 32);
    end;
    7:begin
     if not fBus.LoadEx(TranslatedAddress,PartValue,4) then begin
      aValue:=0;
      exit;
     end;
     aValue:=PartValue and TPasRISCVUInt64($ffffffff);
     if not fBus.LoadEx(TranslatedAddress+4,PartValue,2) then begin
      aValue:=0;
      exit;
     end;
     aValue:=aValue or ((PartValue and TPasRISCVUInt64($ffff)) shl 32);
     if not fBus.LoadEx(TranslatedAddress+6,PartValue,1) then begin
      aValue:=0;
      exit;
     end;
     aValue:=aValue or ((PartValue and TPasRISCVUInt64($ff)) shl 48);
    end;
    else begin
     if fBus.LoadEx(TranslatedAddress,PartValue,aSize) then begin
      aValue:=PartValue;
     end else begin
      aValue:=0;
      exit;
     end;
    end;
   end;
   result:=true;
  end;
 end else begin
  PartSize:=PAGE_SIZE-(aAddress and PAGE_MASK);
  if LoadEx(aAddress,PartValue,PartSize) then begin
   aValue:=PartValue and ((TPasRISCVUInt64(1) shl (PartSize shl 3))-1);
   if LoadEx(aAddress+PartSize,PartValue,aSize-PartSize) then begin
    aValue:=aValue or ((PartValue and ((TPasRISCVUInt64(1) shl ((aSize-PartSize) shl 3))-1)) shl (PartSize shl 3));
    result:=true;
   end;
  end;
 end;
end;

function TPasRISCV.THART.StoreEx(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
var TranslatedAddress,PartSize:TPasRISCVUInt64;
begin
 result:=false;
 if ((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.DebuggerStore,[TMMU.TAccessFlag.IgnoreMMUProtection,TMMU.TAccessFlag.NoTrap]);
  if TranslatedAddress<>0 then begin
   case aSize of
    3:begin
     if not fBus.StoreEx(TranslatedAddress,(aValue shr 0) and TPasRISCVUInt64($ffff),2) then begin
      exit;
     end;
     if not fBus.StoreEx(TranslatedAddress+2,(aValue shr 16) and TPasRISCVUInt64($ff),1) then begin
      exit;
     end;
    end;
    5:begin
     if not fBus.StoreEx(TranslatedAddress,(aValue shr 0) and TPasRISCVUInt64($ffffffff),4) then begin
      exit;
     end;
     if not fBus.StoreEx(TranslatedAddress+4,(aValue shr 32) and TPasRISCVUInt64($ff),1) then begin
      exit;
     end;
    end;
    6:begin
     if not fBus.StoreEx(TranslatedAddress,(aValue shr 0) and TPasRISCVUInt64($ffffffff),4) then begin
      exit;
     end;
     if not fBus.StoreEx(TranslatedAddress+4,(aValue shr 32) and TPasRISCVUInt64($ffff),2) then begin
      exit;
     end;
    end;
    7:begin
     if not fBus.StoreEx(TranslatedAddress,(aValue shr 0) and TPasRISCVUInt64($ffffffff),4) then begin
      exit;
     end;
     if not fBus.StoreEx(TranslatedAddress+4,(aValue shr 32) and TPasRISCVUInt64($ffff),2) then begin
      exit;
     end;
     if not fBus.StoreEx(TranslatedAddress+6,(aValue shr 48) and TPasRISCVUInt64($ff),1) then begin
      exit;
     end;
    end;
    else begin
     if not fBus.StoreEx(TranslatedAddress,aValue,aSize) then begin
      exit;
     end;
    end;
   end;
   result:=true;
  end;
 end else begin
  PartSize:=PAGE_SIZE-(aAddress and PAGE_MASK);
  if StoreEx(aAddress,aValue and ((TPasRISCVUInt64(1) shl (PartSize shl 3))-1),PartSize) and
     StoreEx(aAddress,(aValue shr PartSize) and ((TPasRISCVUInt64(1) shl ((aSize-PartSize) shl 3))-1),aSize-PartSize) then begin
   result:=true;
  end;
 end;
end;

function TPasRISCV.THART.IsCSRENVCFGEnabled(const aMask:TPasRISCVUInt64):Boolean;
var Mask:TPasRISCVUInt64;
begin
 Mask:=aMask;
 if fState.Mode<TPasRISCV.THART.TMode.Machine then begin
  Mask:=Mask and fState.CSR.fData[TCSR.TAddress.MENVCFG];
 end;
 if fState.Mode<TPasRISCV.THART.TMode.Supervisor then begin
  Mask:=Mask and fState.CSR.fData[TCSR.TAddress.SENVCFG];
 end;
 result:=Mask<>0;
end;

class function TPasRISCV.THART.CSROperation(const aOperation:TCSROperation;const aCSR,aRHS:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 case aOperation of
  TCSROperation.Swap:begin
   result:=aRHS;
  end;
  TCSROperation.SetBits:begin
   result:=aCSR or aRHS;
  end;
  TCSROperation.ClearBits:begin
   result:=aCSR and not aRHS;
  end;
  else begin
   result:=aCSR;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerDefault(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue:TPasRISCVUInt64;
begin
 rd:=TRegister((aInstruction shr 7) and $1f);
 CSRValue:=fState.CSR.Load(aCSR);
 fState.CSR.Store(aCSR,CSROperation(aOperation,CSRValue,aRHS));
 {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
  fState.Registers[rd]:=CSRValue;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerDefaultReadOnly(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue:TPasRISCVUInt64;
begin
 rd:=TRegister((aInstruction shr 7) and $1f);
 CSRValue:=fState.CSR.Load(aCSR);
 {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
  fState.Registers[rd]:=CSRValue;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerPrivileged(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  CSRValue:=fState.CSR.Load(aCSR);
  fState.CSR.Store(aCSR,CSROperation(aOperation,CSRValue,aRHS));
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerPrivilegedReadOnly(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  CSRValue:=fState.CSR.Load(aCSR);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerIllegal(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
begin
//writeln(aCSR);
 SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
end;

procedure TPasRISCV.THART.CSRHandlerEnforcedReadOnly(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue,OperationValue:TPasRISCVUInt64;
begin
 rd:=TRegister((aInstruction shr 7) and $1f);
 CSRValue:=fState.CSR.Load(aCSR);
 OperationValue:=CSROperation(aOperation,CSRValue,aRHS);
 if CSRValue<>OperationValue then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerFCSR(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue,OperationValue,FExceptions:TPasRISCVUInt64;
begin
 rd:=TRegister((aInstruction shr 7) and $1f);
 CSRValue:=fState.CSR.Load(aCSR);
 FExceptions:=fState.CSR.fData[THART.TCSR.TAddress.FFLAGS] and TPasRISCVUInt64(TCSR.TFPUExceptionMasks.Mask);
 OperationValue:=CSROperation(aOperation,CSRValue or FExceptions,aRHS);
 fState.CSR.SetFPURM(OperationValue and TPasRISCVUInt64(TCSR.TFloatingPointRoundingModes.Mask));
 fState.CSR.ClearFPUExceptions;
 fState.CSR.SetFPUException(OperationValue and TPasRISCVUInt64(TCSR.TFPUExceptionMasks.Mask));
 fState.CSR.fData[THART.TCSR.TAddress.FCSR]:=OperationValue and $ff;
 {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
  fState.Registers[rd]:=CSRValue and $ff;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerFFLAGS(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue,OperationValue,FExceptions:TPasRISCVUInt64;
begin
 rd:=TRegister((aInstruction shr 7) and $1f);
 CSRValue:=fState.CSR.Load(aCSR);
 FExceptions:=CSRValue and TPasRISCVUInt64(TCSR.TFPUExceptionMasks.Mask);
 OperationValue:=CSROperation(aOperation,FExceptions,aRHS);

 fState.CSR.ClearFPUExceptions;
 fState.CSR.SetFPUException(OperationValue and TPasRISCVUInt64(TCSR.TFPUExceptionMasks.Mask));

 fState.CSR.fData[THART.TCSR.TAddress.FCSR]:=(fState.CSR.fData[THART.TCSR.TAddress.FCSR] and not TPasRISCVUInt64(TCSR.TFPUExceptionMasks.Mask)) or (OperationValue and $ff);

 {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
  fState.Registers[rd]:=CSRValue and TPasRISCVUInt64(TCSR.TFPUExceptionMasks.Mask);
 end;

end;

procedure TPasRISCV.THART.CSRHandlerFRM(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue,OperationValue:TPasRISCVUInt64;
begin

 rd:=TRegister((aInstruction shr 7) and $1f);
 CSRValue:=fState.CSR.fData[THART.TCSR.TAddress.FCSR] shr 5;
 OperationValue:=CSROperation(aOperation,CSRValue,aRHS);

 fState.CSR.ClearFPURM;
 fState.CSR.SetFPURM(OperationValue and TPasRISCVUInt64(TCSR.TFloatingPointRoundingModes.Mask));

 fState.CSR.fData[THART.TCSR.TAddress.FCSR]:=((fState.CSR.fData[THART.TCSR.TAddress.FCSR] and not $e0) or (OperationValue shl 5)) and $ff;

 {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
  fState.Registers[rd]:=CSRValue and TPasRISCVUInt64(TCSR.TFloatingPointRoundingModes.Mask);
 end;

end;

procedure TPasRISCV.THART.CSRHandlerSATP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue:TPasRISCVUInt64;
begin
 if (fState.CSR.fData[TCSR.TAddress.MSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.TVM))<>0 then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  CSRValue:=fState.CSR.Load(aCSR);
  fState.CSR.Store(aCSR,CSROperation(aOperation,CSRValue,aRHS));
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
  UpdateMMU;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerSTATUS(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Status,OldStatus,OutStatus,fs,vs,xs,Mask:TPasRISCVUInt64;
begin

 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin

  if aCSR=TCSR.TAddress.MSTATUS then begin
   Mask:=TCSR.TMask.MSTATUS;
  end else begin
   Mask:=TCSR.TMask.SSTATUS;
  end;

  rd:=TRegister((aInstruction shr 7) and $1f);

  Status:=fState.CSR.fData[TCSR.TAddress.MSTATUS];

  OldStatus:=Status;

  fs:=(Status shr 13) and 3;
  vs:=(Status shr 9) and 3;
  if fs<vs then begin
   xs:=vs;
  end else begin
   xs:=fs;
  end;

  Status:=(Status and not (TPasRISCVUInt64(3) shl 15)) or ((xs and 3) shl 15);

  OutStatus:=Status and Mask;

  Status:=(Status and not Mask) or (CSROperation(aOperation,Status,aRHS) and Mask);

  if xs=TCSR.TFS.Dirty then begin
   // XS is dirty, set SD bit
   OutStatus:=OutStatus or TCSR.TMask.TStatus.SD;
  end;

  if Status<>OldStatus then begin
   // Verify UXL and SXL for RV64
   if ((Status shr 32) and 3)<>2 then begin
    Status:=(Status and not (TPasRISCVUInt64(3) shl 32)) or (TPasRISCVUInt64(2) shl 32);
   end;
   if ((Status shr 34) and 3)<>2 then begin
    Status:=(Status and not (TPasRISCVUInt64(3) shl 34)) or (TPasRISCVUInt64(2) shl 34);
   end;
  end;

  if THART.TMode((Status shr 11) and 3)=THART.TMode.Hypervisor then begin
   // Validate MPP
   Status:=(Status and not (TPasRISCVUInt64(3) shl TCSR.TMask.TMSTATUSBit.MPP)) or (TPasRISCVUInt64(THART.TMode.User) shl 11);
  end;

  if ((Status and $a) and not (OldStatus and $a))<>0 then begin
   // MIE/SIE were enabled, check interrupts
   CheckInterrupts;
  end;

  fState.CSR.fData[TCSR.TAddress.MSTATUS]:=Status;

  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=OutStatus;
  end;

 end;

end;

procedure TPasRISCV.THART.CSRHandlerSTIMECMP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  if IsCSRENVCFGEnabled(TCSR.ENVCFG_STCE) then begin
   rd:=TRegister((aInstruction shr 7) and $1f);
   CSRValue:=fState.CSR.Load(aCSR);
   fState.CSR.Store(aCSR,CSROperation(aOperation,CSRValue,aRHS));
   if fMachine.fACLINTDevice.GetTime>=fSTIMECMP then begin
    RaiseInterrupt(TInterruptValue.SupervisorTimer);
   end else begin
    ClearInterrupt(TInterruptValue.SupervisorTimer);
   end;
   {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
    fState.Registers[rd]:=CSRValue;
   end;
  end else begin
   SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerMIE(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Value,CSRValue:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  Value:=fState.CSR.fData[TCSR.TAddress.MIE];
  CSRValue:=CSROperation(aOperation,Value and TCSR.CSR_MEIP_MASK,aRHS) and TCSR.CSR_MEIP_MASK;
  fState.CSR.fData[TCSR.TAddress.MIE]:=(CSRValue and TCSR.CSR_MEIP_MASK) or (Value and not TCSR.CSR_MEIP_MASK);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
  Checkinterrupts;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerSIE(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Value,CSRValue:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  Value:=fState.CSR.fData[TCSR.TAddress.MIE];
  CSRValue:=CSROperation(aOperation,Value and TCSR.CSR_SEIP_MASK,aRHS) and TCSR.CSR_SEIP_MASK;
  fState.CSR.fData[TCSR.TAddress.MIE]:=(CSRValue and TCSR.CSR_SEIP_MASK) or (Value and not TCSR.CSR_SEIP_MASK);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
  Checkinterrupts;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerMIP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Value,CSRValue:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  Value:=fState.CSR.fData[TCSR.TAddress.MIP];
  CSRValue:=CSROperation(aOperation,Value and TCSR.CSR_MEIP_MASK,aRHS) and TCSR.CSR_MEIP_MASK;
  fState.CSR.fData[TCSR.TAddress.MIP]:=(CSRValue and TCSR.CSR_MEIP_MASK) or (Value and not TCSR.CSR_MEIP_MASK);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   CSRValue:=CSRValue or (fState.PendingIRQs and TCSR.CSR_MEIP_MASK);
   fState.Registers[rd]:=CSRValue;
  end;
  Checkinterrupts;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerSIP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Value,CSRValue:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  Value:=fState.CSR.fData[TCSR.TAddress.MIP];
  CSRValue:=CSROperation(aOperation,Value and TCSR.CSR_SEIP_MASK,aRHS) and TCSR.CSR_SEIP_MASK;
  fState.CSR.fData[TCSR.TAddress.MIP]:=(CSRValue and TCSR.CSR_SEIP_MASK) or (Value and not TCSR.CSR_SEIP_MASK);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   CSRValue:=CSRValue or (fState.PendingIRQs and TCSR.CSR_SEIP_MASK);
   fState.Registers[rd]:=CSRValue;
  end;
  Checkinterrupts;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerMTOPI(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    PendingValue,CSRValue,IRQ:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  PendingValue:=InterruptsPending and TCSR.CSR_MEIP_MASK;
  if PendingValue<>0 then begin
   IRQ:=CLZDWord(PendingValue) xor 31;
  end else begin
   IRQ:=0;
  end;
  CSRValue:=(ord(IRQ<>0) and 1) or (IRQ shl 16);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerSTOPI(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    PendingValue,CSRValue,IRQ:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  PendingValue:=InterruptsPending and TCSR.CSR_SEIP_MASK;
  if PendingValue<>0 then begin
   IRQ:=CLZDWord(PendingValue) xor 31;
  end else begin
   IRQ:=0;
  end;
  CSRValue:=(ord(IRQ<>0) and 1) or (IRQ shl 16);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerMTOPEI(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    IRQ,CSRValue:TPasRISCVUInt64;
    IsWrite:Boolean;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  IsWrite:=(rd<>TRegister.Zero) or (aOperation=TCSROperation.Swap);
  IRQ:=GetAIAIRQ(TPasRISCV.TAIARegFileMode.Machine,IsWrite);
  CSRValue:=IRQ or (IRQ shl 16);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerSTOPEI(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    IRQ,CSRValue:TPasRISCVUInt64;
    IsWrite:Boolean;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  IsWrite:=(rd<>TRegister.Zero) or (aOperation=TCSROperation.Swap);
  IRQ:=GetAIAIRQ(TPasRISCV.TAIARegFileMode.Supervisor,IsWrite);
  CSRValue:=IRQ or (IRQ shl 16);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
 end;
end;

class function TPasRISCV.THART.CSRAtomicHelper(const aValue:PPasRISCVUInt32;const aRHS:TPasRISCVUInt64;out aDest:TPasRISCVUInt64;const aOperation:TCSROperation):Boolean;
begin
 case aOperation of
  TCSROperation.Swap:begin
   aDest:=TPasRISCVUInt32(TPasMPInterlocked.Exchange(aValue^,TPasRISCVUInt32(aRHS)));
   result:=true;
  end;
  TCSROperation.SetBits:begin
   if aRHS<>0 then begin
    aDest:=TPasRISCVUInt32(TPasMPInterlocked.ExchangeBitwiseOr(aValue^,TPasRISCVUInt32(aRHS)));
    result:=true;
   end else begin
    aDest:=TPasRISCVUInt32(TPasMPInterlocked.Read(aValue^));
    result:=false;
   end;
  end;
  TCSROperation.ClearBits:begin
   if aRHS<>0 then begin
    aDest:=TPasRISCVUInt32(TPasMPInterlocked.ExchangeBitwiseAnd(aValue^,not TPasRISCVUInt32(aRHS)));
    result:=true;
   end else begin
    aDest:=TPasRISCVUInt32(TPasMPInterlocked.Read(aValue^));
    result:=false;
   end;
  end;
  else begin
   result:=false;
  end;
 end;
end;

function TPasRISCV.THART.CSRAIAHelper(const aMode:TMode;const aAIARegFileMode:TAIARegFileMode;const aValue:PPasRISCVUInt32;const aRHS:TPasRISCVUInt64;out aDest:TPasRISCVUInt64;const aOperation:TCSROperation):Boolean;
begin
 if CSRAtomicHelper(aValue,aRHS,aDest,aOperation) then begin
  UpdateAIAState(aAIARegFileMode);
 end;
 result:=true;
end;

function TPasRISCV.THART.CSRAIAPairHelper(const aMode:TMode;const aAIARegFileMode:TAIARegFileMode;const aReg:TPasRISCVUInt32;const aValue:Pointer;const aRHS:TPasRISCVUInt64;out aDest:TPasRISCVUInt64;const aOperation:TCSROperation):Boolean;
var Top:TPasRISCVUInt64;
begin
 if (aReg and 1)=0 then begin
  if (aReg+1)<TAIARegFile.ARRAY_LENGTH then begin
   CSRAIAHelper(aMode,aAIARegFileMode,@PPasRISCVUInt32Array(aValue)^[aReg],TPasRISCVUInt32(aRHS),aDest,aOperation);
   CSRAIAHelper(aMode,aAIARegFileMode,@PPasRISCVUInt32Array(aValue)^[aReg+1],TPasRISCVUInt32(TPasRISCVUInt64(aRHS shr 32)),Top,aOperation);
   aDest:=aDest or (Top shl 32);
   result:=true;
  end else begin
   result:=false;
  end;
 end else begin
  result:=false;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerIndirect(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    OK:Boolean;
    ISelect,CSRValue,Reg:TPasRISCVUInt64;
    Mode:TPasRISCV.THART.TMode;
    AIARegFileMode:TPasRISCV.TAIARegFileMode;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  case aCSR of
   TCSR.TAddress.MIREG:begin
    Mode:=THART.TMode.Machine;
    AIARegFileMode:=TPasRISCV.TAIARegFileMode.Machine;
    ISelect:=fState.CSR.fData[TCSR.TAddress.MISELECT];
   end;
   TCSR.TAddress.SIREG:begin
    Mode:=THART.TMode.Supervisor;
    AIARegFileMode:=TPasRISCV.TAIARegFileMode.Supervisor;
    ISelect:=fState.CSR.fData[TCSR.TAddress.SISELECT];
   end;
   else begin
    Mode:=THART.TMode.Invalid;
    AIARegFileMode:=TPasRISCV.TAIARegFileMode.Machine;
    ISelect:=0;
   end;
  end;
  if Mode<>THART.TMode.Invalid then begin
   OK:=false;
   case ISelect of
    TCSR.CSRI_EIDELIVERY:begin
     if fMachine.fConfiguration.fAIA then begin
      OK:=CSRAIAHelper(Mode,AIARegFileMode,@fAIARegFiles[AIARegFileMode].fEIDelivery,aRHS and 1,CSRValue,aOperation);
      if OK then begin
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=CSRValue;
       end;
      end;
     end;
    end;
    TCSR.CSRI_EITHRESHOLD:begin
     if fMachine.fConfiguration.fAIA then begin
      OK:=CSRAIAHelper(Mode,AIARegFileMode,@fAIARegFiles[AIARegFileMode].fEIThreshold,aRHS,CSRValue,aOperation);
      if OK then begin
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=CSRValue;
       end;
      end;
     end;
    end;
    TCSR.CSRI_MIPRIO_0..TCSR.CSRI_MIPRIO_15:begin
     if fMachine.fConfiguration.fAIA then begin
      CSRValue:=0;
      {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
       fState.Registers[rd]:=CSRValue;
      end;
      OK:=true;
     end;
    end;
    TCSR.CSRI_EIP0..TCSR.CSRI_EIP63:begin
     if fMachine.fConfiguration.fAIA then begin
      Reg:=ISelect-TCSR.CSRI_EIP0;
      OK:=CSRAIAPairHelper(Mode,AIARegFileMode,Reg,@fAIARegFiles[AIARegFileMode].fEIP,aRHS,CSRValue,aOperation);
      if OK then begin
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=CSRValue;
       end;
      end;
     end;
    end;
    TCSR.CSRI_EIE0..TCSR.CSRI_EIE63:begin
     if fMachine.fConfiguration.fAIA then begin
      Reg:=ISelect-TCSR.CSRI_EIE0;
      CSRValue:=aRHS;
      OK:=CSRAIAPairHelper(Mode,AIARegFileMode,Reg,@fAIARegFiles[AIARegFileMode].fEIE,aRHS,CSRValue,aOperation);
      if OK then begin
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=CSRValue;
       end;
      end;
     end;
    end;
    else begin
     OK:=false;
    end;
   end;
   if not OK then begin
    SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
   end;
  end else begin
   SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
  end;
 end;
end;

procedure TPasRISCV.THART.SetFPUExceptions(const aMask:TPasRISCVUInt32=$3f);
var Exceptions:TPasRISCVUInt32;
begin
 Exceptions:=fetestexcept(FE_ALL_EXCEPT);
 if Exceptions<>0 then begin
  Exceptions:=Exceptions and aMask;
{ if (Exceptions and FE_INVALID)<>0 then begin // Invalid
   fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
  end;}
  if (Exceptions and FE_DIVBYZERO)<>0 then begin // Divide by zero
   fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.DivByZero);
  end;
  if (Exceptions and FE_OVERFLOW)<>0 then begin // Overflow
   fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Overflow);
  end;
  if (Exceptions and FE_UNDERFLOW)<>0 then begin // Underflow
   fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Underflow);
  end;
  if (Exceptions and FE_INEXACT)<>0 then begin // Inexact
   fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Inexact);
  end;
  feclearexcept(FE_ALL_EXCEPT);
 end;
end;

procedure TPasRISCV.THART.Breakpoint(const aInstruction:TPasRISCVUInt32);
begin
 if assigned(fMachine.fDebugger) and fMachine.fDebugger.Halt then begin
  SetException(TExceptionValue.DebuggerBreakpoint,aInstruction,fState.PC);
 end else begin
  SetException(TExceptionValue.Breakpoint,aInstruction,fState.PC);
 end;
end;

function TPasRISCV.THART.FetchInstruction(const aAddress:TPasRISCVUInt64;out aInstruction:TPasRISCVUInt32):Boolean;
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Execute=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
{$ifdef Use16BitSplittedInstructionFetches}
  aInstruction:=PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryExecute{$endif}+aAddress)))^;
  if (aInstruction and 3)=3 then begin
   aInstruction:=aInstruction or (TPasRISCVUInt32(PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryExecute{$endif}+aAddress+2)))^) shl 16);
  end;
{$else}
  aInstruction:=PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryExecute{$endif}+aAddress)))^;
{$endif}
  result:=true;
  exit;
 end;

 TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Instruction,[]);
 if fState.ExceptionValue<>TExceptionValue.None then begin
  aInstruction:=0;
  result:=false;
  exit;
 end;

{$ifndef Use16BitSplittedInstructionFetches}
 if ((aAddress and PAGE_MASK)+3)<PAGE_SIZE then begin

  aInstruction:=TPasRISCVUInt32(fBus.Fetch(self,TranslatedAddress,4));

  result:=fState.ExceptionValue=TExceptionValue.None;

 end else{$endif}begin

  aInstruction:=TPasRISCVUInt32(fBus.Fetch(self,TranslatedAddress,2));
  if fState.ExceptionValue<>TExceptionValue.None then begin
   aInstruction:=0;
   result:=false;
   exit;
  end;

  if (aInstruction and 3)=3 then begin

   TranslatedAddress:=AddressTranslate(aAddress+2,TMMU.TAccessType.Instruction,[]);
   if fState.ExceptionValue<>TExceptionValue.None then begin
    aInstruction:=0;
    result:=false;
    exit;
   end;

   aInstruction:=aInstruction or (TPasRISCVUInt32(FBus.Fetch(self,TranslatedAddress,2)) shl 16);

   result:=fState.ExceptionValue=TExceptionValue.None;

  end else begin

   result:=true;

  end;

 end;

end;

function TPasRISCV.THART.GetInstructionSize(const aInstruction:TPasRISCVUInt32):TPasRISCVUInt64;
begin
 if (aInstruction and 3)=3 then begin
  result:=4; // Normal instruction
 end else begin
  result:=2; // Compressed instruction
 end;
end;

{$ifdef fpc}
 {$push}
 {$codealign jump=16}
 {$codealign loop=16}
 {$codealign proc=16}
{$endif}
function TPasRISCV.THART.ExecuteInstruction(const aInstruction:TPasRISCVUInt32):TPasRISCVUInt64;
// This function decodes and executes a single RISC-V instruction by using a simple but effective
// switch-based interpreter. This approach is chosen for its simplicity, portability, and ease of
// maintenance. The function is designed to be easily extensible to support additional instruction
// extensions and customizations. Direct/indirect threaded code, or other advanced techniques, could
// be used for improved performance, but would complicate the code and make it harder to maintain.
// However once JIT compilation is implemented later, the interpreter will be used only for the
// initial warm-up phase and for handling edge cases as well as more complex instructions, while the
// JIT-compiled code will be used for subsequent execution, providing a significant performance boost.
//
// Optimizations for Performance:
//
// - Jump Table Heuristics:
//     The code attempts to improve performance by encouraging the compiler to generate jump tables
//     for the top-level case statement (TryToForceCaseJumpTableOnLevel1) by using several equivalent
//     case values in a row, eg. "$00,$04,$08,$0c,$10,$14,.." instead only "$00" exploiting the fact
//     that the RISC-V instruction encoding uses the lower two bits for to distinguish between
//     compressed 16-bit and normal 32-bit instructions. This can potentially speed up instruction
//     decoding by reducing linear branch evaluations.
//     However, this optimization is compiler-dependent and might not always be effective, and
//     enabling jump tables for deeper case levels (e.g. TryToForceCaseJumpTableOnCompressedLevel2)
//     is currently disabled because it can have a negative impact on the performance at the moment.
//
// - Branch Prediction and Cache Locality:
//     Case statements should be ordered such that the most frequent instructions are placed at the
//     beginning. This improves both branch prediction accuracy and cache locality:
//       - Branch Prediction:
//           Frequent instructions are more likely to be predicted correctly, reducing mispredictions
//           and improving instruction pipeline flow.
//       - Cache Locality:
//           Keeping frequently executed code in the cache minimizes data access latency and improves
//           overall execution speed.
//
// - Early Exits:
//     The function utilizes `exit;` statements whenever possible to terminate execution after handling
//     an instruction. This avoids unnecessary jumps to the function's end, improving code locality and
//     potentially reducing cache misses.
//
// However, the effectiveness of these optimizations can vary depending on the specific CPU architecture,
// compiler version, and optimization settings used. The primary goal of these optimizations is to achieve
// a balance between performance and code maintainability.
{$define TryToForceCaseJumpTableOnLevel1}
{-$define TryToForceCaseJumpTableOnCompressedLevel2}
{-$define TryToForceCaseJumpTableOnLevel2}
var Address,Temporary,Offset{$ifdef UseExtraShAmt},ShAmt{$endif}:TPasRISCVUInt64;
    Immediate:TPasRISCVInt64;
    Ptr:Pointer;
    rd,rs1,rs2:TRegister;
    frd,frs1,frs2,frs3:TFPURegister;
    f32,f32n:TPasRISCVFloat;
    f64,f64n:TPasRISCVDouble;
begin

 case {$ifdef TryToForceCaseJumpTableOnLevel1}TPasRISCVUInt8(aInstruction and $7f){$else}aInstruction and 3{$endif} of

  {$ifdef TryToForceCaseJumpTableOnLevel1}
   $00,$04,$08,$0c,$10,$14,$18,$1c,$20,$24,$28,$2c,$30,$34,$38,$3c,
   $40,$44,$48,$4c,$50,$54,$58,$5c,$60,$64,$68,$6c,$70,$74,$78,$7c,
   $80,$84,$88,$8c,$90,$94,$98,$9c,$a0,$a4,$a8,$ac,$b0,$b4,$b8,$bc,
   $c0,$c4,$c8,$cc,$d0,$d4,$d8,$dc,$e0,$e4,$e8,$ec,$f0,$f4,$f8,$fc:
  {$else}
   $00:
  {$endif}begin
   // Compressed quandrant 0
// case TPasRISCVUInt8((aInstruction shr 13) and {$ifdef TryToForceCaseJumpTableOnCompressedLevel2}$ff{$else}7{$endif}) of
   case {$ifdef TryToForceCaseJumpTableOnCompressedLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 13) and 7) of
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
     if aInstruction=0 then begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
      result:=4;
      exit;
     end else begin
      // c.addi4spn
      Immediate:=((aInstruction shr 1) and $3c0) or ((aInstruction shr 7) and $30) or ((aInstruction shr 2) and $08) or ((aInstruction shr 4) and $04);
      if Immediate<>0 then begin
       rd:=TRegister(((aInstruction shr 2) and $7)+8);
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=fState.Registers[TRegister.SP]+TPasRISCVUInt64(Immediate);
       end;
       result:=2;
       exit;
      end else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
       result:=2;
{$ifdef PasRISCVCPUFileDumpDebug}
       halt(0);
{$endif}
       exit;
      end;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
     // c.fld
     frd:=TFPURegister(((aInstruction shr 2) and $7)+8);
     rs1:=TRegister(((aInstruction shr 7) and $7)+8);
     Offset:=((aInstruction shl 1) and $c0) or ((aInstruction shr 7) and $38);
{$ifdef UseSpecializedRegisterLoadStores}
     LoadRegisterF64(frd,fState.Registers[rs1]+Offset);
{$else}
     Temporary:=Load64(fState.Registers[rs1]+Offset);
     if fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None then begin
      fState.FPURegisters[frd].ui64:=Temporary;
      fState.CSR.SetFSDirty;
     end;
{$endif}
//   SetFPUExceptions(FE_ALL_EXCEPT and not FE_INEXACT);
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
     // c.lw
     rd:=TRegister(((aInstruction shr 2) and $7)+8);
     rs1:=TRegister(((aInstruction shr 7) and $7)+8);
     Immediate:=((aInstruction shl 1) and $40) or ((aInstruction shr 7) and $38) or ((aInstruction shr 4) and $04);
{$ifdef UseSpecializedRegisterLoadStores}
     LoadRegisterS32(rd,fState.Registers[rs1]+TPasRISCVUInt64(Immediate));
{$else}
     Temporary:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Load32(fState.Registers[rs1]+TPasRISCVUInt64(Immediate)))));
     if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
      fState.Registers[rd]:=Temporary;
     end;
{$endif}
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
     // c.ld
     rd:=TRegister(((aInstruction shr 2) and $7)+8);
     rs1:=TRegister(((aInstruction shr 7) and $7)+8);
     Offset:=((aInstruction shl 1) and $c0) or ((aInstruction shr 7) and $38);
{$ifdef UseSpecializedRegisterLoadStores}
     LoadRegisterU64(rd,fState.Registers[rs1]+Offset);
{$else}
     Temporary:=Load64(fState.Registers[rs1]+Offset);
     if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
      fState.Registers[rd]:=Temporary;
     end;
{$endif}
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
     // Zcb
     case (aInstruction shr 10) and 7 of
      $0:begin
       // c.lbu (Zcb)
       rs1:=TRegister(((aInstruction shr 7) and $7)+8);
       Offset:=((aInstruction and $20) shr 4) or ((aInstruction and $40) shr 6);
{$ifdef UseSpecializedRegisterLoadStores}
       LoadRegisterU8(TRegister(((aInstruction shr 2) and $7)+8),fState.Registers[rs1]+Offset);
{$else}
       Temporary:=Load8(fState.Registers[rs1]+Offset);
       rd:=TRegister(((aInstruction shr 2) and $7)+8);
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=2;
       exit;
      end;
      $1:begin
       // c.lh/c.lhu (Zcb)
{$ifdef UseSpecializedRegisterLoadStores}
       rd:=TRegister(((aInstruction shr 2) and $7)+8);
{$endif}
       rs1:=TRegister(((aInstruction shr 7) and $7)+8);
       Offset:=(aInstruction and $20) shr 4;
       if (aInstruction and $40)<>0 then begin
        // c.lh (Zcb)
{$ifdef UseSpecializedRegisterLoadStores}
        LoadRegisterS16(rd,fState.Registers[rs1]+Offset);
{$else}
        Temporary:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Load16(fState.Registers[rs1]+Offset))));
{$endif}
       end else begin
        // c.lhu (Zcb)
{$ifdef UseSpecializedRegisterLoadStores}
        LoadRegisterU16(rd,fState.Registers[rs1]+Offset);
{$else}
        Temporary:=Load16(fState.Registers[rs1]+Offset);
{$endif}
       end;
{$ifndef UseSpecializedRegisterLoadStores}
       rd:=TRegister(((aInstruction shr 2) and $7)+8);
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=2;
       exit;
      end;
      $2:begin
       // c.sbu (Zcb)
       rd:=TRegister(((aInstruction shr 2) and $7)+8);
       rs1:=TRegister(((aInstruction shr 7) and $7)+8);
       Offset:=((aInstruction and $20) shr 4) or ((aInstruction and $40) shr 6);
       Store8(fState.Registers[rs1]+Offset,TPasRISCVUInt8(fState.Registers[rd]));
       result:=2;
       exit;
      end;
      $3:begin
       if (aInstruction and $40)=0 then begin
        // c.sh (Zcb)
        rd:=TRegister(((aInstruction shr 2) and $7)+8);
        rs1:=TRegister(((aInstruction shr 7) and $7)+8);
        Offset:=((aInstruction and $20) shr 4) or ((aInstruction and $40) shr 6);
        Store16(fState.Registers[rs1]+Offset,TPasRISCVUInt16(fState.Registers[rd]));
        result:=2;
        exit;
       end else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
        result:=2;
        exit;
       end;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
       result:=2;
       exit;
      end;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
     // c.fsd
     frd:=TFPURegister(((aInstruction shr 2) and $7)+8);
     rs1:=TRegister(((aInstruction shr 7) and $7)+8);
     Offset:=((aInstruction shl 1) and $c0) or ((aInstruction shr 7) and $38);
{$ifdef UseSpecializedRegisterLoadStores}
     StoreRegisterF64(fState.Registers[rs1]+Offset,frd);
{$else}
     Store64(fState.Registers[rs1]+Offset,fState.FPURegisters[frd].ui64);
{$endif}
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
     // c.sw
     rs1:=TRegister(((aInstruction shr 7) and $7)+8);
     rs2:=TRegister(((aInstruction shr 2) and $7)+8);
     Offset:=(((aInstruction shl 1) and $40) or ((aInstruction shr 7) and $38) or ((aInstruction shr 4) and $04));
{$ifdef UseSpecializedRegisterLoadStores}
     StoreRegisterU32(fState.Registers[rs1]+Offset,rs2);
{$else}
     Store32(fState.Registers[rs1]+Offset,fState.Registers[rs2]);
{$endif}
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}else{-$7:}{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
     // c.sd
     rs1:=TRegister(((aInstruction shr 7) and $7)+8);
     rs2:=TRegister(((aInstruction shr 2) and $7)+8);
     Offset:=((aInstruction shl 1) and $c0) or ((aInstruction shr 7) and $38);
{$ifdef UseSpecializedRegisterLoadStores}
     StoreRegisterU64(fState.Registers[rs1]+Offset,rs2);
{$else}
     Store64(fState.Registers[rs1]+Offset,fState.Registers[rs2]);
{$endif}
     result:=2;
     exit;
    end;
   end;
  end;

  {$ifdef TryToForceCaseJumpTableOnLevel1}
   $01,$05,$09,$0d,$11,$15,$19,$1d,$21,$25,$29,$2d,$31,$35,$39,$3d,
   $41,$45,$49,$4d,$51,$55,$59,$5d,$61,$65,$69,$6d,$71,$75,$79,$7d,
   $81,$85,$89,$8d,$91,$95,$99,$9d,$a1,$a5,$a9,$ad,$b1,$b5,$b9,$bd,
   $c1,$c5,$c9,$cd,$d1,$d5,$d9,$dd,$e1,$e5,$e9,$ed,$f1,$f5,$f9,$fd:
  {$else}
   $01:
  {$endif}begin
   // Compressed quandrant 1
// case TPasRISCVUInt8((aInstruction shr 13) and {$ifdef TryToForceCaseJumpTableOnCompressedLevel2}$ff{$else}7{$endif}) of
   case {$ifdef TryToForceCaseJumpTableOnCompressedLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 13) and 7) of
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
     // c.addi
     rd:=TRegister(((aInstruction shr 7) and $1f));
     {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
      Immediate:=SignExtend(((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f),6);
      fState.Registers[rd]:=fState.Registers[rd]+TPasRISCVUInt64(Immediate);
     end;
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
     // c.addiw
     rd:=TRegister(((aInstruction shr 7) and $1f));
     if rd<>TRegister.Zero then begin
      Immediate:=SignExtend(((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f),6);
      fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(fState.Registers[rd]+Immediate)));
      result:=2;
      exit;
     end else begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
      result:=2;
      exit;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
     // c.li
     rd:=TRegister(((aInstruction shr 7) and $1f));
     {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
      Immediate:=SignExtend(((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f),6);
      fState.Registers[rd]:=TPasRISCVUInt64(Immediate);
     end;
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
     case (aInstruction shr 7) and $1f of
      $0:begin
       // c.nop
       result:=2;
       exit;
      end;
      $2:begin
       // c.addi16sp
       Immediate:=SignExtend(((aInstruction shr 3) and $200) or
                             ((aInstruction shr 2) and $10) or
                             ((aInstruction shl 1) and $40) or
                             ((aInstruction shl 4) and $180) or
                             ((aInstruction shl 3) and $20),10);
       if Immediate<>0 then begin
        inc(fState.Registers[TRegister.SP],TPasRISCVUInt64(Immediate));
        result:=2;
        exit;
       end else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
        result:=2;
        exit;
       end;
      end;
      else begin
       // c.lui
       rd:=TRegister((aInstruction shr 7) and $1f);
       Immediate:=SignExtend(((aInstruction shl 5) and $20000) or ((aInstruction shl 10) and $1f000),18);
       if Immediate<>0 then begin
        {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
         fState.Registers[rd]:=TPasRISCVUInt64(Immediate);
        end;
        result:=2;
        exit;
       end else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
        result:=2;
        exit;
       end;
      end;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
     case (aInstruction shr 10) and 3 of
      $0:begin
       // c.srli
       rd:=TRegister(((aInstruction shr 7) and $7)+8);
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        Immediate:=((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f);
        fState.Registers[rd]:=fState.Registers[rd] shr TPasRISCVUInt64(Immediate);
       end;
       result:=2;
       exit;
      end;
      $1:begin
       // c.srai
       rd:=TRegister(((aInstruction shr 7) and $7)+8);
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        Immediate:=((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f);
        fState.Registers[rd]:=SARInt64(fState.Registers[rd],TPasRISCVUInt64(Immediate));
       end;
       result:=2;
       exit;
      end;
      $2:begin
       // c.andi
       rd:=TRegister(((aInstruction shr 7) and $7)+8);
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        Immediate:=SignExtend(((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f),6);
        fState.Registers[rd]:=fState.Registers[rd] and TPasRISCVUInt64(Immediate);
       end;
       result:=2;
       exit;
      end;
      else {-$3:}begin
       if ((aInstruction shr 12) and 1)=0 then begin
        case (aInstruction shr 5) and 3 of
         $0:begin
          // c.sub
          rd:=TRegister(((aInstruction shr 7) and $7)+8);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           rs2:=TRegister(((aInstruction shr 2) and $7)+8);
           fState.Registers[rd]:=fState.Registers[rd]-fState.Registers[rs2];
          end;
          result:=2;
          exit;
         end;
         $1:begin
          // c.xor
          rd:=TRegister(((aInstruction shr 7) and $7)+8);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           rs2:=TRegister(((aInstruction shr 2) and $7)+8);
           fState.Registers[rd]:=fState.Registers[rd] xor fState.Registers[rs2];
          end;
          result:=2;
          exit;
         end;
         $2:begin
          // c.or
          rd:=TRegister(((aInstruction shr 7) and $7)+8);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           rs2:=TRegister(((aInstruction shr 2) and $7)+8);
           fState.Registers[rd]:=fState.Registers[rd] or fState.Registers[rs2];
          end;
          result:=2;
          exit;
         end;
         else {-$3:}begin
          // c.and
          rd:=TRegister(((aInstruction shr 7) and $7)+8);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           rs2:=TRegister(((aInstruction shr 2) and $7)+8);
           fState.Registers[rd]:=fState.Registers[rd] and fState.Registers[rs2];
          end;
          result:=2;
          exit;
         end;
        end;
       end else begin
        case (aInstruction shr 5) and 3 of
         $0:begin
          // c.subw
          rd:=TRegister(((aInstruction shr 7) and $7)+8);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           rs2:=TRegister(((aInstruction shr 2) and $7)+8);
           fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVInt32(fState.Registers[rd])-TPasRISCVInt32(fState.Registers[rs2])));
          end;
          result:=2;
          exit;
         end;
         $1:begin
          // c.addw
          rd:=TRegister(((aInstruction shr 7) and $7)+8);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           rs2:=TRegister(((aInstruction shr 2) and $7)+8);
           fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVInt32(fState.Registers[rd])+TPasRISCVInt32(fState.Registers[rs2])));
          end;
          result:=2;
          exit;
         end;
         $2:begin
          // c.mul (Zcb + M)
          rd:=TRegister(((aInstruction shr 7) and $7)+8);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           rs2:=TRegister(((aInstruction shr 2) and $7)+8);
           fState.Registers[rd]:=fState.Registers[rd]*fState.Registers[rs2];
          end;
          result:=2;
          exit;
         end;
         $3:begin
          case (aInstruction shr 2) and 7 of
           $0:begin
            // c.zext.b (Zcb)
            rd:=TRegister(((aInstruction shr 7) and $7)+8);
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt8(fState.Registers[rd]);
            end;
           end;
           $1:begin
            // c.sext.b (Zcb + Zbb)
            rd:=TRegister(((aInstruction shr 7) and $7)+8);
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(fState.Registers[rd])));
            end;
           end;
           $2:begin
            // c.zext.h (Zcb + Zbb)
            rd:=TRegister(((aInstruction shr 7) and $7)+8);
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt16(fState.Registers[rd]);
            end;
           end;
           $3:begin
            // c.sext.w (Zcb + Zbb)
            rd:=TRegister(((aInstruction shr 7) and $7)+8);
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(fState.Registers[rd])));
            end;
           end;
           $4:begin
            // c.zext.w (Zcb + Zba)
            rd:=TRegister(((aInstruction shr 7) and $7)+8);
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt32(fState.Registers[rd]);
            end;
           end;
           $5:begin
            // c.not (Zcb)
            rd:=TRegister(((aInstruction shr 7) and $7)+8);
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=not fState.Registers[rd];
            end;
           end;
           else begin
            SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
            result:=2;
            exit;
           end;
          end;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
          result:=2;
          exit;
         end;
        end;
       end;
      end;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
     // c.j
     Immediate:=SignExtend(((aInstruction shr 1) and $800) or  //  bit [12] -> [11]
                           ((aInstruction shl 2) and $400) or  //  bit [8] -> [10]
                           ((aInstruction shr 1) and $300) or  //  bits [10:9] -> [9:8]
                           ((aInstruction shl 1) and $80) or   //  bit [6] -> [7]
                           ((aInstruction shr 1) and $40) or   //  bit [7] -> [6]
                           ((aInstruction shl 3) and $20) or   //  bit [2] -> [5]
                           ((aInstruction shr 7) and $10) or   //  bit [11] -> [4]
                           ((aInstruction shr 2) and $0e),12); //  bits [5:3] -> [3:1]
     inc(fState.PC,TPasRISCVUInt64(Immediate)-2);
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
     // c.beqz
     rs1:=TRegister(((aInstruction shr 7) and $7)+8);
     if fState.Registers[rs1]=0 then begin
      Immediate:=SignExtend(((aInstruction shr 4) and $100) or
                            ((aInstruction shl 1) and $c0) or
                            ((aInstruction shl 3) and $20) or
                            ((aInstruction shr 7) and $18) or
                            ((aInstruction shr 2) and $06),9);
      inc(fState.PC,TPasRISCVUInt64(Immediate)-2);
     end;
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}else{-$7:}{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
     // c.bnez
     rs1:=TRegister(((aInstruction shr 7) and $7)+8);
     if fState.Registers[rs1]<>0 then begin
      Immediate:=SignExtend(((aInstruction shr 4) and $100) or
                            ((aInstruction shl 1) and $c0) or
                            ((aInstruction shl 3) and $20) or
                            ((aInstruction shr 7) and $18) or
                            ((aInstruction shr 2) and $06),9);
      inc(fState.PC,TPasRISCVUInt64(Immediate)-2);
     end;
     result:=2;
     exit;
    end;
   end;
  end;

  {$ifdef TryToForceCaseJumpTableOnLevel1}
   $02,$06,$0a,$0e,$12,$16,$1a,$1e,$22,$26,$2a,$2e,$32,$36,$3a,$3e,
   $42,$46,$4a,$4e,$52,$56,$5a,$5e,$62,$66,$6a,$6e,$72,$76,$7a,$7e,
   $82,$86,$8a,$8e,$92,$96,$9a,$9e,$a2,$a6,$aa,$ae,$b2,$b6,$ba,$be,
   $c2,$c6,$ca,$ce,$d2,$d6,$da,$de,$e2,$e6,$ea,$ee,$f2,$f6,$fa,$fe:
  {$else}
   $02:
  {$endif}begin
   // Compressed quandrant 2
// case TPasRISCVUInt8((aInstruction shr 13) and {$ifdef TryToForceCaseJumpTableOnCompressedLevel2}$ff{$else}7{$endif}) of
   case {$ifdef TryToForceCaseJumpTableOnCompressedLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 13) and 7) of
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
     // c.slli
     rd:=TRegister((aInstruction shr 7) and $1f);
     {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
      Immediate:=((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f);
      fState.Registers[rd]:=fState.Registers[rd] shl TPasRISCVUInt64(Immediate);
     end;
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
     // c.fldsp
     if fState.CSR.IsFPUEnabled then begin
      frd:=TFPURegister((aInstruction shr 7) and $1f);
      Offset:=((aInstruction shl 4) and $1c0) or
              ((aInstruction shr 7) and $20) or
              ((aInstruction shr 2) and $18);
{$ifdef UseSpecializedRegisterLoadStores}
      LoadRegisterF64(frd,fState.Registers[TRegister.SP]+Offset);
{$else}
      Temporary:=Load64(fState.Registers[TRegister.SP]+Offset);
      if fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None then begin
       fState.FPURegisters[frd].ui64:=Temporary;
       fState.CSR.SetFSDirty;
      end;
{$endif}
//    SetFPUExceptions(FE_ALL_EXCEPT and not FE_INEXACT);
      result:=2;
      exit;
     end else begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
      result:=2;
      exit;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
     // c.lwsp
     rd:=TRegister((aInstruction shr 7) and $1f);
     if rd<>TRegister.Zero then begin
      Offset:=((aInstruction shl 4) and $c0) or
              ((aInstruction shr 7) and $20) or
              ((aInstruction shr 2) and $1c);
{$ifdef UseSpecializedRegisterLoadStores}
      LoadRegisterS32(rd,fState.Registers[TRegister.SP]+Offset);
{$else}
      Temporary:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Load32(fState.Registers[TRegister.SP]+Offset))));
      if fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None then begin
       fState.Registers[rd]:=Temporary;
      end;
{$endif}
      result:=2;
      exit;
     end else begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
      result:=2;
      exit;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
     // c.ldsp
     rd:=TRegister((aInstruction shr 7) and $1f);
     if rd<>TRegister.Zero then begin
      Offset:=((aInstruction shl 4) and $1c0) or
              ((aInstruction shr 7) and $20) or
              ((aInstruction shr 2) and $18);
{$ifdef UseSpecializedRegisterLoadStores}
      LoadRegisterU64(rd,fState.Registers[TRegister.SP]+Offset);
{$else}
      Temporary:=Load64(fState.Registers[TRegister.SP]+Offset);
      if fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None then begin
       fState.Registers[rd]:=Temporary;
      end;
{$endif}
      result:=2;
      exit;
     end else begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
      result:=2;
      exit;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
     if ((aInstruction shr 12) and 1)=0 then begin
      case (aInstruction shr 2) and $1f of
       $0:begin
        // c.jr
        rs1:=TRegister((aInstruction shr 7) and $1f);
        fState.PC:=fState.Registers[rs1]-2;
        result:=2;
        exit;
       end;
       else begin
        // c.mv
        rd:=TRegister((aInstruction shr 7) and $1f);
        {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
         rs1:=TRegister((aInstruction shr 2) and $1f);
         fState.Registers[rd]:=fState.Registers[rs1];
        end;
        result:=2;
        exit;
       end;
      end;
     end else begin
      if ((aInstruction shr 7) and $1f)<>0 then begin
       case (aInstruction shr 2) and $1f of
        $0:begin
         // c.jalr
         rs1:=TRegister((aInstruction shr 7) and $1f);
         Temporary:=fState.PC+2;
         fState.PC:=fState.Registers[rs1]-2;
         fState.Registers[TRegister.RA]:=Temporary;
         result:=2;
         exit;
        end;
        else begin
         // c.add
         rd:=TRegister((aInstruction shr 7) and $1f);
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          rs1:=TRegister((aInstruction shr 2) and $1f);
          fState.Registers[rd]:=fState.Registers[rd]+fState.Registers[rs1];
         end;
         result:=2;
         exit;
        end;
       end;
      end else begin
       // c.ebreak
       Breakpoint(aInstruction);
       result:=2;
       exit;
      end;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
     // c.fsdsp
     if fState.CSR.IsFPUEnabled then begin
      frs1:=TFPURegister((aInstruction shr 2) and $1f);
      Offset:=(((aInstruction shr 1) and $1c0) or ((aInstruction shr 7) and $38));
{$ifdef UseSpecializedRegisterLoadStores}
      StoreRegisterF64(fState.Registers[TRegister.SP]+Offset,frs1);
{$else}
      Store64(fState.Registers[TRegister.SP]+Offset,fState.FPURegisters[frs1].ui64);
{$endif}
      result:=2;
      exit;
     end else begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
      result:=2;
      exit;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
     // c.swsp
     rs1:=TRegister((aInstruction shr 2) and $1f);
     Offset:=(((aInstruction shr 1) and $c0) or ((aInstruction shr 7) and $3c));
{$ifdef UseSpecializedRegisterLoadStores}
     StoreRegisterU32(fState.Registers[TRegister.SP]+Offset,rs1);
{$else}
     Store32(fState.Registers[TRegister.SP]+Offset,fState.Registers[rs1]);
{$endif}
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}else{-$7:}{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
     // c.sdsp
     rs1:=TRegister((aInstruction shr 2) and $1f);
     Offset:=(((aInstruction shr 1) and $1c0) or ((aInstruction shr 7) and $38));
{$ifdef UseSpecializedRegisterLoadStores}
     StoreRegisterU64(fState.Registers[TRegister.SP]+Offset,rs1);
{$else}
     Store64(fState.Registers[TRegister.SP]+Offset,fState.Registers[rs1]);
{$endif}
     result:=2;
     exit;
    end;
   end;
  end;

  {$ifdef TryToForceCaseJumpTableOnLevel1}
{  $03,$07,$0b,$0f,$13,$17,$1b,$1f,$23,$27,$2b,$2f,$33,$37,$3b,$3f,
   $43,$47,$4b,$4f,$53,$57,$5b,$5f,$63,$67,$6b,$6f,$73,$77,$7b,$7f,
   $83,$87,$8b,$8f,$93,$97,$9b,$9f,$a3,$a7,$ab,$af,$b3,$b7,$bb,$bf,
   $c3,$c7,$cb,$cf,$d3,$d7,$db,$df,$e3,$e7,$eb,$ef,$f3,$f7,$fb,$ff:begin}
  {$else}
   else {-$03:}begin

    case aInstruction and $7f of
  {$endif}

    //////////////////////////////////////////////////////////////////////////////
    // Load                                                                     //
    //////////////////////////////////////////////////////////////////////////////
    $03{$ifdef TryToForceCaseJumpTableOnLevel1},$83{$endif}:begin
     // Immediate[11:0] = inst[31:20]
     rd:=TRegister((aInstruction shr 7) and $1f);
     rs1:=TRegister((aInstruction shr 15) and $1f);
     Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction{and TPasRISCVUInt32($fff00000)}))),20);
     Address:=fState.Registers[rs1]+Immediate;
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       // lb
{$ifdef UseSpecializedRegisterLoadStores}
       LoadRegisterS8(rd,Address);
{$else}
       Temporary:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Load8(Address))));
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // lh
{$ifdef UseSpecializedRegisterLoadStores}
       LoadRegisterS16(rd,Address);
{$else}
       Temporary:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Load16(Address))));
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
       // lw
{$ifdef UseSpecializedRegisterLoadStores}
       LoadRegisterS32(rd,Address);
{$else}
       Temporary:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Load32(Address))));
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
       // ld
{$ifdef UseSpecializedRegisterLoadStores}
       LoadRegisterU64(rd,Address);
{$else}
       Temporary:=Load64(Address);
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
       // lbu
{$ifdef UseSpecializedRegisterLoadStores}
       LoadRegisterU8(rd,Address);
{$else}
       Temporary:=Load8(Address);
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
       // lhu
{$ifdef UseSpecializedRegisterLoadStores}
       LoadRegisterU16(rd,Address);
{$else}
       Temporary:=Load16(Address);
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
       // lwu
{$ifdef UseSpecializedRegisterLoadStores}
       LoadRegisterU32(rd,Address);
{$else}
       Temporary:=Load32(Address);
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}else{-$7:}{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // Misc. Mem                                                                //
    //////////////////////////////////////////////////////////////////////////////
    $0f{$ifdef TryToForceCaseJumpTableOnLevel1},$8f{$endif}:begin
     // A fence instruction does nothing because this emulator executes an instruction sequentially on a single thread.
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       if aInstruction=TPasRISCVUInt32($0100000f) then begin
        // pause
        Sleep(0);
        result:=4;
        exit;
       end else if ((aInstruction and TPasRISCVUInt32($05000000))<>0) and ((aInstruction and TPasRISCVUInt32($00a00000))<>0) then begin
        // StoreLoad fence (SEQ_CST)
        TPasMPMemoryBarrier.ReadDependency;
        TPasMPInterlocked.BitwiseOr(TPasMPUInt64(fState.Bounce.ui64),0);
        result:=4;
        exit;
       end else begin
        // LoadLoad, LoadStore, StoreStore fence (ACQ_REL)
        TPasMPMemoryBarrier.ReadWrite;
        result:=4;
        exit;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // fence.i
       // TODO: JIT flush in the future
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
       // cbo
       case aInstruction shr 20 of
        $00:begin
         // cbo.inval
         if (((aInstruction shr 7) and 15)=0) and IsCSRENVCFGEnabled(TCSR.ENVCFG_CBIE) then begin
          TPasMPMemoryBarrier.ReadWrite;
          result:=4;
          exit;
         end else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
        $01,$02:begin
         // cbo.clean, cbo.flush
         if (((aInstruction shr 7) and 15)=0) and IsCSRENVCFGEnabled(TCSR.ENVCFG_CBCFE) then begin
          TPasMPMemoryBarrier.ReadWrite;
          result:=4;
          exit;
         end else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
        $04:begin
         // cbo.zero
         if (((aInstruction shr 7) and 15)=0) and IsCSRENVCFGEnabled(TCSR.ENVCFG_CBZE) then begin
          rs1:=TRegister((aInstruction shr 15) and $1f);
          Ptr:=RMWTranslate(fState.Registers[rs1] and TPasRISCVUInt64($ffffffffffffffc0),64,nil,false);
          if assigned(Ptr) then begin
           FillChar(Ptr^,64,#0);
          end;
          result:=4;
          exit;
         end else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // Imm                                                                      //
    //////////////////////////////////////////////////////////////////////////////
    $13{$ifdef TryToForceCaseJumpTableOnLevel1},$93{$endif}:begin
     // Immediate[11:0] = inst[31:20]
     Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction{and TPasRISCVUInt32($fff00000)}))),20);
     rd:=TRegister((aInstruction shr 7) and $1f);
     rs1:=TRegister((aInstruction shr 15) and $1f);
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       // addi
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=fState.Registers[rs1]+TPasRISCVUInt64(Immediate);
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // slli bseti bclri binvi
       {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}:=(aInstruction shr 20) and $3f;
       case ((aInstruction shr 25) and $7f) shr 1 of
        $00:begin
         // slli
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] shl {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif};
         end;
         result:=4;
         exit;
        end;
        $14:begin
         // bseti (Zbs)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] or (TPasRISCVUInt64(1) shl {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif});
         end;
         result:=4;
         exit;
        end;
        $24:begin
         // bclri (Zbs)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] and not TPasRISCVUInt64(TPasRISCVUInt64(1) shl {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif});
         end;
         result:=4;
         exit;
        end;
        $30:begin
         // Zbb
         case {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif} of
          $00:begin
           // clz (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=CLZQWord(fState.Registers[rs1]);
           end;
          end;
          $01:begin
           // ctx (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=CTZQWord(fState.Registers[rs1]);
           end;
          end;
          $02:begin
           // cpop (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=POPCNTQWord(fState.Registers[rs1]);
           end;
          end;
          $04:begin
           // sext.b (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(TPasRISCVUInt8(fState.Registers[rs1]))));
           end;
          end;
          $05:begin
           // sext.h (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(TPasRISCVUInt16(fState.Registers[rs1]))));
           end;
          end;
          else begin
           SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
           result:=4;
           exit;
          end;
         end;
        end;
        $34:begin
         // binvi (Zbs)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] xor (TPasRISCVUInt64(1) shl {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif});
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
       // slti
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=ord(TPasRISCVInt64(fState.Registers[rs1])<TPasRISCVInt64(Immediate)) and 1;
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
       // sltiu
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=ord(fState.Registers[rs1]<TPasRISCVUInt64(Immediate)) and 1;
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
       // xori
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=fState.Registers[rs1] xor TPasRISCVUInt64(Immediate);
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
       // srli srai bexti orcb.b rev8
       {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}:=(aInstruction shr 20) and $3f;
       case ((aInstruction shr 25) and $7f) shr 1 of
        $00:begin
         // srli
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] shr {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif};
         end;
         result:=4;
         exit;
        end;
        $10:begin
         // srai
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=SARInt64(fState.Registers[rs1],{$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif});
         end;
         result:=4;
         exit;
        end;
        $14:begin
         case {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif} of
          $07:begin
           // orc.b (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=BitwiseOrCombine(fState.Registers[rs1]);
           end;
           result:=4;
           exit;
          end;
          else begin
           SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
           result:=4;
           exit;
          end;
         end;
        end;
        $24:begin
         // bexti (Zbs)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=(fState.Registers[rs1] shr {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}) and 1;
         end;
         result:=4;
         exit;
        end;
        $30:begin
         // rori (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=RORQWord(fState.Registers[rs1],{$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif});
         end;
         result:=4;
         exit;
        end;
        $34:begin
         case {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif} of
          $38:begin
           // rev8 (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=ByteSwap64(fState.Registers[rs1]);
           end;
           result:=4;
           exit;
          end;
          else begin
           SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
           result:=4;
           exit;
          end;
         end;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
       // ori
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=fState.Registers[rs1] or TPasRISCVUInt64(Immediate);
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$7:{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
       // andi
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=fState.Registers[rs1] and TPasRISCVUInt64(Immediate);
       end;
       result:=4;
       exit;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // auipc                                                                    //
    //////////////////////////////////////////////////////////////////////////////
    $17{$ifdef TryToForceCaseJumpTableOnLevel1},$97{$endif}:begin
     // auipc
     rd:=TRegister((aInstruction shr 7) and $1f);
     {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
      Immediate:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($fffff000))));
      fState.Registers[rd]:=fState.PC+TPasRISCVUInt64(Immediate);
     end;
     result:=4;
     exit;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // Imm32                                                                    //
    //////////////////////////////////////////////////////////////////////////////
    $1b{$ifdef TryToForceCaseJumpTableOnLevel1},$9b{$endif}:begin
     rd:=TRegister((aInstruction shr 7) and $1f);
     rs1:=TRegister((aInstruction shr 15) and $1f);
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       // addiw
       Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction{and TPasRISCVUInt32($fff00000)}))),20);
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(fState.Registers[rs1])+Immediate)));
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // slliw slli.uw
       case (aInstruction shr 25) and $7f of
        $00:begin
         // slliw
         {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}:=(aInstruction shr 20) and $1f;
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(fState.Registers[rs1]) shl TPasRISCVUInt64({$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}))));
         end;
         result:=4;
         exit;
        end;
        $04,$05:begin
         // slli.uw
         {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}:=(aInstruction shr 20) and $3f;
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVUInt32(fState.Registers[rs1]) shl TPasRISCVUInt64({$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif});
         end;
         result:=4;
         exit;
        end;
        $30:begin
         case (aInstruction shr 20) and $1f of
          $00:begin
           // clzw (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=CLZDWord(TPasRISCVUInt32(fState.Registers[rs1]));
           end;
           result:=4;
           exit;
          end;
          $01:begin
           // ctxw (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=CTZDWord(TPasRISCVUInt32(fState.Registers[rs1]));
           end;
           result:=4;
           exit;
          end;
          $02:begin
           // cpopw (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=POPCNTDWord(TPasRISCVUInt32(fState.Registers[rs1]));
           end;
           result:=4;
           exit;
          end;
          else begin
           SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
           result:=4;
           exit;
          end;
         end;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
       // srliw sraiw roriw
       {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}:=(aInstruction shr 20) and $1f;
       case (aInstruction shr 25) and $7f of
        $00:begin
         // srliw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(TPasRISCVUInt32(fState.Registers[rs1]) shr TPasRISCVUInt64({$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}))));
         end;
         result:=4;
         exit;
        end;
        $20:begin
         // sraiw
         Immediate:=(aInstruction shr 20) and $1f;
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=SARLongint(fState.Registers[rs1],TPasRISCVUInt64({$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}));
         end;
         result:=4;
         exit;
        end;
        $30:begin
         // roriw (Zbb)
         Immediate:=(aInstruction shr 20) and $1f;
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(RORDWord(TPasRISCVUInt32(fState.Registers[rs1]),TPasRISCVUInt32({$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif})))));
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // Store                                                                    //
    //////////////////////////////////////////////////////////////////////////////
    $23{$ifdef TryToForceCaseJumpTableOnLevel1},$a3{$endif}:begin
     // Immediate[11:5|4:0] = inst[31:25|11:7]
//   Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($fe000000)))),20) or ((aInstruction shr 7) and $1f);
     Immediate:=SignExtend((((aInstruction shr 25) and $7f) shl 5) or ((aInstruction shr 7) and $1f),12);
     rs1:=TRegister((aInstruction shr 15) and $1f);
     rs2:=TRegister((aInstruction shr 20) and $1f);
     Address:=fState.Registers[rs1]+Immediate;
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       // sb
{$ifdef UseSpecializedRegisterLoadStores}
       StoreRegisterU8(Address,rs2);
{$else}
       Store8(Address,fState.Registers[rs2] and $ff);
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // sh
{$ifdef UseSpecializedRegisterLoadStores}
       StoreRegisterU16(Address,rs2);
{$else}
       Store16(Address,fState.Registers[rs2] and $ffff);
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
       // sw
{$ifdef UseSpecializedRegisterLoadStores}
       StoreRegisterU32(Address,rs2);
{$else}
       Store32(Address,fState.Registers[rs2] and $ffffffff);
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
       // sd
{$ifdef UseSpecializedRegisterLoadStores}
       StoreRegisterU64(Address,rs2);
{$else}
       Store64(Address,fState.Registers[rs2]);
{$endif}
       result:=4;
       exit;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // Op                                                                       //
    //////////////////////////////////////////////////////////////////////////////
    $33{$ifdef TryToForceCaseJumpTableOnLevel1},$b3{$endif}:begin
     // "SLL, SRL, and SRA perform logical left, logical right, and arithmetic right
     // shifts on the value in register rs1 by the shift amount held in register rs2.
     // In RV64I, only the low 6 bits of rs2 are considered for the shift amount."
     rd:=TRegister((aInstruction shr 7) and $1f);
     rs1:=TRegister((aInstruction shr 15) and $1f);
     rs2:=TRegister((aInstruction shr 20) and $1f);
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       // add, sub, sub
       case (aInstruction shr 25) and $7f of
        $00:begin
         // add
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1]+fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // mul
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1]*fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        $20:begin
         // sub
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1]-fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // sll mulh clmul bset bclr rol binv
       case (aInstruction shr 25) and $7f of
        $00:begin
         // sll
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] shl (fState.Registers[rs2] and $3f);
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // mulh
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=MULH(TPasRISCVInt64(fState.Registers[rs1]),TPasRISCVInt64(fState.Registers[rs2]));
         end;
         result:=4;
         exit;
        end;
        $05:begin
         // clmul (Zbc)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=CLMul64(TPasRISCVUInt64(fState.Registers[rs1]),TPasRISCVUInt64(fState.Registers[rs2]));
         end;
         result:=4;
         exit;
        end;
        $14:begin
         // bset (Zbs)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] or (TPasRISCVUInt64(1) shl (fState.Registers[rs2] and $3f));
         end;
         result:=4;
         exit;
        end;
        $24:begin
         // bclr (Zbs)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] and not TPasRISCVUInt64(TPasRISCVUInt64(1) shl (fState.Registers[rs2] and $3f));
         end;
         result:=4;
         exit;
        end;
        $30:begin
         // rol (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=ROLQWord(fState.Registers[rs1],fState.Registers[rs2] and $3f);
         end;
         result:=4;
         exit;
        end;
        $34:begin
         // binv (Zbs)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] xor (TPasRISCVUInt64(1) shl (fState.Registers[rs2] and $3f));
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
       // slt mulhsu clmulr sh1add
       case (aInstruction shr 25) and $7f of
        $00:begin
         // slt
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=ord(TPasRISCVInt64(fState.Registers[rs1])<TPasRISCVInt64(fState.Registers[rs2])) and 1;
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // mulhsu
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=MULHSU(TPasRISCVInt64(fState.Registers[rs1]),fState.Registers[rs2]);
         end;
         result:=4;
         exit;
        end;
        $05:begin
         // clmulr (Zbc)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=CLMulR64(TPasRISCVUInt64(fState.Registers[rs1]),TPasRISCVUInt64(fState.Registers[rs2]));
         end;
         result:=4;
         exit;
        end;
        $10:begin
         // sh1add (Zba)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs2]+(fState.Registers[rs1] shl 1);
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
       // sltu mulhu clmulh
       case (aInstruction shr 25) and $7f of
        $00:begin
         // sltu
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=ord(fState.Registers[rs1]<fState.Registers[rs2]) and 1;
         end;
         result:=4;
         exit;
        end;
        $01:begin
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=MULHU(fState.Registers[rs1],fState.Registers[rs2]);
         end;
         result:=4;
         exit;
        end;
        $05:begin
         // clmulh (Zbc)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=CLMulH64(TPasRISCVUInt64(fState.Registers[rs1]),TPasRISCVUInt64(fState.Registers[rs2]));
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
       // xor div sh2add xnor min
       case (aInstruction shr 25) and $7f of
        $00:begin
         // xor
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] xor fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // div
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if fState.Registers[rs2]=0 then begin
           fState.Registers[rd]:=TPasRISCVUInt64($ffffffffffffffff);
          end else if (TPasRISCVInt64(fState.Registers[rs1])=Low(TPasRISCVInt64)) and (TPasRISCVInt64(fState.Registers[rs2])=-1) then begin
           fState.Registers[rd]:=TPasRISCVInt64(fState.Registers[rs1]);
          end else begin
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(fState.Registers[rs1]) div TPasRISCVInt64(fState.Registers[rs2])));
          end;
         end;
         result:=4;
         exit;
        end;
        $05:begin
         // min (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if TPasRISCVInt64(fState.Registers[rs1])<TPasRISCVInt64(fState.Registers[rs2]) then begin
           fState.Registers[rd]:=fState.Registers[rs1];
          end else begin
           fState.Registers[rd]:=fState.Registers[rs2];
          end;
         end;
         result:=4;
         exit;
        end;
        $10:begin
         // sh2add (Zba)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs2]+(fState.Registers[rs1] shl 2);
         end;
         result:=4;
         exit;
        end;
        $20:begin
         // xnor (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] xor not fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
       // srl divu sra bext minu ror czero.eqz
       case (aInstruction shr 25) and $7f of
        $00:begin
         // srl
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] shr (fState.Registers[rs2] and $3f);
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // divu
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if fState.Registers[rs2]=0 then begin
           fState.Registers[rd]:=TPasRISCVUInt64($ffffffffffffffff);
          end else begin
           fState.Registers[rd]:=fState.Registers[rs1] div fState.Registers[rs2];
          end;
         end;
         result:=4;
         exit;
        end;
        $05:begin
         // minu (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if TPasRISCVUInt64(fState.Registers[rs1])<TPasRISCVUInt64(fState.Registers[rs2]) then begin
           fState.Registers[rd]:=fState.Registers[rs1];
          end else begin
           fState.Registers[rd]:=fState.Registers[rs2];
          end;
         end;
         result:=4;
         exit;
        end;
        $07:begin
         // czero.eqz (Zicond)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if fState.Registers[rs2]<>0 then begin
           fState.Registers[rd]:=fState.Registers[rs1];
          end else begin
           fState.Registers[rd]:=0;
          end;
         end;
         result:=4;
         exit;
        end;
        $20:begin
         // sra
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=SARInt64(fState.Registers[rs1],fState.Registers[rs2] and $3f);
         end;
         result:=4;
         exit;
        end;
        $24:begin
         // bext (Zbs)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=(fState.Registers[rs1] shr (fState.Registers[rs2] and $3f)) and 1;
         end;
         result:=4;
         exit;
        end;
        $30:begin
         // ror (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=RORQWord(fState.Registers[rs1],fState.Registers[rs2] and $3f);
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
       // or rem sh3add orn max
       case (aInstruction shr 25) and $7f of
        $00:begin
         // or
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] or fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // rem
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if fState.Registers[rs2]=0 then begin
           fState.Registers[rd]:=fState.Registers[rs1];
          end else if (TPasRISCVInt64(fState.Registers[rs1])=Low(TPasRISCVInt64)) and (TPasRISCVInt64(fState.Registers[rs2])=-1) then begin
           fState.Registers[rd]:=0;
          end else begin
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(fState.Registers[rs1]) mod TPasRISCVInt64(fState.Registers[rs2])));
          end;
         end;
         result:=4;
         exit;
        end;
        $05:begin
         // max (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if TPasRISCVInt64(fState.Registers[rs1])>TPasRISCVInt64(fState.Registers[rs2]) then begin
           fState.Registers[rd]:=fState.Registers[rs1];
          end else begin
           fState.Registers[rd]:=fState.Registers[rs2];
          end;
         end;
         result:=4;
         exit;
        end;
        $10:begin
         // sh3add (Zba)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs2]+(fState.Registers[rs1] shl 3);
         end;
         result:=4;
         exit;
        end;
        $20:begin
         // orn (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] or not fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$7:{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
       // and remu andn maxu czero.nez
       case (aInstruction shr 25) and $7f of
        $00:begin
         // and
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] and fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // remu
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if fState.Registers[rs2]=0 then begin
           fState.Registers[rd]:=fState.Registers[rs1];
          end else begin
           fState.Registers[rd]:=fState.Registers[rs1] mod fState.Registers[rs2];
          end;
         end;
         result:=4;
         exit;
        end;
        $05:begin
         // maxu (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if TPasRISCVUInt64(fState.Registers[rs1])>TPasRISCVUInt64(fState.Registers[rs2]) then begin
           fState.Registers[rd]:=fState.Registers[rs1];
          end else begin
           fState.Registers[rd]:=fState.Registers[rs2];
          end;
         end;
         result:=4;
         exit;
        end;
        $07:begin
         // czero.nez (Zicond)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if fState.Registers[rs2]<>0 then begin
           fState.Registers[rd]:=0;
          end else begin
           fState.Registers[rd]:=fState.Registers[rs1];
          end;
         end;
         result:=4;
         exit;
        end;
        $20:begin
         // andn (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] and not fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // lui                                                                      //
    //////////////////////////////////////////////////////////////////////////////
    $37{$ifdef TryToForceCaseJumpTableOnLevel1},$b7{$endif}:begin
     // lui
     rd:=TRegister((aInstruction shr 7) and $1f);
     {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
      Immediate:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($fffff000))));
      fState.Registers[rd]:=TPasRISCVUInt64(Immediate);
     end;
     result:=4;
     exit;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // Op32                                                                     //
    //////////////////////////////////////////////////////////////////////////////
    $3b{$ifdef TryToForceCaseJumpTableOnLevel1},$bb{$endif}:begin
     // "The shift amount is given by rs2[4:0]."
     rd:=TRegister((aInstruction shr 7) and $1f);
     rs1:=TRegister((aInstruction shr 15) and $1f);
     rs2:=TRegister((aInstruction shr 20) and $1f);
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       // addw mulw subw add.uw
       case (aInstruction shr 25) and $7f of
        $00:begin
         // addw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(fState.Registers[rs1])+TPasRISCVUInt32(fState.Registers[rs2])));
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // mulw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(TPasRISCVUInt32(fState.Registers[rs1])*TPasRISCVUInt32(fState.Registers[rs2]))));
         end;
         result:=4;
         exit;
        end;
        $04:begin
         // add.uw (Zba)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs2]+TPasRISCVUInt64(TPasRISCVUInt32(fState.Registers[rs1]));
         end;
         result:=4;
         exit;
        end;
        $20:begin
         // subw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(fState.Registers[rs1])-TPasRISCVUInt32(fState.Registers[rs2])));
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // sllw rolw
       case (aInstruction shr 25) and $7f of
        $00:begin
         // sllw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(TPasRISCVUInt32(fState.Registers[rs1]) shl (fState.Registers[rs2] and $1f))));
         end;
         result:=4;
         exit;
        end;
        $30:begin
         // rolw (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVInt32(ROLDWord(TPasRISCVUInt32(fState.Registers[rs1]),fState.Registers[rs2] and $1f))));
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
       // sh1add.uw
       case (aInstruction shr 25) and $7f of
        $10:begin
         // sh1add.uw (Zba)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs2]+(TPasRISCVUInt64(TPasRISCVUInt32(fState.Registers[rs1])) shl 1);
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
       // divw sha2add.uw
       case (aInstruction shr 25) and $7f of
        $01:begin
         // divw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if TPasRISCVUInt32(fState.Registers[rs2])=0 then begin
           fState.Registers[rd]:=TPasRISCVUInt64($ffffffffffffffff);
          end else if (TPasRISCVInt32(fState.Registers[rs1])=Low(TPasRISCVInt32)) and (TPasRISCVInt32(fState.Registers[rs2])=-1) then begin
           fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(fState.Registers[rs1]));
          end else begin
           fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVInt32(fState.Registers[rs1]) div TPasRISCVInt32(fState.Registers[rs2])));
          end;
         end;
         result:=4;
         exit;
        end;
        $04:begin
         if TPasRISCVUInt64(rs2)=0 then begin
          // zext.h (Zbb)
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVUInt16(fState.Registers[rs1]));
          end;
          result:=4;
          exit;
         end else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
        $10:begin
         // sh2add.uw (Zba)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs2]+(TPasRISCVUInt64(TPasRISCVUInt32(fState.Registers[rs1])) shl 2);
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
       // srlw divuw sraw rorw
       case (aInstruction shr 25) and $7f of
        $00:begin
         // srlw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(TPasRISCVUInt32(fState.Registers[rs1]) shr (fState.Registers[rs2] and $1f)))));
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // divuw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if TPasRISCVUInt32(fState.Registers[rs2])=0 then begin
           fState.Registers[rd]:=TPasRISCVUInt64($ffffffffffffffff);
          end else begin
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(TPasRISCVUInt32(fState.Registers[rs1]) div TPasRISCVUInt32(fState.Registers[rs2])))));
          end;
         end;
         result:=4;
         exit;
        end;
        $20:begin
         // sraw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(SARLongint(TPasRISCVInt32(fState.Registers[rs1]),fState.Registers[rs2] and $1f)));
         end;
         result:=4;
         exit;
        end;
        $30:begin
         // rorw (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVInt32(RORDWord(TPasRISCVUInt32(fState.Registers[rs1]),fState.Registers[rs2] and $1f))));
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
       // remw sh3add.uw
       case (aInstruction shr 25) and $7f of
        $01:begin
         // remw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if TPasRISCVUInt32(fState.Registers[rs2])=0 then begin
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(fState.Registers[rs1]))));
          end else if (TPasRISCVInt32(fState.Registers[rs1])=Low(TPasRISCVInt32)) and (TPasRISCVInt32(fState.Registers[rs2])=-1) then begin
           fState.Registers[rd]:=0;
          end else begin
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVInt32(fState.Registers[rs1]) mod TPasRISCVInt32(fState.Registers[rs2]))));
          end;
         end;
         result:=4;
         exit;
        end;
        $10:begin
         // sh3add.uw (Zba)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs2]+(TPasRISCVUInt64(TPasRISCVUInt32(fState.Registers[rs1])) shl 3);
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$7:{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
       // remuw
       case (aInstruction shr 25) and $7f of
        $01:begin
         // remuw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if TPasRISCVUInt32(fState.Registers[rs2])=0 then begin
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(fState.Registers[rs1]))));
          end else begin
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(TPasRISCVUInt32(fState.Registers[rs1]) mod TPasRISCVUInt32(fState.Registers[rs2])))));
          end;
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // Branch                                                                   //
    //////////////////////////////////////////////////////////////////////////////
    $63{$ifdef TryToForceCaseJumpTableOnLevel1},$e3{$endif}:begin
     // Immediate[12|10:5|4:1|11] = inst[31|30:25|11:8|7]
     rs1:=TRegister((aInstruction shr 15) and $1f);
     rs2:=TRegister((aInstruction shr 20) and $1f);
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       // beq
       if fState.Registers[rs1]=fState.Registers[rs2] then begin
        Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($80000000)))),19) or
                   ((aInstruction and $80) shl 4) or
                   ((aInstruction shr 20) and $7e0) or
                   ((aInstruction shr 7) and $1e);
        inc(fState.PC,Immediate-4);
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // bne
       if fState.Registers[rs1]<>fState.Registers[rs2] then begin
        Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($80000000)))),19) or
                   ((aInstruction and $80) shl 4) or
                   ((aInstruction shr 20) and $7e0) or
                   ((aInstruction shr 7) and $1e);
        inc(fState.PC,Immediate-4);
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
       // blt
       if TPasRISCVInt64(fState.Registers[rs1])<TPasRISCVInt64(fState.Registers[rs2]) then begin
        Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($80000000)))),19) or
                   ((aInstruction and $80) shl 4) or
                   ((aInstruction shr 20) and $7e0) or
                   ((aInstruction shr 7) and $1e);
        inc(fState.PC,Immediate-4);
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
       // bge
       if TPasRISCVInt64(fState.Registers[rs1])>=TPasRISCVInt64(fState.Registers[rs2]) then begin
        Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($80000000)))),19) or
                   ((aInstruction and $80) shl 4) or
                   ((aInstruction shr 20) and $7e0) or
                   ((aInstruction shr 7) and $1e);
        inc(fState.PC,Immediate-4);
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
       // bltu
       if fState.Registers[rs1]<fState.Registers[rs2] then begin
        Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($80000000)))),19) or
                   ((aInstruction and $80) shl 4) or
                   ((aInstruction shr 20) and $7e0) or
                   ((aInstruction shr 7) and $1e);
        inc(fState.PC,Immediate-4);
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$7:{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
       // bgeu
       if fState.Registers[rs1]>=fState.Registers[rs2] then begin
        Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($80000000)))),19) or
                   ((aInstruction and $80) shl 4) or
                   ((aInstruction shr 20) and $7e0) or
                   ((aInstruction shr 7) and $1e);
        inc(fState.PC,Immediate-4);
       end;
       result:=4;
       exit;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // jalr                                                                     //
    //////////////////////////////////////////////////////////////////////////////
    $67{$ifdef TryToForceCaseJumpTableOnLevel1},$e7{$endif}:begin
     // jalr
     Temporary:=fState.PC+4;
     Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($fff00000)))),20);
     rd:=TRegister((aInstruction shr 7) and $1f);
     rs1:=TRegister((aInstruction shr 15) and $1f);
     fState.PC:=((fState.Registers[rs1]+TPasRISCVUInt64(Immediate)) and TPasRISCVUInt64($fffffffffffffffe))-4;
     {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
      fState.Registers[rd]:=Temporary;
     end;
     result:=4;
     exit;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // jal                                                                      //
    //////////////////////////////////////////////////////////////////////////////
    $6f{$ifdef TryToForceCaseJumpTableOnLevel1},$ef{$endif}:begin
     // jal
     rd:=TRegister((aInstruction shr 7) and $1f);
     {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
      fState.Registers[rd]:=fState.PC+4;
     end;
     Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($80000000)))),11) or // Immediate[20]
                (aInstruction and $ff000) or // Immediate[19:12]
                ((aInstruction shr 9) and $800) or // Immediate[11]
                ((aInstruction shr 20) and $7fe); // Immediate[10:1]
     inc(fState.PC,TPasRISCVUInt64(Immediate)-4);
     result:=4;
     exit;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // System                                                                   //
    //////////////////////////////////////////////////////////////////////////////
    $73{$ifdef TryToForceCaseJumpTableOnLevel1},$f3{$endif}:begin
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       // Environment call instructions
       case (aInstruction shr 25) and $7f of
        $09:begin
         // SFENCEVMA7
         if ((fState.Mode>=THART.TMode.Supervisor) and
             ((fState.CSR.fData[TCSR.TAddress.MSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.TVM))=0)) or
            (fState.Mode=THART.TMode.Machine) then begin
          rs1:=TRegister((aInstruction shr 15) and $1f);
          if rs1<>TRegister.Zero then begin
           FlushTLBPage(true,fState.Registers[rs1]);
          end else begin
           FlushTLB(true);
          end;
         end else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end;
         result:=4;
         exit;
        end;
        $11:begin
         // HFENCEBVMA7
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
        $51:begin
         // HFENCEGVMA7
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
        else begin
         case (aInstruction shr 20) and $1f of
          $00:begin
           // ecall
           case fState.Mode of
            THART.TMode.User:begin
             SetException(TExceptionValue.ECallUMode,fState.PC,fState.PC);
             result:=4;
             exit;
            end;
            THART.TMode.Supervisor:begin
             SetException(TExceptionValue.ECallSMode,fState.PC,fState.PC);
             result:=4;
             exit;
            end;
            THART.TMode.Hypervisor:begin
             SetException(TExceptionValue.ECallHMode,fState.PC,fState.PC);
             result:=4;
             exit;
            end;
            THART.TMode.Machine:begin
             SetException(TExceptionValue.ECallMMode,fState.PC,fState.PC);
             result:=4;
             exit;
            end;
            else begin
             SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
             result:=4;
             exit;
            end;
           end;
          end;
          $01:begin
           // ebreak
           Breakpoint(aInstruction);
           result:=4;
           exit;
          end;
          $02:begin
           // ret
           case (aInstruction shr 25) and $7f of
            $00:begin
             // uret7
             SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
             result:=4;
             exit;
            end;
            $08:begin
             // sret7
             if ((fState.Mode>=THART.TMode.Supervisor) and
                 ((fState.CSR.fData[TCSR.TAddress.MSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.TSR))=0)) or
                (fState.Mode=THART.TMode.Machine) then begin

              Temporary:=fState.CSR.fData[TCSR.TAddress.MSTATUS];

              SetMode(THART.TMode((Temporary shr TCSR.TMask.TSSTATUSBit.SPP) and 1));

              // Set SPP to U
              Temporary:=(Temporary and not (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPP)) or ((ord(THART.TMode.User) and 1) shl TCSR.TMask.TSSTATUSBit.SPP);

              // Set SIE to SPIE
              Temporary:=(Temporary and not (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SIE)) or (((Temporary shr TCSR.TMask.TSSTATUSBit.SPIE) and 1) shl TCSR.TMask.TSSTATUSBit.SIE);

//            Temporary:=Temporary or (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPIE);

              fState.CSR.fData[TCSR.TAddress.MSTATUS]:=Temporary;

              // Set PC to CSR.SEPC
              fState.PC:=fState.CSR.fData[TCSR.TAddress.SEPC]-4;

              CheckInterrupts;

              result:=4;
              exit;

             end else begin
              SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
              result:=4;
              exit;
             end;
            end;
            $18:begin
             // mret7
             if fState.Mode=THART.TMode.Machine then begin

              Temporary:=fState.CSR.fData[TCSR.TAddress.MSTATUS];

              SetMode(THART.TMode((Temporary shr TCSR.TMask.TMSTATUSBit.MPP) and 3));

              // Clear MPRV when returning to less privileged mode
              if fState.Mode<THART.TMode.Machine then begin
               Temporary:=Temporary and not (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MPRV);
              end;

              // Set MPP to U
              Temporary:=(Temporary and not (TPasRISCVUInt64(3) shl TCSR.TMask.TMSTATUSBit.MPP)) or ((ord(THART.TMode.User) and 3) shl TCSR.TMask.TMSTATUSBit.MPP);

              // Set MIE to MPIE
              Temporary:=(Temporary and not (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MIE)) or (((Temporary shr TCSR.TMask.TMSTATUSBit.MPIE) and 1) shl TCSR.TMask.TMSTATUSBit.MIE);

              fState.CSR.fData[TCSR.TAddress.MSTATUS]:=Temporary;

              // Set PC to CSR.MEPC
              fState.PC:=fState.CSR.fData[TCSR.TAddress.MEPC]-4;

              CheckInterrupts;

              result:=4;
              exit;

             end else begin
              SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
              result:=4;
              exit;
             end;
            end;
            else begin
             SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
             result:=4;
             exit;
            end;
           end;
          end;
          $05:begin
           // wfi
           case (aInstruction shr 25) and $7f of
            $08:begin
             // wfi7
             if ((fState.Mode>=THART.TMode.Supervisor) and
                 ((fState.CSR.fData[TCSR.TAddress.MSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.TW))=0)) or
                (fState.Mode=THART.TMode.Machine) then begin
              if InterruptsPending=0 then begin
               SleepUntilNextInterrupt;
              end;
             end else begin
              SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
             end;
             result:=4;
             exit;
            end;
            else begin
             SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
             result:=4;
             exit;
            end;
           end;
          end;
         end;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // csrrw
       Address:=aInstruction shr 20;
       rs1:=TRegister((aInstruction shr 15) and $1f);
       fCSRHandlerMap[Address](fState.PC,aInstruction,Address,fState.Registers[rs1],TCSROperation.Swap);
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
       // csrrs
       Address:=aInstruction shr 20;
       rs1:=TRegister((aInstruction shr 15) and $1f);
       fCSRHandlerMap[Address](fState.PC,aInstruction,Address,fState.Registers[rs1],TCSROperation.SetBits);
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
       // csrrc
       Address:=aInstruction shr 20;
       rs1:=TRegister((aInstruction shr 15) and $1f);
       fCSRHandlerMap[Address](fState.PC,aInstruction,Address,fState.Registers[rs1],TCSROperation.ClearBits);
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
       // csrrwi
       Address:=aInstruction shr 20;
       fCSRHandlerMap[Address](fState.PC,aInstruction,Address,(aInstruction shr 15) and $1f,TCSROperation.Swap);
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
       // csrrsi
       Address:=aInstruction shr 20;
       fCSRHandlerMap[Address](fState.PC,aInstruction,Address,(aInstruction shr 15) and $1f,TCSROperation.SetBits);
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$7:{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
       // csrrci
       Address:=aInstruction shr 20;
       fCSRHandlerMap[Address](fState.PC,aInstruction,Address,(aInstruction shr 15) and $1f,TCSROperation.ClearBits);
       result:=4;
       exit;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    // FPU

    //////////////////////////////////////////////////////////////////////////////
    // FPU Load                                                                 //
    //////////////////////////////////////////////////////////////////////////////
    $07{$ifdef TryToForceCaseJumpTableOnLevel1},$87{$endif}:begin
     // fl
     if not fState.CSR.IsFPUEnabled then begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
      result:=4;
      exit;
     end else begin
      case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
       {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
        // flw
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        rs1:=TRegister((aInstruction shr 15) and $1f);
        Offset:=TPasRISCVInt64(TPasRISCVInt32(SARLongint(TPasRISCVInt32(aInstruction),20)));
//      Offset:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(aInstruction)),20);
        Address:=fState.Registers[rs1]+TPasRISCVUInt64(Offset);
{$ifdef UseSpecializedRegisterLoadStores}
        LoadRegisterF32(frd,Address);
{$else}
        Temporary:=Load32(Address) or TPasRISCVUInt64($ffffffff00000000);
        if fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None then begin
         fState.FPURegisters[frd].ui64:=Temporary;
         fState.CSR.SetFSDirty;
        end;
{$endif}
        SetFPUExceptions(FE_ALL_EXCEPT and not FE_INEXACT);
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
        // fld
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        rs1:=TRegister((aInstruction shr 15) and $1f);
        Offset:=TPasRISCVInt64(TPasRISCVInt32(SARLongint(TPasRISCVInt32(aInstruction),20)));
//      Offset:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(aInstruction)),20);
        Address:=fState.Registers[rs1]+TPasRISCVUInt64(Offset);
{$ifdef UseSpecializedRegisterLoadStores}
        LoadRegisterF64(frd,Address);
{$else}
        Temporary:=Load64(Address);
        if fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None then begin
         fState.FPURegisters[frd].ui64:=Temporary;
         fState.CSR.SetFSDirty;
        end;
{$endif}
        SetFPUExceptions(FE_ALL_EXCEPT and not FE_INEXACT);
        result:=4;
        exit;
       end;
       else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
        result:=4;
        exit;
       end;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // FPU Store                                                                //
    //////////////////////////////////////////////////////////////////////////////
    $27{$ifdef TryToForceCaseJumpTableOnLevel1},$a7{$endif}:begin
     // fs
     if not fState.CSR.IsFPUEnabled then begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
      result:=4;
      exit;
     end else begin
      case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
       {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
        // fsw
        rs1:=TRegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        Offset:=SignExtend((((aInstruction shr 25) and $7f) shl 5) or ((aInstruction shr 7) and $1f),12);
        Address:=fState.Registers[rs1]+TPasRISCVUInt64(Offset);
{$ifdef UseSpecializedRegisterLoadStores}
        StoreRegisterF32(Address,frs2);
{$else}
        Store32(Address,fState.FPURegisters[frs2].ui64);
{$endif}
        SetFPUExceptions(FE_ALL_EXCEPT and not FE_INEXACT);
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
        // fsd
        rs1:=TRegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        Offset:=SignExtend((((aInstruction shr 25) and $7f) shl 5) or ((aInstruction shr 7) and $1f),12);
        Address:=fState.Registers[rs1]+TPasRISCVUInt64(Offset);
{$ifdef UseSpecializedRegisterLoadStores}
        StoreRegisterF64(Address,frs2);
{$else}
        Store64(Address,fState.FPURegisters[frs2].ui64);
{$endif}
        SetFPUExceptions(FE_ALL_EXCEPT and not FE_INEXACT);
        result:=4;
        exit;
       end;
       else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
        result:=4;
        exit;
       end;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // FPU Add                                                                  //
    //////////////////////////////////////////////////////////////////////////////
    $43{$ifdef TryToForceCaseJumpTableOnLevel1},$c3{$endif}:begin
     // fmadd
     if not fState.CSR.IsFPUEnabled then begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
      result:=4;
      exit;
     end else begin
      case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction and TPasRISCVUInt32($03000000)) shr 25) of
       {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
        // fmadd.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        fState.FPURegisters[frd].f32:=(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)*ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64))+ReadNormalizedFloatF32(fState.FPURegisters[frs3].ui64);
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        if fState.FPURegisters[frd].ui32=TPasRISCVUInt32($7fc00000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
        // fmadd.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        fState.FPURegisters[frd].f64:=(fState.FPURegisters[frs1].f64*fState.FPURegisters[frs2].f64)+fState.FPURegisters[frs3].f64;
        if fState.FPURegisters[frd].ui64=TPasRISCVUInt64($7ff8000000000000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
        result:=4;
        exit;
       end;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // FPU Sub                                                                  //
    //////////////////////////////////////////////////////////////////////////////
    $47{$ifdef TryToForceCaseJumpTableOnLevel1},$c7{$endif}:begin
     // fmsub
     if not fState.CSR.IsFPUEnabled then begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
      result:=4;
      exit;
     end else begin
      case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction and TPasRISCVUInt32($03000000)) shr 25) of
       {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
        // fmsub.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        fState.FPURegisters[frd].f32:=(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)*ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64))-ReadNormalizedFloatF32(fState.FPURegisters[frs3].ui64);
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        if fState.FPURegisters[frd].ui32=TPasRISCVUInt32($7fc00000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
        // fmsub.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        fState.FPURegisters[frd].f64:=(fState.FPURegisters[frs1].f64*fState.FPURegisters[frs2].f64)-fState.FPURegisters[frs3].f64;
        if fState.FPURegisters[frd].ui64=TPasRISCVUInt64($7ff8000000000000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
        result:=4;
        exit;
       end;
      end;
     end;
    end;

{$if defined(PasRISCVCPUDebug)}
    $7f:begin
     // Custom instruction
     case (aInstruction shr 8) and $ff of
      $00:begin
      end;
      $01:begin
{$if defined(PasRISCVCPUDumpDebug)}
       DumpDebug:=true;
{$ifend}
      end;
      $02:begin
{$if defined(PasRISCVCPUDebug)}
       DumpDebug:=false;
{$ifend}
      end;
      $03:begin
      end;
      else begin
      end;
     end;
     result:=4;
     exit;
    end;
{$ifend}

    //////////////////////////////////////////////////////////////////////////////
    // FPU NAdd                                                                 //
    //////////////////////////////////////////////////////////////////////////////
    $4b{$ifdef TryToForceCaseJumpTableOnLevel1},$cb{$endif}:begin
     // fnmadd
     if not fState.CSR.IsFPUEnabled then begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
      result:=4;
      exit;
     end else begin
      case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction and TPasRISCVUInt32($03000000)) shr 25) of
       {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
        // fnmadd.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        fState.FPURegisters[frd].f32:=((-ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64))*ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64))+ReadNormalizedFloatF32(fState.FPURegisters[frs3].ui64);
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        if fState.FPURegisters[frd].ui32=TPasRISCVUInt32($7fc00000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
        // fnmadd.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        fState.FPURegisters[frd].f64:=((-fState.FPURegisters[frs1].f64)*fState.FPURegisters[frs2].f64)+fState.FPURegisters[frs3].f64;
        if fState.FPURegisters[frd].ui64=TPasRISCVUInt64($7ff8000000000000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
        result:=4;
        exit;
       end;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // FPU NSub                                                                 //
    //////////////////////////////////////////////////////////////////////////////
    $4f{$ifdef TryToForceCaseJumpTableOnLevel1},$cf{$endif}:begin
     // fnmsub
     if not fState.CSR.IsFPUEnabled then begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
      result:=4;
      exit;
     end else begin
      case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction and TPasRISCVUInt32($03000000)) shr 25) of
       {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
        // fnmsub.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        fState.FPURegisters[frd].f32:=((-ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64))*ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64))-ReadNormalizedFloatF32(fState.FPURegisters[frs3].ui64);
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        if fState.FPURegisters[frd].ui32=TPasRISCVUInt32($7fc00000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
        // fnmsub.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        fState.FPURegisters[frd].f64:=((-fState.FPURegisters[frs1].f64)*fState.FPURegisters[frs2].f64)-fState.FPURegisters[frs3].f64;
        if fState.FPURegisters[frd].ui64=TPasRISCVUInt64($7ff8000000000000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
        result:=4;
        exit;
       end;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // FPU Op                                                                   //
    //////////////////////////////////////////////////////////////////////////////
    $53{$ifdef TryToForceCaseJumpTableOnLevel1},$d3{$endif}:begin
     // fother
     if not fState.CSR.IsFPUEnabled then begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
      result:=4;
      exit;
     end else begin
      case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 25) and $7f) of
       {$ifndef TryToForceCaseJumpTableOnLevel2}$00:{$else}$00,$80:{$endif}begin
        // fadd.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        if IsFloat32Infinite(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) and IsFloat32Infinite(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
         fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000);
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end else begin
         fState.FPURegisters[frd].f32:=ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)+ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64);
         if fState.FPURegisters[frd].ui32=TPasRISCVUInt32($7fc00000) then begin // Canonical NaN
          fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
         end;
        end;
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$01:{$else}$01,$81:{$endif}begin
        // fadd.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        if IsFloat64Infinite(fState.FPURegisters[frs1].f64) and IsFloat64Infinite(fState.FPURegisters[frs2].f64) then begin
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000);
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end else begin
         fState.FPURegisters[frd].f64:=fState.FPURegisters[frs1].f64+fState.FPURegisters[frs2].f64;
         if fState.FPURegisters[frd].ui64=TPasRISCVUInt64($7ff8000000000000) then begin // Canonical NaN
          fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
         end;
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$04:{$else}$04,$84:{$endif}begin
        // fsub.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        if IsFloat32Infinite(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) and IsFloat32Infinite(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
         fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000);
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end else begin
         fState.FPURegisters[frd].f32:=ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)-ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64);
         if fState.FPURegisters[frd].ui32=TPasRISCVUInt32($7fc00000) then begin // Canonical NaN
          fState.FPURegisters[frd].f32:=TPasRISCVUInt32($7fc00000);
          fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
         end;
        end;
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$05:{$else}$05,$85:{$endif}begin
        // fsub.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        if IsFloat64Infinite(fState.FPURegisters[frs1].f64) and IsFloat64Infinite(fState.FPURegisters[frs2].f64) then begin
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000);
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end else begin
         fState.FPURegisters[frd].f64:=fState.FPURegisters[frs1].f64-fState.FPURegisters[frs2].f64;
         if fState.FPURegisters[frd].ui64=TPasRISCVUInt64($7ff8000000000000) then begin // Canonical NaN
          fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
         end;
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$08:{$else}$08,$88:{$endif}begin
        // fmul.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        fState.FPURegisters[frd].f32:=ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)*ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64);
        if fState.FPURegisters[frd].ui32=TPasRISCVUInt32($7fc00000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$09:{$else}$09,$89:{$endif}begin
        // fmul.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        fState.FPURegisters[frd].f64:=fState.FPURegisters[frs1].f64*fState.FPURegisters[frs2].f64;
        if fState.FPURegisters[frd].ui64=TPasRISCVUInt64($7ff8000000000000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$0c:{$else}$0c,$8c:{$endif}begin
        // fdiv.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        fState.FPURegisters[frd].f32:=ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)/ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64);
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        if fState.FPURegisters[frd].ui32=TPasRISCVUInt32($7fc00000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$0d:{$else}$0d,$8d:{$endif}begin
        // fdiv.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        fState.FPURegisters[frd].f64:=fState.FPURegisters[frs1].f64/fState.FPURegisters[frs2].f64;
        if fState.FPURegisters[frd].ui64=TPasRISCVUInt64($7ff8000000000000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$10:{$else}$10,$90:{$endif}begin
        // fsngl.s
        case (aInstruction shr 12) and 7 of
         $0:begin
          // fsgnl.s
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          fState.FPURegisters[frd].ui64:=((ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64) and TPasRISCVUInt32($7fffffff)) or (ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64) and TPasRISCVUInt32($80000000))) or TPasRISCVUInt64($ffffffff00000000);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $1:begin
          // fsgnjn.s
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          fState.FPURegisters[frd].ui64:=((ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64) and TPasRISCVUInt32($7fffffff)) or ((not ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64)) and TPasRISCVUInt32($80000000))) or TPasRISCVUInt64($ffffffff00000000);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $2:begin
          // fsgnjx.s
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          fState.FPURegisters[frd].ui64:=((ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64) and TPasRISCVUInt32($7fffffff)) or ((ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64) xor ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64)) and TPasRISCVUInt32($80000000))) or TPasRISCVUInt64($ffffffff00000000);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$11:{$else}$11,$91:{$endif}begin
        // fsngl.d
        case (aInstruction shr 12) and 7 of
         $0:begin
          // fsgnl.d
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          fState.FPURegisters[frd].ui64:=(fState.FPURegisters[frs1].ui64 and TPasRISCVUInt64($7fffffffffffffff)) or (fState.FPURegisters[frs2].ui64 and TPasRISCVUInt64($8000000000000000));
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $1:begin
          // fsgnjn.d
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          fState.FPURegisters[frd].ui64:=(fState.FPURegisters[frs1].ui64 and TPasRISCVUInt64($7fffffffffffffff)) or ((not fState.FPURegisters[frs2].ui64) and TPasRISCVUInt64($8000000000000000));
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $2:begin
          // fsgnjx.d
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          fState.FPURegisters[frd].ui64:=(fState.FPURegisters[frs1].ui64 and TPasRISCVUInt64($7fffffffffffffff)) or ((fState.FPURegisters[frs1].ui64 xor fState.FPURegisters[frs2].ui64) and TPasRISCVUInt64($8000000000000000));
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$14:{$else}$14,$94:{$endif}begin
        // fminmax.s
        case (aInstruction shr 12) and 7 of
         $0:begin
          // fmin.s
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) or IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) then begin
           if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
            fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000); // Canonical NaN
           end else begin
            fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
           end;
          end else begin
           if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
            fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
           end else begin
            if ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)<ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64) then begin
             fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
            end else if ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)>ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64) then begin
             fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
            end else begin
             if (ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64) and $80000000)<>0 then begin
              fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
             end else begin
              fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
             end;
            end;
           end;
           fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $1:begin
          // fmax.s
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) or IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) then begin
           if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
            fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000); // Canonical NaN
           end else begin
            fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
           end;
          end else begin
           if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
            fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
           end else begin
            if ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)>ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64) then begin
             fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
            end else if ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)<ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64) then begin
             fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
            end else begin
             if (ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64) and $80000000)<>0 then begin
              fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
             end else begin
              fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
             end;
            end;
           end;
           fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$15:{$else}$15,$95:{$endif}begin
        // fminmax.d
        case (aInstruction shr 12) and 7 of
         $0:begin
          // fmin.d
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat64SignalingNaN(fState.FPURegisters[frs1].f64) or IsFloat64SignalingNaN(fState.FPURegisters[frs2].f64) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          if IsFloat64NaN(fState.FPURegisters[frs1].f64) then begin
           if IsFloat64NaN(fState.FPURegisters[frs2].f64) then begin
            fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000); // Canonical NaN
           end else begin
            fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs2].ui64;
           end;
          end else begin
           if IsFloat64NaN(fState.FPURegisters[frs2].f64) then begin
            fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs1].ui64;
           end else begin
            if fState.FPURegisters[frs1].f64<fState.FPURegisters[frs2].f64 then begin
             fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs1].ui64;
            end else if fState.FPURegisters[frs1].f64>fState.FPURegisters[frs2].f64 then begin
             fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs2].ui64;
            end else begin
             if (fState.FPURegisters[frs1].ui64 and TPasRISCVUInt64($8000000000000000))<>0 then begin
              fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs1].ui64;
             end else begin
              fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs2].ui64;
             end;
            end;
           end;
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $1:begin
          // fmax.d
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat64SignalingNaN(fState.FPURegisters[frs1].f64) or IsFloat64SignalingNaN(fState.FPURegisters[frs2].f64) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          if IsFloat64NaN(fState.FPURegisters[frs1].f64) then begin
           if IsFloat64NaN(fState.FPURegisters[frs2].f64) then begin
            fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000); // Canonical NaN
           end else begin
            fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs2].ui64;
           end;
          end else begin
           if IsFloat64NaN(fState.FPURegisters[frs2].f64) then begin
            fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs1].ui64;
           end else begin
            if fState.FPURegisters[frs1].f64>fState.FPURegisters[frs2].f64 then begin
             fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs1].ui64;
            end else if fState.FPURegisters[frs1].f64<fState.FPURegisters[frs2].f64 then begin
             fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs2].ui64;
            end else begin
             if (fState.FPURegisters[frs1].ui64 and TPasRISCVUInt64($8000000000000000))<>0 then begin
              fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs2].ui64;
             end else begin
              fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs1].ui64;
             end;
            end;
           end;
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$20:{$else}$20,$a0:{$endif}begin
        // fcvt.s.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        if IsFloat64NaN(fState.FPURegisters[frs1].f64) then begin
         fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000); // Canonical NaN
        end else begin
         fState.FPURegisters[frd].f32:=fState.FPURegisters[frs1].f64;
        end;
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$21:{$else}$21,$a1:{$endif}begin
        // fcvt.d.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) then begin
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000); // Canonical NaN
        end else begin
         fState.FPURegisters[frd].f64:=ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$2c:{$else}$2c,$ac:{$endif}begin
        // fsqrt.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        if ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)<0.0 then begin
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
         fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000); // Canonical NaN
        end else begin
         fState.FPURegisters[frd].f32:=sqrt(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64));
        end;
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$2d:{$else}$2d,$ad:{$endif}begin
        // fsqrt.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        if fState.FPURegisters[frs1].f64<0.0 then begin
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000); // Canonical NaN
        end else begin
         fState.FPURegisters[frd].f64:=sqrt(fState.FPURegisters[frs1].f64);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$50:{$else}$50,$d0:{$endif}begin
        // fc.s
        case (aInstruction shr 12) and 7 of
         $0:begin
          // fle.s
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) or IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)<=ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         $1:begin
          // flt.s
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) or IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)<ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         $2:begin
          // feq.s
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) or IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)=ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$51:{$else}$51,$d1:{$endif}begin
        // fc.d
        case (aInstruction shr 12) and 7 of
         $0:begin
          // fle.d
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat64NaN(fState.FPURegisters[frs1].f64) or IsFloat64NaN(fState.FPURegisters[frs2].f64) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(fState.FPURegisters[frs1].f64<=fState.FPURegisters[frs2].f64) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         $1:begin
          // flt.d
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat64NaN(fState.FPURegisters[frs1].f64) or IsFloat64NaN(fState.FPURegisters[frs2].f64) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(fState.FPURegisters[frs1].f64<fState.FPURegisters[frs2].f64) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         $2:begin
          // feq.d
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat64SignalingNaN(fState.FPURegisters[frs1].f64) or IsFloat64SignalingNaN(fState.FPURegisters[frs2].f64) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(fState.FPURegisters[frs1].f64=fState.FPURegisters[frs2].f64) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$60:{$else}$60,$e0:{$endif}begin
        // fcvt.w.s
        rd:=TRegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        f32:=ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64);
        Immediate:=(aInstruction shr 12) and 7;
        if Immediate=TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundDynamic) then begin
         Immediate:=fState.CSR.fData[TCSR.TAddress.FRM] and TPasRISCVUInt64(TCSR.TFloatingPointRoundingModes.Mask);
        end;
        case Immediate of
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundToNearestEven):begin
          f32n:=RoundToNearestTiesToEven32(f32);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundToZero):begin
          f32n:=Trunc(f32);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundDown):begin
          f32n:=Floor(f32);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundUp):begin
          f32n:=Ceil(f32);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundNearestMaxMagnitude):begin
          f32n:=RoundToNearestTiesToMaxMagnitude32(f32);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundDynamic):begin
          f32n:=Round(f32);
         end;
         else begin
          // Rounding mode values of 5 & 6 are illegal
          f32n:=f32;
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
        if f32n<>f32 then begin
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Inexact);
        end;
        case (aInstruction shr 20) and $1f of
         $00:begin
          // fcvt0
          if IsFloat32NaNOrInfinite(f32) or (f32n<Low(TPasRISCVInt32)) or (f32n>High(TPasRISCVInt32)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           if IsFloat32NaN(f32) or not IsFloat32Negative(f32) then begin
            fState.Registers[rd]:=TPasRISCVUInt32($000000007fffffff);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64($ffffffff80000000);
           end;
          end else {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           if IsFloat32NaN(f32) then begin
            if IsFloat32Negative(f32) then begin
             fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(-High(TPasRISCVInt32)));
            end else begin
             fState.Registers[rd]:=High(TPasRISCVInt32);
            end;
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(trunc(f32n))));
           end;
          end;
         end;
         $01:begin
          // fcvt1
          if IsFloat32NaNOrInfinite(f32) or (f32n<Low(TPasRISCVUInt32)) or (f32n>High(TPasRISCVUInt32)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           if IsFloat32NaN(f32) or not IsFloat32Negative(f32) then begin
            fState.Registers[rd]:=TPasRISCVUInt64($ffffffffffffffff);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64($0000000000000000);
           end;
          end else {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           if IsFloat32NaN(f32) then begin
            fState.Registers[rd]:=High(TPasRISCVUInt32);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(trunc(f32n)))));
           end;
          end;
         end;
         $02:begin
          // fcvt2
          if IsFloat32NaNOrInfinite(f32) or (f32n<=-9223372036854775808.0) or (f32n>=9223372036854775807.0) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           if IsFloat32NaN(f32) or not IsFloat32Negative(f32) then begin
            fState.Registers[rd]:=TPasRISCVUInt64($7fffffffffffffff);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64($8000000000000000);
           end;
          end else {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           if IsFloat32NaN(f32) then begin
            if IsFloat32Negative(f32) then begin
             fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(-High(TPasRISCVInt64)));
            end else begin
             fState.Registers[rd]:=High(TPasRISCVInt64);
            end;
           end else begin
            fState.Registers[rd]:=trunc(f32n);
           end;
          end;
         end;
         $03:begin
          // fcvt3
          if IsFloat32NaNOrInfinite(f32) or (f32n<0.0) or (f32n>=18446744073709551615.0) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           if IsFloat32NaN(f32) or not IsFloat32Negative(f32) then begin
            fState.Registers[rd]:=TPasRISCVUInt64($ffffffffffffffff);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64($0000000000000000);
           end;
          end else {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           if IsFloat32NaN(f32) then begin
            fState.Registers[rd]:=High(TPasRISCVUInt64);
           end else begin
            fState.Registers[rd]:=trunc(f32n);
           end;
          end;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end;
        end;
        SetFPUExceptions;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$61:{$else}$61,$e1:{$endif}begin
        // fcvt.w.d
        rd:=TRegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        f64:=fState.FPURegisters[frs1].f64;
        Immediate:=(aInstruction shr 12) and 7;
        if Immediate=TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundDynamic) then begin
         Immediate:=fState.CSR.fData[TCSR.TAddress.FRM] and TPasRISCVUInt64(TCSR.TFloatingPointRoundingModes.Mask);
        end;
        case Immediate of
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundToNearestEven):begin
          f64n:=RoundToNearestTiesToEven64(f64);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundToZero):begin
          f64n:=Trunc(f64);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundDown):begin
          f64n:=Floor(f64);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundUp):begin
          f64n:=Ceil(f64);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundNearestMaxMagnitude):begin
          f64n:=RoundToNearestTiesToMaxMagnitude64(f64);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundDynamic):begin
          f64n:=Round(f64);
         end;
         else begin
          // Rounding mode values of 5 & 6 are illegal
          f64n:=f64;
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
        if f64n<>f64 then begin
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Inexact);
        end;
        case (aInstruction shr 20) and $1f of
         $00:begin
          // fcvt0
          if IsFloat64NaNOrInfinite(f64) or (f64n<Low(TPasRISCVInt32)) or (f64n>High(TPasRISCVInt32)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           if IsFloat64NaN(f64) or not IsFloat64Negative(f64) then begin
            fState.Registers[rd]:=TPasRISCVUInt32($000000007fffffff);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64($ffffffff80000000);
           end;
          end else {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           if IsFloat64NaN(f64) then begin
            if IsFloat64Negative(f64) then begin
             fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(-High(TPasRISCVInt32)));
            end else begin
             fState.Registers[rd]:=High(TPasRISCVInt32);
            end;
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(trunc(f64n))));
           end;
          end;
         end;
         $01:begin
          // fcvt1
          if IsFloat64NaNOrInfinite(f64) or (f64n<Low(TPasRISCVUInt32)) or (f64n>High(TPasRISCVUInt32)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           if IsFloat64NaN(f64) or not IsFloat64Negative(f64) then begin
            fState.Registers[rd]:=TPasRISCVUInt64($ffffffffffffffff);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64($0000000000000000);
           end;
          end else {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           if IsFloat64NaN(f64) then begin
            fState.Registers[rd]:=High(TPasRISCVUInt32);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(trunc(f64n)))));
           end;
          end;
         end;
         $02:begin
          // fcvt2
          if IsFloat64NaNOrInfinite(f64) or (f64n<=-9223372036854775808.0) or (f64n>=9223372036854775807.0) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           if IsFloat64NaN(f64) or not IsFloat64Negative(f64) then begin
            fState.Registers[rd]:=TPasRISCVUInt64($7fffffffffffffff);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64($8000000000000000);
           end;
          end else {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           if IsFloat64NaN(f64) then begin
            if IsFloat64Negative(f64) then begin
             fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(-High(TPasRISCVInt64)));
            end else begin
             fState.Registers[rd]:=High(TPasRISCVInt64);
            end;
           end else begin
            fState.Registers[rd]:=trunc(f64n);
           end;
          end;
         end;
         $03:begin
          // fcvt3
          if IsFloat64NaNOrInfinite(f64) or (f64n<0.0) or (f64n>=18446744073709551615.0) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           if IsFloat64NaN(f64) or not IsFloat64Negative(f64) then begin
            fState.Registers[rd]:=TPasRISCVUInt64($ffffffffffffffff);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64($0000000000000000);
           end;
          end else {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           if IsFloat64NaN(f64) then begin
            fState.Registers[rd]:=High(TPasRISCVUInt64);
           end else begin
            fState.Registers[rd]:=trunc(f64n);
           end;
          end;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end;
        end;
        SetFPUExceptions;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$68:{$else}$68,$e8:{$endif}begin
        // fcvtsdw.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        rs1:=TRegister((aInstruction shr 15) and $1f);
        case (aInstruction shr 20) and $1f of
         0:begin
          // fcvt0
          fState.FPURegisters[frd].f32:=TPasRISCVInt32(fState.Registers[rs1]);
          fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
         end;
         1:begin
          // fcvt1
          fState.FPURegisters[frd].f32:=TPasRISCVUInt32(fState.Registers[rs1]);
          fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
         end;
         2:begin
          // fcvt2
          fState.FPURegisters[frd].f32:=TPasRISCVInt64(fState.Registers[rs1]);
          fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
         end;
         3:begin
          // fcvt3
          fState.FPURegisters[frd].f32:=TPasRISCVUInt64(fState.Registers[rs1]);
          fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end;
        end;
        SetFPUExceptions;
        if fState.ExceptionValue<>TExceptionValue.IllegalInstruction then begin
         fState.CSR.SetFSDirty;
        end;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$69:{$else}$69,$e9:{$endif}begin
        // fcvtdw.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        rs1:=TRegister((aInstruction shr 15) and $1f);
        case (aInstruction shr 20) and $1f of
         0:begin
          // fcvt0
          fState.FPURegisters[frd].f64:=TPasRISCVInt32(fState.Registers[rs1]);
         end;
         1:begin
          // fcvt1
          fState.FPURegisters[frd].f64:=TPasRISCVUInt32(fState.Registers[rs1]);
         end;
         2:begin
          // fcvt2
          fState.FPURegisters[frd].f64:=TPasRISCVInt64(fState.Registers[rs1]);
         end;
         3:begin
          // fcvt3
          fState.FPURegisters[frd].f64:=TPasRISCVUInt64(fState.Registers[rs1]);
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end;
        end;
        SetFPUExceptions;
        if fState.ExceptionValue<>TExceptionValue.IllegalInstruction then begin
         fState.CSR.SetFSDirty;
        end;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$70:{$else}$70,$f0:{$endif}begin
        // fmvxw
        case (aInstruction shr 12) and 7 of
         0:begin
          // fmvxw.s
          rd:=TRegister((aInstruction shr 7) and $1f);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           frs1:=TFPURegister((aInstruction shr 15) and $1f);
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(fState.FPURegisters[frs1].ui32)));
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         1:begin
          // fclass.s
          rd:=TRegister((aInstruction shr 7) and $1f);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           frs1:=TFPURegister((aInstruction shr 15) and $1f);
           f32:=fState.FPURegisters[frs1].f32;
           case Float32Classify(f32) of
            TPasRISCVFPType.Infinite:begin
             if IsFloat32Negative(f32) then begin
              fState.Registers[rd]:=TFClass.NEG_INF;
             end else begin
              fState.Registers[rd]:=TFClass.POS_INF;
             end;
            end;
            TPasRISCVFPType.QuietNaN:begin
             fState.Registers[rd]:=TFClass.NAN_QUIET;
            end;
            TPasRISCVFPType.SignalingNaN:begin
             fState.Registers[rd]:=TFClass.NAN_SIG;
            end;
            TPasRISCVFPType.Normal:begin
             if IsFloat32Negative(f32) then begin
              fState.Registers[rd]:=TFClass.NEG_NORMAL;
             end else begin
              fState.Registers[rd]:=TFClass.POS_NORMAL;
             end;
            end;
            TPasRISCVFPType.SubNormal:begin
             if IsFloat32Negative(f32) then begin
              fState.Registers[rd]:=TFClass.NEG_SUBNORMAL;
             end else begin
              fState.Registers[rd]:=TFClass.POS_SUBNORMAL;
             end;
            end;
            TPasRISCVFPType.Zero:begin
             if IsFloat32Negative(f32) then begin
              fState.Registers[rd]:=TFClass.NEG_ZERO;
             end else begin
              fState.Registers[rd]:=TFClass.POS_ZERO;
             end;
            end;
            else begin
             fState.Registers[rd]:=0;
            end;
           end;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$71:{$else}$71,$f1:{$endif}begin
        // fmvxd
        case (aInstruction shr 12) and 7 of
         0:begin
          // fmvxd.d
          rd:=TRegister((aInstruction shr 7) and $1f);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           frs1:=TFPURegister((aInstruction shr 15) and $1f);
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(fState.FPURegisters[frs1].ui64));
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         1:begin
          // fclass.d
          rd:=TRegister((aInstruction shr 7) and $1f);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           frs1:=TFPURegister((aInstruction shr 15) and $1f);
           f64:=fState.FPURegisters[frs1].f64;
           case Float64Classify(f64) of
            TPasRISCVFPType.Infinite:begin
             if IsFloat64Negative(f64) then begin
              fState.Registers[rd]:=TFClass.NEG_INF;
             end else begin
              fState.Registers[rd]:=TFClass.POS_INF;
             end;
            end;
            TPasRISCVFPType.QuietNaN:begin
             fState.Registers[rd]:=TFClass.NAN_QUIET;
            end;
            TPasRISCVFPType.SignalingNaN:begin
             fState.Registers[rd]:=TFClass.NAN_SIG;
            end;
            TPasRISCVFPType.Normal:begin
             if IsFloat64Negative(f64) then begin
              fState.Registers[rd]:=TFClass.NEG_NORMAL;
             end else begin
              fState.Registers[rd]:=TFClass.POS_NORMAL;
             end;
            end;
            TPasRISCVFPType.SubNormal:begin
             if IsFloat64Negative(f64) then begin
              fState.Registers[rd]:=TFClass.NEG_SUBNORMAL;
             end else begin
              fState.Registers[rd]:=TFClass.POS_SUBNORMAL;
             end;
            end;
            TPasRISCVFPType.Zero:begin
             if IsFloat64Negative(f64) then begin
              fState.Registers[rd]:=TFClass.NEG_ZERO;
             end else begin
              fState.Registers[rd]:=TFClass.POS_ZERO;
             end;
            end;
            else begin
             fState.Registers[rd]:=0;
            end;
           end;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$78:{$else}$78,$f8:{$endif}begin
        // fmvwx
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        rs1:=TRegister((aInstruction shr 15) and $1f);
        fState.FPURegisters[frd].ui64:=fState.Registers[rs1] or TPasRISCVUInt64($ffffffff00000000);
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$79:{$else}$79,$f9:{$endif}begin
        // fmvdx
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        rs1:=TRegister((aInstruction shr 15) and $1f);
        fState.FPURegisters[frd].ui64:=fState.Registers[rs1];
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
        result:=4;
        exit;
       end;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // AMO                                                                      //
    //////////////////////////////////////////////////////////////////////////////
    $2f{$ifdef TryToForceCaseJumpTableOnLevel1},$af{$endif}:begin
     // RV64A: "A" standard extension for atomic instructions
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
       // amow
       rd:=TRegister((aInstruction shr 7) and $1f);
       rs1:=TRegister((aInstruction shr 15) and $1f);
       rs2:=TRegister((aInstruction shr 20) and $1f);
       if (fState.Registers[rs1] and 3)<>0 then begin
        SetException(TExceptionValue.StoreAddressMisaligned,fState.Registers[rs1],fState.PC);
        result:=4;
        exit;
       end else begin
        case ((aInstruction shr 25) and $7c) shr 2 of
         $00:begin
          // amoadd.w
          Ptr:=RMWTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.Add(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWStore(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $01:begin
          // amoswap.w
          Ptr:=RMWTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.Exchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWStore(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $02:begin
          // lr.w
          Ptr:=RMWTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           fState.LSRC:=true;
           fState.LSRCAddress:=fState.Registers[rs1];
           fState.LSRCCAS:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(fState.LSRCCAS)));
           end;
          end;
          result:=4;
          exit;
         end;
         $03:begin
          // sc.w
          Ptr:=RMWTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           if fState.LSRC and
              (fState.LSRCAddress=fState.Registers[rs1]) and
              (TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]),TPasMPUInt32(fState.LSRCCAS))=TPasMPUInt32(fState.LSRCCAS)) then begin
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=0;
            end;
            if Ptr=@fState.Bounce.ui32 then begin
             RMWStore(fState.Registers[rs1],4,@fState.Bounce.ui32);
            end;
           end else begin
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=1;
            end;
           end;
           fState.LSRC:=false;
          end;
          result:=4;
          exit;
         end;
         $04:begin
          // amoxor.w
          Ptr:=RMWTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.ExchangeBitwiseXor(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWStore(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $05:begin
          // amocas.w (Zacas)
          Ptr:=RMWTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPUInt32(TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]),TPasMPUInt32(fState.Registers[rd])));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWStore(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $08:begin
          // amoor.w
          Ptr:=RMWTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.ExchangeBitwiseOr(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWStore(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $0c:begin
          // amoand.w
          Ptr:=RMWTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.ExchangeBitwiseAnd(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWStore(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $10:begin
          // amomin.w
          Ptr:=RMWTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           repeat
            Temporary:=TPasMPUInt64(TPasMPInt64(TPasMPInt32(TPasMPInterlocked.Read(PPasMPInt32(Ptr)^))));
            if TPasMPInt32(Temporary)<TPasMPInt32(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPInt32(Ptr)^,TPasMPInt32(Temporary),TPasMPInt32(Temporary))=TPasMPInt32(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPInt32(Ptr)^,TPasMPInt32(fState.Registers[rs2]),TPasMPInt32(Temporary))=TPasMPInt32(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWStore(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $14:begin
          // amomax.w
          Ptr:=RMWTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           repeat
            Temporary:=TPasMPUInt64(TPasMPInt64(TPasMPInt32(TPasMPInterlocked.Read(PPasMPInt32(Ptr)^))));
            if TPasMPInt32(Temporary)>TPasMPInt32(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPInt32(Ptr)^,TPasMPInt32(Temporary),TPasMPInt32(Temporary))=TPasMPInt32(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPInt32(Ptr)^,TPasMPInt32(fState.Registers[rs2]),TPasMPInt32(Temporary))=TPasMPInt32(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWStore(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $18:begin
          // amominu.w
          Ptr:=RMWTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           repeat
            Temporary:=TPasMPUInt64(TPasMPUInt32(TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^)));
            if TPasMPUInt32(Temporary)<TPasMPUInt32(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(Temporary),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWStore(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $1c:begin
          // amomaxu.w
          Ptr:=RMWTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           repeat
            Temporary:=TPasMPUInt64(TPasMPUInt32(TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^)));
            if TPasMPUInt32(Temporary)>TPasMPUInt32(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(Temporary),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWStore(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
       // amod
       rd:=TRegister((aInstruction shr 7) and $1f);
       rs1:=TRegister((aInstruction shr 15) and $1f);
       rs2:=TRegister((aInstruction shr 20) and $1f);
       if (fState.Registers[rs1] and 7)<>0 then begin
        SetException(TExceptionValue.StoreAddressMisaligned,fState.Registers[rs1],fState.PC);
        result:=4;
        exit;
       end else begin
        case ((aInstruction shr 25) and $7c) shr 2 of
         $00:begin
          // amoadd.d
          Ptr:=RMWTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.Add(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWStore(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $01:begin
          // amoswap.d
          Ptr:=RMWTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.Exchange(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWStore(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $02:begin
          // lr.d
          Ptr:=RMWTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           fState.LSRC:=true;
           fState.LSRCAddress:=fState.Registers[rs1];
           fState.LSRCCAS:=TPasMPInterlocked.Read(PPasMPUInt64(Ptr)^);
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(fState.LSRCCAS)));
           end;
          end;
          result:=4;
          exit;
         end;
         $03:begin
          // sc.d
          Ptr:=RMWTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           if fState.LSRC and
              (fState.LSRCAddress=fState.Registers[rs1]) and
              (TPasMPInterlocked.CompareExchange(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]),TPasMPUInt64(fState.LSRCCAS))=TPasMPUInt64(fState.LSRCCAS)) then begin
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=0;
            end;
            if Ptr=@fState.Bounce.ui64 then begin
             RMWStore(fState.Registers[rs1],8,@fState.Bounce.ui64);
            end;
           end else begin
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=1;
            end;
           end;
           fState.LSRC:=false;
          end;
          result:=4;
          exit;
         end;
         $04:begin
          // amoxor.d
          Ptr:=RMWTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.ExchangeBitwiseXor(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWStore(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $05:begin
          // amocas.d (Zacas)
          Ptr:=RMWTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPUInt64(TPasMPInterlocked.CompareExchange(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]),TPasMPUInt64(fState.Registers[rd])));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=Temporary;
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWStore(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $08:begin
          // amoor.d
          Ptr:=RMWTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.ExchangeBitwiseOr(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWStore(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $0c:begin
          // amoand.d
          Ptr:=RMWTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.ExchangeBitwiseAnd(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWStore(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $10:begin
          // amomin.d
          Ptr:=RMWTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           repeat
            Temporary:=TPasMPUInt64(TPasMPInt64(TPasMPInt64(TPasMPInterlocked.Read(PPasMPInt64(Ptr)^))));
            if TPasMPInt64(Temporary)<TPasMPInt64(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPInt64(Ptr)^,TPasMPInt64(Temporary),TPasMPInt64(Temporary))=TPasMPInt64(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPInt64(Ptr)^,TPasMPInt64(fState.Registers[rs2]),TPasMPInt64(Temporary))=TPasMPInt64(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWStore(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $14:begin
          // amomax.d
          Ptr:=RMWTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           repeat
            Temporary:=TPasMPUInt64(TPasMPInt64(TPasMPInt64(TPasMPInterlocked.Read(PPasMPInt64(Ptr)^))));
            if TPasMPInt64(Temporary)>TPasMPInt64(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPInt64(Ptr)^,TPasMPInt64(Temporary),TPasMPInt64(Temporary))=TPasMPInt64(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPInt64(Ptr)^,TPasMPInt64(fState.Registers[rs2]),TPasMPInt64(Temporary))=TPasMPInt64(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWStore(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $18:begin
          // amominu.d
          Ptr:=RMWTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           repeat
            Temporary:=TPasMPUInt64(TPasMPUInt64(TPasMPInterlocked.Read(PPasMPUInt64(Ptr)^)));
            if TPasMPUInt64(Temporary)<TPasMPUInt64(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt64(Ptr)^,TPasMPUInt64(Temporary),TPasMPUInt64(Temporary))=TPasMPUInt64(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]),TPasMPUInt64(Temporary))=TPasMPUInt64(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWStore(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $1c:begin
          // amomaxu.d
          Ptr:=RMWTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           repeat
            Temporary:=TPasMPUInt64(TPasMPUInt64(TPasMPInterlocked.Read(PPasMPUInt64(Ptr)^)));
            if TPasMPUInt64(Temporary)>TPasMPUInt64(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt64(Ptr)^,TPasMPUInt64(Temporary),TPasMPUInt64(Temporary))=TPasMPUInt64(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]),TPasMPUInt64(Temporary))=TPasMPUInt64(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWStore(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
      end;
     {$ifndef TryToForceCaseJumpTableOnLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
       // amoq
       rd:=TRegister((aInstruction shr 7) and $1f);
       rs1:=TRegister((aInstruction shr 15) and $1f);
       rs2:=TRegister((aInstruction shr 20) and $1f);
       if (fState.Registers[rs1] and 15)<>0 then begin
        SetException(TExceptionValue.StoreAddressMisaligned,fState.Registers[rs1],fState.PC);
        result:=4;
        exit;
       end else begin
        case ((aInstruction shr 25) and $7c) shr 2 of
         $05:begin
          // amocas.q (Zacas)
          Ptr:=RMWTranslate(fState.Registers[rs1],16,@fState.Bounce.ui128,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           fState.CAS128OldValue.Lo:=TPasMPUInt64(fState.Registers[rd]);
           fState.CAS128OldValue.Hi:=TPasMPUInt64(fState.Registers[TRegister((TPasRISCVUInt32(rd)+1) and $1f)]);
           fState.CAS128NewValue.Lo:=TPasMPUInt64(fState.Registers[rs2]);
           fState.CAS128NewValue.Hi:=TPasMPUInt64(fState.Registers[TRegister((TPasRISCVUInt32(rs2)+1) and $1f)]);
           fState.CAS128Result:=TPasMPInterlocked.CompareExchange(PPasMPInt128Record(Ptr)^,fState.CAS128NewValue,fState.CAS128OldValue);
           if rd<>TRegister.Zero then begin
            fState.Registers[rd]:=fState.CAS128Result.Lo;
            if TRegister((TPasRISCVUInt32(rd)+1) and $1f)<>TRegister.Zero then begin
             fState.Registers[TRegister((TPasRISCVUInt32(rd)+1) and $1f)]:=fState.CAS128Result.Hi;
            end;
           end;
           if Ptr=@fState.Bounce.ui128 then begin
            RMWStore(fState.Registers[rs1],16,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    else begin
     SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
     result:=4;
     exit;
    end;

{$ifndef TryToForceCaseJumpTableOnLevel1}
   end;

  end;
{$endif}

 end;

end;
{$ifdef fpc}{$pop}{$endif}

function TPasRISCV.THART.InterruptsRaised:TPasRISCVUInt64;
begin
 result:=TPasMPInterlocked.Read(fState.PendingIRQs);
end;

function TPasRISCV.THART.InterruptsPending:TPasRISCVUInt64;
begin
 result:=(TPasMPInterlocked.Read(fState.PendingIRQs) or fState.CSR.fData[TCSR.TAddress.MIP]) and fState.CSR.fData[TCSR.TAddress.MIE];
end;

function TPasRISCV.THART.InterruptsNotPending:TPasRISCVUInt64;
begin
 result:=(not (TPasMPInterlocked.Read(fState.PendingIRQs) or fState.CSR.fData[TCSR.TAddress.MIP])) and fState.CSR.fData[TCSR.TAddress.MIE];
end;

procedure TPasRISCV.THART.ClearInterrupt(const aInterruptValue:TPasRISCV.THART.TInterruptValue);
var Mask:TPasRISCVUInt64;
begin
 Mask:=TPasRISCVUInt64(1) shl TPasRISCVUInt64(aInterruptValue);
 TPasMPInterlocked.BitwiseAnd(fState.PendingIRQs,TPasRISCVUInt64(not TPasRISCVUInt64(Mask)));
//TPasMPInterlocked.BitwiseAnd(fState.CSR.fData[TCSR.TAddress.MIP],TPasRISCVUInt64(not TPasRISCVUInt64(Mask)));
end;

procedure TPasRISCV.THART.RaiseInterrupt(const aInterruptValue:TPasRISCV.THART.TInterruptValue);
var Mask:TPasRISCVUInt64;
begin
 Mask:=TPasRISCVUInt64(1) shl TPasRISCVUInt64(aInterruptValue);
 if (TPasMPInterlocked.ExchangeBitwiseOr(fState.PendingIRQs,Mask) and Mask)=0 then begin
  fMachine.fWakeUpConditionVariableLock.Acquire;
  try
   TPasMPInterlocked.BitwiseOr(fMachine.fRunState,fMachine.fAllHARTMask);
   fMachine.fWakeUpConditionVariable.Broadcast;
  finally
   fMachine.fWakeUpConditionVariableLock.Release;
  end;
 end;
end;

function TPasRISCV.THART.SetInterrupt(const aInterruptValue:TPasRISCV.THART.TInterruptValue):Boolean;
var Mask:TPasRISCVUInt64;
begin
 Mask:=TPasRISCVUInt64(1) shl TPasRISCVUInt64(aInterruptValue);
 result:=(TPasMPInterlocked.ExchangeBitwiseOr(fState.PendingIRQs,Mask) and Mask)=0;
end;

procedure TPasRISCV.THART.SendAIAIRQ(const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aIRQ:TPasRISCVUInt32);
var AIARegFile:TPasRISCV.THART.TAIARegFile;
    MSIP:THART.TInterruptValue;
    Threshold,Reg,Value,EIE,Previous:TPasRISCVUInt32;
begin
 AIARegFile:=fAIARegFiles[aAIARegFileMode];
 if assigned(AIARegFile) and (aIRQ>0) and (aIRQ<TPasRISCV.THART.TAIARegFile.IRQ_LIMIT) then begin
  TPasMPMemoryBarrier.ReadDependency;
  if AIARegFile.fEIDelivery<>0 then begin
   TPasMPMemoryBarrier.ReadDependency;
   Threshold:=AIARegFile.fEIThreshold-1;
   case aAIARegFileMode of
    TPasRISCV.TAIARegFileMode.Machine:begin
     MSIP:=THART.TInterruptValue.MachineExternal;
    end;
    TPasRISCV.TAIARegFileMode.Supervisor:begin
     MSIP:=THART.TInterruptValue.SupervisorExternal;
    end;
    else begin
     MSIP:=THART.TInterruptValue.None;
    end;
   end;
   Reg:=aIRQ shr 5;
   Value:=TPasRISCVUInt32(1) shl (aIRQ and $1f);
   TPasMPMemoryBarrier.ReadDependency;
   EIE:=AIARegFile.fEIE[Reg];
   Previous:=TPasMPInterlocked.ExchangeBitwiseOr(AIARegFile.fEIP[Reg],Value);
   if (aIRQ<Threshold) and ((Value and EIE)<>0) and ((Value and Previous)=0) then begin
    RaiseInterrupt(MSIP);
   end;
  end;
 end;
end;

function TPasRISCV.THART.UpdateAIAInternal(const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aUpdate,aClaim:Boolean):TPasRISCVUInt32;
var AIARegFile:TPasRISCV.THART.TAIARegFile;
    MSIP:THART.TInterruptValue;
    Threshold,EIE,EIP,Bits,Bit,IRQ,Mask:TPasRISCVUInt32;
    Index:TPasRISCVInt32;
begin
 result:=0;
 AIARegFile:=fAIARegFiles[aAIARegFileMode];
 if assigned(AIARegFile) then begin
  TPasMPMemoryBarrier.ReadDependency;
  Threshold:=AIARegFile.fEIThreshold-1;
  case aAIARegFileMode of
   TPasRISCV.TAIARegFileMode.Machine:begin
    MSIP:=THART.TInterruptValue.MachineExternal;
   end;
   TPasRISCV.TAIARegFileMode.Supervisor:begin
    MSIP:=THART.TInterruptValue.SupervisorExternal;
   end;
   else begin
    MSIP:=THART.TInterruptValue.None;
   end;
  end;
  if aUpdate then begin
   ClearInterrupt(MSIP);
  end;
  TPasMPMemoryBarrier.ReadDependency;
  if AIARegFile.fEIDelivery<>0 then begin
   for Index:=0 to TPasRISCV.THART.TAIARegFile.ARRAY_LENGTH-1 do begin
    TPasMPMemoryBarrier.ReadDependency;
    EIE:=AIARegFile.fEIE[Index];
    TPasMPMemoryBarrier.ReadDependency;
    EIP:=AIARegFile.fEIP[Index];
    Bits:=EIE and EIP;
    if Bits<>0 then begin
     if result<>0 then begin
      RaiseInterrupt(MSIP);
      exit;
     end else begin
      Bit:=CLZDWord(Bits) xor 31;
      IRQ:=(Index shl 5) or Bit;
      Mask:=not (TPasRISCVUInt32(1) shl Bit);
      if IRQ<Threshold then begin
       result:=IRQ;
       if aClaim then begin
        Bits:=Bits and Mask;
        TPasMPInterlocked.BitwiseAnd(AIARegFile.fEIP[Index],Mask);
       end;
       if aUpdate then begin
        if Bits<>0 then begin
         RaiseInterrupt(MSIP);
         exit;
        end;
       end else begin
        exit;
       end;
      end;
     end;
    end;
   end;
  end;
 end;
end;

function TPasRISCV.THART.UpdateAIAState(const aAIARegFileMode:TPasRISCV.TAIARegFileMode):TPasRISCVUInt32;
begin
 result:=UpdateAIAInternal(aAIARegFileMode,true,false);
end;

function TPasRISCV.THART.GetAIAIRQ(const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aClaim:Boolean):TPasRISCVUInt32;
begin
 result:=UpdateAIAInternal(aAIARegFileMode,true,aClaim);
end;

procedure TPasRISCV.THART.HandleInterrupts;
var PC,Status,PendingIRQs,IRQs,IDELEG:TPasRISCVUInt64;
    Mode,Privilege:THART.TMode;
    InterruptValue:TPasRISCV.THART.TInterruptValue;
begin

 PendingIRQs:=InterruptsPending;

 if PendingIRQs<>0 then begin

  Privilege:=TMode.Machine;
  IDELEG:=fState.CSR.fData[TCSR.TAddress.MIDELEG];
  IRQs:=PendingIRQs and not IDELEG;
  PendingIRQs:=PendingIRQs and IDELEG;

  if IRQs=0 then begin

   Privilege:=TMode.Supervisor;
   IDELEG:=fState.CSR.fData[TCSR.TAddress.SIDELEG];
   IRQs:=PendingIRQs and not IDELEG;
   PendingIRQs:=PendingIRQs and IDELEG;

   // No TMode.User here, since User-level interrupts are optional for implementation were part of the
   // "n" extension that has been removed from the RISC-V specs.
{  if IRQs=0 then begin
    Privilege:=TMode.User;
   end;}

  end;

  Mode:=fState.Mode;
  if Mode>Privilege then begin
   exit;
  end else if ((fState.Mode=Privilege) and (((TPasRISCVUInt32(1) shl TPasRISCVUInt32(Mode)) and fState.CSR.fData[TCSR.TAddress.MSTATUS])=0)) then begin
   exit;
  end else if IRQs<>0 then begin

   PC:=fState.PC;

   InterruptValue:=TInterruptValue(TPasMPMath.BitScanReverse64(IRQs));

   case Privilege of

    TMode.Machine:begin

     SetMode(THART.TMode.Machine);

     fState.PC:=(fState.CSR.fData[TCSR.TAddress.MTVEC] and TPasRISCVUInt64($fffffffffffffffc))+TPasRISCVUInt64(ord(fState.CSR.fData[TCSR.TAddress.MTVEC] and 1)*TPasRISCVUInt64(InterruptValue)*4);

     fState.CSR.fData[TCSR.TAddress.MEPC]:=PC and TPasRISCVUInt64($fffffffffffffffe);

     fState.CSR.fData[TCSR.TAddress.MCAUSE]:=(TPasRISCVUInt64(1) shl 63) or TPasRISCVUInt64(InterruptValue);

     fState.CSR.fData[TCSR.TAddress.MTVAL]:=0;

     Status:=fState.CSR.fData[TCSR.TAddress.MSTATUS];
     Status:=(Status and not ((TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MPIE) or (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MIE))) or (((Status shr TCSR.TMask.TMSTATUSBit.MIE) and 1) shl TCSR.TMask.TMSTATUSBit.MPIE);
     Status:=(Status and not (TPasRISCVUInt64(3) shl 11)) or (TPasRISCVUInt64(TPasRISCVUInt64(Mode) and 3) shl 11);
     fState.CSR.fData[TCSR.TAddress.MSTATUS]:=Status;

    end;

    TMode.Supervisor:begin

     SetMode(THART.TMode.Supervisor);

     fState.PC:=(fState.CSR.fData[TCSR.TAddress.STVEC] and TPasRISCVUInt64($fffffffffffffffc))+TPasRISCVUInt64(ord(fState.CSR.fData[TCSR.TAddress.STVEC] and 1)*TPasRISCVUInt64(InterruptValue)*4);

     fState.CSR.fData[TCSR.TAddress.SEPC]:=PC and TPasRISCVUInt64($fffffffffffffffe);

     fState.CSR.fData[TCSR.TAddress.SCAUSE]:=(TPasRISCVUInt64(1) shl 63) or TPasRISCVUInt64(InterruptValue);

     fState.CSR.fData[TCSR.TAddress.STVAL]:=0;

     Status:=fState.CSR.fData[TCSR.TAddress.MSTATUS];
     Status:=(Status and not ((TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPIE) or (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SIE))) or (((Status shr TCSR.TMask.TSSTATUSBit.SIE) and 1) shl TCSR.TMask.TSSTATUSBit.SPIE);
     Status:=(Status and not (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPP)) or ((TPasRISCVUInt32(Mode) and 1) shl TCSR.TMask.TSSTATUSBit.SPP);
     fState.CSR.fData[TCSR.TAddress.MSTATUS]:=Status;

    end;

    else begin
    end;

   end;

  end;

 end;

end;

procedure TPasRISCV.THART.ExecuteException;
var Status:TPasRISCVUInt64;
    Mode,Privilege:THART.TMode;
begin

 if fState.ExceptionValue=TExceptionValue.DebuggerBreakpoint then begin
  fState.ExceptionValue:=TExceptionValue.None;
  fState.PC:=fState.ExceptionPC;
  exit;
 end;

 // No TMode.User here, since User-level interrupts are optional for implementation were part of the
 // "n" extension that has been removed from the RISC-V specs.

 Mode:=fState.Mode;

 if (THART.TMode.Machine>Mode) and ((fState.CSR.fData[TCSR.TAddress.MEDELEG] and (TPasRISCVUInt64(1) shl TPasRISCVUInt32(fState.ExceptionValue)))<>0) then begin
//if (THART.TMode.Hypervisor>Mode) and ((fState.CSR.fData[TCSR.TAddress.HEDELEG] and (TPasRISCVUInt64(1) shl TPasRISCVUInt32(fState.ExceptionValue)))<>0) then begin
   Privilege:=THART.TMode.Supervisor;
{ end else begin
   Privilege:=THART.TMode.Hypervisor;
  end;}
 end else begin
  Privilege:=THART.TMode.Machine;
 end;

 case Privilege of

  THART.TMode.Supervisor:begin

   SetMode(THART.TMode.Supervisor);

   fState.PC:=(fState.CSR.fData[TCSR.TAddress.STVEC] and TPasRISCVUInt64($fffffffffffffffc))+((fState.CSR.fData[TCSR.TAddress.STVEC] and 1)*(TPasRISCVUInt32(fState.ExceptionValue) shl 2));

   fState.CSR.fData[TCSR.TAddress.SEPC]:=fState.ExceptionPC and TPasRISCVUInt64($fffffffffffffffe);

   fState.CSR.fData[TCSR.TAddress.SCAUSE]:=TPasRISCVUInt32(fState.ExceptionValue);

   fState.CSR.fData[TCSR.TAddress.STVAL]:=fState.ExceptionData;

   Status:=fState.CSR.fData[TCSR.TAddress.MSTATUS];
   Status:=(Status and not ((TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPIE) or (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SIE))) or (((Status shr TCSR.TMask.TSSTATUSBit.SIE) and 1) shl TCSR.TMask.TSSTATUSBit.SPIE);
   Status:=(Status and not (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPP)) or ((TPasRISCVUInt32(Mode) and 1) shl TCSR.TMask.TSSTATUSBit.SPP);
   fState.CSR.fData[TCSR.TAddress.MSTATUS]:=Status;

  end;

  else {THART.TMode.Machine:}begin

   SetMode(THART.TMode.Machine);

   fState.PC:=(fState.CSR.fData[TCSR.TAddress.MTVEC] and TPasRISCVUInt64($fffffffffffffffc))+((fState.CSR.fData[TCSR.TAddress.MTVEC] and 1)*(TPasRISCVUInt32(fState.ExceptionValue) shl 2));

   fState.CSR.fData[TCSR.TAddress.MEPC]:=fState.ExceptionPC and TPasRISCVUInt64($fffffffffffffffe);

   fState.CSR.fData[TCSR.TAddress.MCAUSE]:=TPasRISCVUInt32(fState.ExceptionValue);

   fState.CSR.fData[TCSR.TAddress.MTVAL]:=fState.ExceptionData;

   Status:=fState.CSR.fData[TCSR.TAddress.MSTATUS];
   Status:=(Status and not ((TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MPIE) or (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MIE))) or (((Status shr TCSR.TMask.TMSTATUSBit.MIE) and 1) shl TCSR.TMask.TMSTATUSBit.MPIE);
   Status:=(Status and not (TPasRISCVUInt64(3) shl 11)) or (TPasRISCVUInt64(TPasRISCVUInt64(Mode) and 3) shl 11);
   fState.CSR.fData[TCSR.TAddress.MSTATUS]:=Status;

  end;

 end;

 ClearException;

end;

procedure TPasRISCV.THART.SleepUntilNextInterrupt;
var SleepDuration,CurrentSleepDuration,WaitForDuration,
    Time,TimeA,TimeB,ActiveTimers,MTIMECMP,STIMECMP,SleepThreshold,
    Remaining,Difference:TPasRISCVUInt64;
    DoInterrupt:Boolean;
begin

 fState.Sleep:=true;

 if (InterruptsPending and (TPasRISCV.THART.TInterruptValueMasks.MachineTimer or TPasRISCV.THART.TInterruptValueMasks.SupervisorTimer))=0 then begin

  ActiveTimers:=fState.CSR.fData[TPasRISCV.THART.TCSR.TAddress.MIE] and (TPasRISCV.THART.TInterruptValueMasks.MachineTimer or TPasRISCV.THART.TInterruptValueMasks.SupervisorTimer);

  if ActiveTimers<>0 then begin

   Time:=fACLINTDevice.GetTime;

   SleepDuration:=TPasRISCVUInt64($ffffffffffffffff);

   MTIMECMP:=fMTIMECMP;
   if (MTIMECMP<>TPasRISCVUInt64($ffffffffffffffff)) and
      ((ActiveTimers and TPasRISCV.THART.TInterruptValueMasks.MachineTimer)<>0) and
      (Time<MTIMECMP) then begin
    CurrentSleepDuration:=TPasRISCVInt64(MTIMECMP)-TPasRISCVInt64(Time);
    if CurrentSleepDuration<SleepDuration then begin
     SleepDuration:=CurrentSleepDuration;
    end;
   end;

   STIMECMP:=fSTIMECMP;
   if (STIMECMP<>TPasRISCVUInt64($ffffffffffffffff)) and
      ((ActiveTimers and TPasRISCV.THART.TInterruptValueMasks.SupervisorTimer)<>0) and
      (Time<STIMECMP) then begin
    CurrentSleepDuration:=TPasRISCVInt64(STIMECMP)-TPasRISCVInt64(Time);
    if CurrentSleepDuration<SleepDuration then begin
     SleepDuration:=CurrentSleepDuration;
    end;
   end;

   if (SleepDuration>0) and (SleepDuration<>TPasRISCVUInt64($ffffffffffffffff)) then begin

    if SleepDuration>(60*CLOCK_FREQUENCY) then begin
     SleepDuration:=60*CLOCK_FREQUENCY;
    end;

    SleepThreshold:=GlobalSleepThreshold;
    if GlobalSleepGranularity<>0 then begin
     inc(SleepThreshold,SleepDuration div 6);
    end;

    Remaining:=SleepDuration;

    TimeA:=Time;

    if Remaining>SleepThreshold then begin

     fMachine.fWakeUpConditionVariableLock.Acquire;
     try
      while (Remaining>SleepThreshold) and ((TPasMPInterlocked.Read(fMachine.fRunState) and (fHARTMask or TPasRISCVUInt32(RUNSTATE_GLOBAL_MASK)))=RUNSTATE_RUNNING) do begin
       WaitForDuration:=ConvertScale(Remaining-SleepThreshold,CLOCK_FREQUENCY,1000);
       if WaitForDuration>0 then begin
        fMachine.fWakeUpConditionVariable.Wait(fMachine.fWakeUpConditionVariableLock,WaitForDuration);
       end;
       TimeB:=fACLINTDevice.GetTime;
       Difference:=TimeB-TimeA;
       if Remaining>Difference then begin
        dec(Remaining,Difference);
       end else begin
        Remaining:=0;
       end;
       TimeA:=TimeB;
      end;
     finally
      fMachine.fWakeUpConditionVariableLock.Release;
     end;

     TimeB:=fACLINTDevice.GetTime;
     Difference:=TimeB-TimeA;
     if Remaining>Difference then begin
      dec(Remaining,Difference);
     end else begin
      Remaining:=0;
     end;
     TimeA:=TimeB;

    end;

    while (Remaining>0) and ((TPasMPInterlocked.Read(fMachine.fRunState) and (fHARTMask or TPasRISCVUInt32(RUNSTATE_GLOBAL_MASK)))=RUNSTATE_RUNNING) do begin
     TimeB:=fACLINTDevice.GetTime;
     Difference:=TimeB-TimeA;
     if Remaining>Difference then begin
      dec(Remaining,Difference);
     end else begin
      Remaining:=0;
     end;
     TimeA:=TimeB;
    end;

    Time:=fACLINTDevice.GetTime;

   end;

   DoInterrupt:=false;

   if ((ActiveTimers and TPasRISCV.THART.TInterruptValueMasks.MachineTimer)<>0) and (Time>=fMTIMECMP) then begin
    if SetInterrupt(TPasRISCV.THART.TInterruptValue.MachineTimer) then begin
     DoInterrupt:=true;
    end;
   end;

   if ((ActiveTimers and TPasRISCV.THART.TInterruptValueMasks.SupervisorTimer)<>0) and (Time>=STIMECMP) then begin
    if SetInterrupt(TPasRISCV.THART.TInterruptValue.SupervisorTimer) then begin
     DoInterrupt:=true;
    end;
   end;

   if DoInterrupt then begin
    fMachine.InterruptAndWakeUp;
   end;

  end;

 end;

 fState.Sleep:=false;

end;

procedure TPasRISCV.THART.SleepPause;
begin
 fMachine.fWakeUpConditionVariableLock.Acquire;
 try
  fMachine.fWakeUpConditionVariable.Wait(fMachine.fWakeUpConditionVariableLock,10);
 finally
  fMachine.fWakeUpConditionVariableLock.Release;
 end;
end;

procedure TPasRISCV.THART.CheckTimers;
var Interrupts,Time:TPasRISCVUInt64;
    DoInterrupt:Boolean;
begin
 Interrupts:=InterruptsNotPending and (TPasRISCV.THART.TInterruptValueMasks.MachineTimer or TPasRISCV.THART.TInterruptValueMasks.SupervisorTimer);
 if Interrupts<>0 then begin
  Time:=fACLINTDevice.GetTime;
  DoInterrupt:=false;
  if ((Interrupts and TPasRISCV.THART.TInterruptValueMasks.MachineTimer)<>0) and (Time>=fMTIMECMP) then begin
   if SetInterrupt(TPasRISCV.THART.TInterruptValue.MachineTimer) then begin
    DoInterrupt:=true;
   end;
  end;
  if ((Interrupts and TPasRISCV.THART.TInterruptValueMasks.SupervisorTimer)<>0) and (Time>=fSTIMECMP) then begin
   if SetInterrupt(TPasRISCV.THART.TInterruptValue.SupervisorTimer) then begin
    DoInterrupt:=true;
   end;
  end;
  if DoInterrupt then begin
   fMachine.InterruptAndWakeUp;
  end;
 end;
end;

procedure TPasRISCV.THART.CheckInterrupts;
var Interrupts:TPasRISCVUInt64;
begin
 Interrupts:=InterruptsPending;
 if Interrupts<>0 then begin
  fMachine.InterruptAndWakeUp;
 end;
end;

{$if defined(PasRISCVCPUFileDumpDebug)}
var DumpFile:^Text=nil;
{$ifend}

procedure TPasRISCV.THART.Execute;
type PDirectAccessTLBEntry=TMMU.PDirectAccessTLBEntry;
var Instruction:TPasRISCVUInt32;
    InstructionAddress,PageAddress:TPasRISCVUInt64;
    InstructionPointer:TPasRISCVPtrUInt;
    RunState:PPasRISCVUInt32;
begin

 RunState:=@fMachine.fRunState;

 repeat

  if (fMachine.fFlushTLBHARTMask and fHARTMask)<>0 then begin
   FlushTLB(false);
   TPasMPInterlocked.BitwiseAnd(fMachine.fFlushTLBHARTMask,TPasMPUInt32(not TPasMPUInt32(fHARTMask)));
  end;

  {$if defined(PasRISCVCPUDebug)}if not IgnoreInterrupts then{$ifend}begin
   CheckTimers;
  end;

  if fState.ExceptionValue<>TExceptionValue.None then begin
   ExecuteException;
  end else begin
   {$if defined(PasRISCVCPUDebug)}if not IgnoreInterrupts then{$ifend}begin
    HandleInterrupts;
   end;
  end;

  InstructionPointer:=0;
  Instruction:=0;
  PageAddress:=TPasRISCVUInt64($7fffffffffffffff);

  repeat

   inc(fState.Cycle);

   InstructionAddress:=fState.PC;

   if TPasRISCVUInt64(InstructionAddress-PageAddress)<TPasRISCVUInt64($ffd) then begin

    Instruction:=PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt(InstructionPointer+InstructionAddress)))^;

   end else if FetchInstruction(InstructionAddress,Instruction) then begin

    PDirectAccessTLBEntry(InstructionPointer):=@fDirectAccessTLBCache[(InstructionAddress shr PAGE_SHIFT) and TMMU.DIRECT_ACCESS_TLB_MASK];
    PageAddress:=PDirectAccessTLBEntry(InstructionPointer)^.Execute shl PAGE_SHIFT;
    InstructionPointer:={$ifdef CombinedDirectAccessTLBCache}PDirectAccessTLBEntry(InstructionPointer)^.RelativeMemory{$else}PDirectAccessTLBEntry(InstructionPointer)^.RelativeMemoryExecute{$endif};

   end else begin

    break;

   end;

{$if defined(PasRISCVCPUDumpDebug)}
   if DumpDebug then begin
    write('PC=',LowerCase(IntToHex(fState.PC,16)),' ');
    if (Instruction and 3)=3 then begin
     write('Inst=',LowerCase(IntToHex(Instruction,8)),' ');
    end else begin
     write('Inst=',LowerCase(IntToHex(Instruction and $ffff,4)),' ');
    end;
    writeln;
   end;
{$ifend}

{$if defined(PasRISCVCPUFileDumpDebug)}
   begin
    if not assigned(DumpFile) then begin
     New(DumpFile);
     Assign(DumpFile^,'pasriscv_trace.txt');
     Rewrite(DumpFile^);
    end;
    write(DumpFile^,'PC=',LowerCase(IntToHex(fState.PC,16)),' ');
    if (Instruction and 3)=3 then begin
     write(DumpFile^,'Inst=',LowerCase(IntToHex(Instruction,8)),' ');
    end else begin
     write(DumpFile^,'Inst=',LowerCase(IntToHex(Instruction and $ffff,4)),' ');
    end;
    writeln(DumpFile^);
    Flush(DumpFile^);
  end;
{$ifend}

   inc(fState.PC,ExecuteInstruction(Instruction));

  until ((RunState^ and (fHARTMask or TPasRISCVUInt32(RUNSTATE_GLOBAL_MASK)))<>RUNSTATE_RUNNING) or
        ((fState.Cycle and TPasRISCVUInt32($ffff))=0);

  TPasMPInterlocked.BitwiseAnd(RunState^,TPasRISCVUInt32(TPasRISCVUInt32(not TPasRISCVUInt32(fHARTMask)) or TPasRISCVUInt32(RUNSTATE_GLOBAL_MASK)));

  if fState.ExceptionValue<>TExceptionValue.None then begin
   ExecuteException;
  end;

 until (RunState^ and (RUNSTATE_POWEROFF or RUNSTATE_REBOOT or RUNSTATE_SINGLESTEP or RUNSTATE_PAUSED or RUNSTATE_PAUSING))<>0;

end;

procedure TPasRISCV.THART.ThreadProc;
var HARTActive:Boolean;
begin

 while not fExecutionThread.Terminated do begin

  fMachine.fHARTWakeUpConditionVariableLock.Acquire;
  try
   repeat
    HARTActive:=(TPasMPInterlocked.Read(TPasMPUInt32(fMachine.fHARTActiveMask)) and fHARTMask)<>0;
    if HARTActive or fExecutionThread.Terminated then begin
     break;
    end else begin
     fMachine.fHARTWakeUpConditionVariable.Wait(fMachine.fHARTWakeUpConditionVariableLock);
    end;
   until false;
  finally
   fMachine.fHARTWakeUpConditionVariableLock.Release;
  end;

  if fExecutionThread.Terminated then begin
   break;
  end else begin

   if HARTActive then begin

    fMachine.fHARTStatusChangeConditionVariableLock.Acquire;
    try
     TPasMPInterlocked.BitwiseOr(TPasMPUInt32(fMachine.fHARTRunningMask),TPasMPUInt32(fHARTMask));
     fMachine.fHARTStatusChangeConditionVariable.Broadcast;
    finally
     fMachine.fHARTStatusChangeConditionVariableLock.Release;
    end;

//  Sleep(fHARTID*10);

    Execute;

    fMachine.fHARTStatusChangeConditionVariableLock.Acquire;
    try
     TPasMPInterlocked.BitwiseAnd(TPasMPUInt32(fMachine.fHARTActiveMask),not TPasMPUInt32(fHARTMask));
     TPasMPInterlocked.BitwiseAnd(TPasMPUInt32(fMachine.fHARTRunningMask),not TPasMPUInt32(fHARTMask));
     fMachine.fHARTStatusChangeConditionVariable.Broadcast;
    finally
     fMachine.fHARTStatusChangeConditionVariableLock.Release;
    end;

   end else begin
    TPasMP.Yield;
   end;

  end;

 end;

 fMachine.fHARTStatusChangeConditionVariableLock.Acquire;
 try
  TPasMPInterlocked.BitwiseAnd(TPasMPUInt32(fMachine.fHARTActiveMask),not TPasMPUInt32(fHARTMask));
  TPasMPInterlocked.BitwiseAnd(TPasMPUInt32(fMachine.fHARTRunningMask),not TPasMPUInt32(fHARTMask));
  fMachine.fHARTStatusChangeConditionVariable.Broadcast;
 finally
  fMachine.fHARTStatusChangeConditionVariableLock.Release;
 end;

end;

procedure TPasRISCV.THART.DumpRegisters;
var Register:TRegister;
    FPURegister:TFPURegister;
    s:string;
begin
 WriteLn('Registers:');
 WriteLn;
 for Register:=Low(TRegister) to High(TRegister) do begin
  WriteLn(RegisterABINames[Register]+': 0x'+LowerCase(IntToHex(fState.Registers[Register],8)));
 end;
 WriteLn('Float registers:');
 for FPURegister:=Low(TFPURegister) to High(TFPURegister) do begin
  s:=FloatToStr(fState.FPURegisters[FPURegister].f64);
  WriteLn(FPURegisterABINames[FPURegister]+': '+s+' ('+LowerCase(IntToHex(fState.FPURegisters[FPURegister].ui64,8))+')');
 end;
 WriteLn('pc: 0x'+LowerCase(IntToHex(fState.PC,8)));
 if fState.Sleep then begin
  WriteLn('wfi: true');
 end else begin
  WriteLn('wfi: false');
 end;
 WriteLn;
 WriteLn;
end;

{ TPasRISCV.TDebugger.TClientThread }

constructor TPasRISCV.TDebugger.TClientThread.Create(const aDebugger:TDebugger;const aSocket:TRNLSocket;const aAddress:TRNLAddress);
begin
 fDebugger:=aDebugger;
 fSocket:=aSocket;
 fAddress:=aAddress;
 fHART:=nil;
 fRecvSize:=0;
 fSendBufferString:='';
 fEvent:=TRNLNetworkEvent.Create;
 if fDebugger.fMachine.fCountHARTs>0 then begin
  fHART:=fDebugger.fMachine.fHARTs[0];
 end else begin
  fHART:=nil;
 end;
 inherited Create(false);
end;

destructor TPasRISCV.TDebugger.TClientThread.Destroy;
begin
 Shutdown;
 fSendBufferString:='';
 inherited Destroy;
end;

procedure TPasRISCV.TDebugger.TClientThread.AfterConstruction;
var Index:TPasRISCVSizeInt;
begin

 inherited AfterConstruction;

 // Add the client thread to the list
 if assigned(fDebugger) and assigned(fDebugger.fLock) then begin
  fDebugger.fLock.Acquire;
  try
   Index:=fDebugger.fCountClientThreads;
   inc(fDebugger.fCountClientThreads);
   if length(fDebugger.fClientThreads)<fDebugger.fCountClientThreads then begin
    SetLength(fDebugger.fClientThreads,fDebugger.fCountClientThreads+((fDebugger.fCountClientThreads+1) shr 1));
   end;
   fDebugger.fClientThreads[Index]:=self;
  finally
   fDebugger.fLock.Release;
  end;
 end;

end;

procedure TPasRISCV.TDebugger.TClientThread.BeforeDestruction;
var Index:TPasRISCVSizeInt;
begin

 if assigned(fDebugger) and assigned(fDebugger.fLock) then begin

  // Close the socket
  if fSocket<>RNL_SOCKET_NULL then begin
   try
    fDebugger.fRNLNetwork.SocketShutdown(fSocket);
    fDebugger.fRNLNetwork.SocketDestroy(fSocket);
   finally
    fSocket:=RNL_SOCKET_NULL;
   end;
  end;

  // Remove the client thread from the list
  fDebugger.fLock.Acquire;
  try
   for Index:=0 to fDebugger.fCountClientThreads-1 do begin
    if fDebugger.fClientThreads[Index]=self then begin
     if (Index+1)<fDebugger.fCountClientThreads then begin
      fDebugger.fClientThreads[Index]:=fDebugger.fClientThreads[fDebugger.fCountClientThreads-1];
     end;
     dec(fDebugger.fCountClientThreads);
     break;
    end;
   end;
  finally
   fDebugger.fLock.Release;
  end;

  if assigned(fDebugger.fClientsInvertedSemaphore) then begin
   fDebugger.fClientsInvertedSemaphore.Release;
  end;

 end;

 inherited BeforeDestruction;

end;

procedure TPasRISCV.TDebugger.TClientThread.Shutdown;
begin
 if not Finished then begin
  Terminate;
  fEvent.SetEvent;
  WaitFor;
 end;
end;

class function TPasRISCV.TDebugger.TClientThread.Hexify(const aNibble:TPasRISCVUInt8):TPasRISCVRawByteChar;
begin
 if aNibble<10 then begin
  result:=TPasRISCVRawByteChar(TPasRISCVUInt8(aNibble+$30));
 end else if aNibble<16 then begin
  result:=TPasRISCVRawByteChar(TPasRISCVUInt8(aNibble+$57));
 end else begin
  result:='?';
 end;
end;

class function TPasRISCV.TDebugger.TClientThread.ByteToHex(const aValue:TPasRISCVUInt8):TPasRISCVRawByteString;
begin
 result:=Hexify((aValue shr 4) and $f)+Hexify(aValue and $f);
end;

class function TPasRISCV.TDebugger.TClientThread.LittleEndianBytesToHex(const aData:Pointer;const aBytes:TPasRISCVSizeInt):TPasRISCVRawByteString;
var Index:TPasRISCVSizeInt;
    p:PPasRISCVUInt8;
begin
 result:='';
 p:=aData;
 for Index:=0 to aBytes-1 do begin
  result:=result+ByteToHex(p^);
  inc(p);
 end;
end;

class function TPasRISCV.TDebugger.TClientThread.LittleEndianValueToHex(const aValue:TPasRISCVUInt64;const aBytes:TPasRISCVSizeInt):TPasRISCVRawByteString;
var Index:TPasRISCVSizeInt;
    p:TPasRISCVUInt8;
begin
 result:='';
 for Index:=0 to aBytes-1 do begin
  p:=TPasRISCVUInt8((aValue shr (Index shl 3)) and $ff);
  result:=result+ByteToHex(p);
 end;
end;

class function TPasRISCV.TDebugger.TClientThread.HexNibble(const aDigit:TPasRISCVRawByteChar):TPasRISCVUInt8;
begin
 case aDigit of
  '0'..'9':begin
   result:=TPasRISCVUInt8(aDigit)-$30;
  end;
  'a'..'f':begin
   result:=TPasRISCVUInt8(aDigit)-$57;
  end;
  'A'..'F':begin
   result:=TPasRISCVUInt8(aDigit)-$37;
  end;
  else begin
   result:=0;
  end;
 end;
end;

class function TPasRISCV.TDebugger.TClientThread.HexToByte(const aString:TPasRISCVRawByteString;var aStringPosition:TPasRISCVSizeInt):TPasRISCVUInt8;
begin
 result:=0;
 if aStringPosition<=length(aString) then begin
  result:=result or HexNibble(aString[aStringPosition]);
  inc(aStringPosition);
 end;
 if aStringPosition<=length(aString) then begin
  result:=(result shl 4) or HexNibble(aString[aStringPosition]);
  inc(aStringPosition);
 end;
end;

class procedure TPasRISCV.TDebugger.TClientThread.HexToLittleEndianBytes(const aData:Pointer;const aString:TPasRISCVRawByteString;var aStringPosition:TPasRISCVSizeInt;const aBytes:TPasRISCVSizeInt);
var Index:TPasRISCVSizeInt;
    p:PPasRISCVUInt8;
begin
 p:=aData;
 for Index:=0 to aBytes-1 do begin
  p^:=HexToByte(aString,aStringPosition);
  inc(p);
 end;
end;

class function TPasRISCV.TDebugger.TClientThread.HexToLittleEndianValue(const aString:TPasRISCVRawByteString;var aStringPosition:TPasRISCVSizeInt;const aBytes:TPasRISCVSizeInt):TPasRISCVUInt64;
var Index:TPasRISCVSizeInt;
begin
 result:=0;
 for Index:=0 to aBytes-1 do begin
  result:=result or (TPasRISCVUInt64(HexToByte(aString,aStringPosition)) shl (Index shl 3));
 end;
end;

procedure TPasRISCV.TDebugger.TClientThread.Send(const aData:TPasRISCVRawByteString);
var BytesSent,Count:TPasRISCVSizeInt;
begin
 writeln('< ',aData);
 if length(aData)>0 then begin
  BytesSent:=0;
  while BytesSent<length(aData) do begin
   Count:=fDebugger.fRNLNetwork.Send(fSocket,@fAddress,aData[BytesSent+1],length(aData)-BytesSent,RNL_IPV4);
   if Count>0 then begin
    inc(BytesSent,Count);
   end;
  end;
 end;
 writeln('!');
end;

procedure TPasRISCV.TDebugger.TClientThread.ReplyACK;
begin
 Send('+');
end;

procedure TPasRISCV.TDebugger.TClientThread.ReplyNAK;
begin
 Send('-');
end;

procedure TPasRISCV.TDebugger.TClientThread.ResendReply;
begin
 Send(fSendBufferString);
end;

procedure TPasRISCV.TDebugger.TClientThread.SendBufferAppend(const aString:TPasRISCVRawByteString);
begin
 fSendBufferString:=fSendBufferString+aString;
end;

procedure TPasRISCV.TDebugger.TClientThread.ReplyString(const aString:TPasRISCVRawByteString);
var Index:TPasRISCVSizeInt;
    Checksum:TPasRISCVUInt8;
begin
 Checksum:=0;
 for Index:=1 to length(aString) do begin
  Checksum:=Checksum+TPasRISCVUInt8(aString[Index]);
 end;
 fSendBufferString:='$'+aString+'#'+LittleEndianBytesToHex(@Checksum,1);
 ResendReply;
end;

procedure TPasRISCV.TDebugger.TClientThread.ConsumeBytes(const aBytes:TPasRISCVSizeInt);
var Amount:TPasRISCVSizeInt;
begin
 if fRecvSize>0 then begin
  if aBytes>fRecvSize then begin
   Amount:=fRecvSize;
  end else begin
   Amount:=aBytes;
  end;
  dec(fRecvSize,Amount);
  Move(fRecvBuffer[Amount],fRecvBuffer[0],fRecvSize);
 end;
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessStep;
begin
 fDebugger.SingleStep;
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessContinue;
begin
 fDebugger.Continue_;
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessMemory(const aPacketString:TPasRISCVRawByteString;const aWrite:Boolean);
var Index,Size,ToDo,Remain,Len:TPasRISCVSizeInt;
    MemoryAddress,MemorySize,Value:TPasRISCVUInt64;
    ByteData:array[0..7] of TPasRISCVUInt8;
    s:TPasRISCVRawByteString;
begin

 Index:=2;

 MemoryAddress:=StrToUIntBase(aPacketString,Index,Size,16);
 if (Index>length(aPacketString)) or (aPacketString[Index]<>TPasRISCVRawByteChar(',')) then begin
  ReplyNAK;
  exit;
 end else begin
  inc(Index);
 end;

 Size:=0;
 MemorySize:=StrToUIntBase(aPacketString,Index,Size,16);
 if Size=0 then begin
  ReplyNAK;
  exit;
 end;

 case aPacketString[1] of
  'm':begin
   // Read memory
   if assigned(fHART) then begin
    Remain:=MemorySize;
    s:='';
    while Remain>0 do begin
     if Remain>8 then begin
      ToDo:=8;
     end else begin
      ToDo:=Remain;
     end;
     case ToDo of
      1:begin
       if fHART.LoadEx(MemoryAddress,Value,1) then begin
        ByteData[0]:=Value;
        inc(MemoryAddress);
       end else begin
        break;
       end;
      end;
      2:begin
       if fHART.LoadEx(MemoryAddress,Value,2) then begin
        PPASRISCVUInt16(Pointer(@ByteData[0]))^:=Value;
        inc(MemoryAddress,2);
       end else begin
        break;
       end;
      end;
      3:begin
       if fHART.LoadEx(MemoryAddress,Value,2) then begin
        PPASRISCVUInt16(Pointer(@ByteData[0]))^:=Value;
        inc(MemoryAddress,2);
       end else begin
        break;
       end;
       if fHART.LoadEx(MemoryAddress,Value,1) then begin
        ByteData[2]:=Value;
        inc(MemoryAddress);
       end else begin
        break;
       end;
      end;
      4:begin
       if fHART.LoadEx(MemoryAddress,Value,4) then begin
        PPASRISCVUInt32(Pointer(@ByteData[0]))^:=Value;
        inc(MemoryAddress,4);
       end else begin
        break;
       end;
      end;
      5:begin
       if fHART.LoadEx(MemoryAddress,Value,4) then begin
        PPASRISCVUInt32(Pointer(@ByteData[0]))^:=Value;
        inc(MemoryAddress,4);
       end else begin
        break;
       end;
       if fHART.LoadEx(MemoryAddress,Value,1) then begin
        ByteData[4]:=Value;
        inc(MemoryAddress);
       end else begin
        break;
       end;
      end;
      6:begin
       if fHART.LoadEx(MemoryAddress,Value,4) then begin
        PPASRISCVUInt32(Pointer(@ByteData[0]))^:=Value;
        inc(MemoryAddress,4);
       end else begin
        break;
       end;
       if fHART.LoadEx(MemoryAddress,Value,2) then begin
        PPASRISCVUInt16(Pointer(@ByteData[4]))^:=Value;
        inc(MemoryAddress,2);
       end else begin
        break;
       end;
      end;
      7:begin
       if fHART.LoadEx(MemoryAddress,Value,4) then begin
        PPASRISCVUInt32(Pointer(@ByteData[0]))^:=Value;
        inc(MemoryAddress,4);
       end else begin
        break;
       end;
       if fHART.LoadEx(MemoryAddress,Value,2) then begin
        PPASRISCVUInt16(Pointer(@ByteData[4]))^:=Value;
        inc(MemoryAddress,2);
       end else begin
        break;
       end;
       if fHART.LoadEx(MemoryAddress,Value,1) then begin
        ByteData[6]:=Value;
        inc(MemoryAddress);
       end else begin
        break;
       end;
      end;
      8:begin
       if fHART.LoadEx(MemoryAddress,Value,8) then begin
        PPASRISCVUInt64(Pointer(@ByteData[0]))^:=Value;
        inc(MemoryAddress,8);
       end else begin
        break;
       end;
      end;
      else begin
       break;
      end;
     end;
     s:=s+LittleEndianBytesToHex(@ByteData[0],ToDo);
     dec(Remain,ToDo);
    end;
    if Remain=0 then begin
     ReplyString(s);
    end else begin
     ReplyString('E00');
    end;
   end else begin
    ReplyString('E00');
   end;
  end;
  'M':begin
   // Write memory
   if (Index>length(aPacketString)) or (aPacketString[Index]<>TPasRISCVRawByteChar(':')) then begin
    ReplyNAK;
    exit;
   end else begin
    inc(Index);
   end;
   if assigned(fHART) then begin
    Remain:=MemorySize;
    Len:=length(aPacketString);
    while (Remain>0) and (((Index+(Remain shl 1))-1)<=Len) do begin
     if Remain>8 then begin
      ToDo:=8;
     end else begin
      ToDo:=Remain;
     end;
     case ToDo of
      1:begin
       ByteData[0]:=HexToByte(aPacketString,Index);
       if fHART.StoreEx(MemoryAddress,ByteData[0],1) then begin
        inc(MemoryAddress);
       end else begin
        break;
       end;
      end;
      2:begin
       ByteData[0]:=HexToByte(aPacketString,Index);
       ByteData[1]:=HexToByte(aPacketString,Index);
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt16(@ByteData[0])^,2) then begin
        inc(MemoryAddress,2);
       end else begin
        break;
       end;
      end;
      3:begin
       ByteData[0]:=HexToByte(aPacketString,Index);
       ByteData[1]:=HexToByte(aPacketString,Index);
       ByteData[2]:=HexToByte(aPacketString,Index);
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt16(@ByteData[0])^,2) then begin
        inc(MemoryAddress,2);
       end else begin
        break;
       end;
       if fHART.StoreEx(MemoryAddress,ByteData[2],1) then begin
        inc(MemoryAddress);
       end else begin
        break;
       end;
      end;
      4:begin
       ByteData[0]:=HexToByte(aPacketString,Index);
       ByteData[1]:=HexToByte(aPacketString,Index);
       ByteData[2]:=HexToByte(aPacketString,Index);
       ByteData[3]:=HexToByte(aPacketString,Index);
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt32(@ByteData[0])^,4) then begin
        inc(MemoryAddress,4);
       end else begin
        break;
       end;
      end;
      5:begin
       ByteData[0]:=HexToByte(aPacketString,Index);
       ByteData[1]:=HexToByte(aPacketString,Index);
       ByteData[2]:=HexToByte(aPacketString,Index);
       ByteData[3]:=HexToByte(aPacketString,Index);
       ByteData[4]:=HexToByte(aPacketString,Index);
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt32(@ByteData[0])^,4) then begin
        inc(MemoryAddress,4);
       end else begin
        break;
       end;
       if fHART.StoreEx(MemoryAddress,ByteData[4],1) then begin
        inc(MemoryAddress);
       end else begin
        break;
       end;
      end;
      6:begin
       ByteData[0]:=HexToByte(aPacketString,Index);
       ByteData[1]:=HexToByte(aPacketString,Index);
       ByteData[2]:=HexToByte(aPacketString,Index);
       ByteData[3]:=HexToByte(aPacketString,Index);
       ByteData[4]:=HexToByte(aPacketString,Index);
       ByteData[5]:=HexToByte(aPacketString,Index);
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt32(@ByteData[0])^,4) then begin
        inc(MemoryAddress,4);
       end else begin
        break;
       end;
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt16(@ByteData[4])^,2) then begin
        inc(MemoryAddress,2);
       end else begin
        break;
       end;
      end;
      7:begin
       ByteData[0]:=HexToByte(aPacketString,Index);
       ByteData[1]:=HexToByte(aPacketString,Index);
       ByteData[2]:=HexToByte(aPacketString,Index);
       ByteData[3]:=HexToByte(aPacketString,Index);
       ByteData[4]:=HexToByte(aPacketString,Index);
       ByteData[5]:=HexToByte(aPacketString,Index);
       ByteData[6]:=HexToByte(aPacketString,Index);
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt32(@ByteData[0])^,4) then begin
        inc(MemoryAddress,4);
       end else begin
        break;
       end;
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt16(@ByteData[4])^,2) then begin
        inc(MemoryAddress,2);
       end else begin
        break;
       end;
       if fHART.StoreEx(MemoryAddress,ByteData[6],1) then begin
        inc(MemoryAddress);
       end else begin
        break;
       end;
      end;
      8:begin
       ByteData[0]:=HexToByte(aPacketString,Index);
       ByteData[1]:=HexToByte(aPacketString,Index);
       ByteData[2]:=HexToByte(aPacketString,Index);
       ByteData[3]:=HexToByte(aPacketString,Index);
       ByteData[4]:=HexToByte(aPacketString,Index);
       ByteData[5]:=HexToByte(aPacketString,Index);
       ByteData[6]:=HexToByte(aPacketString,Index);
       ByteData[7]:=HexToByte(aPacketString,Index);
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt64(@ByteData[0])^,8) then begin
        inc(MemoryAddress,8);
       end else begin
        break;
       end;
      end;
      else begin
       break;
      end;
     end;
     dec(Remain,ToDo);
    end;
    if Remain=0 then begin
     ReplyString('OK');
    end else begin
     ReplyString('E00');
    end;
   end else begin
    ReplyString('E00');
   end;
  end;
  else begin
   ReplyString('');
  end;
 end;
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessReadRegisters;
var s:TPasRISCVRawByteString;
    Register:THART.TRegister;
begin
 if assigned(fHART) then begin
  s:='';
  for Register:=THART.TRegister(0) to THART.TRegister(31) do begin
   s:=s+LittleEndianValueToHex(fHART.fState.Registers[Register],8);
  end;
  s:=s+LittleEndianValueToHex(fHART.fState.PC,8);
  ReplyString(s);
 end else begin
  ReplyString('E.Invalid CPU');
 end;
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessWriteRegisters(const aPacketString:TPasRISCVRawByteString);
var StringPosition:TPasRISCVSizeInt;
    Register:THART.TRegister;
begin
 if assigned(fHART) then begin
  StringPosition:=1;
  for Register:=THART.TRegister(0) to THART.TRegister(31) do begin
   if (StringPosition+16)<=length(aPacketString) then begin
    fHART.fState.Registers[Register]:=HexToLittleEndianValue(aPacketString,StringPosition,8);
   end else begin
    break;
   end;
  end;
  if (StringPosition+16)<=length(aPacketString) then begin
   fHART.fState.PC:=HexToLittleEndianValue(aPacketString,StringPosition,8);
  end;
 end;
 ReplyString('OK');
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessSetThread(const aPacketString:TPasRISCVRawByteString);
var ThreadID,Position,Size:TPasRISCVSizeInt;
begin
 if length(aPacketString)>=2 then begin
  Position:=2;
  if (Position<=length(aPacketString)) and (aPacketString[Position]='g') then begin
   inc(Position);
   ThreadID:=StrToUIntBase(aPacketString,Position,Size,16);
   if ThreadID<fDebugger.fMachine.fCountHARTs then begin
    fHART:=fDebugger.fMachine.fHARTs[ThreadID];
   end else begin
    fHART:=nil;
   end;
  end;
 end;
 ReplyString('OK');
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessHaltReason;
begin
 ReplyString('S05');
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessQuery(const aPacketString:TPasRISCVRawByteString);
var HARTIndex,Index:TPasRISCVSizeInt;
    QueryCommand,QueryPayload,Feature,s:TPasRISCVRawByteString;
begin
 QueryCommand:='';
 QueryPayload:='';
 if length(aPacketString)>=2 then begin
  for Index:=2 to length(aPacketString) do begin
   if aPacketString[Index]=TPasRISCVRawByteChar(':') then begin
    QueryCommand:=Copy(aPacketString,2,Index-2);
    QueryPayload:=Copy(aPacketString,Index+1,length(aPacketString)-Index);
    break;
   end;
  end;
 end;
 if QueryCommand='Supported' then begin
  s:='PacketSize=1024';
  Index:=1;
  while Index<=length(QueryPayload) do begin
   Feature:='';
   while (Index<=length(QueryPayload)) and (QueryPayload[Index]<>';') do begin
    Feature:=Feature+QueryPayload[Index];
    inc(Index);
   end;
   if (Index<=length(QueryPayload)) and (QueryPayload[Index]=';') then begin
    inc(Index);
   end;
  {if Feature='qXfer:features:read+' then begin
    if length(s)>0 then begin
     s:=s+';';
    end;
    s:=s+'qXfer:features:read+';
   end else if Feature='multiprocess+' then begin
    if length(s)>0 then begin
     s:=s+';';
    end;
    s:=s+'multiprocess+';
   end else}if Feature='swbreak+' then begin
    if length(s)>0 then begin
     s:=s+';';
    end;
    s:=s+'swbreak+';
{  end else if Feature='vContSupported+' then begin
    if length(s)>0 then begin
     s:=s+';';
    end;
    s:=s+'vContSupported+';}
   end else if (length(Feature)>1) and (Feature[length(Feature)]='+') then begin
    if length(s)>0 then begin
     s:=s+';';
    end;
    s:=s+copy(Feature,1,length(Feature)-1)+'-';
   end;
  end;
  ReplyString(s);
 end else if QueryCommand='fThreadInfo' then begin
  s:='m';
  for HARTIndex:=0 to fDebugger.fMachine.fCountHARTs-1 do begin
   s:=s+IntToStr(HARTIndex);
   if (HARTIndex+1)<fDebugger.fMachine.fCountHARTs then begin
    s:=s+',';
   end;
  end;
  ReplyString(s);
 end else if QueryCommand='sThreadInfo' then begin
  ReplyString('l');
{end else if QueryCommand='Attached' then begin
  ReplyString('1');}
 end else begin
  ReplyString('');
 end;
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessReset;
begin
 fDebugger.Reset;
 ReplyString('OK');
end;

procedure TPasRISCV.TDebugger.TClientThread.HandlePacket(const aPacketString:TPasRISCVRawByteString);
begin
 if length(aPacketString)>0 then begin
  fDebugger.Pause;
  case TPasRISCVUInt8(aPacketString[1]) of
   TPasRISCVUInt8(TPasRISCVRawByteChar('s')):begin
    // Step
    ProcessStep;
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('c')):begin
    // Continue
    ProcessContinue;
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('m')):begin
    // Read memory
    ProcessMemory(aPacketString,false);
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('M')):begin
    // Write memory
    ProcessMemory(aPacketString,true);
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('g')):begin
    // Read registers
    ProcessReadRegisters;
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('G')):begin
    // Write registers
    ProcessWriteRegisters(aPacketString);
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('T')):begin
    // Thread status
    ReplyString('OK');
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('H')):begin
    // Set thread
    ProcessSetThread(aPacketString);
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('?')):begin
    // Halt reason
    ProcessHaltReason;
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('q')):begin
    // Query
    ProcessQuery(aPacketString);
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('r')):begin
    // Reset
    ProcessReset;
   end;
   else begin
    ReplyString('');
   end;
  end;
 end;
end;

function TPasRISCV.TDebugger.TClientThread.ParsePacket:Boolean;
var Index:TPasRISCVSizeInt;
    PacketString:TPasRISCVRawByteString;
begin

 // Process the packet
 for Index:=0 to fRecvSize-1 do begin
  if (fRecvBuffer[Index]=TPasRISCVUInt8(AnsiChar('#'))) and ((Index+3)<=fRecvSize) then begin
   ReplyACK;
   PacketString:='';
   SetLength(PacketString,Index-1);
   Move(fRecvBuffer[1],PacketString[1],Index-1);
   try
 // writeln('> $'+PacketString+'#'+Chr(fRecvBuffer[Index+1])+Chr(fRecvBuffer[Index+2]));
    HandlePacket(PacketString);
   finally
    PacketString:='';
   end;
   ConsumeBytes(Index+3);
   result:=true;
   exit;
  end;
 end;

 if fRecvSize>=GDB_MAX_PACKET_SIZE then begin
  // Buffer overflow
  WriteLn('GDBStub Buffer overflow');
  ReplyNAK;
  ConsumeBytes(fRecvSize);
 end;

 result:=false;
end;

procedure TPasRISCV.TDebugger.TClientThread.Execute;
var Conditions:TRNLSocketWaitConditions;
    Ret:TPasRISCVSizeInt;
begin
 NameThreadForDebugging('TPasRISCV.TDebugger.TClientThread');
 while not (Terminated or fDebugger.fTerminated) do begin
  Conditions:=[TRNLSocketWaitCondition.RNL_SOCKET_WAIT_CONDITION_IO_RECEIVE,
               TRNLSocketWaitCondition.RNL_SOCKET_WAIT_CONDITION_SERVICE_INTERRUPT];
  fDebugger.fRNLNetwork.SocketWait([fSocket],Conditions,10,fDebugger.fRNLNetworkEvent);
  if Terminated or fDebugger.fTerminated then begin
   break;
  end else begin
   if TRNLSocketWaitCondition.RNL_SOCKET_WAIT_CONDITION_IO_RECEIVE in Conditions then begin
    if fRecvSize<SizeOf(TPacketBuffer) then begin
     Ret:=fDebugger.fRNLNetwork.Receive(fSocket,@fAddress,fRecvBuffer[fRecvSize],SizeOf(TPacketBuffer)-fRecvSize,RNL_IPV4);
     if Ret>0 then begin
      writeln('> ',Copy(PAnsiChar(@fRecvBuffer[fRecvSize]),0,Ret));
     end;
    end else begin
     Ret:=0;
    end;
    if Ret>=0 then begin
     inc(fRecvSize,Ret);
     while fRecvSize>0 do begin
      case fRecvBuffer[0] of
       TPasRISCVUInt8(AnsiChar('$')):begin
        // Packet
        if not ParsePacket then begin
         // Incomplete packet, wait for more data, so break the loop
         break;
        end;
       end;
       TPasRISCVUInt8(AnsiChar('+')):begin
        // ACK
//      writeln('> +');
        ConsumeBytes(1);
       end;
       TPasRISCVUInt8(AnsiChar('-')):begin
        // NAK
//      writeln('> -');
        ResendReply;
        ConsumeBytes(1);
       end;
       $03:begin
//      writeln('> 0x3');
        fDebugger.Interrupt;
        ConsumeBytes(1);
       end;
       else begin
//      writeln('GDBStub Desync');
        ReplyNAK;
        ConsumeBytes(1);
       end;
      end;
     end;
    end else begin
//   writeln('GDBStub error');
     break;
    end;
   end;
  end;
 end;
end;

{ TPasRISCV.TDebugger.TServerThread }

constructor TPasRISCV.TDebugger.TServerThread.Create(const aDebugger:TDebugger);
begin
 fDebugger:=aDebugger;
 inherited Create(false);
end;

destructor TPasRISCV.TDebugger.TServerThread.Destroy;
begin
 Shutdown;
 inherited Destroy;
end;

procedure TPasRISCV.TDebugger.TServerThread.Shutdown;
begin
 if not Finished then begin
  Terminate;
  fDebugger.fRNLNetworkEvent.SetEvent;
  WaitFor;
 end;
end;

procedure TPasRISCV.TDebugger.TServerThread.Execute;
var ClientSocket:TRNLSocket;
    ClientThread:TClientThread;
    Conditions:TRNLSocketWaitConditions;
    ClientAddress:TRNLAddress;
    Count:TPasMPInt32;
begin
 NameThreadForDebugging('TPasRISCV.TDebugger.TServerThread');
 fListenSocket:=fDebugger.fRNLNetwork.SocketCreate(TRNLSocketType.RNL_SOCKET_TYPE_STREAM,RNL_IPV4);
 if fListenSocket<>RNL_SOCKET_NULL then begin
  try
   try
    fDebugger.fRNLNetwork.SocketSetOption(fListenSocket,RNL_SOCKET_OPTION_NONBLOCK,1);
    fDebugger.fRNLNetwork.SocketSetOption(fListenSocket,RNL_SOCKET_OPTION_REUSEADDR,1);
 ///fDebugger.fRNLNetwork.SocketSetOption(fListenSocket,RNL_SOCKET_OPTION_IPV6_V6ONLY,0);
    if fDebugger.fRNLNetwork.SocketBind(fListenSocket,@fDebugger.fServerAddress,RNL_IPV4) then begin
     try
      if fDebugger.fRNLNetwork.SocketListen(fListenSocket,64) then begin
       while not Terminated do begin
        Conditions:=[TRNLSocketWaitCondition.RNL_SOCKET_WAIT_CONDITION_IO_RECEIVE,
                     TRNLSocketWaitCondition.RNL_SOCKET_WAIT_CONDITION_IO_SEND,
                     TRNLSocketWaitCondition.RNL_SOCKET_WAIT_CONDITION_SERVICE_INTERRUPT];
        // Special IFDEF case for Windows, because WSACloseEvent (in TRNLRealNetwork.EmulatePoll)
        // seems to be close the to accepting socket, so here fRNLNetworkEvent will be not used, so
        // that TRNLRealNetwork.SocketWait uses then the native select-API without this issue,
        // but with a lower timeout value as a compensation, for less time lag at the server
        // shutdown process.
        fDebugger.fRNLNetwork.SocketWait([fListenSocket],Conditions,{$ifdef Windows}10,nil{$else}100,fDebugger.fRNLNetworkEvent{$endif});
        if Terminated then begin
         break;
        end else begin
         if ([TRNLSocketWaitCondition.RNL_SOCKET_WAIT_CONDITION_IO_RECEIVE,
              TRNLSocketWaitCondition.RNL_SOCKET_WAIT_CONDITION_IO_SEND]*Conditions)<>[] then begin
          repeat
           ClientSocket:=fDebugger.fRNLNetwork.SocketAccept(fListenSocket,@ClientAddress,RNL_IPV4);
           if ClientSocket=RNL_SOCKET_NULL then begin
            break;
           end else begin
            Count:=0;
            if (fDebugger.fClientsInvertedSemaphore.Acquire(1,Count)=1) and (Count>=0) then begin
             TClientThread.Create(fDebugger,ClientSocket,ClientAddress);
            end else begin
             try
              fDebugger.fRNLNetwork.SocketShutdown(ClientSocket);
             finally
              fDebugger.fRNLNetwork.SocketDestroy(ClientSocket);
             end;
            end;
           end;
           break;
          until Terminated;
          if Terminated then begin
           break;
          end;
         end;
        end;
       end;
      end;
     finally
      fDebugger.fRNLNetwork.SocketShutdown(fListenSocket);
     end;
    end;
   finally
    fDebugger.fRNLNetwork.SocketDestroy(fListenSocket);
   end;
  finally
  end;
 end;
end;

{ TPasRISCV.TDebugger }

constructor TPasRISCV.TDebugger.Create(const aMachine:TPasRISCV;const aPort:TPasRISCVUInt16);
begin
 inherited Create;
 fMachine:=aMachine;
 fRNLInstance:=TRNLInstance.Create;
 fRNLNetwork:=TRNLRealNetwork.Create(fRNLInstance);
 fRNLNetworkEvent:=TRNLNetworkEvent.Create;
 fClientsInvertedSemaphore:=TPasMPInvertedSemaphore.Create(0,$7ffffffe);
 fServerAddress:=TRNLAddress.CreateFromString('0.0.0.0:'+IntToStr(aPort));
 fLock:=TPasMPCriticalSection.Create;
 fClientThreads:=nil;
 fCountClientThreads:=0;
 fServerThread:=nil;
//fSWBreakState:=SWBREAK_NONE;
 fTerminated:=false;
end;

destructor TPasRISCV.TDebugger.Destroy;
begin
 Stop;
 FreeAndNil(fLock);
 FreeAndNil(fRNLNetworkEvent);
 FreeAndNil(fRNLNetwork);
 FreeAndNil(fRNLInstance);
 FreeAndNil(fClientsInvertedSemaphore);
 inherited Destroy;
end;

procedure TPasRISCV.TDebugger.Interrupt;
var ClientIndex:TPasRISCVSizeInt;
    ClientThread:TClientThread;
begin
 fMachine.Pause(true);
 fLock.Acquire;
 try
  for ClientIndex:=0 to fCountClientThreads-1 do begin
   ClientThread:=fClientThreads[ClientIndex];
   if assigned(ClientThread) then begin
    ClientThread.ProcessHaltReason;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TDebugger.NotifyPaused;
var ClientIndex:TPasRISCVSizeInt;
    ClientThread:TClientThread;
begin
 fLock.Acquire;
 try
{if TPasMPInterlocked.CompareExchange(fSWBreakState,SWBREAK_ACTIVE,SWBREAK_TRIGGERED)=SWBREAK_TRIGGERED then begin
  end;}
  for ClientIndex:=0 to fCountClientThreads-1 do begin
   ClientThread:=fClientThreads[ClientIndex];
   if assigned(ClientThread) then begin
    ClientThread.ProcessHaltReason;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

function TPasRISCV.TDebugger.Halt:Boolean;
begin
 fLock.Acquire;
 try
  if fCountClientThreads>0 then begin
   result:=fMachine.QueuePause(false);//TPasMPInterlocked.CompareExchange(fSWBreakState,SWBREAK_TRIGGERED,SWBREAK_NONE)=SWBREAK_NONE;
  end else begin
   result:=false;
  end;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TDebugger.Pause;
begin
 fMachine.Pause(true);
{if TPasMPInterlocked.CompareExchange(fSWBreakState,SWBREAK_PAUSED,SWBREAK_ACTIVE)=SWBREAK_ACTIVE then begin
 end;}
end;

procedure TPasRISCV.TDebugger.SingleStep;
begin
//fSWBreakState:=SWBREAK_NONE;
 fMachine.SingleStep(false);
end;

procedure TPasRISCV.TDebugger.Continue_;
begin
//fSWBreakState:=SWBREAK_NONE;
 fMachine.Resume(true);
end;

procedure TPasRISCV.TDebugger.Reset;
begin
 fMachine.Resume(false);
 TPasMPInterlocked.BitwiseOr(fMachine.fRunState,TPasMPUInt32(RUNSTATE_REBOOT));
 fMachine.Interrupt;
 fMachine.WakeUp;
end;

procedure TPasRISCV.TDebugger.Start;
begin
 if not assigned(fServerThread) then begin
  fServerThread:=TServerThread.Create(self);
 end;
end;

procedure TPasRISCV.TDebugger.Stop;
var //ClientIndex:TPasRISCVSizeInt;
    ClientThread:TClientThread;
begin

 if assigned(fServerThread) then begin

  fTerminated:=true;

  // Shutdown server thread first, so that no new clients can connect anymore while we are shutting down
  try
   fServerThread.Shutdown;
  finally
   FreeAndNil(fServerThread);
  end;

  // Shutdown all client threads, after the server thread has been shut down
  fLock.Acquire;
  try

   while fCountClientThreads>0 do begin

    dec(fCountClientThreads);

    ClientThread:=fClientThreads[fCountClientThreads];
    if assigned(ClientThread) then begin

     // Unlock the client thread list lock before shutting down the client thread, so that the client thread can remove itself from the list
     fLock.Release;
     try
      try
       ClientThread.Shutdown;
      finally
       FreeAndNil(ClientThread);
      end;
     finally
      fLock.Acquire;
     end;

    end;
   end;

  finally
   fLock.Release;
  end;

 end;

end;

{ TPasRISCV.TConfiguration }

constructor TPasRISCV.TConfiguration.Create;
begin
 inherited Create;

 fDebugger:=false;
 fDebuggerPort:=1234;

 fCountHARTs:=1;

 fBootArguments:='root=/dev/mem rw earlyprintk console=$LINUXUART$ console=tty0 earlycon=sbi';

 fBootMemoryBase:=TPasRISCVUInt64($00000000);
 fBootMemorySize:=TPasRISCVUInt64(65536);

 fMemoryBase:=TPasRISCVUInt64($80000000);
 fMemorySize:=TPasRISCVUInt64(256) shl 20;

 fCLINTBase:=TPasRISCV.TACLINTDevice.DefaultBaseAddress;
 fCLINTSize:=TPasRISCV.TACLINTDevice.DefaultSize;

 fIMSICMachineBase:=TPasRISCV.TIMSICDevice.DefaultBaseAddressMachine;
 fIMSICMachineSizePerHART:=TPasRISCV.TIMSICDevice.DefaultSizePerHART;

 fIMSICSupervisorBase:=TPasRISCV.TIMSICDevice.DefaultBaseAddressSupervisor;
 fIMSICSupervisorSizePerHART:=TPasRISCV.TIMSICDevice.DefaultSizePerHART;

 fAPLICMachineBase:=TPasRISCV.TAPLICDevice.DefaultDomainBaseAddressMachine;
 fAPLICMachineSize:=TPasRISCV.TAPLICDevice.DefaultDomainSize;

 fAPLICSupervisorBase:=TPasRISCV.TAPLICDevice.DefaultDomainBaseAddressSupervisor;
 fAPLICSupervisorSize:=TPasRISCV.TAPLICDevice.DefaultDomainSize;

 fPLICBase:=TPasRISCV.TPLICDevice.DefaultBaseAddress;
 fPLICSize:=TPasRISCV.TPLICDevice.DefaultSize;

 fSYSCONBase:=TPasRISCV.TSYSCONDevice.DefaultBaseAddress;
 fSYSCONSize:=TPasRISCV.TSYSCONDevice.DefaultSize;

 fUARTBase:=TPasRISCV.TUARTDevice.DefaultBaseAddress;
 fUARTSize:=TPasRISCV.TUARTDevice.DefaultSize;
 fUARTIRQ:=TPasRISCV.TUARTDevice.DefaultIRQ;

 fVirtIOBlockBase:=TPasRISCV.TVirtIOBlockDevice.DefaultBaseAddress;
 fVirtIOBlockSize:=TPasRISCV.TVirtIOBlockDevice.DefaultSize;
 fVirtIOBlockIRQ:=TPasRISCV.TVirtIOBlockDevice.DefaultIRQ;

 fDS1742Base:=TPasRISCV.TDS1742Device.DefaultBaseAddress;
 fDS1742Size:=TPasRISCV.TDS1742Device.DefaultSize;

 fFrameBufferBase:=TPasRISCVUInt64($28000000)-TFrameBufferDevice.FrameBufferAddress;
 fFrameBufferWidth:=640;
 fFrameBufferHeight:=400;
 fFrameBufferBytesPerPixel:=4;
 fFrameBufferStride:=fFrameBufferWidth*fFrameBufferBytesPerPixel;
 fFrameBufferSize:=fFrameBufferWidth*fFrameBufferHeight*fFrameBufferBytesPerPixel;
 fFrameBufferFormat:=0;

 fRawKeyboardBase:=TPasRISCV.TRawKeyboardDevice.DefaultBaseAddress;
 fRawKeyboardSize:=TPasRISCV.TRawKeyboardDevice.DefaultSize;

 fI2CBase:=TPasRISCV.TI2CDevice.DefaultBaseAddress;
 fI2CSize:=TPasRISCV.TI2CDevice.DefaultSize;

 fPS2KeyboardBase:=TPasRISCV.TPS2KeyboardDevice.DefaultBaseAddress;
 fPS2KeyboardSize:=TPasRISCV.TPS2KeyboardDevice.DefaultSize;
 fPS2KeyboardIRQ:=TPasRISCV.TPS2KeyboardDevice.DefaultIRQ;

 fPS2MouseBase:=TPasRISCV.TPS2MouseDevice.DefaultBaseAddress;
 fPS2MouseSize:=TPasRISCV.TPS2MouseDevice.DefaultSize;
 fPS2MouseIRQ:=TPasRISCV.TPS2MouseDevice.DefaultIRQ;

 fVirtIOInputKeyboardBase:=TPasRISCV.TVirtIOInputKeyboardDevice.DefaultBaseAddress;
 fVirtIOInputKeyboardSize:=TPasRISCV.TVirtIOInputKeyboardDevice.DefaultSize;
 fVirtIOInputKeyboardIRQ:=TPasRISCV.TVirtIOInputKeyboardDevice.DefaultIRQ;

 fVirtIOInputMouseBase:=TPasRISCV.TVirtIOInputMouseDevice.DefaultBaseAddress;
 fVirtIOInputMouseSize:=TPasRISCV.TVirtIOInputMouseDevice.DefaultSize;
 fVirtIOInputMouseIRQ:=TPasRISCV.TVirtIOInputMouseDevice.DefaultIRQ;

 fVirtIOSoundBase:=TPasRISCV.TVirtIOSoundDevice.DefaultBaseAddress;
 fVirtIOSoundSize:=TPasRISCV.TVirtIOSoundDevice.DefaultSize;
 fVirtIOSoundIRQ:=TPasRISCV.TVirtIOSoundDevice.DefaultIRQ;

 fVirtIO9PBase:=TPasRISCV.TVirtIO9PDevice.DefaultBaseAddress;
 fVirtIO9PSize:=TPasRISCV.TVirtIO9PDevice.DefaultSize;
 fVirtIO9PIRQ:=TPasRISCV.TVirtIO9PDevice.DefaultIRQ;

 fVirtIONetBase:=TPasRISCV.TVirtIONetDevice.DefaultBaseAddress;
 fVirtIONetSize:=TPasRISCV.TVirtIONetDevice.DefaultSize;
 fVirtIONetIRQ:=TPasRISCV.TVirtIONetDevice.DefaultIRQ;

 fVirtIORandomGeneratorBase:=TPasRISCV.TVirtIORandomGeneratorDevice.DefaultBaseAddress;
 fVirtIORandomGeneratorSize:=TPasRISCV.TVirtIORandomGeneratorDevice.DefaultSize;
 fVirtIORandomGeneratorIRQ:=TPasRISCV.TVirtIORandomGeneratorDevice.DefaultIRQ;

 fBIOS:=TMemoryStream.Create;

 fKernel:=TMemoryStream.Create;

 fINITRD:=TMemoryStream.Create;

 fAIA:=false;

end;

destructor TPasRISCV.TConfiguration.Destroy;
begin
 FreeAndNil(fINITRD);
 FreeAndNil(fKernel);
 FreeAndNil(fBIOS);
 inherited Destroy;
end;

procedure TPasRISCV.TConfiguration.Assign(const aConfiguration:TConfiguration);
begin

 fDebugger:=aConfiguration.fDebugger;
 fDebuggerPort:=aConfiguration.fDebuggerPort;

 fCountHARTs:=aConfiguration.fCountHARTs;

 fBootArguments:=aConfiguration.fBootArguments;

 fBootMemoryBase:=aConfiguration.fBootMemoryBase;
 fBootMemorySize:=aConfiguration.fBootMemorySize;

 fMemoryBase:=aConfiguration.fMemoryBase;
 fMemorySize:=aConfiguration.fMemorySize;

 fCLINTBase:=aConfiguration.fCLINTBase;
 fCLINTSize:=aConfiguration.fCLINTSize;

 fIMSICMachineBase:=aConfiguration.fIMSICMachineBase;
 fIMSICMachineSizePerHART:=aConfiguration.fIMSICMachineSizePerHART;

 fIMSICSupervisorBase:=aConfiguration.fIMSICSupervisorBase;
 fIMSICSupervisorSizePerHART:=aConfiguration.fIMSICSupervisorSizePerHART;

 fAPLICMachineBase:=aConfiguration.fAPLICMachineBase;
 fAPLICMachineSize:=aConfiguration.fAPLICMachineSize;

 fAPLICSupervisorBase:=aConfiguration.fAPLICSupervisorBase;
 fAPLICSupervisorSize:=aConfiguration.fAPLICSupervisorSize;

 fPLICBase:=aConfiguration.fPLICBase;
 fPLICSize:=aConfiguration.fPLICSize;

 fSYSCONBase:=aConfiguration.fSYSCONBase;
 fSYSCONSize:=aConfiguration.fSYSCONSize;

 fUARTBase:=aConfiguration.fUARTBase;
 fUARTSize:=aConfiguration.fUARTSize;
 fUARTIRQ:=aConfiguration.fUARTIRQ;

 fVirtIOBlockBase:=aConfiguration.fVirtIOBlockBase;
 fVirtIOBlockSize:=aConfiguration.fVirtIOBlockSize;
 fVirtIOBlockIRQ:=aConfiguration.fVirtIOBlockIRQ;

 fDS1742Base:=aConfiguration.fDS1742Base;
 fDS1742Size:=aConfiguration.fDS1742Size;

 fFrameBufferBase:=aConfiguration.fFrameBufferBase;
 fFrameBufferWidth:=aConfiguration.fFrameBufferWidth;
 fFrameBufferHeight:=aConfiguration.fFrameBufferHeight;
 fFrameBufferBytesPerPixel:=aConfiguration.fFrameBufferBytesPerPixel;
 fFrameBufferStride:=aConfiguration.fFrameBufferStride;
 fFrameBufferSize:=aConfiguration.fFrameBufferSize;
 fFrameBufferFormat:=aConfiguration.fFrameBufferFormat;

 fRawKeyboardBase:=aConfiguration.fRawKeyboardBase;
 fRawKeyboardSize:=aConfiguration.fRawKeyboardSize;

 fI2CBase:=aConfiguration.fI2CBase;
 fI2CSize:=aConfiguration.fI2CSize;

 fPS2KeyboardBase:=aConfiguration.fPS2KeyboardBase;
 fPS2KeyboardSize:=aConfiguration.fPS2KeyboardSize;
 fPS2KeyboardIRQ:=aConfiguration.fPS2KeyboardIRQ;

 fPS2MouseBase:=aConfiguration.fPS2MouseBase;
 fPS2MouseSize:=aConfiguration.fPS2MouseSize;
 fPS2MouseIRQ:=aConfiguration.fPS2MouseIRQ;

 fVirtIOInputKeyboardBase:=aConfiguration.fVirtIOInputKeyboardBase;
 fVirtIOInputKeyboardSize:=aConfiguration.fVirtIOInputKeyboardSize;
 fVirtIOInputKeyboardIRQ:=aConfiguration.fVirtIOInputKeyboardIRQ;

 fVirtIOInputMouseBase:=aConfiguration.fVirtIOInputMouseBase;
 fVirtIOInputMouseSize:=aConfiguration.fVirtIOInputMouseSize;
 fVirtIOInputMouseIRQ:=aConfiguration.fVirtIOInputMouseIRQ;

 fVirtIOSoundBase:=aConfiguration.fVirtIOSoundBase;
 fVirtIOSoundSize:=aConfiguration.fVirtIOSoundSize;
 fVirtIOSoundIRQ:=aConfiguration.fVirtIOSoundIRQ;

 fVirtIO9PBase:=aConfiguration.fVirtIO9PBase;
 fVirtIO9PSize:=aConfiguration.fVirtIO9PSize;
 fVirtIO9PIRQ:=aConfiguration.fVirtIO9PIRQ;

 fVirtIONetBase:=aConfiguration.fVirtIONetBase;
 fVirtIONetSize:=aConfiguration.fVirtIONetSize;
 fVirtIONetIRQ:=aConfiguration.fVirtIONetIRQ;

 fVirtIORandomGeneratorBase:=aConfiguration.fVirtIORandomGeneratorBase;
 fVirtIORandomGeneratorSize:=aConfiguration.fVirtIORandomGeneratorSize;
 fVirtIORandomGeneratorIRQ:=aConfiguration.fVirtIORandomGeneratorIRQ;

 fAIA:=aConfiguration.fAIA;

 fBIOS.Clear;
 if aConfiguration.fBIOS.Size>0 then begin
  aConfiguration.fBIOS.Seek(0,soBeginning);
  fBIOS.CopyFrom(aConfiguration.fBIOS,aConfiguration.fBIOS.Size);
 end;

 fKernel.Clear;
 if aConfiguration.fKernel.Size>0 then begin
  aConfiguration.fKernel.Seek(0,soBeginning);
  fKernel.CopyFrom(aConfiguration.fKernel,aConfiguration.fKernel.Size);
 end;

 fINITRD.Clear;
 if aConfiguration.fINITRD.Size>0 then begin
  aConfiguration.fINITRD.Seek(0,soBeginning);
  fINITRD.CopyFrom(aConfiguration.fINITRD,aConfiguration.fINITRD.Size);
 end;

end;

procedure TPasRISCV.TConfiguration.LoadBIOSFromFile(const aFileName:TPasRISCVUTF8String);
begin
 fBIOS.Clear;
 fBIOS.LoadFromFile(aFileName);
end;

procedure TPasRISCV.TConfiguration.LoadBIOSFromStream(const aStream:TStream);
begin
 fBIOS.Clear;
 if aStream.Size>0 then begin
  aStream.Seek(0,soBeginning);
  fBIOS.CopyFrom(aStream,aStream.Size);
 end;
end;

procedure TPasRISCV.TConfiguration.LoadBIOSFromMemory(const aMemory:pointer;const aSize:TPasRISCVSizeInt);
begin
 fBIOS.Clear;
 if aSize>0 then begin
  fBIOS.WriteBuffer(aMemory^,aSize);
 end;
end;

procedure TPasRISCV.TConfiguration.LoadKernelFromFile(const aFileName:TPasRISCVUTF8String);
begin
 fKernel.Clear;
 fKernel.LoadFromFile(aFileName);
end;

procedure TPasRISCV.TConfiguration.LoadKernelFromStream(const aStream:TStream);
begin
 fKernel.Clear;
 if aStream.Size>0 then begin
  aStream.Seek(0,soBeginning);
  fKernel.CopyFrom(aStream,aStream.Size);
 end;
end;

procedure TPasRISCV.TConfiguration.LoadKernelFromMemory(const aMemory:pointer;const aSize:TPasRISCVSizeInt);
begin
 fKernel.Clear;
 if aSize>0 then begin
  fKernel.WriteBuffer(aMemory^,aSize);
 end;
end;

procedure TPasRISCV.TConfiguration.LoadINITRDFromFile(const aFileName:TPasRISCVUTF8String);
begin
 fINITRD.Clear;
 fINITRD.LoadFromFile(aFileName);
end;

procedure TPasRISCV.TConfiguration.LoadINITRDFromStream(const aStream:TStream);
begin
 fINITRD.Clear;
 if aStream.Size>0 then begin
  aStream.Seek(0,soBeginning);
  fINITRD.CopyFrom(aStream,aStream.Size);
 end;
end;

procedure TPasRISCV.TConfiguration.LoadINITRDFromMemory(const aMemory:pointer;const aSize:TPasRISCVSizeInt);
begin
 fINITRD.Clear;
 if aSize>0 then begin
  fINITRD.WriteBuffer(aMemory^,aSize);
 end;
end;

{ TPasRISCV }

constructor TPasRISCV.Create(const aConfiguration:TConfiguration);
var Index:TPasRISCVSizeInt;
    HART:THART;
begin
 inherited Create;

 fRandomGeneratorLock:=TPasMPSlimReaderWriterLock.Create;

 fRandomGenerator:=TRNLRandomGenerator.Create;

 fPCG32Lock:=TPasMPSlimReaderWriterLock.Create;

 fPCG32.Init(GetCurrentTime xor fRandomGenerator.GetUInt64);

 fPHandleCounter:=0;

 fInterrupts:=TInterrupts.Create(self);

 fFDT:=TFDT.Create;

 fFDTStream:=TMemoryStream.Create;

 fConfiguration:=TConfiguration.Create;
 if assigned(aConfiguration) then begin
  fConfiguration.Assign(aConfiguration);
 end;

 fCountHARTs:=fConfiguration.fCountHARTs;
 if fCountHARTs<1 then begin
  fCountHARTs:=1;
 end else if fCountHARTs>16 then begin
  fCountHARTs:=16;
 end;

 InitializeFDT;

 fRunState:=RUNSTATE_RUNNING;

 fFlushTLBHARTMask:=0;

 fHARTActiveMask:=0;

 fHARTRunningMask:=0;

 fAllHARTMask:=0;

 fHARTWakeUpConditionVariableLock:=TPasMPConditionVariableLock.Create;
 fHARTWakeUpConditionVariable:=TPasMPConditionVariable.Create;

 fHARTStatusChangeConditionVariableLock:=TPasMPConditionVariableLock.Create;
 fHARTStatusChangeConditionVariable:=TPasMPConditionVariable.Create;

 fOnReboot:=nil;

 fOnNewFrame:=nil;

 fOnCPUException:=nil;

 fWakeUpConditionVariableLock:=TPasMPConditionVariableLock.Create;

 fWakeUpConditionVariable:=TPasMPConditionVariable.Create;

 fAtomicCriticalSection:=TCriticalSection.Create;

 fJobManager:=TJobManager.Create(4);

 fBootMemoryDevice:=TMemoryDevice.Create(self,fConfiguration.fBootMemoryBase,fConfiguration.fBootMemorySize);

 fMemoryDevice:=TMemoryDevice.Create(self,fConfiguration.fMemoryBase,fConfiguration.fMemorySize);

 fACLINTDevice:=TACLINTDevice.Create(self);

 if fConfiguration.fAIA then begin

  fIMSICMachineDevice:=TIMSICDevice.Create(self,fConfiguration.fIMSICMachineBase,fConfiguration.fIMSICMachineSizePerHART*fConfiguration.CountHARTs,TPasRISCV.TAIARegFileMode.Machine);

  fIMSICSupervisorDevice:=TIMSICDevice.Create(self,fConfiguration.fIMSICSupervisorBase,fConfiguration.fIMSICSupervisorSizePerHART*fConfiguration.CountHARTs,TPasRISCV.TAIARegFileMode.Supervisor);

  fAPLICDevice:=TAPLICDevice.Create(self);

  fPLICDevice:=nil;

  fINTCDevice:=fAPLICDevice;

 end else begin

  fIMSICMachineDevice:=nil;

  fIMSICSupervisorDevice:=nil;

  fPLICDevice:=TPLICDevice.Create(self);

  fINTCDevice:=fPLICDevice;

 end;

 fSYSCONDevice:=TSYSCONDevice.Create(self);

 fVirtIOBlockDevice:=TVirtIOBlockDevice.Create(self);

 fUARTDevice:=TUARTDevice.Create(self);

 fDS1742Device:=TDS1742Device.Create(self);

 fPCIBusDevice:=TPCIBusDevice.Create(self);

 fFrameBufferDevice:=TFrameBufferDevice.Create(self);

 fRawKeyboardDevice:=TRawKeyboardDevice.Create(self);

{fI2CDevice:=TI2CDevice.Create(self);

 fI2CHIDKeyboardBusDevice:=TI2CHIDKeyboardBusDevice.Create(fI2CDevice);
 fI2CDevice.AttachBusDevice(fI2CHIDKeyboardBusDevice);//\}

 fPS2KeyboardDevice:=TPS2KeyboardDevice.Create(self);

 fPS2MouseDevice:=TPS2MouseDevice.Create(self);

 fVirtIOInputKeyboardDevice:=TVirtIOInputKeyboardDevice.Create(self);

 fVirtIOInputMouseDevice:=TVirtIOInputMouseDevice.Create(self);

 fVirtIOSoundDevice:=TVirtIOSoundDevice.Create(self);

 fVirtIO9PDevice:=TVirtIO9PDevice.Create(self);

 fVirtIONetDevice:=TVirtIONetDevice.Create(self);

 fVirtIORandomGeneratorDevice:=TVirtIORandomGeneratorDevice.Create(self);

 fBus:=TBus.Create(self);
 fBus.AddBusDevice(fBootMemoryDevice);
 fBus.AddBusDevice(fMemoryDevice);
 fBus.AddBusDevice(fACLINTDevice);
 if assigned(fIMSICMachineDevice) then begin
  fBus.AddBusDevice(fIMSICMachineDevice);
 end;
 if assigned(fIMSICSupervisorDevice) then begin
  fBus.AddBusDevice(fIMSICSupervisorDevice);
 end;
 if assigned(fAPLICDevice) then begin
  fBus.AddBusDevice(fAPLICDevice);
 end;
 if assigned(fPLICDevice) then begin
  fBus.AddBusDevice(fPLICDevice);
 end;
 fBus.AddBusDevice(fSYSCONDevice);
 fBus.AddBusDevice(fVirtIOBlockDevice);
 fBus.AddBusDevice(fUARTDevice);
 fBus.AddBusDevice(fDS1742Device);
 fBus.AddBusDevice(fPCIBusDevice);
 fBus.AddBusDevice(fFrameBufferDevice);
 fBus.AddBusDevice(fRawKeyboardDevice);
//fBus.AddBusDevice(fI2CDevice);
 fBus.AddBusDevice(fPS2KeyboardDevice);
 fBus.AddBusDevice(fPS2MouseDevice);
 fBus.AddBusDevice(fVirtIOInputKeyboardDevice);
 fBus.AddBusDevice(fVirtIOInputMouseDevice);
 fBus.AddBusDevice(fVirtIOSoundDevice);
 fBus.AddBusDevice(fVirtIO9PDevice);
 fBus.AddBusDevice(fVirtIONetDevice);
 fBus.AddBusDevice(fVirtIORandomGeneratorDevice);

 fNVMeDevice:=TNVMeDevice.Create(fPCIBusDevice);
 fPCIBusDevice.AddBusDevice(fNVMeDevice);

 fHARTs:=nil;
 SetLength(fHARTs,fCountHARTs);
 for Index:=0 to length(fHARTs)-1 do begin
  HART:=THART.Create(self,Index);
  try
  finally
   fHARTs[Index]:=HART;
  end;
 end;

 fHART:=fHARTs[0];

 if fConfiguration.fDebugger then begin

  fDebugger:=TDebugger.Create(self,fConfiguration.fDebuggerPort);

  fDebugger.Start;

 end else begin

  fDebugger:=nil;

 end;

end;

destructor TPasRISCV.Destroy;
var Index:TPasRISCVSizeInt;
//  HART:THART;
begin

 if assigned(fDebugger) then begin
  try
   fDebugger.Stop;
  finally
   FreeAndNil(fDebugger);
  end;
 end;

 ShutdownCPUs;

 fJobManager.Shutdown;

 for Index:=0 to length(fHARTs)-1 do begin
  FreeAndNil(fHARTs[Index]);
 end;

 fHARTs:=nil;
 fHART:=nil;

 fPCIBusDevice.RemoveBusDevice(fNVMeDevice);

 FreeAndNil(fNVMeDevice);

 FreeAndNil(fMemoryDevice);

 FreeAndNil(fSYSCONDevice);

 FreeAndNil(fPLICDevice);

 FreeAndNil(fIMSICSupervisorDevice);

 FreeAndNil(fIMSICMachineDevice);

 FreeAndNil(fACLINTDevice);

 FreeAndNil(fVirtIOBlockDevice);

 FreeAndNil(fUARTDevice);

 FreeAndNil(fDS1742Device);

 FreeAndNil(fPCIBusDevice);

 FreeAndNil(fFrameBufferDevice);

 FreeAndNil(fRawKeyboardDevice);

 FreeAndNil(fI2CHIDKeyboardBusDevice);
 FreeAndNil(fI2CDevice);

 FreeAndNil(fPS2KeyboardDevice);
 FreeAndNil(fPS2MouseDevice);

 FreeAndNil(fVirtIOInputKeyboardDevice);
 FreeAndNil(fVirtIOInputMouseDevice);
 FreeAndNil(fVirtIOSoundDevice);
 FreeAndNil(fVirtIO9PDevice);
 FreeAndNil(fVirtIONetDevice);
 FreeAndNil(fVirtIORandomGeneratorDevice);

 FreeAndNil(fBus);

 FreeAndNil(fAtomicCriticalSection);

 FreeAndNil(fInterrupts);

 FreeAndNil(fJobManager);

 FreeAndNil(fConfiguration);

 FreeAndNil(fFDTStream);
 FreeAndNil(fFDT);

 FreeAndNil(fPCG32Lock);

 FreeAndNil(fRandomGenerator);

 FreeAndNil(fRandomGeneratorLock);

 FreeAndNil(fHARTWakeUpConditionVariable);
 FreeAndNil(fHARTWakeUpConditionVariableLock);

 FreeAndNil(fHARTStatusChangeConditionVariable);
 FreeAndNil(fHARTStatusChangeConditionVariableLock);

 FreeAndNil(fWakeUpConditionVariable);
 FreeAndNil(fWakeUpConditionVariableLock);

 inherited Destroy;

end;

procedure TPasRISCV.ShutdownCPUs;
var Index:TPasRISCVSizeInt;
    HART:THART;
begin

 for Index:=0 to length(fHARTs)-1 do begin
  HART:=fHARTs[Index];
  if not HART.fExecutionThread.Finished then begin
   HART.fExecutionThread.Terminate;
  end;
 end;

 fHARTWakeUpConditionVariableLock.Acquire;
 try
  TPasMPInterlocked.BitwiseOr(TPasMPUInt32(fRunState),RUNSTATE_POWEROFF);
  TPasMPInterlocked.BitwiseAnd(TPasMPUInt32(fRunState),not TPasMPUInt32(RUNSTATE_RUNNING));
  fHARTWakeUpConditionVariable.Broadcast;
 finally
  fHARTWakeUpConditionVariableLock.Release;
 end;

 fHARTStatusChangeConditionVariableLock.Acquire;
 try
  while TPasMPInterlocked.Read(fHARTRunningMask)<>0 do begin
   fHARTStatusChangeConditionVariable.Wait(fHARTStatusChangeConditionVariableLock);
  end;
 finally
  fHARTStatusChangeConditionVariableLock.Release;
 end;

 for Index:=0 to length(fHARTs)-1 do begin
  HART:=fHARTs[Index];
  if not HART.fExecutionThread.Finished then begin
   HART.fExecutionThread.WaitFor;
  end;
 end;

end;

function TPasRISCV.AllocatePHandle:TPasRISCVUInt32;
begin
 result:=TPasMPInterlocked.Increment(fPHandleCounter);
end;

procedure TPasRISCV.InitializeFDT;
var Index,DeviceID,IRQPin:TPasRISCVSizeInt;
    ChosenNode,CPUNode,CPUInterruptControllerNode,CPUsNode,CPUMap,CPUClusterNode,CoreNode,
    MemoryNode,SysConNode,PowerOffNode,RebootNode,
    SoCNode,IMSIC0,IMSICM0,IMSICS0,APLIC0,APLICM0,APLICS0,PLIC0,ACLINTNode,UART0,DS1742Node,
    INTC0,PCIBusNode,
    I2CClockNode,I2CNode,I2CHIDKeyboardNode,
    PS2KeyboardNode,PS2MouseNode,
    VirtIOBlockNode,
    VirtIOInputKeyboardNode,VirtIOInputMouseNode,VirtIOSoundNode,VirtIO9PNode,VirtIONetNode,
    VirtIORandomGeneratorNode,
    SimpleFrameBufferNode:TPasRISCV.TFDT.TFDTNode;
    AIARegFileMode:TPasRISCV.TAIARegFileMode;
    CPUInterruptControllerNodes:array[0..15] of TPasRISCV.TFDT.TFDTNode;
    CPUNodes:array of TPasRISCV.TFDT.TFDTNode;
    InterruptControllerHandle:TPasRISCVUInt32;
    RandomBuffer:array[0..15] of TPasRISCVUInt32;
    Cells:array[0..3] of TPasRISCVUInt32;
    Ranges:array[0..20] of TPasRISCVUInt32;
    InterruptExtCells:array[0..(4*16)-1] of TPasRISCVUInt32;
    InterruptMap:TPasRISCVUInt32DynamicArray;
    InterrurtMask:array[0..3] of TPasRISCVUInt32;
    BootArguments:TPasRISCVRawByteString;
    FileStream:TFileStream;
    IRQExt:TPasRISCVUInt32DynamicArray;
    ISA,ISAExtensions:TPasRISCVRawByteString;
begin

 FreeAndNil(fFDT);

 CPUNodes:=nil;
 try

  fFDT:=TFDT.Create;

  fFDT.fRoot.AddPropertyU32('#address-cells',2);
  fFDT.fRoot.AddPropertyU32('#size-cells',2);

  fFDT.fRoot.AddPropertyString('model','riscv-virtio,qemu,pasriscv');
  fFDT.fRoot.AddPropertyString('compatible','riscv-virtio'#0'pasriscv'#0);

  ISA:='rv64imafdcb_zicsr_zifencei_zkr_zicboz_zicbom_svadu_sstc_svnapot';
//ISA:=ISA+'_svpbmt';
  ISAExtensions:='i'#0'm'#0'a'#0'f'#0'd'#0'c'#0'b'#0'zicsr'#0'zifencei'#0'zkr'#0+
                  'zicboz'#0'zicbom'#0'svadu'#0'sstc'#0'svnapot';
  if fConfiguration.AIA then begin
   ISA:=ISA+'_smaia_ssaia';
   ISAExtensions:=ISAExtensions+#0'smaia'#0'ssaia';
  end;

  ChosenNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'chosen');
  try
   BootArguments:=fConfiguration.fBootArguments;
   BootArguments:=StringReplace(BootArguments,'$LINUXUART$','uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase),[rfReplaceAll,rfIgnoreCase]);
   ChosenNode.AddPropertyString('bootargs',BootArguments);
 //ChosenNode.AddPropertyString('bootargs','console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/mem rw earlyprintk console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','rw earlyprintk debug console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/mem rw earlyprintk debug console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/mem rw earlyprintk debug console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/vda1 rw earlyprintk debug console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/vda4 rw earlyprintk console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/vda4 rw earlyprintk console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/mem rw earlyprintk console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' console=tty0 earlycon=sbi');
 // ChosenNode.AddPropertyString('bootargs','root=/dev/vda rw console=ttyS earlycon=sbi earlyprintk');
 //  ChosenNode.AddPropertyString('bootargs','root=/dev/vda rw console=ttyS console=tty0 earlycon=sbi earlyprintk');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/nvme0 rootflags=discard rw earlyprintk debug console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' rootwait earlycon=sbi');
 //  ChosenNode.AddPropertyString('bootargs','root=/dev/vda rootflags=discard rw earlyprintk debug console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' rootwait earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/nvme0n1 rootflags=discard rw earlyprintk debug console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' rootwait earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','earlyprintk debug console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' rootwait earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','earlyprintk debug root=/dev/vda1 console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' rootwait earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/vda rw console=ttyS console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','rw console=ttyS console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/vda rw console=ttyS console=tty0 earlycon=sbi');
   ChosenNode.AddPropertyString('stdout-path','/soc/uart@'+FDTHex64(fConfiguration.fUARTBase));
   if fKernelSize>0 then begin
    ChosenNode.AddPropertyU64('riscv,kernel-start',fConfiguration.fMemoryBase+fKernelOffset);
    ChosenNode.AddPropertyU64('riscv,kernel-end',fConfiguration.fMemoryBase+fKernelOffset+fKernelSize);
   end;
   if fINITRDSize>0 then begin
    ChosenNode.AddPropertyU64('linux,initrd-start',fConfiguration.fMemoryBase+fINITRDOffset);
    ChosenNode.AddPropertyU64('linux,initrd-end',fConfiguration.fMemoryBase+fINITRDOffset+fINITRDSize);
   end;
   fRandomGeneratorLock.Acquire;
   try
    for Index:=0 to 15 do begin
     RandomBuffer[Index]:=fRandomGenerator.GetUInt32;
    end;
   finally
    fRandomGeneratorLock.Release;
   end;
   ChosenNode.AddProperty('rng-seed',RandomBuffer,SizeOf(RandomBuffer));
  finally
   fFDT.fRoot.AddChild(ChosenNode);
  end;

  CPUsNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'cpus');
  try

   CPUsNode.AddPropertyU32('#address-cells',1);
   CPUsNode.AddPropertyU32('#size-cells',0);
   CPUsNode.AddPropertyU32('timebase-frequency',CLOCK_FREQUENCY);

   CPUMap:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'cpus-map');
   try

    CPUClusterNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'cluster0');
    try

     SetLength(CPUNodes,length(fHARTs));
     for Index:=0 to length(fHARTs)-1 do begin

      CPUNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'cpu@'+IntToStr(Index));
      try

       CPUNode.GetPHandle;

       CPUNode.AddPropertyString('device_type','cpu');
       CPUNode.AddPropertyU32('reg',Index);
       CPUNode.AddPropertyString('status','okay');
       CPUNode.AddPropertyString('compatible','riscv');
       CPUNode.AddPropertyU32('riscv,cboz-block-size',64);
       CPUNode.AddPropertyU32('riscv,cbom-block-size',64);
       CPUNode.AddPropertyString('riscv,isa',ISA);
       CPUNode.AddPropertyString('riscv,isa-base','rv64i');
       CPUNode.AddPropertyString('riscv,isa-extensions',ISAExtensions);
       CPUNode.AddPropertyString('mmu-type','riscv,sv39');
       CPUNode.AddPropertyU32('clock-frequency',3000000000);

       CPUInterruptControllerNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'cpu'+IntToStr(Index)+'-intc');
       try
        CPUInterruptControllerNode.GetPHandle;
        CPUInterruptControllerNode.AddPropertyU32('#interrupt-cells',1);
        CPUInterruptControllerNode.AddPropertyCells('interrupt-controller',nil,0);
        CPUInterruptControllerNode.AddPropertyString('compatible','riscv,cpu-intc');
       finally
        CPUNode.AddChild(CPUInterruptControllerNode);
        CPUInterruptControllerNodes[Index]:=CPUInterruptControllerNode;
       end;

       CoreNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'core'+IntToStr(Index));
       try

        CoreNode.AddPropertyU32('cpu',CPUNode.GetPHandle);

       finally
        CPUClusterNode.AddChild(CoreNode);
       end;

      finally
       CPUsNode.AddChild(CPUNode);
       CPUNodes[Index]:=CPUNode;
      end;

     end;

    finally
     CPUMap.AddChild(CPUClusterNode);
    end;

   finally
    CPUsNode.AddChild(CPUMap);
   end;

  finally
   fFDT.fRoot.AddChild(CPUsNode);
  end;

  MemoryNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'memory',fConfiguration.fMemoryBase);
  try
   MemoryNode.AddPropertyString('device_type','memory');
   Cells[0]:=0;
   Cells[1]:=fConfiguration.fMemoryBase;
   Cells[2]:=0;
   Cells[3]:=fConfiguration.fMemorySize;
   MemoryNode.AddPropertyCells('reg',@Cells,4);
  finally
   fFDT.fRoot.AddChild(MemoryNode);
  end;

  SysConNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'syscon',fConfiguration.fSYSCONBase);
  try
   SysConNode.GetPHandle;
   Cells[0]:=0;
   Cells[1]:=fConfiguration.fSYSCONBase;
   Cells[2]:=0;
   Cells[3]:=fConfiguration.fSYSCONSize;
   SysConNode.AddPropertyCells('reg',@Cells,4);
   SysConNode.AddPropertyString('compatible','sifive,test1'#0'sifive,test0'#0'syscon'#0);
  finally
   fFDT.fRoot.AddChild(SysConNode);
  end;

  PowerOffNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'poweroff');
  try
   PowerOffNode.AddPropertyU32('value',$5555);
   PowerOffNode.AddPropertyU32('offset',0);
   PowerOffNode.AddPropertyU32('regmap',SysConNode.GetPHandle);
   PowerOffNode.AddPropertyString('compatible','syscon-poweroff');
  finally
   fFDT.fRoot.AddChild(PowerOffNode);
  end;

  RebootNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'reboot');
  try
   RebootNode.AddPropertyU32('value',$7777);
   RebootNode.AddPropertyU32('offset',0);
   RebootNode.AddPropertyU32('regmap',SysConNode.GetPHandle);
   RebootNode.AddPropertyString('compatible','syscon-reboot');
  finally
   fFDT.fRoot.AddChild(RebootNode);
  end;

  SoCNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'soc');
  try

   SoCNode.AddPropertyU32('#address-cells',2);
   SoCNode.AddPropertyU32('#size-cells',2);
   SoCNode.AddPropertyString('compatible','simple-bus');
   SoCNode.AddPropertyCells('ranges',nil,0);

   if fConfiguration.fAIA then begin

    INTC0:=nil;

    for AIARegFileMode:=Low(TPasRISCV.TAIARegFileMode) to High(TPasRISCV.TAIARegFileMode) do begin

     case AIARegFileMode of
      TPasRISCV.TAIARegFileMode.Machine:begin
       IMSIC0:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'imsics_m',fConfiguration.fIMSICMachineBase);
       APLIC0:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'aplics_m',fConfiguration.fAPLICMachineBase);
      end;
      TPasRISCV.TAIARegFileMode.Supervisor:begin
       IMSIC0:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'imsics_s',fConfiguration.fIMSICSupervisorBase);
       APLIC0:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'aplics_s',fConfiguration.fAPLICSupervisorBase);
      end;
      else begin
      end;
     end;
     try

      ///////////
      // IMSIC //
      ///////////

      IMSIC0.GetPHandle;

      Cells[0]:=0;
      Cells[1]:=fConfiguration.fIMSICMachineBase;
      Cells[2]:=0;
      Cells[3]:=fConfiguration.fIMSICMachineSizePerHART*fConfiguration.fCountHARTs;
      IMSIC0.AddPropertyCells('reg',@Cells,4);

      IMSIC0.AddPropertyString('compatible','riscv,imsics');
      IMSIC0.AddPropertyCells('interrupt-controller',nil,0);
      IMSIC0.AddPropertyU32('#interrupt-cells',0);
      IMSIC0.AddPropertyCells('msi-controller',nil,0);
      IMSIC0.AddPropertyU32('#msi-cells',0);
      IMSIC0.AddPropertyU32('riscv,num-ids',TPasRISCV.THART.TAIARegFile.IRQ_LIMIT-1);

      IRQExt:=nil;
      try
       SetLength(IRQExt,length(CPUNodes)*2);
       for Index:=0 to length(CPUNodes)-1 do begin
        CPUNode:=CPUNodes[Index];
        if assigned(CPUNode) then begin
         CPUInterruptControllerNode:=CPUInterruptControllerNodes[Index];
         if assigned(CPUInterruptControllerNode) then begin
          IRQExt[(Index shl 1) or 0]:=CPUInterruptControllerNode.GetPHandle;
          case AIARegFileMode of
           TPasRISCV.TAIARegFileMode.Machine:begin
            IRQExt[(Index shl 1) or 1]:=TPasRISCVUInt32(TPasRISCV.THART.TInterruptValue.MachineExternal);
           end;
           TPasRISCV.TAIARegFileMode.Supervisor:begin
            IRQExt[(Index shl 1) or 1]:=TPasRISCVUInt32(TPasRISCV.THART.TInterruptValue.SupervisorExternal);
           end;
           else begin
           end;
          end;
         end;
        end;
       end;
       IMSIC0.AddPropertyCells('interrupts-extended',@IRQExt[0],length(IRQExt));
      finally
       IRQExt:=nil;
      end;

      ///////////
      // APLIC //
      ///////////

      APLIC0.GetPHandle;

      Cells[0]:=0;
      Cells[2]:=0;
      case AIARegFileMode of
       TPasRISCV.TAIARegFileMode.Machine:begin
        Cells[1]:=fConfiguration.fAPLICMachineBase;
        Cells[3]:=fConfiguration.fAPLICMachineSize;
       end;
       TPasRISCV.TAIARegFileMode.Supervisor:begin
        Cells[1]:=fConfiguration.fAPLICSupervisorBase;
        Cells[3]:=fConfiguration.fAPLICSupervisorSize;
       end;
       else begin
        Cells[1]:=0;
        Cells[3]:=0;
       end;
      end;
      APLIC0.AddPropertyCells('reg',@Cells,4);

      APLIC0.AddPropertyString('compatible','riscv,aplic');
      APLIC0.AddPropertyU32('msi-parent',IMSIC0.GetPHandle);
      APLIC0.AddPropertyCells('interrupt-controller',nil,0);
      APLIC0.AddPropertyU32('#interrupt-cells',2);
      APLIC0.AddPropertyU32('#address-cells',0);
      APLIC0.AddPropertyU32('riscv,num-sources',TPasRISCV.TAPLICDevice.APLIC_SRC_LIMIT-1);
      
     finally
      SoCNode.AddChild(IMSIC0);
      SoCNode.AddChild(APLIC0);
      case AIARegFileMode of
       TPasRISCV.TAIARegFileMode.Machine:begin
        IMSICM0:=IMSIC0;
        APLICM0:=APLIC0;
       end;
       TPasRISCV.TAIARegFileMode.Supervisor:begin
        IMSICS0:=IMSIC0;
        APLICS0:=APLIC0;
       end;
       else begin
       end;
      end;
     end;

    end;

    Cells[0]:=APLICS0.GetPHandle;
    Cells[1]:=1;
    Cells[2]:=TPasRISCV.TAPLICDevice.APLIC_SRC_LIMIT-1;
    Cells[3]:=0;
    APLICM0.AddPropertyU32('riscv,children',APLICS0.GetPHandle);
    APLICM0.AddPropertyCells('riscv,delegate',@Cells,3);
    APLICM0.AddPropertyCells('riscv,delegation',@Cells,3);

    PLIC0:=nil;
     
    // APLIC as interrupt controller for devices 
    INTC0:=APLICS0;

   end else begin

    IMSICM0:=nil;

    IMSICS0:=nil;

    APLICM0:=nil;

    APLICS0:=nil;

    PLIC0:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'interrupt-controller',fConfiguration.fPLICBase);
    try

     PLIC0.GetPHandle;
     PLIC0.AddPropertyU32('riscv,ndev',$35);

     Cells[0]:=0;
     Cells[1]:=fConfiguration.fPLICBase;
     Cells[2]:=0;
     Cells[3]:=fConfiguration.fPLICSize;
     PLIC0.AddPropertyCells('reg',@Cells,4);

     for Index:=0 to length(fHARTs)-1 do begin
      InterruptExtCells[(Index shl 2) or 0]:=CPUInterruptControllerNodes[Index].GetPHandle;
      InterruptExtCells[(Index shl 2) or 1]:=TPasRISCVUInt32(THART.TInterruptValue.MachineExternal);
      InterruptExtCells[(Index shl 2) or 2]:=CPUInterruptControllerNodes[Index].GetPHandle;
      InterruptExtCells[(Index shl 2) or 3]:=TPasRISCVUInt32(THART.TInterruptValue.SupervisorExternal);
     end;
     PLIC0.AddPropertyCells('interrupts-extended',@InterruptExtCells[0],length(fHARTs)*4);

     PLIC0.AddPropertyCells('interrupt-controller',nil,0);
  // PLIC0.AddPropertyString('compatible','riscv,plic0');
     PLIC0.AddPropertyString('compatible','sifive,plic-1.0.0');
     PLIC0.AddPropertyU32('#interrupt-cells',1);
     PLIC0.AddPropertyU32('#address-cells',0);

    finally
     SoCNode.AddChild(PLIC0);
    end;
    
    // PLIC as interrupt controller for devices
    INTC0:=PLIC0;
    
   end;

   ACLINTNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'clint',fConfiguration.fCLINTBase);
   try

    Cells[0]:=0;
    Cells[1]:=fConfiguration.fCLINTBase;
    Cells[2]:=0;
    Cells[3]:=fConfiguration.fCLINTSize;
    ACLINTNode.AddPropertyCells('reg',@Cells,4);

    for Index:=0 to length(fHARTs)-1 do begin
     InterruptExtCells[(Index shl 2) or 0]:=CPUInterruptControllerNodes[Index].GetPHandle;
     InterruptExtCells[(Index shl 2) or 1]:=TPasRISCVUInt32(THART.TInterruptValue.MachineSoftware);
     InterruptExtCells[(Index shl 2) or 2]:=CPUInterruptControllerNodes[Index].GetPHandle;
     InterruptExtCells[(Index shl 2) or 3]:=TPasRISCVUInt32(THART.TInterruptValue.MachineTimer);
    end;
    ACLINTNode.AddPropertyCells('interrupts-extended',@InterruptExtCells[0],length(fHARTs)*4);

    ACLINTNode.AddPropertyString('compatible','sifive,clint0'#0'riscv,clint0'#0);

   finally
    SoCNode.AddChild(ACLINTNode);
   end;

   UART0:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'uart',fConfiguration.fUARTBase);
   try

    UART0.AddPropertyU32('interrupts',fConfiguration.fUARTIRQ);
    UART0.AddPropertyU32('interrupt-parent',INTC0.GetPHandle);
    UART0.AddPropertyU32('clock-frequency',$384000);

    Cells[0]:=0;
    Cells[1]:=fConfiguration.fUARTBase;
    Cells[2]:=0;
    Cells[3]:=fConfiguration.fUARTSize;
    UART0.AddPropertyCells('reg',@Cells,4);

    UART0.AddPropertyString('compatible','ns16550a');

   finally
    SoCNode.AddChild(UART0);
   end;

   DS1742Node:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'rtc',fConfiguration.fDS1742Base);
   try
    DS1742Node.AddPropertyReg('reg',fConfiguration.fDS1742Base,fConfiguration.fDS1742Size);
    DS1742Node.AddPropertyString('compatible','maxim,ds1742');
   finally
    SoCNode.AddChild(DS1742Node);
   end;//}

   begin

    PCIBusNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'pci',TPCI.PCI_BASE_DEFAULT_MMIO);
    try

     PCIBusNode.AddPropertyU32('#address-cells',3);

     PCIBusNode.AddPropertyU32('#size-cells',2);

     PCIBusNode.AddPropertyU32('#interrupt-cells',1);

     PCIBusNode.AddPropertyString('device_type','pci');

     Cells[0]:=0;
     Cells[1]:=TPCI.PCI_BASE_DEFAULT_MMIO;
     Cells[2]:=0;
     Cells[3]:=256 shl 20;//TPCI.PCI_SIZE;
     PCIBusNode.AddPropertyCells('reg',@Cells,4);

     PCIBusNode.AddPropertyString('compatible','pci-host-ecam-generic');

     PCIBusNode.AddPropertyString('dma-coherent','');

     Cells[0]:=0;
     Cells[1]:=255;//TPCI.PCI_BUS_COUNT-1;
     PCIBusNode.AddPropertyCells('bus-range',@Cells,2);

     Ranges[0]:=$1000000;
     Ranges[1]:=0;
     Ranges[2]:=0;
     Ranges[3]:=TPCI.PCI_IO_DEFAULT_ADDR shr 32;
     Ranges[4]:=TPCI.PCI_IO_DEFAULT_ADDR and TPasRISCVUInt64($ffffffff);
     Ranges[5]:=TPCI.PCI_IO_DEFAULT_SIZE shr 32;
     Ranges[6]:=TPCI.PCI_IO_DEFAULT_SIZE and TPasRISCVUInt64($ffffffff);

     Ranges[7]:=$2000000;
     Ranges[8]:=TPCI.PCI_MEM32_DEFAULT_MMIO shr 32;
     Ranges[9]:=TPCI.PCI_MEM32_DEFAULT_MMIO and TPasRISCVUInt64($ffffffff);
     Ranges[10]:=TPCI.PCI_MEM32_DEFAULT_MMIO shr 32;
     Ranges[11]:=TPCI.PCI_MEM32_DEFAULT_MMIO and TPasRISCVUInt64($ffffffff);
     Ranges[12]:=TPCI.PCI_MEM32_DEFAULT_SIZE shr 32;
     Ranges[13]:=TPCI.PCI_MEM32_DEFAULT_SIZE and TPasRISCVUInt64($ffffffff);

 {   Ranges[14]:=$43000000;
     Ranges[15]:=TPCI.PCI_MEM64_DEFAULT_MMIO shr 32;
     Ranges[16]:=TPCI.PCI_MEM64_DEFAULT_MMIO and TPasRISCVUInt64($ffffffff);
     Ranges[17]:=TPCI.PCI_MEM64_DEFAULT_MMIO shr 32;
     Ranges[18]:=TPCI.PCI_MEM64_DEFAULT_MMIO and TPasRISCVUInt64($ffffffff);
     Ranges[19]:=TPCI.PCI_MEM64_DEFAULT_SIZE shr 32;
     Ranges[20]:=TPCI.PCI_MEM64_DEFAULT_SIZE and TPasRISCVUInt64($ffffffff);}

     if TPCI.PCI_IO_DEFAULT_SIZE<>0 then begin
      PCIBusNode.AddPropertyCells('ranges',@Ranges[0],14{21});
     end else begin
      PCIBusNode.AddPropertyCells('ranges',@Ranges[7],7);
     end;

     // Crossing-style IRQ routing for IRQ balancing
     InterruptControllerHandle:=INTC0.GetPHandle;

     InterruptMap:=nil;
     try
      SetLength(InterruptMap,TPCI.PCI_BUS_IRQS*TPCI.PCI_BUS_IRQS*6);
      Index:=0;
      for DeviceID:=0 to TPCI.PCI_BUS_IRQS-1 do begin
       for IRQPin:=1 to TPCI.PCI_BUS_IRQS do begin

        // PCIe address
        InterruptMap[Index+0]:=DeviceID shl 11;
        InterruptMap[Index+1]:=0;
        InterruptMap[Index+2]:=0;

        // PCIe irq pin
        InterruptMap[Index+3]:=IRQPin;

        // Interrupt controller handle
        InterruptMap[Index+4]:=InterruptControllerHandle;

        // Interrupt cell(s)
        InterruptMap[Index+5]:=TPCI.PCI_IRQs[TPasRISCV.TPCIBusDevice.GetIRQID(DeviceID,IRQPin)];

        inc(Index,6);
       end;
      end;

      PCIBusNode.AddPropertyCells('interrupt-map',@InterruptMap[0],length(InterruptMap));

     finally
      InterruptMap:=nil;
     end;

{    InterruptMap:=nil;
     try
      SetLength(InterruptMap,96);
      InterruptMap[0]:=$0000;  InterruptMap[1]:=0;  InterruptMap[2]:=0;  InterruptMap[3]:=1;  InterruptMap[4]:=InterruptControllerHandle;  InterruptMap[5]:=TPCI.PCI_IRQs[0];
      InterruptMap[6]:=$0000;  InterruptMap[7]:=0;  InterruptMap[8]:=0;  InterruptMap[9]:=2;  InterruptMap[10]:=InterruptControllerHandle; InterruptMap[11]:=TPCI.PCI_IRQs[1];
      InterruptMap[12]:=$0000; InterruptMap[13]:=0; InterruptMap[14]:=0; InterruptMap[15]:=3; InterruptMap[16]:=InterruptControllerHandle; InterruptMap[17]:=TPCI.PCI_IRQs[2];
      InterruptMap[18]:=$0000; InterruptMap[19]:=0; InterruptMap[20]:=0; InterruptMap[21]:=4; InterruptMap[22]:=InterruptControllerHandle; InterruptMap[23]:=TPCI.PCI_IRQs[3];
      InterruptMap[24]:=$0800; InterruptMap[25]:=0; InterruptMap[26]:=0; InterruptMap[27]:=1; InterruptMap[28]:=InterruptControllerHandle; InterruptMap[29]:=TPCI.PCI_IRQs[1];
      InterruptMap[30]:=$0800; InterruptMap[31]:=0; InterruptMap[32]:=0; InterruptMap[33]:=2; InterruptMap[34]:=InterruptControllerHandle; InterruptMap[35]:=TPCI.PCI_IRQs[2];
      InterruptMap[36]:=$0800; InterruptMap[37]:=0; InterruptMap[38]:=0; InterruptMap[39]:=3; InterruptMap[40]:=InterruptControllerHandle; InterruptMap[41]:=TPCI.PCI_IRQs[3];
      InterruptMap[42]:=$0800; InterruptMap[43]:=0; InterruptMap[44]:=0; InterruptMap[45]:=4; InterruptMap[46]:=InterruptControllerHandle; InterruptMap[47]:=TPCI.PCI_IRQs[0];
      InterruptMap[48]:=$1000; InterruptMap[49]:=0; InterruptMap[50]:=0; InterruptMap[51]:=1; InterruptMap[52]:=InterruptControllerHandle; InterruptMap[53]:=TPCI.PCI_IRQs[2];
      InterruptMap[54]:=$1000; InterruptMap[55]:=0; InterruptMap[56]:=0; InterruptMap[57]:=2; InterruptMap[58]:=InterruptControllerHandle; InterruptMap[59]:=TPCI.PCI_IRQs[3];
      InterruptMap[60]:=$1000; InterruptMap[61]:=0; InterruptMap[62]:=0; InterruptMap[63]:=3; InterruptMap[64]:=InterruptControllerHandle; InterruptMap[65]:=TPCI.PCI_IRQs[0];
      InterruptMap[66]:=$1000; InterruptMap[67]:=0; InterruptMap[68]:=0; InterruptMap[69]:=4; InterruptMap[70]:=InterruptControllerHandle; InterruptMap[71]:=TPCI.PCI_IRQs[1];
      InterruptMap[72]:=$1800; InterruptMap[73]:=0; InterruptMap[74]:=0; InterruptMap[75]:=1; InterruptMap[76]:=InterruptControllerHandle; InterruptMap[77]:=TPCI.PCI_IRQs[3];
      InterruptMap[78]:=$1800; InterruptMap[79]:=0; InterruptMap[80]:=0; InterruptMap[81]:=2; InterruptMap[82]:=InterruptControllerHandle; InterruptMap[83]:=TPCI.PCI_IRQs[0];
      InterruptMap[84]:=$1800; InterruptMap[85]:=0; InterruptMap[86]:=0; InterruptMap[87]:=3; InterruptMap[88]:=InterruptControllerHandle; InterruptMap[89]:=TPCI.PCI_IRQs[2];
      InterruptMap[90]:=$1800; InterruptMap[91]:=0; InterruptMap[92]:=0; InterruptMap[93]:=4; InterruptMap[94]:=InterruptControllerHandle; InterruptMap[95]:=TPCI.PCI_IRQs[1];
      PCIBusNode.AddPropertyCells('interrupt-map',@InterruptMap[0],96);
     finally
      InterruptMap:=nil;
     end;}

     InterrurtMask[0]:=$1800;
     InterrurtMask[1]:=0;
     InterrurtMask[2]:=0;
     InterrurtMask[3]:=7;
     PCIBusNode.AddPropertyCells('interrupt-map-mask',@InterrurtMask,4);

    finally
     SoCNode.AddChild(PCIBusNode);
    end;

   end;

   SimpleFrameBufferNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'framebuffer',fConfiguration.fFrameBufferBase+TFrameBufferDevice.FrameBufferAddress);
   try
    Cells[0]:=0;
    Cells[1]:=fConfiguration.fFrameBufferBase+TFrameBufferDevice.FrameBufferAddress;
    Cells[2]:=0;
    Cells[3]:=fConfiguration.fFrameBufferSize;
    SimpleFrameBufferNode.AddPropertyCells('reg',@Cells,4);
    SimpleFrameBufferNode.AddPropertyString('compatible','simple-framebuffer');
    SimpleFrameBufferNode.AddPropertyString('format','a8b8g8r8');
    SimpleFrameBufferNode.AddPropertyU32('width',fConfiguration.fFrameBufferWidth);
    SimpleFrameBufferNode.AddPropertyU32('height',fConfiguration.fFrameBufferHeight);
    SimpleFrameBufferNode.AddPropertyU32('stride',fConfiguration.fFrameBufferStride);
   finally
    SoCNode.AddChild(SimpleFrameBufferNode);
   end;//}

   if true then begin

    if true then begin

     PS2KeyboardNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'ps2',fConfiguration.fPS2KeyboardBase);
     try
      Cells[0]:=0;
      Cells[1]:=fConfiguration.fPS2KeyboardBase;
      Cells[2]:=0;
      Cells[3]:=TPasRISCVUInt32(TPasRISCV.TPS2KeyboardDevice.DefaultSize);
      PS2KeyboardNode.AddPropertyCells('reg',@Cells,4);
      PS2KeyboardNode.AddPropertyString('compatible','altr,ps2-1.0');
      PS2KeyboardNode.AddPropertyU32('interrupt-parent',INTC0.GetPHandle);
      PS2KeyboardNode.AddPropertyU32('interrupts',fConfiguration.fPS2KeyboardIRQ);
     finally
      SoCNode.AddChild(PS2KeyboardNode);
     end;

     PS2MouseNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'ps2',fConfiguration.fPS2MouseBase);
     try
      Cells[0]:=0;
      Cells[1]:=fConfiguration.fPS2MouseBase;
      Cells[2]:=0;
      Cells[3]:=TPasRISCVUInt32(TPasRISCV.TPS2MouseDevice.DefaultSize);
      PS2MouseNode.AddPropertyCells('reg',@Cells,4);
      PS2MouseNode.AddPropertyString('compatible','altr,ps2-1.0');
      PS2MouseNode.AddPropertyU32('interrupt-parent',INTC0.GetPHandle);
      PS2MouseNode.AddPropertyU32('interrupts',fConfiguration.fPS2MouseIRQ);
     finally
      SoCNode.AddChild(PS2MouseNode);
     end;

    end;

    if true then begin

     VirtIOInputKeyboardNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'virtio',fConfiguration.fVirtIOInputKeyboardBase);
     try
      VirtIOInputKeyboardNode.AddPropertyString('compatible','virtio,mmio');
      Cells[0]:=0;
      Cells[1]:=fConfiguration.fVirtIOInputKeyboardBase;
      Cells[2]:=0;
      Cells[3]:=fConfiguration.fVirtIOInputKeyboardSize;
      VirtIOInputKeyboardNode.AddPropertyCells('reg',@Cells,4);
      Cells[0]:=INTC0.GetPHandle;
      Cells[1]:=TPasRISCVUInt32(fConfiguration.fVirtIOInputKeyboardIRQ);
      VirtIOInputKeyboardNode.AddPropertyCells('interrupts-extended',@Cells,2);
     finally
      SoCNode.AddChild(VirtIOInputKeyboardNode);
     end;

     VirtIOInputMouseNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'virtio',fConfiguration.fVirtIOInputMouseBase);
     try
      VirtIOInputMouseNode.AddPropertyString('compatible','virtio,mmio');
      Cells[0]:=0;
      Cells[1]:=fConfiguration.fVirtIOInputMouseBase;
      Cells[2]:=0;
      Cells[3]:=fConfiguration.fVirtIOInputMouseSize;
      VirtIOInputMouseNode.AddPropertyCells('reg',@Cells,4);
      Cells[0]:=INTC0.GetPHandle;
      Cells[1]:=TPasRISCVUInt32(fConfiguration.fVirtIOInputMouseIRQ);
      VirtIOInputMouseNode.AddPropertyCells('interrupts-extended',@Cells,2);
     finally
      SoCNode.AddChild(VirtIOInputMouseNode);
     end;

     VirtIOSoundNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'virtio',fConfiguration.fVirtIOSoundBase);
     try
      VirtIOSoundNode.AddPropertyString('compatible','virtio,mmio');
      Cells[0]:=0;
      Cells[1]:=fConfiguration.fVirtIOSoundBase;
      Cells[2]:=0;
      Cells[3]:=fConfiguration.fVirtIOSoundSize;
      VirtIOSoundNode.AddPropertyCells('reg',@Cells,4);
      Cells[0]:=INTC0.GetPHandle;
      Cells[1]:=TPasRISCVUInt32(fConfiguration.fVirtIOSoundIRQ);
      VirtIOSoundNode.AddPropertyCells('interrupts-extended',@Cells,2);
     finally
      SoCNode.AddChild(VirtIOSoundNode);
     end;

     VirtIO9PNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'virtio',fConfiguration.fVirtIO9PBase);
     try
      VirtIO9PNode.AddPropertyString('compatible','virtio,mmio');
      Cells[0]:=0;
      Cells[1]:=fConfiguration.fVirtIO9PBase;
      Cells[2]:=0;
      Cells[3]:=fConfiguration.fVirtIO9PSize;
      VirtIO9PNode.AddPropertyCells('reg',@Cells,4);
      Cells[0]:=INTC0.GetPHandle;
      Cells[1]:=TPasRISCVUInt32(fConfiguration.fVirtIO9PIRQ);
      VirtIO9PNode.AddPropertyCells('interrupts-extended',@Cells,2);
     finally
      SoCNode.AddChild(VirtIO9PNode);
     end;

     VirtIONetNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'virtio',fConfiguration.fVirtIONetBase);
     try
      VirtIONetNode.AddPropertyString('compatible','virtio,mmio');
      Cells[0]:=0;
      Cells[1]:=fConfiguration.fVirtIONetBase;
      Cells[2]:=0;
      Cells[3]:=fConfiguration.fVirtIONetSize;
      VirtIONetNode.AddPropertyCells('reg',@Cells,4);
      Cells[0]:=INTC0.GetPHandle;
      Cells[1]:=TPasRISCVUInt32(fConfiguration.fVirtIONetIRQ);
      VirtIONetNode.AddPropertyCells('interrupts-extended',@Cells,2);
     finally
      SoCNode.AddChild(VirtIONetNode);
     end;

     VirtIORandomGeneratorNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'virtio',fConfiguration.fVirtIORandomGeneratorBase);
     try
      VirtIORandomGeneratorNode.AddPropertyString('compatible','virtio,mmio');
      Cells[0]:=0;
      Cells[1]:=fConfiguration.fVirtIORandomGeneratorBase;
      Cells[2]:=0;
      Cells[3]:=fConfiguration.fVirtIORandomGeneratorSize;
      VirtIORandomGeneratorNode.AddPropertyCells('reg',@Cells,4);
      Cells[0]:=INTC0.GetPHandle;
      Cells[1]:=TPasRISCVUInt32(fConfiguration.fVirtIORandomGeneratorIRQ);
      VirtIORandomGeneratorNode.AddPropertyCells('interrupts-extended',@Cells,2);
     finally
      SoCNode.AddChild(VirtIORandomGeneratorNode);
     end;

    end;

   end;

   if false then begin

    I2CClockNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'i2c_oc_osc');
    try
     I2CClockNode.AddPropertyString('compatible','fixed-clock');
     I2CClockNode.AddPropertyU32('#clock-cells',0);
     I2CClockNode.AddPropertyU32('clock-frequency',20000000);
     I2CClockNode.AddPropertyString('clock-output-names','clk');
    finally
     SoCNode.AddChild(I2CClockNode);
    end;

    I2CNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'i2c',fConfiguration.fI2CBase);
    try
     Cells[0]:=0;
     Cells[1]:=fConfiguration.fI2CBase;
     Cells[2]:=0;
     Cells[3]:=fConfiguration.fI2CSize;
     I2CNode.AddPropertyCells('reg',@Cells,4);
     I2CNode.AddPropertyString('compatible','opencores,i2c-ocores');
     I2CNode.AddPropertyU32('interrupt-parent',INTC0.GetPHandle);
     I2CNode.AddPropertyU32('interrupts',TI2CDevice.IRQ);
     I2CNode.AddPropertyU32('clocks',I2CClockNode.GetPHandle);
     I2CNode.AddPropertyString('clock-names','clk');
     I2CNode.AddPropertyU32('reg-shift',2);
     I2CNode.AddPropertyU32('reg-io-width',1);
     I2CNode.AddPropertyU32('opencores,ip-clock-frequency',20000000);
     I2CNode.AddPropertyU32('#address-cells',1);
     I2CNode.AddPropertyU32('#size-cells',0);
     I2CNode.AddPropertyString('status','okay');

     I2CHIDKeyboardNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'i2c',TI2CHIDKeyboardBusDevice.Address);
     try
      I2CHIDKeyboardNode.AddPropertyString('compatible','hid-over-i2c');
      I2CHIDKeyboardNode.AddPropertyU32('reg',TI2CHIDKeyboardBusDevice.Address);
      I2CHIDKeyboardNode.AddPropertyU32('hid-descr-addr',TI2CHIDKeyboardBusDevice.DESC_REG);
      I2CHIDKeyboardNode.AddPropertyU32('interrupt-parent',INTC0.GetPHandle);
      I2CHIDKeyboardNode.AddPropertyU32('interrupts',TI2CHIDKeyboardBusDevice.IRQ);
     finally
      I2CNode.AddChild(I2CHIDKeyboardNode);
     end;

    finally
     SoCNode.AddChild(I2CNode);
    end;

   end;

   if true then begin

    VirtIOBlockNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'virtio',fConfiguration.fVirtIOBlockBase);
    try
     VirtIOBlockNode.AddPropertyString('compatible','virtio,mmio');
     Cells[0]:=0;
     Cells[1]:=fConfiguration.fVirtIOBlockBase;
     Cells[2]:=0;
     Cells[3]:=fConfiguration.fVirtIOBlockSize;
     VirtIOBlockNode.AddPropertyCells('reg',@Cells,4);
     Cells[0]:=INTC0.GetPHandle;
     Cells[1]:=TPasRISCVUInt32(fConfiguration.fVirtIOBlockIRQ);
     VirtIOBlockNode.AddPropertyCells('interrupts-extended',@Cells,2);
    finally
     SoCNode.AddChild(VirtIOBlockNode);
    end;

   end;

  finally
   fFDT.fRoot.AddChild(SoCNode);
  end;

 {FileStream:=TFileStream.Create('fdt.dtb',fmCreate);
  try
   fFDT.SerializeToStream(FileStream);
  finally
   FreeAndNil(FileStream);
  end;//}

  fFDTStream.Clear;
  fFDT.SerializeToStream(fFDTStream);

 finally
  CPUNodes:=nil;
 end;

end;

function TPasRISCV.LoadELFIntoMemory(const aBinary:TMemoryStream;const aOffset:TPasRISCVUInt64;out aSize:TPasRISCVUInt64;const aObjCopy:Boolean):Boolean;
const ELF_ET_NONE=$0;
      ELF_ET_REL=$1;
      ELF_ET_EXEC=$2;
      ELF_ET_DYN=$3;
      ELF_PT_NULL=$0;
      ELF_PT_LOAD=$1;
      ELF_PT_DYNAMIC=$2;
      ELF_PT_INTERP=$3;
      ELF_PT_NOTE=$4;
      ELF_PT_SHLIB=$5;
      ELF_PT_PHDR=$6;
      ELF_PT_TLS=$7;
      ELF_PF_X=$1;
      ELF_PF_W=$2;
      ELF_PF_R=$4;
      ELF_PN_XNUM=$ffff;
var Tmp:array[0..63] of TPasRISCVUInt8;
    ObjCopy,Class64:Boolean;
    ELFType:TPasRISCVUInt16;
    ELFEntry:TPasRISCVUInt64;
    ELFPHOffset,ELFPHSize,ELFPHNum,ELFLoAddr,ELFHiAddr,ELFPHEntryOffset,
    PType,PVAddr,PMemSize,POffset,PFSize,PHDR,BufferSize,Base:TPasRISCVUInt64;
    Index:TPasRISCVSizeInt;
 function ReadUInt16LE(const aData:pointer):TPasRISCVUInt16;
 begin
{$ifdef LITTLE_ENDIAN}
  result:=PPasRISCVUInt16(aData)^;
{$else}
  result:=TPasRISCVUInt16(PPasRISCVUInt8(aData)^) or
         (TPasRISCVUInt16(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+1)))^) shl 8);
{$endif}
 end;
 function ReadUInt32LE(const aData:pointer):TPasRISCVUInt32;
 begin
 {$ifdef LITTLE_ENDIAN}
  result:=PPasRISCVUInt32(aData)^;
{$else}
  result:=TPasRISCVUInt32(PPasRISCVUInt8(aData)^) or
         (TPasRISCVUInt32(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+1)))^) shl 8) or
         (TPasRISCVUInt32(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+2)))^) shl 16) or
         (TPasRISCVUInt32(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+3)))^) shl 24);
{$endif}
 end;
 function ReadUInt64LE(const aData:pointer):TPasRISCVUInt64;
 begin
 {$ifdef LITTLE_ENDIAN}
  result:=PPasRISCVUInt64(aData)^;
{$else}
  result:=TPasRISCVUInt64(PPasRISCVUInt8(aData)^) or
         (TPasRISCVUInt64(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+1)))^) shl 8) or
         (TPasRISCVUInt64(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+2)))^) shl 16) or
         (TPasRISCVUInt64(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+3)))^) shl 24) or
         (TPasRISCVUInt64(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+4)))^) shl 32) or
         (TPasRISCVUInt64(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+5)))^) shl 40) or
         (TPasRISCVUInt64(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+6)))^) shl 48) or
         (TPasRISCVUInt64(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+7)))^) shl 56);
{$endif}
 end;
begin

 result:=false;

 if assigned(aBinary) and (aBinary.Size>=64) then begin

  aBinary.Seek(0,soBeginning);
  aBinary.ReadBuffer(Tmp[0],64);

  if (TPasRISCVUInt32((TPasRISCVUInt32(Tmp[0]) shl 0) or
                      (TPasRISCVUInt32(Tmp[1]) shl 8) or
                      (TPasRISCVUInt32(Tmp[2]) shl 16) or
                      (TPasRISCVUInt32(Tmp[3]) shl 24))=$464c457f) and // ELF magic
     ((TPasRISCVUInt8(Tmp[4])=1) or // 32-bit
      (TPasRISCVUInt8(Tmp[4])=2)) and // 64-bit
     (TPasRISCVUInt8(Tmp[5])=1) then begin // Little endian

   Base:=aOffset;

   ObjCopy:=aObjCopy;

   Class64:=TPasRISCVUInt8(Tmp[4])=2;

   ELFType:=ReadUInt16LE(@Tmp[16]);

   if Class64 then begin
    ELFEntry:=ReadUInt64LE(@Tmp[24]);
    ELFPHOffset:=ReadUInt64LE(@Tmp[32]);
    ELFPHSize:=56;
    ELFPHNum:=ReadUInt16LE(@Tmp[56]);
   end else begin
    ELFEntry:=ReadUInt32LE(@Tmp[24]);
    ELFPHOffset:=ReadUInt32LE(@Tmp[28]);
    ELFPHSize:=32;
    ELFPHNum:=ReadUInt16LE(@Tmp[44]);
   end;

   ELFLoAddr:=TPasRISCVUInt64($ffffffffffffffff);
   ELFHiAddr:=0;

   PHDR:=0;

   for Index:=0 to TPasRISCVSizeInt(ELFPHNum)-1 do begin

    ELFPHEntryOffset:=ELFPHOffset+(Index*ELFPHSize);

    aBinary.Seek(ELFPHEntryOffset,soBeginning);
    aBinary.ReadBuffer(Tmp[0],ELFPHSize);

    PType:=ReadUInt32LE(@Tmp[0]);
    if Class64 then begin
     PVAddr:=ReadUInt64LE(@Tmp[16]);
     PMemSize:=ReadUInt64LE(@Tmp[40]);
    end else begin
     PVAddr:=ReadUInt32LE(@Tmp[8]);
     PMemSize:=ReadUInt32LE(@Tmp[20]);
    end;
    case PType of
     ELF_PT_LOAD,ELF_PT_PHDR:begin
      if PVAddr<ELFLoAddr then begin
       ELFLoAddr:=PVAddr;
      end;
      if (PVAddr+PMemSize)>ELFHiAddr then begin
       ELFHiAddr:=PVAddr+PMemSize;
      end;
      if PType=ELF_PT_PHDR then begin
       PHDR:=PVAddr;
      end;
     end;
     else begin
     end;
    end;

   end;

   if ELFLoAddr=TPasRISCVUInt64($ffffffffffffffff) then begin
    ELFLoAddr:=0; // No loadable segments
   end;

   if ObjCopy then begin
    if ELFEntry<>0 then begin
     dec(ELFEntry,ELFLoAddr);
    end;
    if PHDR<>0 then begin
     dec(PHDR,ELFLoAddr);
    end;
    BufferSize:=fMemoryDevice.fSize-aOffset;
   end else begin
    BufferSize:=ELFHiAddr-ELFLoAddr;
    if ELFType=ELF_ET_DYN then begin
    end;
    if ELFEntry<>0 then begin
     inc(ELFEntry,Base);
    end;
    if PHDR<>0 then begin
     inc(PHDR,Base);
    end;
   end;

   for Index:=0 to TPasRISCVSizeInt(ELFPHNum)-1 do begin

    ELFPHEntryOffset:=ELFPHOffset+(Index*ELFPHSize);

    aBinary.Seek(ELFPHEntryOffset,soBeginning);
    aBinary.ReadBuffer(Tmp[0],ELFPHSize);

    PType:=ReadUInt32LE(@Tmp[0]);
    if Class64 then begin
     POffset:=ReadUInt64LE(@Tmp[8]);
     PVAddr:=ReadUInt64LE(@Tmp[16]);
     PFSize:=ReadUInt64LE(@Tmp[32]);
     PMemSize:=ReadUInt64LE(@Tmp[40]);
    end else begin
     POffset:=ReadUInt32LE(@Tmp[4]);
     PVAddr:=ReadUInt32LE(@Tmp[8]);
     PFSize:=ReadUInt32LE(@Tmp[16]);
     PMemSize:=ReadUInt32LE(@Tmp[20]);
    end;

    case PType of
     ELF_PT_LOAD,ELF_PT_PHDR:begin
      if OBJCopy then begin
       dec(PVAddr,ELFLoAddr);
       if (PVAddr+PMemSize)>BufferSize then begin
        exit; // Too large
       end;
      end;
      aBinary.Seek(POffset,soBeginning);
      aBinary.ReadBuffer(PPasRISCVUInt8Array(fMemoryDevice.fData)^[PVAddr+Base],PFSize);
     end;
     ELF_PT_INTERP:begin
      // Ignore for now
     end;
     else begin
     end;
    end;

   end;

   result:=true;

  end;

 end;

end;


function TPasRISCV.LoadBinaryIntoMemory(const aBinary: TMemoryStream;
 const aOffset: TPasRISCVUInt64; out aSize: TPasRISCVUInt64;
 const aCanELF: Boolean; const aObjCopy: Boolean): Boolean;
begin

 result:=false;

 if assigned(aBinary) then begin

  if aBinary.Size>0 then begin

   aBinary.Seek(0,soBeginning);

   aSize:=aBinary.Size;

   if aSize>0 then begin

    if aCanELF and LoadELFIntoMemory(aBinary,aOffset,aSize,aObjCopy) then begin

     result:=true;

    end else begin

     if (aOffset+aSize)<=fMemoryDevice.fSize then begin
      aBinary.Seek(0,soBeginning);
      aBinary.ReadBuffer(PPasRISCVUInt8Array(fMemoryDevice.fData)^[aOffset],aSize);
      result:=true;
     end else begin
      raise EPasRISCV.Create('Binary does not fit into memory, at least '+IntToStr(aSize)+' bytes at offset '+IntToStr(aOffset)+' are required');
     end;
    end;

   end;

  end;

 end;

end;

function TPasRISCV.LoadINITRDIntoMemory(const aBinary:TMemoryStream;const aOffset:TPasRISCVUInt64;out aSize:TPasRISCVUInt64):Boolean;
const CompressionNone=0;
      CompressionDeflate=1;
      CompressionGZIP=2;
var CompressionMethod:TPasRISCVUInt32;
    Tmp:array[0..1] of TPasRISCVUInt8;
    CompressedSize,UncompressedSize:TPasRISCVSizeUInt;
    CompressedData,UncompressedData:pointer;
begin

 result:=false;

 if assigned(aBinary) and (aBinary.Size>4) then begin

  aBinary.Seek(0,soBeginning);
  aBinary.ReadBuffer(Tmp[0],2);
  if Tmp[0]=$1f then begin
   case Tmp[1] of
    $08:begin
     CompressionMethod:=CompressionDeflate;
    end;
    $8b:begin
     CompressionMethod:=CompressionGZIP;
    end;
    else begin
     CompressionMethod:=CompressionNone;
    end;
   end;
  end else begin
   CompressionMethod:=CompressionNone;
  end;

  aBinary.Seek(0,soBeginning);

  case CompressionMethod of
   CompressionDeflate,
   CompressionGZIP:begin

    CompressedSize:=aBinary.Size;

    GetMem(CompressedData,CompressedSize);
    try

     aBinary.Seek(0,soBeginning);
     aBinary.ReadBuffer(CompressedData^,CompressedSize);

     UncompressedData:=nil;
     try

      if DoInflate(CompressedData,CompressedSize,UncompressedData,UncompressedSize,true) then begin

       aSize:=UncompressedSize;

       if (aOffset+aSize)<=fMemoryDevice.Size then begin
        Move(UncompressedData^,PPasRISCVUInt8Array(fMemoryDevice.fData)^[aOffset],aSize);
        result:=true;
       end else begin
        raise EPasRISCV.Create('INITRD does not fit into memory, at least '+IntToStr(aSize)+' bytes at offset '+IntToStr(aOffset)+' are required');
       end;

      end else begin

       // Decompression failed, try to load as is, so that the kernel can handle it itself, since it is just a performance optimization to decompress it here beforehands

       aSize:=CompressedSize;

       if (aOffset+aSize)<=fMemoryDevice.fSize then begin
        Move(CompressedData^,PPasRISCVUInt8Array(fMemoryDevice.fData)^[aOffset],aSize);
        result:=true;
       end else begin
        raise EPasRISCV.Create('INITRD does not fit into memory, at least '+IntToStr(aSize)+' bytes at offset '+IntToStr(aOffset)+' are required');
       end;

      end;

     finally
      if assigned(UncompressedData) then begin
       FreeMem(UncompressedData);
      end;
     end;

    finally
     FreeMem(CompressedData);
    end;

   end;
   else begin

    aSize:=aBinary.Size;

    if (aOffset+aSize)<=fMemoryDevice.fSize then begin
     aBinary.Seek(0,soBeginning);
     aBinary.ReadBuffer(PPasRISCVUInt8Array(fMemoryDevice.fData)^[aOffset],aSize);
     result:=true;
    end else begin
     raise EPasRISCV.Create('INITRD does not fit into memory, at least '+IntToStr(aSize)+' bytes at offset '+IntToStr(aOffset)+' are required');
    end;

   end;
  end;

 end;

end;

procedure TPasRISCV.Reset;
var Index:TPasRISCVSizeInt;
    BIOSOffset,BIOSSize:TPasRISCVUInt64;
    FDTOffset,FDTSize:TPasRISCVUInt64;
    HasBIOS,HasKernel,HasINITRD:Boolean;
    StartCode:PPasRISCVUInt32Array;
begin

 BIOSOffset:=0; // Hardwired to 0
 BIOSSize:=0;
 HasBIOS:=LoadBinaryIntoMemory(fConfiguration.fBIOS,BIOSOffset,BIOSSize,true,true);

{if BIOSSize>KERNEL_OFFSET then begin
  raise EPasRISCV.Create('BIOS size is too large');
 end;}

 fKernelOffset:=KERNEL_OFFSET;
 fKernelSize:=0;
 HasKernel:=LoadBinaryIntoMemory(fConfiguration.fKernel,fKernelOffset,fKernelSize,true,true);

 if HasBIOS or HasKernel then begin

  if HasKernel then begin
   fINITRDOffset:=fKernelOffset+fKernelSize;
  end else begin
   fINITRDOffset:=BIOSOffset+BIOSSize;
  end;
  if (fINITRDOffset and $fff)<>0 then begin
   inc(fINITRDOffset,$1000-(fINITRDOffset and $fff));
  end;
  fINITRDSize:=0;
  HasINITRD:=LoadINITRDIntoMemory(fConfiguration.fINITRD,fINITRDOffset,fINITRDSize);

 end;

 InitializeFDT;

 FDTOffset:=$1000+(8*8);
 FDTSize:=fFDTStream.Size;
 Move(fFDTStream.Memory^,PPasRISCVUInt8Array(fBootMemoryDevice.fData)^[FDTOffset-fBootMemoryDevice.fBase],FDTSize);
 fFDTMemoryOffset:=fConfiguration.fBootMemoryBase+FDTOffset;

 StartCode:=Pointer(@PPasRISCVUInt8Array(fBootMemoryDevice.fData)^[$1000]);
 StartCode^[0]:=$00000297+($80000000-$1000);                     // auipc t0, jump_addr
 StartCode^[1]:=$00000597;                                       // auipc a1, dtb
 StartCode^[2]:=$00058593+(TPasRISCVUInt32(FDTOffset-4) shl 20); // addi a1, a1, dtb
 StartCode^[3]:=$f1402573;                                       // csrr a0, mhartid
 StartCode^[4]:=$00028067;                                       // jalr zero, t0, jump_addr

 fStartStackPointer:=fConfiguration.fMemoryBase+fConfiguration.fMemorySize; // Initial startup stack starts below FDT at the end of the memory

 fACLINTDevice.Reset;
 if assigned(fIMSICMachineDevice) then begin
  fIMSICMachineDevice.Reset;
 end;
 if assigned(fIMSICSupervisorDevice) then begin
  fIMSICSupervisorDevice.Reset;
 end;
 if assigned(fPLICDevice) then begin
  fPLICDevice.Reset;
 end;
 fSYSCONDevice.Reset;
 fVirtIOBlockDevice.Reset;
 fUARTDevice.Reset;
 fDS1742Device.Reset;
 fPCIBusDevice.Reset;
 fFrameBufferDevice.Reset;
 fRawKeyboardDevice.Reset;
//fI2CDevice.Reset;
 fPS2KeyboardDevice.Reset;
 fPS2MouseDevice.Reset;
 fVirtIOInputKeyboardDevice.Reset;
 fVirtIOInputMouseDevice.Reset;
 fVirtIOSoundDevice.Reset;
 fVirtIO9PDevice.Reset;
 fVirtIONetDevice.Reset;
 fVirtIORandomGeneratorDevice.Reset;

 fNVMeDevice.Reset;

 for Index:=0 to length(fHARTs)-1 do begin
  fHARTs[Index].Init;
 end;

end;

function TPasRISCV.GetRunning:Boolean;
begin
 result:=(fRunState and RUNSTATE_POWEROFF)=0;
end;

procedure TPasRISCV.Execute(const aSingleStep:Boolean);
var Index:TPasRISCVSizeInt;
    RunStateUntilMask:TPasRISCVUInt32;
    SingleStepExecuted:Boolean;
begin

 RunStateUntilMask:=RUNSTATE_POWEROFF;

 if aSingleStep then begin
  TPasMPInterlocked.BitwiseOr(fRunState,RUNSTATE_SINGLESTEP);
  RunStateUntilMask:=RunStateUntilMask or RUNSTATE_SINGLESTEP;
 end else begin
  TPasMPInterlocked.BitwiseAnd(fRunState,TPasMPUInt32(not TPasMPUInt32(RUNSTATE_SINGLESTEP)));
 end;

 if (fRunState and RUNSTATE_POWEROFF)=0 then begin

  repeat

   if (fRunState and RUNSTATE_PAUSING)=RUNSTATE_PAUSING then begin
    TPasMPInterlocked.ExchangeBitwiseAndOr(fRunState,TPasMPUInt32(not TPasMPUInt32(RUNSTATE_PAUSING)),TPasMPUInt32(RUNSTATE_PAUSED));
    if assigned(fDebugger) then begin
     fDebugger.NotifyPaused;
    end;
   end;

   if (fRunState and (RUNSTATE_RUNNING or RUNSTATE_PAUSED or RUNSTATE_POWEROFF))=(RUNSTATE_RUNNING or RUNSTATE_PAUSED) then begin
    fWakeUpConditionVariableLock.Acquire;
    try
     while (fRunState and (RUNSTATE_RUNNING or RUNSTATE_PAUSED or RUNSTATE_POWEROFF))=(RUNSTATE_RUNNING or RUNSTATE_PAUSED) do begin
      fWakeUpConditionVariable.Wait(fWakeUpConditionVariableLock,100);
     end;
    finally
     fWakeUpConditionVariableLock.Release;
    end;
    if (fRunState and RUNSTATE_POWEROFF)<>0 then begin
     break;
    end;
   end;

   if (fRunState and RUNSTATE_REBOOT)<>0 then begin
    Reset;
    if assigned(fOnReboot) then begin
     fOnReboot;
    end;
    TPasMPInterlocked.BitwiseAnd(fRunState,TPasMPUInt32(not TPasMPUInt32(RUNSTATE_REBOOT)));
   end;

   if aSingleStep and ((fRunState and RUNSTATE_SINGLESTEP)<>0) then begin

    for Index:=0 to length(fHARTs)-1 do begin
     fHARTs[Index].Execute;
    end;

    SingleStepExecuted:=true;

   end else begin

    SingleStepExecuted:=(fRunState and RUNSTATE_SINGLESTEP)<>0;

    fHARTWakeUpConditionVariableLock.Acquire;
    try
     TPasMPInterlocked.BitwiseOr(fHARTActiveMask,fAllHARTMask);
     fHARTWakeUpConditionVariable.Broadcast;
    finally
     fHARTWakeUpConditionVariableLock.Release;
    end;

    fHARTStatusChangeConditionVariableLock.Acquire;
    try
     while TPasMPInterlocked.Read(fHARTRunningMask)<>0 do begin
      fHARTStatusChangeConditionVariable.Wait(fHARTStatusChangeConditionVariableLock);
     end;
    finally
     fHARTStatusChangeConditionVariableLock.Release;
    end;

   end;

   if SingleStepExecuted and ((fRunState and RUNSTATE_SINGLESTEP)<>0) and not aSingleStep then begin
    SingleStepExecuted:=false;
    TPasMPInterlocked.ExchangeBitwiseAndOr(fRunState,TPasMPUInt32(not TPasMPUInt32(RUNSTATE_SINGLESTEP)),TPasMPUInt32(RUNSTATE_PAUSING));
   end;

  until (fRunState and RunStateUntilMask)<>0;

 end;

end;

procedure TPasRISCV.Step;
begin
 Execute(true);
end;

procedure TPasRISCV.Run;
begin
 Execute(false);
end;

procedure TPasRISCV.Reboot;
begin
 TPasMPInterlocked.BitwiseOr(fRunState,RUNSTATE_REBOOT);
end;

procedure TPasRISCV.PowerOff;
begin
 TPasMPInterlocked.BitwiseOr(fRunState,RUNSTATE_POWEROFF);
end;

procedure TPasRISCV.FlushTLB;
begin
 TPasMPInterlocked.BitwiseOr(fFlushTLBHARTMask,fAllHARTMask);
 TPasMPInterlocked.BitwiseOr(fRunState,fAllHARTMask);
end;

procedure TPasRISCV.Interrupt;
begin
 TPasMPInterlocked.BitwiseOr(fRunState,fAllHARTMask);
end;

procedure TPasRISCV.WakeUp;
begin
 fWakeUpConditionVariable.Broadcast;
end;

procedure TPasRISCV.InterruptAndWakeUp;
begin
 fWakeUpConditionVariableLock.Acquire;
 try
  TPasMPInterlocked.BitwiseOr(fRunState,fAllHARTMask);
  fWakeUpConditionVariable.Broadcast;
 finally
  fWakeUpConditionVariableLock.Release;
 end;
end;

function TPasRISCV.QueuePause(const aWaitUntilHalted:Boolean):Boolean;
begin

 if (TPasMPInterlocked.Read(fRunState) and (RUNSTATE_PAUSING or RUNSTATE_PAUSED))=0 then begin

  result:=(TPasMPInterlocked.ExchangeBitwiseOr(fRunState,TPasMPUInt32(RUNSTATE_PAUSING)) and RUNSTATE_PAUSING)=0;

  if result then begin

   Interrupt;
   WakeUp;

   if aWaitUntilHalted then begin
    fHARTStatusChangeConditionVariableLock.Acquire;
    try
     while TPasMPInterlocked.Read(fHARTRunningMask)<>0 do begin
      fHARTStatusChangeConditionVariable.Wait(fHARTStatusChangeConditionVariableLock);
     end;
    finally
     fHARTStatusChangeConditionVariableLock.Release;
    end;
   end;

  end;

 end else begin

  result:=false;

 end;

end;

procedure TPasRISCV.Pause(const aWaitUntilHalted:Boolean);
begin

 if (TPasMPInterlocked.ExchangeBitwiseOr(fRunState,TPasMPUInt32(RUNSTATE_PAUSED)) and RUNSTATE_PAUSED)=0 then begin

  Interrupt;
  WakeUp;

  if aWaitUntilHalted then begin
   fHARTStatusChangeConditionVariableLock.Acquire;
   try
    while TPasMPInterlocked.Read(fHARTRunningMask)<>0 do begin
     fHARTStatusChangeConditionVariable.Wait(fHARTStatusChangeConditionVariableLock);
    end;
   finally
    fHARTStatusChangeConditionVariableLock.Release;
   end;
  end;

 end;

end;

procedure TPasRISCV.Resume(const aWaitUntilRunning:Boolean);
begin
 if (TPasMPInterlocked.ExchangeBitwiseAnd(fRunState,not TPasMPUInt32(RUNSTATE_PAUSED)) and RUNSTATE_PAUSED)<>0 then begin

  Interrupt;
  WakeUp;

  if aWaitUntilRunning then begin
   fHARTStatusChangeConditionVariableLock.Acquire;
   try
    while (TPasMPInterlocked.Read(fHARTRunningMask) and fAllHARTMask)<>fAllHARTMask do begin
     fHARTStatusChangeConditionVariable.Wait(fHARTStatusChangeConditionVariableLock);
    end;
   finally
    fHARTStatusChangeConditionVariableLock.Release;
   end;
  end;

 end;
end;

procedure TPasRISCV.SingleStep(const aWaitUntilDone:Boolean);
begin
 if (TPasMPInterlocked.ExchangeBitwiseOr(fRunState,TPasMPUInt32(RUNSTATE_SINGLESTEP)) and RUNSTATE_SINGLESTEP)=0 then begin

  Resume(aWaitUntilDone);

  if aWaitUntilDone then begin
   fHARTStatusChangeConditionVariableLock.Acquire;
   try
    while TPasMPInterlocked.Read(fHARTRunningMask)<>0 do begin
     fHARTStatusChangeConditionVariable.Wait(fHARTStatusChangeConditionVariableLock);
    end;
   finally
    fHARTStatusChangeConditionVariableLock.Release;
   end;
  end;

 end;
end;


initialization
{$ifdef windows}
 KERNEL32LibHandle:=LoadLibrary('kernel32.dll');
 if KERNEL32LibHandle<>HMODULE(0) then begin
  @CreateWaitableTimerExW:=GetProcAddress(KERNEL32LibHandle,'CreateWaitableTimerExW');
 end;
 NTDLLLibHandle:=LoadLibrary('ntdll.dll');
 if NTDLLLibHandle<>HMODULE(0) then begin
  @NtDelayExecution:=GetProcAddress(NTDLLLibHandle,'NtDelayExecution');
  @NtQueryTimerResolution:=GetProcAddress(NTDLLLibHandle,'NtQueryTimerResolution');
  @NtSetTimerResolution:=GetProcAddress(NTDLLLibHandle,'NtSetTimerResolution');
 end;
 timeBeginPeriod(1);
 if assigned(NtDelayExecution) and
    assigned(NtQueryTimerResolution) and
    assigned(NtSetTimerResolution) then begin
  if NtQueryTimerResolution(MinimumResolution,MaximumResolution,CurrentResolution)=0 then begin
   GlobalSleepGranularity:=CurrentResolution;
   if NtSetTimerResolution(MaximumResolution,true,CurrentResolution)=0 then begin
    GlobalSleepGranularity:=MaximumResolution;
   end;
  end else begin
   GlobalSleepGranularity:=10000; // 1ms in 100-ns units
  end;
 end else begin
  GlobalSleepGranularity:=10000; // 1ms in 100-ns units
 end;
{$else}
 GlobalSleepGranularity:=5000; // 0.5ms in 100-ns units
{$endif}
 GlobalSleepGranularity:=ConvertScale(GlobalSleepGranularity,10000000,CLOCK_FREQUENCY);
 GlobalSleepThreshold:=GlobalSleepGranularity*4;
 FillChar(ZeroBuffer,SizeOf(TZeroBuffer),#0);
end.

