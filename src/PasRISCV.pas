(******************************************************************************
 *                                  PasRISCV                                  *
 ******************************************************************************
 *                        Version 2026-02-13-01-29-0000                       *
 ******************************************************************************
 *                                zlib license                                *
 *============================================================================*
 *                                                                            *
 * Copyright (C) 2024-2026, Benjamin Rosseaux (benjamin@rosseaux.de)          *
 *                                                                            *
 * This software is provided 'as-is', without any express or implied          *
 * warranty. In no event will the authors be held liable for any damages      *
 * arising from the use of this software.                                     *
 *                                                                            *
 * Permission is granted to anyone to use this software for any purpose,      *
 * including commercial applications, and to alter it and redistribute it     *
 * freely, subject to the following restrictions:                             *
 *                                                                            *
 * 1. The origin of this software must not be misrepresented; you must not    *
 *    claim that you wrote the original software. If you use this software    *
 *    in a product, an acknowledgement in the product documentation would be  *
 *    appreciated but is not required.                                        *
 * 2. Altered source versions must be plainly marked as such, and must not be *
 *    misrepresented as being the original software.                          *
 * 3. This notice may not be removed or altered from any source distribution. *
 *                                                                            *
 *****************************************************************************)
unit PasRISCV;
{$ifdef fpc}
 {$mode delphi}
 {$ifdef cpui386}
  {$define cpu386}
 {$endif}
 {$ifdef cpu386}
  {$asmmode intel}
 {$endif}
 {$ifdef cpuamd64}
  {$asmmode intel}
 {$endif}
 {$ifdef FPC_LITTLE_ENDIAN}
  {$define LITTLE_ENDIAN}
 {$else}
  {$ifdef FPC_BIG_ENDIAN}
   {$define BIG_ENDIAN}
  {$endif}
 {$endif}
 {-$pic off}
 {$ifdef fpc_has_internal_sar}
  {$define HasSAR}
 {$endif}
 {$ifdef FPC_HAS_TYPE_EXTENDED}
  {$define HAS_TYPE_EXTENDED}
 {$else}
  {$undef HAS_TYPE_EXTENDED}
 {$endif}
 {$ifdef FPC_HAS_TYPE_DOUBLE}
  {$define HAS_TYPE_DOUBLE}
 {$else}
  {$undef HAS_TYPE_DOUBLE}
 {$endif}
 {$ifdef FPC_HAS_TYPE_SINGLE}
  {$define HAS_TYPE_SINGLE}
 {$else}
  {$undef HAS_TYPE_SINGLE}
 {$endif}
 {$define CAN_INLINE}
 {$define HAS_ADVANCED_RECORDS}
{$else}
 {$realcompatibility off}
 {$localsymbols on}
 {$define LITTLE_ENDIAN}
 {$ifndef cpu64}
  {$define cpu32}
 {$endif}
 {$define HAS_TYPE_EXTENDED}
 {$define HAS_TYPE_DOUBLE}
 {$define HAS_TYPE_SINGLE}
 {$undef CAN_INLINE}
 {$undef HAS_ADVANCED_RECORDS}
 {$ifndef BCB}
  {$ifdef ver120}
   {$define Delphi4or5}
  {$endif}
  {$ifdef ver130}
   {$define Delphi4or5}
  {$endif}
  {$ifdef ver140}
   {$define Delphi6}
  {$endif}
  {$ifdef ver150}
   {$define Delphi7}
  {$endif}
  {$ifdef ver170}
   {$define Delphi2005}
  {$endif}
 {$else}
  {$ifdef ver120}
   {$define Delphi4or5}
   {$define BCB4}
  {$endif}
  {$ifdef ver130}
   {$define Delphi4or5}
  {$endif}
 {$endif}
 {$ifdef conditionalexpressions}
  {$if CompilerVersion>=24.0}
   {$legacyifend on}
  {$ifend}
  {$if CompilerVersion>=14.0}
   {$if CompilerVersion=14.0}
    {$define Delphi6}
   {$ifend}
   {$define Delphi6AndUp}
  {$ifend}
  {$if CompilerVersion>=15.0}
   {$if CompilerVersion=15.0}
    {$define Delphi7}
   {$ifend}
   {$define Delphi7AndUp}
  {$ifend}
  {$if CompilerVersion>=17.0}
   {$if CompilerVersion=17.0}
    {$define Delphi2005}
   {$ifend}
   {$define Delphi2005AndUp}
  {$ifend}
  {$if CompilerVersion>=18.0}
   {$if CompilerVersion=18.0}
    {$define BDS2006}
    {$define Delphi2006}
   {$ifend}
   {$define Delphi2006AndUp}
   {$define CAN_INLINE}
   {$define HAS_ADVANCED_RECORDS}
  {$ifend}
  {$if CompilerVersion>=18.5}
   {$if CompilerVersion=18.5}
    {$define Delphi2007}
   {$ifend}
   {$define Delphi2007AndUp}
  {$ifend}
  {$if CompilerVersion=19.0}
   {$define Delphi2007Net}
  {$ifend}
  {$if CompilerVersion>=20.0}
   {$if CompilerVersion=20.0}
    {$define Delphi2009}
   {$ifend}
   {$define Delphi2009AndUp}
  {$ifend}
  {$if CompilerVersion>=21.0}
   {$if CompilerVersion=21.0}
    {$define Delphi2010}
   {$ifend}
   {$define Delphi2010AndUp}
  {$ifend}
  {$if CompilerVersion>=22.0}
   {$if CompilerVersion=22.0}
    {$define DelphiXE}
   {$ifend}
   {$define DelphiXEAndUp}
  {$ifend}
  {$if CompilerVersion>=23.0}
   {$if CompilerVersion=23.0}
    {$define DelphiXE2}
   {$ifend}
   {$define DelphiXE2AndUp}
  {$ifend}
  {$if CompilerVersion>=24.0}
   {$legacyifend on}
   {$if CompilerVersion=24.0}
    {$define DelphiXE3}
   {$ifend}
   {$define DelphiXE3AndUp}
  {$ifend}
  {$if CompilerVersion>=25.0}
   {$if CompilerVersion=25.0}
    {$define DelphiXE4}
   {$ifend}
   {$define DelphiXE4AndUp}
  {$ifend}
  {$if CompilerVersion>=26.0}
   {$if CompilerVersion=26.0}
    {$define DelphiXE5}
   {$ifend}
   {$define DelphiXE5AndUp}
  {$ifend}
  {$if CompilerVersion>=27.0}
   {$if CompilerVersion=27.0}
    {$define DelphiXE6}
   {$ifend}
   {$define DelphiXE6AndUp}
  {$ifend}
  {$if CompilerVersion>=28.0}
   {$if CompilerVersion=28.0}
    {$define DelphiXE7}
   {$ifend}
   {$define DelphiXE7AndUp}
  {$ifend}
  {$if CompilerVersion>=29.0}
   {$if CompilerVersion=29.0}
    {$define DelphiXE8}
   {$ifend}
   {$define DelphiXE8AndUp}
  {$ifend}
  {$if CompilerVersion>=30.0}
   {$if CompilerVersion=30.0}
    {$define Delphi10Seattle}
   {$ifend}
   {$define Delphi10SeattleAndUp}
  {$ifend}
  {$if CompilerVersion>=31.0}
   {$if CompilerVersion=31.0}
    {$define Delphi10Berlin}
   {$ifend}
   {$define Delphi10BerlinAndUp}
  {$ifend}
 {$endif}
 {$ifndef Delphi4or5}
  {$ifndef BCB}
   {$define Delphi6AndUp}
  {$endif}
   {$ifndef Delphi6}
    {$define BCB6OrDelphi7AndUp}
    {$ifndef BCB}
     {$define Delphi7AndUp}
    {$endif}
    {$ifndef BCB}
     {$ifndef Delphi7}
      {$ifndef Delphi2005}
       {$define BDS2006AndUp}
      {$endif}
     {$endif}
    {$endif}
   {$endif}
 {$endif}
 {$ifdef Delphi6AndUp}
  {$warn symbol_platform off}
  {$warn symbol_deprecated off}
 {$endif}
{$endif}
{$if defined(Win32) or defined(Win64)}
 {$define Windows}
{$ifend}
{$rangechecks off}
{$extendedsyntax on}
{$writeableconst on}
{$hints off}
{$booleval off}
{$typedaddress off}
{$stackframes off}
{$varstringchecks on}
{$typeinfo on}
{$overflowchecks off}
{$longstrings on}
{$openstrings on}
{$ifndef HAS_TYPE_SINGLE}
 {$error No single floating point precision}
{$endif}
{$ifndef HAS_TYPE_DOUBLE}
 {$error No double floating point precision}
{$endif}
{$scopedenums on}
{$ifndef fpc}
 {$ifdef conditionalexpressions}
  {$if CompilerVersion>=24.0}
   {$legacyifend on}
  {$ifend}
 {$endif}
{$endif}

{$undef ExplicitEnforceZeroRegister}
{$define UseExtraShAmt}
{$define CombinedDirectAccessTLBCache}
{$define UseSpecializedRegisterLoadStores}
{$undef Use16BitSplittedInstructionFetches}
{$undef PreferDirectMemoryAccess}
{$undef FrameBufferDeviceDirtyMarking}

{-$define PasRISCVDebugVirtIO9P}

{$if defined(fpc) and (defined(cpux86_64) or defined(cpuamd64))}
 {$optimization level3}
{$ifend}

(*{$ifdef fpc}
 {$codealign jump=16}
 {$codealign loop=16}
 {$codealign proc=16}
{$endif}//*)

{$define NewPCI}

{$define GStageQEMUParity}

{$define NVMELevelTriggeredPCIEInterrupts}

//{$define I2CDebug} // Enable I2C debug output — remove/comment out when not needed

//{$define PasRISCVCPUFileDumpDebug}

//{$define PasRISCVStepDebugOutput}

{$define PasRISCVSingleStepCounter}
//{$define PasRISCVSingleStepRunStateWait}
{$if defined(PasRISCVSingleStepCounter) and defined(PasRISCVSingleStepRunStateWait)}
 {$error Choose only one of PasRISCVSingleStepCounter or PasRISCVSingleStepRunStateWait}
{$ifend}

interface

uses {$if defined(Posix) and not defined(fpc)}
      // Delphi: Linux, Android, Darwin (MacOS, iOS)
      Posix.Base,
      Posix.NetDB,
      Posix.NetIf,
      Posix.NetinetIn,
      Posix.NetinetIp6,
      Posix.NetinetTCP,
      Posix.NetinetUDP,
      Posix.StrOpts,
      Posix.SysSelect,
      Posix.SysSocket,
      Posix.SysTime,
      Posix.SysTimes,
      Posix.SysTypes,
      Posix.SysWait,
      Posix.Termios,
      Posix.Errno,
      Posix.Fcntl,
      Posix.Unistd,
      Posix.Time,
      System.Net.Socket,
      {$ifdef Linux}
       Linuxapi.KernelIoctl,
      {$endif}
      {$if defined(Android) and defined(RNL_DEBUG)}
       Androidapi.Log,
      {$ifend}
     {$elseif defined(fpc) and defined(Unix)}
      // FreePascal: Unix, Linux, Android, Darwin (MacOS, iOS)
      ctypes,
      BaseUnix,
      Unix,
      UnixType,
      Sockets,
      {$if not defined(Darwin)}
       cnetdb,
      {$ifend}
      {$if defined(PasRISCVUseRealConsole)}
       termio,
      {$ifend}
      {$if defined(linux) or defined(android)}
       linux,
      {$ifend}
     {$elseif defined(Windows)}
      // Delphi and FreePascal: Win32, Win64
      Windows,
      MMSystem,
      {$ifdef fpc}
       jwaIpTypes,
       JwaIpHlpApi,
      {$else}
       Winapi.IpTypes,
       Winapi.IpHlpApi,
      {$endif}
      {$if defined(PasRISCVUseRealConsole)}
       CRT,
      {$ifend}
     {$ifend}
     SysUtils,
     Classes,
     Math,
     DateUtils,
{$if defined(fpc)}
     // FreePascal
{$if defined(Linux) or defined(Android)}
     zlib,
{$ifend}
{$else}
     // Delphi
     System.ZLIB,
{$ifend}
     SyncObjs,
     PasMP,
     RNL;

type PPPasRISCVInt8=^PPasRISCVInt8;
     PPasRISCVInt8=^TPasRISCVInt8;
     TPasRISCVInt8={$ifdef fpc}Int8{$else}shortint{$endif};

     TPasRISCVInt8Array=array[0..65535] of TPasRISCVInt8;
     PPasRISCVInt8Array=^TPasRISCVInt8Array;

     PPPasRISCVUInt8=^PPasRISCVUInt8;
     PPasRISCVUInt8=^TPasRISCVUInt8;
     TPasRISCVUInt8={$ifdef fpc}UInt8{$else}byte{$endif};

     PPPasRISCVUInt8Array=^PPasRISCVUInt8Array;
     PPasRISCVUInt8Array=^TPasRISCVUInt8Array;
     TPasRISCVUInt8Array=array[0..65535] of TPasRISCVUInt8;

     TPasRISCVUInt8DynamicArray=array of TPasRISCVUInt8;

     PPPasRISCVInt16=^PPasRISCVInt16;
     PPasRISCVInt16=^TPasRISCVInt16;
     TPasRISCVInt16={$ifdef fpc}Int16{$else}smallint{$endif};

     TPasRISCVInt16Array=array[0..65535] of TPasRISCVInt16;
     PPasRISCVInt16Array=^TPasRISCVInt16Array;

     PPPasRISCVUInt16=^PPasRISCVUInt16;
     PPasRISCVUInt16=^TPasRISCVUInt16;
     TPasRISCVUInt16={$ifdef fpc}UInt16{$else}word{$endif};

     TPasRISCVUInt16Array=array[0..65535] of TPasRISCVUInt16;
     PPasRISCVUInt16Array=^TPasRISCVUInt16Array;

     PPPasRISCVInt32=^PPasRISCVInt32;
     PPasRISCVInt32=^TPasRISCVInt32;
     TPasRISCVInt32={$ifdef fpc}Int32{$else}longint{$endif};

     TPasRISCVInt32Array=array[0..65535] of TPasRISCVInt32;
     PPasRISCVInt32Array=^TPasRISCVInt32Array;

     PPPasRISCVUInt32=^PPasRISCVUInt32;
     PPasRISCVUInt32=^TPasRISCVUInt32;
     TPasRISCVUInt32={$ifdef fpc}UInt32{$else}longword{$endif};

     PPPasRISCVUInt32rray=^PPasRISCVUInt32Array;
     PPasRISCVUInt32Array=^TPasRISCVUInt32Array;
     TPasRISCVUInt32Array=array[0..65535] of TPasRISCVUInt32;

     TPasRISCVUInt32DynamicArray=array of TPasRISCVUInt32;

     PPPasRISCVInt64=^PPasRISCVInt64;
     PPasRISCVInt64=^TPasRISCVInt64;
     TPasRISCVInt64=Int64;

     TPasRISCVInt64Array=array[0..65535] of TPasRISCVInt64;
     PPasRISCVInt64Array=^TPasRISCVInt64Array;

     PPPasRISCVUInt64=^PPasRISCVUInt64;
     PPasRISCVUInt64=^TPasRISCVUInt64;
     TPasRISCVUInt64=UInt64;

     TPasRISCVUInt64Array=array[0..65535] of TPasRISCVUInt64;
     PPasRISCVUInt64Array=^TPasRISCVUInt64Array;

     PPPasRISCVChar=^PAnsiChar;
     PPasRISCVChar=PAnsiChar;
     TPasRISCVChar=AnsiChar;

     PPPasRISCVRawByteChar=^PAnsiChar;
     PPasRISCVRawByteChar=PAnsiChar;
     TPasRISCVRawByteChar=AnsiChar;

     PPPasRISCVUTF16Char=^PWideChar;
     PPasRISCVUTF16Char=PWideChar;
     TPasRISCVUTF16Char=WideChar;

     PPPasRISCVPointer=^PPasRISCVPointer;
     PPasRISCVPointer=^TPasRISCVPointer;
     TPasRISCVPointer=Pointer;

     PPPasRISCVPointers=^PPasRISCVPointers;
     PPasRISCVPointers=^TPasRISCVPointers;
     TPasRISCVPointers=array[0..65535] of TPasRISCVPointer;

     PPPasRISCVVoid=^PPasRISCVVoid;
     PPasRISCVVoid=TPasRISCVPointer;

     PPPasRISCVFloat=^PPasRISCVFloat;
     PPasRISCVFloat=^TPasRISCVFloat;
     TPasRISCVFloat=Single;

     TPasRISCVFloats=array of TPasRISCVFloat;

     TPasRISCVFloatDynamicArray=array of TPasRISCVFloat;

     TPasRISCVFloatArray=array[0..65535] of TPasRISCVFloat;
     PPasRISCVFloatArray=^TPasRISCVFloatArray;

     PPPasRISCVDouble=^PPasRISCVDouble;
     PPasRISCVDouble=^TPasRISCVDouble;
     TPasRISCVDouble=Double;

     TPasRISCVDoubleArray=array[0..65535] of TPasRISCVDouble;
     PPasRISCVDoubleArray=^TPasRISCVDoubleArray;

     PPPasRISCVPtrUInt=^PPasRISCVPtrUInt;
     PPPasRISCVPtrInt=^PPasRISCVPtrInt;
     PPasRISCVPtrUInt=^TPasRISCVPtrUInt;
     PPasRISCVPtrInt=^TPasRISCVPtrInt;
{$ifdef fpc}
     TPasRISCVPtrUInt=PtrUInt;
     TPasRISCVPtrInt=PtrInt;
 {$undef OldDelphi}
{$else}
 {$ifdef conditionalexpressions}
  {$if CompilerVersion>=23.0}
   {$undef OldDelphi}
     TPasRISCVPtrUInt=NativeUInt;
     TPasRISCVPtrInt=NativeInt;
  {$else}
   {$define OldDelphi}
  {$ifend}
 {$else}
  {$define OldDelphi}
 {$endif}
{$endif}
{$ifdef OldDelphi}
{$ifdef cpu64}
     TPasRISCVPtrUInt=uint64;
     TPasRISCVPtrInt=int64;
{$else}
     TPasRISCVPtrUInt=longword;
     TPasRISCVPtrInt=longint;
{$endif}
{$endif}

     PPPasRISCVSizeUInt=^PPasRISCVSizeUInt;
     PPasRISCVSizeUInt=^TPasRISCVSizeUInt;
     TPasRISCVSizeUInt=TPasRISCVPtrUInt;

     PPPasRISCVSizeInt=^PPasRISCVSizeInt;
     PPasRISCVSizeInt=^TPasRISCVSizeInt;
     TPasRISCVSizeInt=TPasRISCVPtrInt;

     PPPasRISCVNativeUInt=^PPasRISCVNativeUInt;
     PPasRISCVNativeUInt=^TPasRISCVNativeUInt;
     TPasRISCVNativeUInt=TPasRISCVPtrUInt;

     PPPasRISCVNativeInt=^PPasRISCVNativeInt;
     PPasRISCVNativeInt=^TPasRISCVNativeInt;
     TPasRISCVNativeInt=TPasRISCVPtrInt;

     PPPasRISCVSize=^PPasRISCVSizeUInt;
     PPasRISCVSize=^TPasRISCVSizeUInt;
     TPasRISCVSize=TPasRISCVPtrUInt;

     PPPasRISCVPtrDiff=^PPasRISCVPtrDiff;
     PPasRISCVPtrDiff=^TPasRISCVPtrDiff;
     TPasRISCVPtrDiff=TPasRISCVPtrInt;

     PPPasRISCVRawByteString=^PPasRISCVRawByteString;
     PPasRISCVRawByteString=^TPasRISCVRawByteString;
     TPasRISCVRawByteString={$if declared(RawByteString)}RawByteString{$else}AnsiString{$ifend};

     PPPasRISCVUTF8String=^PPasRISCVUTF8String;
     PPasRISCVUTF8String=^TPasRISCVUTF8String;
     TPasRISCVUTF8String={$if declared(UTF8String)}UTF8String{$else}AnsiString{$ifend};

     PPPasRISCVUTF16String=^PPasRISCVUTF16String;
     PPasRISCVUTF16String=^TPasRISCVUTF16String;
     TPasRISCVUTF16String={$if declared(UnicodeString)}UnicodeString{$else}WideString{$ifend};

     TPasRISCVFPType=
      (
       Infinite,
       QuietNaN,
       SignalingNaN,
       Normal,
       Subnormal,
       Zero
      );

     TPasRISCVCPUFeatures=TPasRISCVUInt32;

     PPPasRISCVHalfFloat=^PPasRISCVHalfFloat;
     PPasRISCVHalfFloat=^TPasRISCVHalfFloat;
     TPasRISCVHalfFloat=record
      private
       const ToFloatMagic:TPasRISCVUInt32=TPasRISCVUInt32(TPasRISCVUInt32(254-15) shl 23);
             ToFloatWasInfNAN:TPasRISCVUInt32=TPasRISCVUInt32(TPasRISCVUInt32(127+16) shl 23);
      public
       Value:TPasRISCVUInt16;
       class function FromFloat(const aValue:TPasRISCVFloat):TPasRISCVHalfFloat; static; {$if defined(CAN_INLINE) and not (defined(cpu386) or defined(cpuamd64) or defined(cpux64) or defined(cpux86_64))}inline;{$elseif defined(cpu386)}stdcall;{$ifend}
       constructor Create(const aValue:TPasRISCVFloat);
       function ToFloat:TPasRISCVFloat; {$if defined(CAN_INLINE) and not (defined(cpu386) or defined(cpuamd64) or defined(cpux64) or defined(cpux86_64))}inline;{$elseif defined(cpu386)}stdcall;{$ifend}
       class operator Implicit(const a:TPasRISCVFloat):TPasRISCVHalfFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Implicit(const a:TPasRISCVHalfFloat):TPasRISCVFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Explicit(const a:TPasRISCVFloat):TPasRISCVHalfFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Explicit(const a:TPasRISCVHalfFloat):TPasRISCVFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Equal(const a,b:TPasRISCVHalfFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Equal(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Equal(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator NotEqual(const a,b:TPasRISCVHalfFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator NotEqual(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator NotEqual(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator GreaterThan(const a,b:TPasRISCVHalfFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator GreaterThan(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator GreaterThan(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator GreaterThanOrEqual(const a,b:TPasRISCVHalfFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator GreaterThanOrEqual(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator GreaterThanOrEqual(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator LessThan(const a,b:TPasRISCVHalfFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator LessThan(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator LessThan(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator LessThanOrEqual(const a,b:TPasRISCVHalfFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator LessThanOrEqual(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator LessThanOrEqual(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):boolean; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Inc(const a:TPasRISCVHalfFloat):TPasRISCVHalfFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Dec(const a:TPasRISCVHalfFloat):TPasRISCVHalfFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Add(const a,b:TPasRISCVHalfFloat):TPasRISCVFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Add(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):TPasRISCVFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Add(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):TPasRISCVFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Subtract(const a,b:TPasRISCVHalfFloat):TPasRISCVFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Subtract(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):TPasRISCVFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Subtract(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):TPasRISCVFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Multiply(const a,b:TPasRISCVHalfFloat):TPasRISCVFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Multiply(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):TPasRISCVFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Multiply(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):TPasRISCVFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Divide(const a,b:TPasRISCVHalfFloat):TPasRISCVFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Divide(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):TPasRISCVFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Divide(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):TPasRISCVFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Modulus(const a,b:TPasRISCVHalfFloat):TPasRISCVFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Negative(const a:TPasRISCVHalfFloat):TPasRISCVHalfFloat; {$ifdef CAN_INLINE}inline;{$endif}
       class operator Positive(const a:TPasRISCVHalfFloat):TPasRISCVHalfFloat; {$ifdef CAN_INLINE}inline;{$endif}
       function Abs:TPasRISCVHalfFloat; {$ifdef CAN_INLINE}inline;{$endif}
       function IsNaN:boolean; {$ifdef CAN_INLINE}inline;{$endif}
       function IsInfinity:boolean; {$ifdef CAN_INLINE}inline;{$endif}
       function IsNegativeInfinity:boolean; {$ifdef CAN_INLINE}inline;{$endif}
       function IsPositiveInfinity:boolean; {$ifdef CAN_INLINE}inline;{$endif}
     end;

     EPasRISCV=class(Exception);

     { TPasRISCVDynamicQueue<T> }
     TPasRISCVDynamicQueue<T>=record
      public
       type TQueueItems=array of T;
      public
       Items:TQueueItems;
       Head:TPasRISCVSizeInt;
       Tail:TPasRISCVSizeInt;
       Count:TPasRISCVSizeInt;
       Size:TPasRISCVSizeInt;
       procedure Initialize;
       procedure Finalize;
       procedure GrowResize(const aSize:TPasRISCVSizeInt);
       procedure Clear;
       function IsEmpty:boolean;
       procedure EnqueueAtFront(const aItem:T);
       procedure Enqueue(const aItem:T);
       function Dequeue(out aItem:T):boolean; overload;
       function Dequeue:boolean; overload;
       function Peek(out aItem:T):boolean;
     end;

     { TPasRISCVThreadSafeDynamicQueue<T> }
     TPasRISCVThreadSafeDynamicQueue<T>=class
      public
       type TQueueItems=array of T;
      private
       fLock:TPasMPSlimReaderWriterLock;
       fItems:TQueueItems;
       fHead:TPasRISCVSizeInt;
       fTail:TPasRISCVSizeInt;
       fCount:TPasRISCVSizeInt;
       fSize:TPasRISCVSizeInt;
      public
       constructor Create; reintroduce;
       destructor Destroy; override;
       procedure GrowResize(const aSize:TPasRISCVSizeInt);
       procedure Clear;
       function IsEmpty:boolean;
       procedure EnqueueAtFront(const aItem:T);
       procedure Enqueue(const aItem:T);
       function Dequeue(out aItem:T):boolean; overload;
       function Dequeue:boolean; overload;
       function TryDequeue(out aItem:T):boolean; overload;
       function TryDequeue:boolean; overload;
       function Peek(out aItem:T):boolean;
     end;

     TPasRISCVHashMapEntityIndices=array of TPasRISCVInt32;

     TPasRISCVHashMapUInt128=array[0..1] of TPasRISCVUInt64;

     { TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue> }
     TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>=class
      public
       type TEntity=record
             public
              const Empty=0;
                    Deleted=1;
                    Used=2;
             public
              State:TPasRISCVUInt32;
              Key:TPasRISCVHashMapKey;
              Value:TPasRISCVHashMapValue;
            end;
            PEntity=^TEntity;
            TEntities=array of TEntity;
      private
       type TEntityEnumerator=record
             private
              fHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>;
              fIndex:TPasRISCVSizeInt;
              function GetCurrent:TEntity; inline;
             public
              constructor Create(const aHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
              function MoveNext:boolean; inline;
              property Current:TEntity read GetCurrent;
            end;
            TKeyEnumerator=record
             private
              fHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>;
              fIndex:TPasRISCVSizeInt;
              function GetCurrent:TPasRISCVHashMapKey; inline;
             public
              constructor Create(const aHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
              function MoveNext:boolean; inline;
              property Current:TPasRISCVHashMapKey read GetCurrent;
            end;
            TPasRISCVHashMapValueEnumerator=record
             private
              fHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>;
              fIndex:TPasRISCVSizeInt;
              function GetCurrent:TPasRISCVHashMapValue; inline;
             public
              constructor Create(const aHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
              function MoveNext:boolean; inline;
              property Current:TPasRISCVHashMapValue read GetCurrent;
            end;
            TEntitiesObject=class
             private
              fOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>;
             public
              constructor Create(const aOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
              function GetEnumerator:TEntityEnumerator;
            end;
            TKeysObject=class
             private
              fOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>;
             public
              constructor Create(const aOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
              function GetEnumerator:TKeyEnumerator;
            end;
            TValuesObject=class
             private
              fOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>;
              function GetValue(const aKey:TPasRISCVHashMapKey):TPasRISCVHashMapValue; inline;
              procedure SetValue(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue); inline;
             public
              constructor Create(const aOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
              function GetEnumerator:TPasRISCVHashMapValueEnumerator;
              property Values[const Key:TPasRISCVHashMapKey]:TPasRISCVHashMapValue read GetValue write SetValue; default;
            end;
      private
       fSize:TPasRISCVSizeUInt;
       fLogSize:TPasRISCVSizeUInt;
       fCountNonEmptyEntites:TPasRISCVSizeUInt;
       fCountDeletedEntites:TPasRISCVSizeUInt;
       fEntities:TEntities;
       fDefaultValue:TPasRISCVHashMapValue;
       fCanShrink:boolean;
       fEntitiesObject:TEntitiesObject;
       fKeysObject:TKeysObject;
       fValuesObject:TValuesObject;
       function HashData(const aData:TPasRISCVPointer;const aDataLength:TPasRISCVUInt32):TPasRISCVUInt32;
       function HashKey(const aKey:TPasRISCVHashMapKey):TPasRISCVUInt32;
       function CompareKey(const aKeyA,aKeyB:TPasRISCVHashMapKey):boolean;
       function FindEntity(const aKey:TPasRISCVHashMapKey):PEntity;
       function FindEntityForAdd(const aKey:TPasRISCVHashMapKey):PEntity;
       procedure Resize;
      protected
       function GetValue(const aKey:TPasRISCVHashMapKey):TPasRISCVHashMapValue;
       procedure SetValue(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue);
      public
       constructor Create(const aDefaultValue:TPasRISCVHashMapValue);
       destructor Destroy; override;
       procedure Clear(const aCanFree:Boolean=true);
       function Add(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue):PEntity;
       function Get(const aKey:TPasRISCVHashMapKey;const aCreateIfNotExist:boolean=false):PEntity;
       function TryGet(const aKey:TPasRISCVHashMapKey;out aValue:TPasRISCVHashMapValue):boolean;
       function ExistKey(const aKey:TPasRISCVHashMapKey):boolean;
       function Delete(const aKey:TPasRISCVHashMapKey):boolean;
       property EntityValues[const Key:TPasRISCVHashMapKey]:TPasRISCVHashMapValue read GetValue write SetValue; default;
       property Entities:TEntitiesObject read fEntitiesObject;
       property Keys:TKeysObject read fKeysObject;
       property Values:TValuesObject read fValuesObject;
       property CanShrink:boolean read fCanShrink write fCanShrink;
     end;

{$ifdef ExtraStringHashMap}
     { TPasRISCVStringHashMap<TPasRISCVHashMapValue> }
     TPasRISCVStringHashMap<TPasRISCVHashMapValue>=class
      private
       type TPasRISCVHashMapKey=RawByteString;
            TEntity=record
             public
              const Empty=0;
                    Deleted=1;
                    Used=2;
             public
              State:TPasRISCVUInt32;
              Key:TPasRISCVHashMapKey;
              Value:TPasRISCVHashMapValue;
            end;
            PEntity=^TEntity;
            TEntities=array of TEntity;
      private
       type TEntityEnumerator=record
             private
              fHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>;
              fIndex:TPasRISCVSizeInt;
              function GetCurrent:TEntity; inline;
             public
              constructor Create(const aHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
              function MoveNext:boolean; inline;
              property Current:TEntity read GetCurrent;
            end;
            TKeyEnumerator=record
             private
              fHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>;
              fIndex:TPasRISCVSizeInt;
              function GetCurrent:TPasRISCVHashMapKey; inline;
             public
              constructor Create(const aHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
              function MoveNext:boolean; inline;
              property Current:TPasRISCVHashMapKey read GetCurrent;
            end;
            TPasRISCVHashMapValueEnumerator=record
             private
              fHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>;
              fIndex:TPasRISCVSizeInt;
              function GetCurrent:TPasRISCVHashMapValue; inline;
             public
              constructor Create(const aHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
              function MoveNext:boolean; inline;
              property Current:TPasRISCVHashMapValue read GetCurrent;
            end;
            TEntitiesObject=class
             private
              fOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>;
             public
              constructor Create(const aOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
              function GetEnumerator:TEntityEnumerator;
            end;
            TKeysObject=class
             private
              fOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>;
             public
              constructor Create(const aOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
              function GetEnumerator:TKeyEnumerator;
            end;
            TValuesObject=class
             private
              fOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>;
              function GetValue(const aKey:TPasRISCVHashMapKey):TPasRISCVHashMapValue; inline;
              procedure SetValue(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue); inline;
             public
              constructor Create(const aOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
              function GetEnumerator:TPasRISCVHashMapValueEnumerator;
              property Values[const Key:TPasRISCVHashMapKey]:TPasRISCVHashMapValue read GetValue write SetValue; default;
            end;
      private
       fSize:TPasRISCVSizeUInt;
       fLogSize:TPasRISCVSizeUInt;
       fCountNonEmptyEntites:TPasRISCVSizeUInt;
       fCountDeletedEntites:TPasRISCVSizeUInt;
       fEntities:TEntities;
       fDefaultValue:TPasRISCVHashMapValue;
       fCanShrink:boolean;
       fEntitiesObject:TEntitiesObject;
       fKeysObject:TKeysObject;
       fValuesObject:TValuesObject;
       function HashKey(const aKey:TPasRISCVHashMapKey):TPasRISCVUInt32;
       function FindEntity(const aKey:TPasRISCVHashMapKey):PEntity;
       function FindEntityForAdd(const aKey:TPasRISCVHashMapKey):PEntity;
       procedure Resize;
      protected
       function GetValue(const aKey:TPasRISCVHashMapKey):TPasRISCVHashMapValue;
       procedure SetValue(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue);
      public
       constructor Create(const aDefaultValue:TPasRISCVHashMapValue);
       destructor Destroy; override;
       procedure Clear(const aCanFree:Boolean=true);
       function Add(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue):PEntity;
       function Get(const aKey:TPasRISCVHashMapKey;const aCreateIfNotExist:boolean=false):PEntity;
       function TryGet(const aKey:TPasRISCVHashMapKey;out aValue:TPasRISCVHashMapValue):boolean;
       function ExistKey(const aKey:TPasRISCVHashMapKey):boolean;
       function Delete(const aKey:TPasRISCVHashMapKey):boolean;
       property EntityValues[const Key:TPasRISCVHashMapKey]:TPasRISCVHashMapValue read GetValue write SetValue; default;
       property Entities:TEntitiesObject read fEntitiesObject;
       property Keys:TKeysObject read fKeysObject;
       property Values:TValuesObject read fValuesObject;
       property CanShrink:boolean read fCanShrink write fCanShrink;
     end;
{$else}
     TPasRISCVStringHashMap<TPasRISCVHashMapValue>=class(TPasRISCVHashMap<RawByteString,TPasRISCVHashMapValue>);
{$endif}

     { TPasRISCVFileMappedStream }
     TPasRISCVFileMappedStream=class(TStream)
      public
       const DefaultViewSize=64 shl 20; // 64MB
      private
       fFileHandle:{$ifdef unix}TPasRISCVInt32{$else}hFile{$endif};
{$ifndef unix}
       fMapHandle:{$ifdef unix}Pointer{$else}THandle{$endif};
{$endif}
       fAllocationGranularity:TPasRISCVInt64;
       fMemory:Pointer;
       fReadOnly:Boolean;
       fCurrentViewOffset:TPasRISCVInt64;
       fCurrentViewSize:TPasRISCVInt64;
       fViewSize:TPasRISCVInt64;
       fViewMask:TPasRISCVInt64;
       fPosition:TPasRISCVInt64;
       fSize:TPasRISCVInt64;
       fFileName:String;
{$ifdef unix}
       FTemporary:Boolean;
{$endif}
       procedure CreateMapView;
       procedure UpdateMapView;
       procedure CloseMapView;
      protected
       procedure SetSize(aNewSize:TPasRISCVInt32); overload; override;
       procedure SetSize(const aNewSize:TPasRISCVInt64); overload; override;
      public
       constructor Create(const aFileName:String;aMode:TPasRISCVUInt16;const aMappingWholeFile:Boolean);
       destructor Destroy; override;
       procedure Clear;
       function Flush:Boolean;
       function Read(var aBuffer;aCount:TPasRISCVInt32):TPasRISCVInt32; override;
       function Write(const aBuffer;aCount:TPasRISCVInt32):TPasRISCVInt32; override;
       function Seek(const aOffset:TPasRISCVInt64;aOrigin:TSeekOrigin):TPasRISCVInt64; override;
       property Memory:Pointer read fMemory;
       property MemoryViewOffset:TPasRISCVInt64 read fCurrentViewOffset;
       property MemoryViewSize:TPasRISCVInt64 read fCurrentViewSize;
       property ReadOnly:Boolean read fReadOnly;
     end;

     TPasRISCVAudioWAVFormat=class
      public
       type TWaveSignature=array[1..4] of ansichar;
            TWaveFileHeader=packed record
             Signature:TWaveSignature;
             Size:TPasRISCVUInt32;
             WAVESignature:TWaveSignature;
            end;
            PWaveFileHeader=^TWaveFileHeader;
            TWaveFormatHeader=packed record
             FormatTag:TPasRISCVUInt16;
             Channels:TPasRISCVUInt16;
             SamplesPerSecond:TPasRISCVUInt32;
             AvgBytesPerSecond:TPasRISCVUInt32;
             SampleSize:TPasRISCVUInt16;
             BitsPerSample:TPasRISCVUInt16;
            end;
            PWaveFormatHeader=^TWaveFormatHeader;
            TWaveChunkHeader=packed record
             Signature:TWaveSignature;
             Size:TPasRISCVUInt32;
            end;
            PWaveChunkHeader=^TWaveChunkHeader;
       const RIFFSignature:TWaveSignature=('R','I','F','F');
             WAVESignature:TWaveSignature=('W','A','V','E');
             FMTSignature:TWaveSignature=('f','m','t',' ');
             DATASignature:TWaveSignature=('d','a','t','a');
     end;

     { TPasRISCVAudioWAVStreamDump }
     TPasRISCVAudioWAVStreamDump=class
      private
       fStream:TStream;
       fDoFreeStream:boolean;
       fSampleRate:TPasRISCVInt32;
       fChannels:TPasRISCVInt32;
       fBitsPerSample:TPasRISCVInt32;
       fDataOffset:TPasRISCVInt64;
       fDataSize:TPasRISCVInt64;
       fFileHeaderOffset:TPasRISCVInt64;
       fFormatChunkHeaderOffset:TPasRISCVInt64;
       fDataChunkHeaderOffset:TPasRISCVInt64;
       fWaveFileHeader:TPasRISCVAudioWAVFormat.TWaveFileHeader;
       fWaveFormatChunkHeader:TPasRISCVAudioWAVFormat.TWaveChunkHeader;
       fWaveFormatHeader:TPasRISCVAudioWAVFormat.TWaveFormatHeader;
       fWaveDataChunkHeader:TPasRISCVAudioWAVFormat.TWaveChunkHeader;
       fBufferFloats:TPasRISCVFloatDynamicArray;
      public
       constructor Create(const aSampleRate:TPasRISCVInt32;const aStream:TStream;const aDoFreeStream:boolean=true);
       destructor Destroy; override;
       procedure Flush;
       procedure Dump(const aData:TPasRISCVPointer;const aDataSize:TPasRISCVSizeInt;const aFloat:Boolean);
     end;

     { TPasRISCV9PFileSystem }
     TPasRISCV9PFileSystem=class
      public
       const // FSQID type
             P9_QTDIR=$80;
             P9_QTAPP=$40;
             P9_QTEXCL=$20;
             P9_QTMOUNT=$10;
             P9_QTAUTH=$08;
             P9_QTTMP=$04;
             P9_QTSYMLINK=$02;
             P9_QTLINK=$01;
             P9_QTFILE=$00;

             // Mode Bits
             P9_S_IXOTH=$0001;
             P9_S_IWOTH=$0002;
             P9_S_IROTH=$0004;
             P9_S_IRWXO=$0007;
             P9_S_IXGRP=$0008;
             P9_S_IWGRP=$0010;
             P9_S_IRGRP=$0020;
             P9_S_IRWXG=$0038;
             P9_S_IXUSR=$0040;
             P9_S_IWUSR=$0080;
             P9_S_IRUSR=$0100;
             P9_S_IRWXU=$01c0;
             P9_S_IRWXUGO=$01ff;
             P9_S_IXOGU=P9_S_IXOTH or P9_S_IXGRP or P9_S_IXUSR;
             P9_S_IWOGU=P9_S_IWOTH or P9_S_IWGRP or P9_S_IWUSR;
             P9_S_IROGU=P9_S_IROTH or P9_S_IRGRP or P9_S_IRUSR;
             P9_S_ISVTX=$0200;
             P9_S_ISGID=$0400;
             P9_S_ISUID=$0800;
             P9_S_IFMT=$f000;
             P9_S_IFIFO=$1000;
             P9_S_IFCHR=$2000;
             P9_S_IFDIR=$4000;
             P9_S_IFBLK=$6000;
             P9_S_IFREG=$8000;
             P9_S_IFLNK=$a000;
             P9_S_IFSOCK=$c000;

             // Flags for open/create
             P9_O_RDONLY=$00000000;
             P9_O_WRONLY=$00000001;
             P9_O_RDWR=$00000002;
             P9_O_NOACCESS=$00000003;
             P9_O_CREAT=$00000040;
             P9_O_EXCL=$00000080;
             P9_O_NOCTTY=$00000100;
             P9_O_TRUNC=$00000200;
             P9_O_APPEND=$00000400;
             P9_O_NONBLOCK=$00000800;
             P9_O_DSYNC=$00001000;
             P9_O_FASYNC=$00002000;
             P9_O_DIRECT=$00004000;
             P9_O_LARGEFILE=$00008000;
             P9_O_DIRECTORY=$00010000;
             P9_O_NOFOLLOW=$00020000;
             P9_O_NOATIME=$00040000;
             P9_O_CLOEXEC=$00080000;
             P9_O_SYNC=$00100000;

             // SetAttr flags
             P9_SETATTR_MODE=$00000001;
             P9_SETATTR_UID=$00000002;
             P9_SETATTR_GID=$00000004;
             P9_SETATTR_SIZE=$00000008;
             P9_SETATTR_ATIME=$00000010;
             P9_SETATTR_MTIME=$00000020;
             P9_SETATTR_CTIME=$00000040;
             P9_SETATTR_ATIME_SET=$00000080;
             P9_SETATTR_MTIME_SET=$00000100;

             // Error codes
             P9_EPERM=1;
             P9_ENOENT=2;
             P9_EIO=5;
             P9_EEXIST=17;
             P9_ENOTDIR=20;
             P9_EINVAL=22;
             P9_ENOSPC=28;
             P9_ENOTEMPTY=39;
             P9_EPROTO=71;
             P9_ENOTSUP=524;

             // Lock types
             P9_LOCK_TYPE_RDLCK=0;
             P9_LOCK_TYPE_WRLCK=1;
             P9_LOCK_TYPE_UNLCK=2;

             // Lock flags
             P9_LOCK_FLAGS_BLOCK=1;
             P9_LOCK_FLAGS_RECLAIM=2;

             // Lock codes
             P9_LOCK_SUCCESS=0;
             P9_LOCK_BLOCKED=1;
             P9_LOCK_ERROR=2;
             P9_LOCK_GRACE=3;

             // FSCMD name
             FSCMD_NAME:PAnsiChar='.fscmd';
       type TFSQID=packed record
             Type_:TPasRISCVUInt8;
             Version:TPasRISCVUInt32;
             Path:TPasRISCVUInt64;
            end;
            PFSQID=^TFSQID;
            TFSQIDArray=array[0..65535] of TFSQID;
            PFSQIDArray=^TFSQIDArray;
            TFSStatFS=packed record
             BSize:TPasRISCVUInt32;
             Blocks:TPasRISCVUInt64;
             BFree:TPasRISCVUInt64;
             BAvail:TPasRISCVUInt64;
             Files:TPasRISCVUInt64;
             FFree:TPasRISCVUInt64;
            end;
            PFSStatFS=^TFSStatFS;
            TFSStat=packed record
             QID:TFSQID;
             Mode:TPasRISCVUInt32;
             UID:TPasRISCVUInt32;
             GID:TPasRISCVUInt32;
             NLink:TPasRISCVUInt64;
             RDev:TPasRISCVUInt64;
             Size:TPasRISCVUInt64;
             BlkSize:TPasRISCVUInt64;
             Blocks:TPasRISCVUInt64;
             ATimeSec:TPasRISCVUInt64;
             ATimeNSec:TPasRISCVUInt32;
             MTimeSec:TPasRISCVUInt64;
             MTimeNSec:TPasRISCVUInt32;
             CTimeSec:TPasRISCVUInt64;
             CTimeNSec:TPasRISCVUInt32;
            end;
            PFSStat=^TFSStat;
            TFSLock=packed record
             Type_:TPasRISCVUInt8;
             Flags:TPasRISCVUInt16;
             Start:TPasRISCVUInt64;
             Length:TPasRISCVUInt64;
             ProcID:TPasRISCVUInt32;
             ClientID:PPasRISCVUInt32;
            end;
            PFSLock=^TFSLock;
            TFSFile=class;
            TFSFile=class
             private
              fUID:TPasRISCVUInt32;
              fPath:TPasRISCVRawByteString;
              fIsOpened:TPasMPBool32;
              fIsDirectory:TPasMPBool32;
              fStream:TStream;
{$if defined(fpc) and defined(Unix)}
              fFile:cint;
              fDirectory:PDIR;
{$elseif defined(Windows)}
              fFileHandle:THandle;
              fDirectoryHandle:THandle;
              fIsOverlapped:TPasMPBool32;
{$ifend}
            end;
            TOnOpenCompletion=procedure(const aFileSystem:TPasRISCV9PFileSystem;const aQID:TPasRISCV9PFileSystem.PFSQID;const aError:TPasRISCVUInt32;const aOpaque:Pointer) of object;
      private
       fRootPath:TPasRISCVRawByteString;
      public
       constructor Create; virtual;
       destructor Destroy; override;
       procedure Delete(const aFile:TPasRISCV9PFileSystem.TFSFile); virtual;
       procedure StatFS(out aStatFS:TPasRISCV9PFileSystem.TFSStatFS); virtual;
       function Attach(out aFile:TPasRISCV9PFileSystem.TFSFile;const aQID:TPasRISCV9PFileSystem.PFSQID;const aUID:TPasRISCVUInt32;const aUName,aAName:TPasRISCVRawByteString):TPasRISCVInt32; virtual;
       function Walk(out aFiles:TPasRISCV9PFileSystem.TFSFile;const aQIDs:TPasRISCV9PFileSystem.PFSQIDArray;const aFile:TPasRISCV9PFileSystem.TFSFile;const aCount:TPasRISCVSizeInt;const aNames:array of TPasRISCVRawByteString):TPasRISCVInt32; virtual;
       function MkDir(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32; virtual;
       function Open(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aFlags:TPasRISCVUInt32;const aOnOpenCompletion:TPasRISCV9PFileSystem.TOnOpenCompletion;const aOpaque:Pointer):TPasRISCVInt32; virtual;
       function Create_(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aFlags:TPasRISCVUInt32;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32; virtual;
       function ReadDir(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; virtual;
       function Read(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; virtual;
       function Write(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; virtual;
       procedure Close(const aFile:TPasRISCV9PFileSystem.TFSFile); virtual;
       function Stat(const aFile:TPasRISCV9PFileSystem.TFSFile;out aStat:TPasRISCV9PFileSystem.TFSStat):TPasRISCVInt32; virtual;
       function SetAttr(const aFile:TPasRISCV9PFileSystem.TFSFile;const aMask,aMode,aUID,aGID:TPasRISCVUInt32;const aSize,aATimeSec,aATimeNSec,aMTimeSec,aMTimeNSec,aCTimeSec,aCTimeNSec:TPasRISCVUInt64):TPasRISCVInt32; virtual;
       function Link(const aDestFile,aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32; virtual;
       function SymLink(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName,aTarget:TPasRISCVRawByteString;const aGID:TPasRISCVUInt32):TPasRISCVInt32; virtual;
       function MkNod(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aMajor,aMinor,aGID:TPasRISCVUInt32):TPasRISCVInt32; virtual;
       function ReadLink(const aBuffer:Pointer;const aSize:TPasRISCVInt64;const aFile:TPasRISCV9PFileSystem.TFSFile):TPasRISCVInt64; virtual;
       function RenameAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aNewFile:TPasRISCV9PFileSystem.TFSFile;const aNewName:TPasRISCVRawByteString):TPasRISCVInt32; virtual;
       function UnlinkAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32; virtual;
       function Lock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32; virtual;
       function GetLock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32; virtual;
      public
       property RootPath:TPasRISCVRawByteString read fRootPath write fRootPath;
     end;

{$if defined(fpc) and defined(Unix)}
     { TPasRISCV9PFileSystemPOSIX }
     TPasRISCV9PFileSystemPOSIX=class(TPasRISCV9PFileSystem)
      public
       const DT_UNKNOWN=0;
             DT_FIFO=1;
             DT_CHR=2;
             DT_DIR=4;
             DT_BLK=6;
             DT_REG=8;
             DT_LNK=10;
             DT_SOCK=12;
             DT_WHT=14;
             UTIME_NOW=TPasRISCVUInt32((TPasRISCVUInt32(1) shl 30)-1);
             UTIME_OMIT=TPasRISCVUInt32((TPasRISCVUInt32(1) shl 30)-2);
      private
       function POSIXErrorCodeToP9ErrorCode(const aErrorCode:TPasRISCVInt32):TPasRISCVInt32;
       function P9OpenFlagsToPOSIXOpenFlags(const aFlags:TPasRISCVUInt32):TPasRISCVUInt32;
       procedure StatToQID(const aQID:TPasRISCV9PFileSystem.PFSQID;const aStat:PStat);
       function ComposePath(const aPath,aName:TPasRISCVRawByteString):TPasRISCVRawByteString;
       function CreateFileObject(const aPath:TPasRISCVRawByteString;const aUID:TPasRISCVUInt32):TPasRISCV9PFileSystem.TFSFile;
      public
       constructor Create(const aRootPath:TPasRISCVRawByteString); reintroduce;
       destructor Destroy; override;
       procedure Delete(const aFile:TPasRISCV9PFileSystem.TFSFile); override;
       procedure StatFS(out aStatFS:TPasRISCV9PFileSystem.TFSStatFS); override;
       function Attach(out aFile:TPasRISCV9PFileSystem.TFSFile;const aQID:TPasRISCV9PFileSystem.PFSQID;const aUID:TPasRISCVUInt32;const aUName,aAName:TPasRISCVRawByteString):TPasRISCVInt32; override;
       function Walk(out aFiles:TPasRISCV9PFileSystem.TFSFile;const aQIDs:TPasRISCV9PFileSystem.PFSQIDArray;const aFile:TPasRISCV9PFileSystem.TFSFile;const aCount:TPasRISCVSizeInt;const aNames:array of TPasRISCVRawByteString):TPasRISCVInt32; override;
       function MkDir(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32; override;
       function Open(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aFlags:TPasRISCVUInt32;const aOnOpenCompletion:TPasRISCV9PFileSystem.TOnOpenCompletion;const aOpaque:Pointer):TPasRISCVInt32; override;
       function Create_(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aFlags:TPasRISCVUInt32;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32; override;
       function ReadDir(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; override;
       function Read(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; override;
       function Write(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; override;
       procedure Close(const aFile:TPasRISCV9PFileSystem.TFSFile); override;
       function Stat(const aFile:TPasRISCV9PFileSystem.TFSFile;out aStat:TPasRISCV9PFileSystem.TFSStat):TPasRISCVInt32; override;
       function SetAttr(const aFile:TPasRISCV9PFileSystem.TFSFile;const aMask,aMode,aUID,aGID:TPasRISCVUInt32;const aSize,aATimeSec,aATimeNSec,aMTimeSec,aMTimeNSec,aCTimeSec,aCTimeNSec:TPasRISCVUInt64):TPasRISCVInt32; override;
       function Link(const aDestFile,aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32; override;
       function SymLink(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName,aTarget:TPasRISCVRawByteString;const aGID:TPasRISCVUInt32):TPasRISCVInt32; override;
       function MkNod(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aMajor,aMinor,aGID:TPasRISCVUInt32):TPasRISCVInt32; override;
       function ReadLink(const aBuffer:Pointer;const aSize:TPasRISCVInt64;const aFile:TPasRISCV9PFileSystem.TFSFile):TPasRISCVInt64; override;
       function RenameAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aNewFile:TPasRISCV9PFileSystem.TFSFile;const aNewName:TPasRISCVRawByteString):TPasRISCVInt32; override;
       function UnlinkAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32; override;
       function Lock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32; override;
       function GetLock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32; override;
     end;
{$ifend}

{$if defined(Windows)}
     { TPasRISCV9PFileSystemWindows }
     TPasRISCV9PFileSystemWindows=class(TPasRISCV9PFileSystem)
      public
      private
       function FileTimeToUnixTime(const aFileTime:TFileTime):TPasRISCVUInt64;
       function UnixTimeToFileTime(const aUnixTime:TPasRISCVUInt64):TFileTime;
       function Win32FileAttributesToP9Mode(const aFileAttributes:DWORD):TPasRISCVUInt32;
       function Win32ErrorCodeToP9ErrorCode(const aErrorCode:DWORD):TPasRISCVInt32;
       function P9OpenFlagsToWin32OpenFlags(const aFlags:TPasRISCVUInt32):DWORD;
       procedure StatToQID(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFileInfo:BY_HANDLE_FILE_INFORMATION);
       function ComposePath(const aPath,aName:TPasRISCVRawByteString):TPasRISCVRawByteString;
       function CreateFileObject(const aPath:TPasRISCVRawByteString;const aUID:TPasRISCVUInt32):TPasRISCV9PFileSystem.TFSFile;
      public
       constructor Create(const aRootPath:TPasRISCVRawByteString); reintroduce;
       destructor Destroy; override;
       procedure Delete(const aFile:TPasRISCV9PFileSystem.TFSFile); override;
       procedure StatFS(out aStatFS:TPasRISCV9PFileSystem.TFSStatFS); override;
       function Attach(out aFile:TPasRISCV9PFileSystem.TFSFile;const aQID:TPasRISCV9PFileSystem.PFSQID;const aUID:TPasRISCVUInt32;const aUName,aAName:TPasRISCVRawByteString):TPasRISCVInt32; override;
       function Walk(out aFiles:TPasRISCV9PFileSystem.TFSFile;const aQIDs:TPasRISCV9PFileSystem.PFSQIDArray;const aFile:TPasRISCV9PFileSystem.TFSFile;const aCount:TPasRISCVSizeInt;const aNames:array of TPasRISCVRawByteString):TPasRISCVInt32; override;
       function MkDir(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32; override;
       function Open(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aFlags:TPasRISCVUInt32;const aOnOpenCompletion:TPasRISCV9PFileSystem.TOnOpenCompletion;const aOpaque:Pointer):TPasRISCVInt32; override;
       function Create_(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aFlags:TPasRISCVUInt32;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32; override;
       function ReadDir(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; override;
       function Read(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; override;
       function Write(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64; override;
       procedure Close(const aFile:TPasRISCV9PFileSystem.TFSFile); override;
       function Stat(const aFile:TPasRISCV9PFileSystem.TFSFile;out aStat:TPasRISCV9PFileSystem.TFSStat):TPasRISCVInt32; override;
       function SetAttr(const aFile:TPasRISCV9PFileSystem.TFSFile;const aMask,aMode,aUID,aGID:TPasRISCVUInt32;const aSize,aATimeSec,aATimeNSec,aMTimeSec,aMTimeNSec,aCTimeSec,aCTimeNSec:TPasRISCVUInt64):TPasRISCVInt32; override;
       function Link(const aDestFile,aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32; override;
       function SymLink(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName,aTarget:TPasRISCVRawByteString;const aGID:TPasRISCVUInt32):TPasRISCVInt32; override;
       function MkNod(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aMajor,aMinor,aGID:TPasRISCVUInt32):TPasRISCVInt32; override;
       function ReadLink(const aBuffer:Pointer;const aSize:TPasRISCVInt64;const aFile:TPasRISCV9PFileSystem.TFSFile):TPasRISCVInt64; override;
       function RenameAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aNewFile:TPasRISCV9PFileSystem.TFSFile;const aNewName:TPasRISCVRawByteString):TPasRISCVInt32; override;
       function UnlinkAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32; override;
       function Lock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32; override;
       function GetLock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32; override;
     end;
{$ifend}

     TPasRISCV9PFileSystemNative={$if defined(fpc) and defined(Unix)}TPasRISCV9PFileSystemPOSIX{$elseif defined(Windows)}TPasRISCV9PFileSystemWindows{$else}TPasRISCV9PFileSystem{$ifend};

     { TPasRISCV9PFileSystemMemory }

     { TPasRISCVEthernetDevice }
     TPasRISCVEthernetDevice=class
      public
       type TMACAddress=array[0..5] of TPasRISCVUInt8;
            PMACAddress=^TMACAddress;
            TOnCanWritePacket=function():Boolean of object;
            TOnWritePacket=procedure(const aBuffer:Pointer;const aBufferSize:TPasRISCVSizeInt) of object;
            TOnSetCarrier=procedure(const aCarrierStatus:Boolean) of object;
      private
       fMACAddress:TMACAddress;
       fOnCanWritePacket:TOnCanWritePacket;
       fOnWritePacket:TOnWritePacket;
       fOnSetCarrier:TOnSetCarrier;
      public
       constructor Create; reintroduce;
       destructor Destroy; override;
       procedure GenerateMACAddress;
       procedure Shutdown; virtual;
       procedure WritePacket(const aBuffer:Pointer;const aBufferSize:TPasRISCVSizeInt); virtual;
      public
       property MACAddress:TMACAddress read fMACAddress write fMACAddress;
       property OnCanWritePacket:TOnCanWritePacket read fOnCanWritePacket write fOnCanWritePacket;
       property OnWritePacket:TOnWritePacket read fOnWritePacket write fOnWritePacket;
       property OnSetCarrier:TOnSetCarrier read fOnSetCarrier write fOnSetCarrier;
     end;

{$if defined(fpc) and defined(unix)}
     { TPasRISCVEthernetDeviceTUN }
     TPasRISCVEthernetDeviceTUN=class(TPasRISCVEthernetDevice)
      public
       const TUNSETIFF=$400454ca;
             IFF_TUN=$0001;
             IFF_TAP=$0002;
             IFF_NAPI=$0010;
             IFF_NAPI_FRAGS=$0020;
             IFF_NO_CARRIER=$0040;
             IFF_NO_PI=$1000;
             IFF_ONE_QUEUE=$2000;
             IFF_VNET_HDR=$4000;
             IFF_TUN_EXCL=$8000;
             IFF_MULTI_QUEUE=$0100;
             IFF_ATTACH_QUEUE=$0200;
             IFF_DETACH_QUEUE=$0400;
             IFF_PERSIST=$0800;
             IFF_NOFILTER=$1000;
       type Tifmap=record
             mem_start:TPasRISCVUInt32;
             mem_end:TPasRISCVUInt32;
             base_addr:TPasRISCVUInt16;
             irq:TPasRISCVUInt8;
             dma:TPasRISCVUInt8;
             port:TPasRISCVUInt8;
            end;
            Pifmap=^Tifmap;
            Tifreq=record
             ifr_ifrn:record
              case TPasRISCVInt32 of
               0:(ifr_name:array[0..15] of TPasRISCVRawByteChar);
             end;
             ifr_ifru:record
              case TPasRISCVInt32 of
               0:(ifru_addr:sockaddr);
               1:(ifru_dstaddr:sockaddr);
               2:(ifru_broadaddr:sockaddr);
               3:(ifru_netmask:sockaddr);
               4:(ifru_hwaddr:sockaddr);
               5:(ifru_flags:TPasRISCVInt16);
               6:(ifru_ivalue:TPasRISCVInt32);
               7:(ifru_mtu:TPasRISCVInt32);
               8:(ifru_map:Tifmap);
               9:(ifru_slave:array[0..15] of TPasRISCVRawByteChar);
               10:(ifru_newname:array[0..15] of TPasRISCVRawByteChar);
               11:(ifru_data:PPasRISCVRawByteChar);
             end;
            end;
            Pifreq=^Tifreq;
            TNetworkThread=class(TPasMPThread)
             private
              fEthernetDevice:TPasRISCVEthernetDeviceTUN;
              fEvent:TPasMPEvent;
             protected
              procedure Execute; override;
             public
              constructor Create(const aEthernetDevice:TPasRISCVEthernetDeviceTUN);
              destructor Destroy; override;
              procedure Shutdown;
            end;
      private
       fTunFD:TPasRISCVInt32;
       fSelectedFilled:TPasMPBool32;
       fThread:TNetworkThread;
       fRFDS:TFDSet;
       fWFDS:TFDSet;
       fEFDS:TFDSet;
       fBuffer:array[0..65535] of TPasRISCVUInt8;
       procedure ThreadProc;
      public
       constructor Create; reintroduce;
       destructor Destroy; override;
       procedure Shutdown; override;
       function Open(const aInterfaceName:TPasRISCVRawByteString):Boolean;
       procedure WritePacket(const aBuffer:Pointer;const aBufferSize:TPasRISCVSizeInt); override;
     end;
{$ifend}

     { TPasRISCV }
     TPasRISCV=class
      public
       const PAGE_SIZE=4096;
             PAGE_MASK=4095;
             PAGE_SHIFT=12;
             PAGE_ADDRESS_MASK=TPasRISCVUInt64($fffffffffffff000);
             RUNSTATE_POWEROFF=TPasRISCVUInt32(1) shl 16;
             RUNSTATE_RUNNING=TPasRISCVUInt32(1) shl 17;
             RUNSTATE_REBOOT=TPasRISCVUInt32(1) shl 18;
             RUNSTATE_SINGLESTEP=TPasRISCVUInt32(1) shl 19;
             RUNSTATE_PAUSING=TPasRISCVUInt32(1) shl 20;
             RUNSTATE_PAUSED=TPasRISCVUInt32(1) shl 21;
             RUNSTATE_FLUSHTLB=TPasRISCVUInt32(1) shl 22;
             RUNSTATE_GLOBAL_MASK=TPasRISCVUInt32($ffff0000);
             RUNSTATE_HARTS_MASK=TPasRISCVUInt32($0000ffff);
             RUNSTATE_HART_SHIFT=0;
             CLOCK_FREQUENCY=1000000;
             FE_ALL_EXCEPT=$3f;
             FE_INVALID=$01;
             FE_DENORM=$02;
             FE_DIVBYZERO=$04;
             FE_OVERFLOW=$08;
             FE_UNDERFLOW=$10;
             FE_INEXACT=$20;
             KERNEL_OFFSET=$200000;
             POLL_RX=1 shl 0;
             POLL_TX=1 shl 1;
             SerialChars:array[0..35] of TPasRISCVChar=
              (
               '0','1','2','3','4','5','6','7','8','9',
               'A','B','C','D','E','F','G','H','I','J',
               'K','L','M','N','O','P','Q','R','S','T',
               'U','V','W','X','Y','Z'
              );
       type TRegister=
             (
              // Raw
              x0=0,
              x1=1,
              x2=2,
              x3=3,
              x4=4,
              x5=5,
              x6=6,
              x7=7,
              x8=8,
              x9=9,
              x10=10,
              x11=11,
              x12=12,
              x13=13,
              x14=14,
              x15=15,
              x16=16,
              x17=17,
              x18=18,
              x19=19,
              x20=20,
              x21=21,
              x22=22,
              x23=23,
              x24=24,
              x25=26,
              x27=27,
              x28=28,
              x29=29,
              x30=30,
              x31=31,

              // ABI
              Zero=0,
              RA=1,
              SP=2,
              GP=3,
              TP=4,
              T0=5,
              T1=6,
              T2=7,
              S0=8,
              S1=9,
              A0=10,
              A1=11,
              A2=12,
              A3=13,
              A4=14,
              A5=15,
              A6=16,
              A7=17,
              S2=18,
              S3=19,
              S4=20,
              S5=21,
              S6=22,
              S7=23,
              S8=24,
              S9=25,
              S10=26,
              S11=27,
              T3=28,
              T4=29,
              T5=30,
              T6=31
             );
            PRegister=^TRegister;
            TRegisters=array[TRegister] of TPasRISCVUInt64;
            PRegisters=^TRegisters;
            TFPURegister=
             (
              // Raw
              f0=0,
              f1=1,
              f2=2,
              f3=3,
              f4=4,
              f5=5,
              f6=6,
              f7=7,
              f8=8,
              f9=9,
              f10=10,
              f11=11,
              f12=12,
              f13=13,
              f14=14,
              f15=15,
              f16=16,
              f17=17,
              f18=18,
              f19=19,
              f20=20,
              f21=21,
              f22=22,
              f23=23,
              f24=24,
              f25=25,
              f26=26,
              f27=27,
              f28=28,
              f29=29,
              f30=30,
              f31=31,

              // ABI
              ft0=0,
              ft1=1,
              ft2=2,
              ft3=3,
              ft4=4,
              ft5=5,
              ft6=6,
              ft7=7,
              fs0=8,
              fs1=9,
              fa0=10,
              fa1=11,
              fa2=12,
              fa3=13,
              fa4=14,
              fa5=15,
              fa6=16,
              fa7=17,
              fs2=18,
              fs3=19,
              fs4=20,
              fs5=21,
              fs6=22,
              fs7=23,
              fs8=24,
              fs9=25,
              fs10=26,
              fs11=27,
              ft8=28,
              ft9=29,
              ft10=30,
              ft11=31
             );
            PFPURegister=^TFPURegister;
            TFPURegisterValue=record
             case TPasRISCVUInt8 of
              0:(
               ui32:TPasRISCVUInt32;
               NaNBoxUI32:TPasRISCVUInt32;
              );
              1:(
               ui64:TPasRISCVUInt64;
              );
              2:(
               f32:TPasRISCVFloat;
              );
              3:(
               f64:TPasRISCVDouble;
              );
              4:(
               ui16:TPasRISCVUInt16;
               NaNBoxUI16Pad:TPasRISCVUInt16;
               NaNBoxUI16High:TPasRISCVUInt32;
              );
            end;
            PFPURegisterValue=^TFPURegisterValue;
            TFPURegisters=array[TFPURegister] of TFPURegisterValue;
            PFPURegisters=^TFPURegisters;
            TInstructionSetArchitecture=class
             public
              const RegisterRawNames:array[TRegister] of TPasRISCVUTF8String=
                     (
                      'x0','x1','x2','x3','x4','x5','x6','x7',
                      'x8','x9','x10','x11','x12','x13','x14','x15',
                      'x16','x17','x18','x19','x20','x21','x22','x23',
                      'x24','x25','x26','x27','x28','x29','x30','x31'
                     );
                   RegisterABINames:array[TRegister] of TPasRISCVUTF8String=
                     (
                      'zero','ra','sp','gp','tp','t0','t1','t2',
                      's0','s1','a0','a1','a2','a3','a4','a5',
                      'a6','a7','s2','s3','s4','s5','s6','s7',
                      's8','s9','s10','s11','t3','t4','t5','t6'
                     );
                   FPURegisterRawNames:array[TFPURegister] of TPasRISCVUTF8String=
                     (
                      'f0','f1','f2','f3','f4','f5','f6','f7',
                      'f8','f9','f10','f11','f12','f13','f14','f15',
                      'f16','f17','f18','f19','f20','f21','f22','f23',
                      'f24','f25','f26','f27','f28','f29','f30','f31'
                     );
                   FPURegisterABINames:array[TFPURegister] of TPasRISCVUTF8String=
                     (
                      'ft0','ft1','ft2','ft3','ft4','ft5','ft6','ft7',
                      'fs0','fs1','fa0','fa1','fa2','fa3','fa4','fa5',
                      'fa6','fa7','fs2','fs3','fs4','fs5','fs6','fs7',
                      'fs8','fs9','fs10','fs11','ft8','ft9','ft10','ft11'
                     );
              type TInstructionFormat=
                    (
                     None,
                     R,
                     RUnary,
                     I,
                     IShift,
                     IShiftW,
                     Load,
                     Store,
                     Branch,
                     U,
                     J,
                     Jalr,
                     Fence,
                     Cbo,
                     CSR,
                     CSRImm,
                     SFence,
                     AMO,
                     LR,
                     SC,
                     FLoad,
                     FStore,
                     FMA,
                     FPBinaryRM,
                     FPBinary,
                     FPUnaryRM,
                     FPCompare,
                     FPClass,
                     FPCvtIntFromFP,
                     FPCvtFPFromInt,
                     FPCvtFP,
                     FPMoveToInt,
                     FPMoveFromInt,
                     FPLoadImm,
                     Prefetch,
                     HLV,
                     HSV
                    );
                   TInstruction=record
                    Mask:TPasRISCVUInt32;
                    Value:TPasRISCVUInt32;
                    Mnemonic:TPasRISCVUTF8String;
                    Format:TInstructionFormat;
                   end;
                   PInstruction=^TInstruction;
                   TInstructionList=array of TInstruction;
                   TRegisterKind=
                    (
                     Integer,
                     Float
                    );
                   TCompressedFormat=
                    (
                     None,
                     CI,
                     CIPrime,
                     CIShift,
                     CIShiftPrime,
                     CIAddi16sp,
                     CILui,
                     CIW,
                     CLW,
                     CLD,
                     CSW,
                     CSD,
                     CJ,
                     CB,
                     CR,
                     CA,
                     RDPrime,
                     CLWSP,
                     CLDSP,
                     CSWSP,
                     CSDSP,
                     CJR,
                     ZcbLbu,
                     ZcbLh,
                     ZcbLhu,
                     ZcbSbu,
                     ZcbSh
                    );
                   TCompressedInstruction=record
                    Mask:TPasRISCVUInt32;
                    Value:TPasRISCVUInt32;
                    Mnemonic:TPasRISCVUTF8String;
                    Format:TCompressedFormat;
                    DataRegisterKind:TRegisterKind;
                   end;
                   PCompressedInstruction=^TCompressedInstruction;
                   TCompressedInstructionList=array of TCompressedInstruction;
             private
              type TInstructionIndexList=array of TPasRISCVSizeInt;
             private
              fMachine:TPasRISCV;
              fInstructions32:TInstructionList;
              fInstructions16:TCompressedInstructionList;
              fCountInstructions32:TPasRISCVSizeInt;
              fCountInstructions16:TPasRISCVSizeInt;
              fOpcodeIndex32:array[0..127] of TInstructionIndexList;
              fCompressedIndex16:array[0..3,0..7] of TInstructionIndexList;
              procedure AddInstruction32(const aMnemonic:TPasRISCVUTF8String;
                                         const aFormat:TInstructionFormat;
                                         const aMask,aValue:TPasRISCVUInt32);
              procedure AddInstruction16(const aMnemonic:TPasRISCVUTF8String;
                                         const aFormat:TCompressedFormat;
                                         const aDataRegisterKind:TRegisterKind;
                                         const aMask,aValue:TPasRISCVUInt32);
              procedure BuildInstructionTables;
              procedure BuildIndexes;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function FindInstruction32(const aInstruction:TPasRISCVUInt32;out aInstructionDefinition:TInstruction):Boolean;
              function FindInstruction16(const aInstruction:TPasRISCVUInt32;out aInstructionDefinition:TCompressedInstruction):Boolean;
            end;
            THART=class;
            THARTs=array of THART;
            TBus=class;
            { TPCG32 }
            TPCG32=record
             private
              const DefaultState=TPasRISCVUInt64($853c49e6748fea9b);
                    DefaultStream=TPasRISCVUInt64($da3e39cb94b95bdb);
                    Mult=TPasRISCVUInt64($5851f42d4c957f2d);
             private
              fState:TPasRISCVUInt64;
              fIncrement:TPasRISCVUInt64;
             public
              procedure Init(const aSeed:TPasRISCVUInt64=0);
              function Get32:TPasRISCVUInt32;
              function GetUnbiasedBounded(const aRange:TPasRISCVUInt32):TPasRISCVUInt32;
            end;
            TFSQID=packed record
             Type_:TPasRISCVUInt8;
             Version:TPasRISCVUInt32;
             Path:TPasRISCVUInt64;
            end;
            PFSQID=^TFSQID;
            { TEVDEV }
            TEVDEV=class
             public
              const KEY_RESERVED=0;
                    KEY_ESC=1;
                    KEY_1=2;
                    KEY_2=3;
                    KEY_3=4;
                    KEY_4=5;
                    KEY_5=6;
                    KEY_6=7;
                    KEY_7=8;
                    KEY_8=9;
                    KEY_9=10;
                    KEY_0=11;
                    KEY_MINUS=12;
                    KEY_EQUAL=13;
                    KEY_BACKSPACE=14;
                    KEY_TAB=15;
                    KEY_Q=16;
                    KEY_W=17;
                    KEY_E=18;
                    KEY_R=19;
                    KEY_T=20;
                    KEY_Y=21;
                    KEY_U=22;
                    KEY_I=23;
                    KEY_O=24;
                    KEY_P=25;
                    KEY_LEFTBRACE=26;
                    KEY_RIGHTBRACE=27;
                    KEY_ENTER=28;
                    KEY_LEFTCTRL=29;
                    KEY_A=30;
                    KEY_S=31;
                    KEY_D=32;
                    KEY_F=33;
                    KEY_G=34;
                    KEY_H=35;
                    KEY_J=36;
                    KEY_K=37;
                    KEY_L=38;
                    KEY_SEMICOLON=39;
                    KEY_APOSTROPHE=40;
                    KEY_GRAVE=41;
                    KEY_LEFTSHIFT=42;
                    KEY_BACKSLASH=43;
                    KEY_Z=44;
                    KEY_X=45;
                    KEY_C=46;
                    KEY_V=47;
                    KEY_B=48;
                    KEY_N=49;
                    KEY_M=50;
                    KEY_COMMA=51;
                    KEY_DOT=52;
                    KEY_SLASH=53;
                    KEY_RIGHTSHIFT=54;
                    KEY_KPASTERISK=55;
                    KEY_LEFTALT=56;
                    KEY_SPACE=57;
                    KEY_CAPSLOCK=58;
                    KEY_F1=59;
                    KEY_F2=60;
                    KEY_F3=61;
                    KEY_F4=62;
                    KEY_F5=63;
                    KEY_F6=64;
                    KEY_F7=65;
                    KEY_F8=66;
                    KEY_F9=67;
                    KEY_F10=68;
                    KEY_NUMLOCK=69;
                    KEY_SCROLLLOCK=70;
                    KEY_KP7=71;
                    KEY_KP8=72;
                    KEY_KP9=73;
                    KEY_KPMINUS=74;
                    KEY_KP4=75;
                    KEY_KP5=76;
                    KEY_KP6=77;
                    KEY_KPPLUS=78;
                    KEY_KP1=79;
                    KEY_KP2=80;
                    KEY_KP3=81;
                    KEY_KP0=82;
                    KEY_KPDOT=83;

                    KEY_ZENKAKUHANKAKU=85;
                    KEY_102ND=86;
                    KEY_F11=87;
                    KEY_F12=88;
                    KEY_RO=89;
                    KEY_KATAKANA=90;
                    KEY_HIRAGANA=91;
                    KEY_HENKAN=92;
                    KEY_KATAKANAHIRAGANA=93;
                    KEY_MUHENKAN=94;
                    KEY_KPJPCOMMA=95;
                    KEY_KPENTER=96;
                    KEY_RIGHTCTRL=97;
                    KEY_KPSLASH=98;
                    KEY_SYSRQ=99;
                    KEY_RIGHTALT=100;
                    KEY_LINEFEED=101;
                    KEY_HOME=102;
                    KEY_UP=103;
                    KEY_PAGEUP=104;
                    KEY_LEFT=105;
                    KEY_RIGHT=106;
                    KEY_END=107;
                    KEY_DOWN=108;
                    KEY_PAGEDOWN=109;
                    KEY_INSERT=110;
                    KEY_DELETE=111;
                    KEY_MACRO=112;
                    KEY_MUTE=113;
                    KEY_VOLUMEDOWN=114;
                    KEY_VOLUMEUP=115;
                    KEY_POWER=116; // SC System Power Down
                    KEY_KPEQUAL=117;
                    KEY_KPPLUSMINUS=118;
                    KEY_PAUSE=119;
                    KEY_SCALE=120; // AL Compiz Scale (Expose)
                    KEY_KPCOMMA=121;
                    KEY_HANGEUL=122;
                    KEY_HANGUEL=KEY_HANGEUL;
                    KEY_HANJA=123;
                    KEY_YEN=124;
                    KEY_LEFTMETA=125;
                    KEY_RIGHTMETA=126;
                    KEY_COMPOSE=127;
                    KEY_STOP=128; // AC Stop
                    KEY_AGAIN=129;
                    KEY_PROPS=130; // AC Properties
                    KEY_UNDO=131;  // AC Undo
                    KEY_FRONT=132;
                    KEY_COPY=133;  // AC Copy
                    KEY_OPEN=134;  // AC Open
                    KEY_PASTE=135; // AC Paste
                    KEY_FIND=136; // AC Search
                    KEY_CUT=137;   // AC Cut
                    KEY_HELP=138;  // AL Integrated Help Center
                    KEY_MENU=139;  // Menu (show menu)
                    KEY_CALC=140;  // AL Calculator
                    KEY_SETUP=141;
                    KEY_SLEEP=142;  // SC System Sleep
                    KEY_WAKEUP=143; // System Wake Up
                    KEY_FILE=144;   // AL Local Machine Browser
                    KEY_SENDFILE=145;
                    KEY_DELETEFILE=146;
                    KEY_XFER=147;
                    KEY_PROG1=148;
                    KEY_PROG2=149;
                    KEY_WWW=150; // AL Internet Browser
                    KEY_MSDOS=151;
                    KEY_COFFEE=152; // AL Terminal Lock/Screensaver
                    KEY_SCREENLOCK=KEY_COFFEE;
                    KEY_ROTATE_DISPLAY=153; // Display orientation for e.g. tablets
                    KEY_DIRECTION=KEY_ROTATE_DISPLAY;
                    KEY_CYCLEWINDOWS=154;
                    KEY_MAIL=155;
                    KEY_BOOKMARKS=156; // AC Bookmarks
                    KEY_COMPUTER=157;
                    KEY_BACK=158;    // AC Back
                    KEY_FORWARD=159; // AC Forward
                    KEY_CLOSECD=160;
                    KEY_EJECTCD=161;
                    KEY_EJECTCLOSECD=162;
                    KEY_NEXTSONG=163;
                    KEY_PLAYPAUSE=164;
                    KEY_PREVIOUSSONG=165;
                    KEY_STOPCD=166;
                    KEY_RECORD=167;
                    KEY_REWIND=168;
                    KEY_PHONE=169; // Media Select Telephone
                    KEY_ISO=170;
                    KEY_CONFIG=171;   // AL Consumer Control Configuration
                    KEY_HOMEPAGE=172; // AC Home
                    KEY_REFRESH=173;  // AC Refresh
                    KEY_EXIT=174;     // AC Exit
                    KEY_MOVE=175;
                    KEY_EDIT=176;
                    KEY_SCROLLUP=177;
                    KEY_SCROLLDOWN=178;
                    KEY_KPLEFTPAREN=179;
                    KEY_KPRIGHTPAREN=180;
                    KEY_NEW=181;  // AC New
                    KEY_REDO=182; // AC Redo/Repeat
                    KEY_F13=183;
                    KEY_F14=184;
                    KEY_F15=185;
                    KEY_F16=186;
                    KEY_F17=187;
                    KEY_F18=188;
                    KEY_F19=189;
                    KEY_F20=190;
                    KEY_F21=191;
                    KEY_F22=192;
                    KEY_F23=193;
                    KEY_F24=194;
                    KEY_PLAYCD=200;
                    KEY_PAUSECD=201;
                    KEY_PROG3=202;
                    KEY_PROG4=203;
                    KEY_ALL_APPLICATIONS=204; // AC Desktop Show All Applications
                    KEY_DASHBOARD=KEY_ALL_APPLICATIONS;
                    KEY_SUSPEND=205;
                    KEY_CLOSE=206; // AC Close
                    KEY_PLAY=207;
                    KEY_FASTFORWARD=208;
                    KEY_BASSBOOST=209;
                    KEY_PRINT=210; // AC Print
                    KEY_HP=211;
                    KEY_CAMERA=212;
                    KEY_SOUND=213;
                    KEY_QUESTION=214;
                    KEY_EMAIL=215;
                    KEY_CHAT=216;
                    KEY_SEARCH=217;
                    KEY_CONNECT=218;
                    KEY_FINANCE=219; // AL Checkbook/Finance
                    KEY_SPORT=220;
                    KEY_SHOP=221;
                    KEY_ALTERASE=222;
                    KEY_CANCEL=223; // AC Cancel
                    KEY_BRIGHTNESSDOWN=224;
                    KEY_BRIGHTNESSUP=225;
                    KEY_MEDIA=226;
                    KEY_SWITCHVIDEOMODE =227; // Cycle between available video outputs (Monitor/LCD/TV-out/etc)
                    KEY_KBDILLUMTOGGLE=228;
                    KEY_KBDILLUMDOWN=229;
                    KEY_KBDILLUMUP=230;
                    KEY_SEND=231;        // AC Send
                    KEY_REPLY=232;       // AC Reply
                    KEY_FORWARDMAIL=233; // AC Forward Msg
                    KEY_SAVE=234;        // AC Save
                    KEY_DOCUMENTS=235;
                    KEY_BATTERY=236;
                    KEY_BLUETOOTH=237;
                    KEY_WLAN=238;
                    KEY_UWB=239;
                    KEY_UNKNOWN=240;
                    KEY_VIDEO_NEXT=241;       // drive next video source
                    KEY_VIDEO_PREV=242;       // drive previous video source
                    KEY_BRIGHTNESS_CYCLE=243; // brightness up, after max is min
                    KEY_BRIGHTNESS_AUTO=244; // Set Auto Brightness: manual
                    KEY_BRIGHTNESS_ZERO=KEY_BRIGHTNESS_AUTO;
                    KEY_DISPLAY_OFF=245; // display device to off state
                    KEY_WWAN=246; // Wireless WAN (LTE, UMTS, GSM, etc.)
                    KEY_WIMAX=KEY_WWAN;
                    KEY_RFKILL=247; // Key that controls all radios
                    KEY_MICMUTE=248; // Mute / unmute the microphone
            end;
            { THID }
            THID=class
             public
              const BTN_NONE=$0;
                    BTN_LEFT=$1;
                    BTN_RIGHT=$2;
                    BTN_MIDDLE=$4;
                    SCROLL_UP=-1;
                    SCROLL_DOWN=1;
                    KEY_NONE=$00;
                    KEY_ERR_ROLLOVER=$01;
                    KEY_ERR_POSTFAIL=$02;
                    KEY_ERR_UNDEFINED=$03;
                    KEY_A=$04;
                    KEY_B=$05;
                    KEY_C=$06;
                    KEY_D=$07;
                    KEY_E=$08;
                    KEY_F=$09;
                    KEY_G=$0a;
                    KEY_H=$0b;
                    KEY_I=$0c;
                    KEY_J=$0d;
                    KEY_K=$0e;
                    KEY_L=$0f;
                    KEY_M=$10;
                    KEY_N=$11;
                    KEY_O=$12;
                    KEY_P=$13;
                    KEY_Q=$14;
                    KEY_R=$15;
                    KEY_S=$16;
                    KEY_T=$17;
                    KEY_U=$18;
                    KEY_V=$19;
                    KEY_W=$1a;
                    KEY_X=$1b;
                    KEY_Y=$1c;
                    KEY_Z=$1d;
                    KEY_1=$1e;
                    KEY_2=$1f;
                    KEY_3=$20;
                    KEY_4=$21;
                    KEY_5=$22;
                    KEY_6=$23;
                    KEY_7=$24;
                    KEY_8=$25;
                    KEY_9=$26;
                    KEY_0=$27;
                    KEY_RETURN=$28;
                    KEY_ESCAPE=$29;
                    KEY_BACKSPACE=$2a;
                    KEY_TAB=$2b;
                    KEY_SPACE=$2c;
                    KEY_MINUS=$2d;
                    KEY_EQUAL=$2e;
                    KEY_LEFTBRACE=$2f;
                    KEY_RIGHTBRACE=$30;
                    KEY_BACKSLASH=$31;
                    KEY_HASHTILDE=$32;
                    KEY_SEMICOLON=$33;
                    KEY_APOSTROPHE=$34;
                    KEY_GRAVE=$35;
                    KEY_COMMA=$36;
                    KEY_DOT=$37;
                    KEY_SLASH=$38;
                    KEY_CAPSLOCK=$39;
                    KEY_F1=$3a;
                    KEY_F2=$3b;
                    KEY_F3=$3c;
                    KEY_F4=$3d;
                    KEY_F5=$3e;
                    KEY_F6=$3f;
                    KEY_F7=$40;
                    KEY_F8=$41;
                    KEY_F9=$42;
                    KEY_F10=$43;
                    KEY_F11=$44;
                    KEY_F12=$45;
                    KEY_SYSRQ=$46;
                    KEY_SCROLLLOCK=$47;
                    KEY_PAUSE=$48;
                    KEY_INSERT=$49;
                    KEY_HOME=$4a;
                    KEY_PAGEUP=$4b;
                    KEY_DELETE=$4c;
                    KEY_END=$4d;
                    KEY_PAGEDOWN=$4e;
                    KEY_RIGHT=$4f;
                    KEY_LEFT=$50;
                    KEY_DOWN=$51;
                    KEY_UP=$52;
                    KEY_NUMLOCK=$53;
                    KEY_KPSLASH=$54;
                    KEY_KPASTERISK=$55;
                    KEY_KPMINUS=$56;
                    KEY_KPPLUS=$57;
                    KEY_KPENTER=$58;
                    KEY_KP1=$59;
                    KEY_KP2=$5a;
                    KEY_KP3=$5b;
                    KEY_KP4=$5c;
                    KEY_KP5=$5d;
                    KEY_KP6=$5e;
                    KEY_KP7=$5f;
                    KEY_KP8=$60;
                    KEY_KP9=$61;
                    KEY_KP0=$62;
                    KEY_KPDOT=$63;
                    KEY_102ND=$64;
                    KEY_COMPOSE=$65;
                    KEY_POWER=$66;
                    KEY_KPEQUAL=$67;
                    KEY_F13=$68;
                    KEY_F14=$69;
                    KEY_F15=$6a;
                    KEY_F16=$6b;
                    KEY_F17=$6c;
                    KEY_F18=$6d;
                    KEY_F19=$6e;
                    KEY_F20=$6f;
                    KEY_F21=$70;
                    KEY_F22=$71;
                    KEY_F23=$72;
                    KEY_F24=$73;
                    KEY_OPEN=$74;
                    KEY_HELP=$75;
                    KEY_MENU=$76;
                    KEY_FRONT=$77;
                    KEY_STOP=$78;
                    KEY_AGAIN=$79;
                    KEY_UNDO=$7a;
                    KEY_CUT=$7b;
                    KEY_COPY=$7c;
                    KEY_PASTE=$7d;
                    KEY_FIND=$7e;
                    KEY_MUTE=$7f;
                    KEY_VOLUMEUP=$80;
                    KEY_VOLUMEDOWN=$81;
                    KEY_KPCOMMA=$85;
                    KEY_RO=$87;
                    KEY_KATAKANAHIRAGANA=$88;
                    KEY_YEN=$89;
                    KEY_HENKAN=$8a;
                    KEY_MUHENKAN=$8b;
                    KEY_KPJPCOMMA=$8c;
                    KEY_HANGEUL=$90;
                    KEY_HANJA=$91;
                    KEY_KATAKANA=$92;
                    KEY_HIRAGANA=$93;
                    KEY_ZENKAKUHANKAKU=$94;
                    KEY_KPLEFTPAREN=$b6;
                    KEY_KPRIGHTPAREN=$b7;
                    KEY_LEFTCTRL=$e0;
                    KEY_LEFTSHIFT=$e1;
                    KEY_LEFTALT=$e2;
                    KEY_LEFTMETA=$e3;
                    KEY_RIGHTCTRL=$e4;
                    KEY_RIGHTSHIFT=$e5;
                    KEY_RIGHTALT=$e6;
                    KEY_RIGHTMETA=$e7;
                    KEY_MEDIA_PLAYPAUSE=$e8;
                    KEY_MEDIA_STOPCD=$e9;
                    KEY_MEDIA_PREVIOUSSONG=$ea;
                    KEY_MEDIA_NEXTSONG=$eb;
                    KEY_MEDIA_EJECTCD=$ec;
                    KEY_MEDIA_VOLUMEUP=$ed;
                    KEY_MEDIA_VOLUMEDOWN=$ee;
                    KEY_MEDIA_MUTE=$ef;
                    KEY_MEDIA_WWW=$f0;
                    KEY_MEDIA_BACK=$f1;
                    KEY_MEDIA_FORWARD=$f2;
                    KEY_MEDIA_STOP=$f3;
                    KEY_MEDIA_FIND=$f4;
                    KEY_MEDIA_SCROLLUP=$f5;
                    KEY_MEDIA_SCROLLDOWN=$f6;
                    KEY_MEDIA_EDIT=$f7;
                    KEY_MEDIA_SLEEP=$f8;
                    KEY_MEDIA_COFFEE=$f9;
                    KEY_MEDIA_REFRESH=$fa;
                    KEY_MEDIA_CALC=$fb;
            end;
            TAIARegFileMode=
             (
              Machine,
              Supervisor
             );
            { TTimer }
            TTimer=record
             public
              fBeginTime:TPasRISCVUInt64;
              fFrequency:TPasRISCVUInt64;
             public
              procedure Rebase(const aTime:TPasRISCVUInt64);
              procedure Initialize(const aFrequency:TPasRISCVUInt64);
              function Get:TPasRISCVUInt64;
              property Frequency:TPasRISCVUInt64 read fFrequency;
            end;
            PTimer=^TTimer;
            { TTimeCmp }
            TTimeCmp=record
             public
              fTimeCmp:TPasMPUInt64;
              fTimer:PTimer;
             public
              procedure Initialize(const aTimer:PTimer);
              function GetTimeCmp:TPasMPUInt64;
              procedure SetTimeCmp(aTimeCmp:TPasMPUInt64);
              function Pending:Boolean;
              function Delay:TPasMPUInt64;
              function DelayNS:TPasMPUInt64;
            end;
            { TThreadTimer }
            TThreadTimer=class(TPasMPThread)
             public
              type TThreadTimerEvent=procedure of object;
             private
              fInterval:TPasRISCVUInt64;
              fEvent:TPasMPEvent;
              fOnTimer:TThreadTimerEvent;
             protected
              procedure Execute; override;
             public
              constructor Create(const aOnTimer:TThreadTimerEvent); reintroduce;
              destructor Destroy; override;
              procedure Shutdown;
              procedure SetInterval(const aInterval:TPasRISCVUInt64);
            end;
            TVirtIODevice=class;
            TNVMeDevice=class;
            TBochsVBEDevice=class;
            TCirrusDevice=class;
            TVirtIOBlockDeviceCommand=record
             RequestType:TPasRISCVUInt32;
             SectorIndex:TPasRISCVUInt64;
             Count:TPasRISCVUInt64;
             WriteSize:TPasRISCVUInt64;
             QueueIndex:TPasRISCVUInt64;
             DescriptorIndex:TPasRISCVUInt64;
            end;
            PVirtIOBlockDeviceCommand=^TVirtIOBlockDeviceCommand;
            TNVMeDeviceCommand=record
             SubmissionQueueID:TPasRISCVUInt64;
             SubmissionQueueHead:TPasRISCVUInt64;
            end;
            PNVMeDeviceCommand=^TNVMeDeviceCommand;
            TNVMeDeviceCommandDynamicArray=array of TNVMeDeviceCommand;
            TJobQueueItem=record
             public
              type TJobType=
                    (
                     VirtIODeviceQueue,
                     NVMeDeviceQueue,
                     NVMeDeviceCommand
                    );
             public
              fObject:TObject;
              case fJobType:TJobType of
               TJobType.VirtIODeviceQueue:(
                fVirtIODeviceQueue:TPasRISCVUInt32;
                fVirtIODeviceAvailableIndex:TPasRISCVInt32;
               );
               TJobType.NVMeDeviceQueue:(
                fNVMeDeviceQueue:TPasRISCVUInt32;
                fNVMeDeviceQueueValue:TPasRISCVUInt32;
               );
               TJobType.NVMeDeviceCommand:(
                fNVMeDeviceCommand:TNVMeDeviceCommand;
               );
            end;
            PJobQueueItem=^TJobQueueItem;
            TJobQueue=TPasRISCVThreadSafeDynamicQueue<TJobQueueItem>;
            TJobManager=class;
            TJobWorkerThread=class(TPasMPThread)
             private
              fJobManager:TJobManager;
             protected
              procedure Execute; override;
             public
              constructor Create(const aJobManager:TJobManager); reintroduce;
              destructor Destroy; override;
            end;
            TJobWorkerThreads=array of TJobWorkerThread;
            TJobManager=class
             private
              fQueue:TJobQueue;
              fWorkerThreads:TJobWorkerThreads;
              fCountWorkerThreads:TPasRISCVSizeInt;
              fSequence:TPasMPUInt64;
              fSleepingOnIdle:TPasMPBool32;
              fSleepingJobWorkerThreads:TPasMPInt32;
              fWakeUpCounter:TPasMPInt32;
              fWakeUpConditionVariableLock:TPasMPConditionVariableLock;
              fWakeUpConditionVariable:TPasMPConditionVariable;
             public
              constructor Create(const aCountWorkerThreads:TPasRISCVSizeInt); reintroduce;
              destructor Destroy; override;
              procedure Shutdown;
              procedure WaitForWakeUp;
              procedure WakeUpAllWorkerThreads;
              function EnqueueVirtIODeviceQueue(const aVirtIODevice:TVirtIODevice;const aVirtIODeviceQueue:TPasRISCVUInt32;const aVirtIODeviceAvailableIndex:TPasRISCVInt32):Boolean;
              function EnqueueNVMeDeviceQueue(const aNVMeDevice:TNVMeDevice;const aNVMeDeviceQueue,aNVMeDeviceQueueValue:TPasRISCVUInt32):Boolean;
              function EnqueueNVMeDeviceCommand(const aNVMeDevice:TNVMeDevice;const aNVMeDeviceCommand:TNVMeDeviceCommand):Boolean;
              function EnqueueNVMeDeviceCommands(const aNVMeDevice:TNVMeDevice;const aNVMeDeviceCommands:TNVMeDeviceCommandDynamicArray;const aCount:TPasRISCVSizeInt):Boolean;
            end;
            { TFDT }
            TFDT=class
             public
              const FDT_MAGIC=TPasRISCVUInt32($d00dfeed);
                    FDT_VERSION=TPasRISCVUInt32(17);
                    FDT_COMP_VERSION=TPasRISCVUInt32(16);
                    FDT_BEGIN_NODE=1;
                    FDT_END_NODE=2;
                    FDT_PROP=3;
                    FDT_NOP=4;
                    FDT_END=9;
                    FDT_HDR_SIZE=40;
                    FDT_RSV_SIZE=16;
              type TFDTSizeDescriptor=record
                    StructSize:TPasRISCVUInt32;
                    StringsSize:TPasRISCVUInt32;
                   end;
                   { TFDTProperty }
                   TFDTProperty=class
                    private
                     fName:TPasRISCVRawByteString;
                     fData:TPasRISCVUInt8DynamicArray;
                     fLen:TPasRISCVUInt32;
                    public
                     constructor Create;
                     destructor Destroy; override;
                    public
                     property Name:TPasRISCVRawByteString read fName write fName;
                     property Data:TPasRISCVUInt8DynamicArray read fData write fData;
                     property Len:TPasRISCVUInt32 read fLen write fLen;
                   end;
                   TFDTProperties=array of TFDTProperty;
                   { TFDTNode }
                   TFDTNode=class;
                   TFDTNodes=array of TFDTNode;
                   TFDTNode=class
                    private
                     fFDT:TFDT;
                     fName:TPasRISCVRawByteString;
                     fParent:TFDTNode;
                     fProperties:TFDTProperties;
                     fCountProperties:TPasRISCVSizeInt;
                     fNodes:TFDTNodes;
                     fCountNodes:TPasRISCVSizeInt;
                     fPHandle:TPasRISCVUInt32;
                    public
                     constructor Create(const aFDT:TFDT;const aName:TPasRISCVRawByteString); overload;
                     constructor Create(const aFDT:TFDT;const aName:TPasRISCVRawByteString;const aAddress:TPasRISCVUInt64); overload;
                     destructor Destroy; override;
                     procedure AddChild(const aNode:TFDTNode);
                     function FindNode(const aName:TPasRISCVRawByteString):TFDTNode; overload;
                     function FindNode(const aName:TPasRISCVRawByteString;const aAddress:TPasRISCVUInt64):TFDTNode; overload;
                     function FindNodeAny(const aName:TPasRISCVRawByteString):TFDTNode;
                     function GetNewPHandle:TPasRISCVUInt32;
                     function GetPHandle:TPasRISCVUInt32;
                     function AddProperty(const aName:TPasRISCVRawByteString;const aData;const aSize:TPasRISCVUInt32):TPasRISCV.TFDT.TFDTProperty;
                     function AddPropertyU32(const aName:TPasRISCVRawByteString;const aValue:TPasRISCVUInt32):TFDTProperty;
                     function AddPropertyU64(const aName:TPasRISCVRawByteString;const aValue:TPasRISCVUInt64):TFDTProperty;
                     function AddPropertyCells(const aName:TPasRISCVRawByteString;const aCells:PPasRISCVUInt32;const aCountCells:TPasRISCVSizeInt):TFDTProperty;
                     function AddPropertyString(const aName,aValue:TPasRISCVRawByteString):TFDTProperty;
                     function AddPropertyReg(const aName:TPasRISCVRawByteString;const aBegin,aSize:TPasRISCVUInt64):TFDTProperty;
                     function DeleteProperty(const aName:TPasRISCVRawByteString):Boolean;
                     function FindProperty(const aName:TPasRISCVRawByteString):TFDTProperty;
                     procedure GetTreeSize(var aSize:TFDTSizeDescriptor);
                     procedure SerializeToStream(const aFDT:TFDT);
                    public
                     property Name:TPasRISCVRawByteString read fName write fName;
                     property Parent:TFDTNode read fParent write fParent;
                     property Properties:TFDTProperties read fProperties write fProperties;
                     property Nodes:TFDTNodes read fNodes write fNodes;
                     property PHandle:TPasRISCVUInt32 read fPHandle write fPHandle;
                   end;
             private
              fRoot:TFDTNode;
              fMemoryStream:TMemoryStream;
              fBufferSize:TPasRISCVUInt32;
              fStructOffset:TPasRISCVUInt32;
              fStringsBegin:TPasRISCVUInt32;
              fStringsOffset:TPasRISCVUInt32;
              fReservedOffset:TPasRISCVUInt32;
              fPHandleCounter:TPasRISCVUInt32;
              procedure WriteBigEndian32(const aValue:TPasRISCVUInt32);
             public
              constructor Create; reintroduce;
              destructor Destroy; override;
              class function NameWithAddr(const aName:TPasRISCVRawByteString;const aAddress:TPasRISCVUInt64):TPasRISCVRawByteString; static;
              class function IsIllegalPHandle(const aPHandle:TPasRISCVUInt32):Boolean; static;
              function GetTreeSize:TFDTSizeDescriptor;
              procedure SerializeToStream(const aStream:TStream);
             public
              property Root:TFDTNode read fRoot;
            end;
            { TSoundIO }
            TSoundIO=class
             public
              type TOnOutputFillBuffer=procedure(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt) of object;
                   TOnInputFillBuffer=procedure(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt) of object;
             private
              fMachine:TPasRISCV;
              fSampleRate:TPasRISCVUInt64;
              fOnOutputFillBuffer:TOnOutputFillBuffer;
              fOnInputFillBuffer:TOnInputFillBuffer;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce; virtual;
              destructor Destroy; override;
              procedure OutputFillBuffer(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt); virtual;
              procedure InputFillBuffer(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt); virtual;
              procedure OutputAudioFillBufferCallback(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
              procedure InputAudioFillBufferCallback(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
             public
              property Machine:TPasRISCV read fMachine;
              property SampleRate:TPasRISCVUInt64 read fSampleRate write fSampleRate;
              property OnOutputFillBuffer:TOnOutputFillBuffer read fOnOutputFillBuffer write fOnOutputFillBuffer;
              property OnInputFillBuffer:TOnInputFillBuffer read fOnInputFillBuffer write fOnInputFillBuffer;
            end;
            TBusDevice=class;
            TBusDeviceArray=array of TBusDevice;
            { TBusDevice }
            TBusDevice=class
             private
              fMachine:TPasRISCV;
              fBase:TPasRISCVUInt64;
              fSize:TPasRISCVUInt64;
              fPHandle:TPasRISCVUInt32;
              fUnalignedAccessSupport:Boolean;
              fMinOpSize:TPasRISCVUInt64;
              fMaxOpSize:TPasRISCVUInt64;
              fSubBusDevices:TBusDeviceArray;
              fCountSubBusDevices:TPasRISCVUInt64;
              procedure SetBase(const aValue:TPasRISCVUInt64);
              procedure SetSize(const aValue:TPasRISCVUInt64); virtual;
              procedure SetEnd(const aValue:TPasRISCVUInt64);
             public
              constructor Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64); reintroduce; virtual;
              destructor Destroy; override;
              procedure AddSubBusDevice(const aSubBusDevice:TBusDevice);
              procedure RemoveSubBusDevice(const aSubBusDevice:TBusDevice);
              function FindSubBusDevice(const aAddress:TPasRISCVUInt64):TPasRISCV.TBusDevice;
              procedure Reset; virtual;
              function GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer; virtual;
              function GetGlobalDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; virtual;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); virtual;
              procedure Step; virtual;
             public
              property Machine:TPasRISCV read fMachine;
              property Base:TPasRISCVUInt64 read fBase write SetBase;
              property Size:TPasRISCVUInt64 read fSize write SetSize;
              property PHandle:TPasRISCVUInt32 read fPHandle;
              property UnalignedAccessSupport:Boolean read fUnalignedAccessSupport write fUnalignedAccessSupport;
              property MinOpSize:TPasRISCVUInt64 read fMinOpSize write fMinOpSize;
              property MaxOpSize:TPasRISCVUInt64 read fMaxOpSize write fMaxOpSize;
            end;
            { TInterrupts }
            TInterrupts=class
             public
              const CountIRQs=1024;
                    NoIRQ=TPasRISCVUInt32($ffffffff);
              type TIRQBitmap=array[0..(CountIRQs+$1f) shr 5] of TPasRISCVUInt32;
             private
              fMachine:TPasRISCV;
              fIRQAllocationBitmap:TIRQBitmap;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function AllocateIRQ:TPasRISCVUInt32;
              function AcquireIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
              function ReleaseIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
              function SendIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
              function RaiseIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
              function LowerIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
            end;
            { TACLINTDevice }
            TACLINTDevice=class(TBusDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($2000000);
                    DefaultSize=TPasRISCVUInt64($10000);
                    MSIPAddress=0;
                    MTimeCmpAddress=$4000;
                    MTimeCmpAddressSize=$8000;
                    MTimeAddress=$bff8;
                    SSIPAddress=$c000;
              type { TCLINTMTimerSubDevice } // for own MMIO sub-region with other minimum and maximum operation sizes, so it calls just the parent class methods for Load and Store
                   TCLINTMTimerSubDevice=class(TBusDevice)
                    private
                     fACLINTDevice:TACLINTDevice;
                    public
                     constructor Create(const aACLINTDevice:TACLINTDevice); reintroduce;
                     destructor Destroy; override;
                     function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
                     procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
                   end;
             private
              fCLINTMTimerSubDevice:TCLINTMTimerSubDevice;
              fStartTime:TPasRISCVUInt64;
              function GetTime:TPasRISCVUInt64;
              function GetCachedTime(var aTime:TPasRISCVUInt64):TPasRISCVUInt64;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TIMSICDevice }
            TIMSICDevice=class(TBusDevice)
             public
              const DefaultBaseAddressMachine=TPasRISCVUInt64($24000000);
                    DefaultBaseAddressSupervisor=TPasRISCVUInt64($28000000);
                    DefaultSizePerHART=TPasRISCVUInt64($4000);
             private
              fAIARegFileMode:TAIARegFileMode;
             public
              constructor Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64;const aAIARegFileMode:TPasRISCV.TAIARegFileMode); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TINTCDevice }
            TINTCDevice=class(TBusDevice)
             public
              function SendIRQ(const aIRQ:TPasRISCVUInt32):Boolean; virtual; abstract;
              function RaiseIRQ(const aIRQ:TPasRISCVUInt32):Boolean; virtual; abstract;
              function LowerIRQ(const aIRQ:TPasRISCVUInt32):Boolean; virtual; abstract;
            end;
            { TAPLICDevice }
            TAPLICDevice=class(TINTCDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($0cfffffc);
                    DefaultSize=TPasRISCVUInt64($0);
                    DefaultDomainBaseAddressMachine=TPasRISCVUInt64($0c000000);
                    DefaultDomainBaseAddressSupervisor=TPasRISCVUInt64($0d000000);
                    DefaultDomainSize=TPasRISCVUInt64($4000);
                    APLIC_REGION_SIZE=$4000;
                    APLIC_REG_DOMAINCFG=$0000;
                    APLIC_REG_SOURCECFG_1=$0004;
                    APLIC_REG_SOURCECFG_1023=$0ffc;
                    APLIC_REG_MMSIADDRCFG=$1bc0;
                    APLIC_REG_MMSIADDRCFGH=$1bc4;
                    APLIC_REG_SMSIADDRCFG=$1bc8;
                    APLIC_REG_SMSIADDRCFGH=$1bcc;
                    APLIC_REG_SETIP_0=$1c00;
                    APLIC_REG_SETIP_31=$1c7c;
                    APLIC_REG_SETIPNUM=$1cdc;
                    APLIC_REG_IN_CLRIP_0=$1d00;
                    APLIC_REG_IN_CLRIP_31=$1d7c;
                    APLIC_REG_CLRIPNUM=$1ddc;
                    APLIC_REG_SETIE_0=$1e00;
                    APLIC_REG_SETIE_31=$1e7c;
                    APLIC_REG_SETIENUM=$1edc;
                    APLIC_REG_CLRIE_0=$1f00;
                    APLIC_REG_CLRIE_31=$1f7c;
                    APLIC_REG_CLRIENUM=$1fdc;
                    APLIC_REG_SETIPNUM_LE=$2000;
                    APLIC_REG_SETIPNUM_BE=$2004;
                    APLIC_REG_GENMSI=$3000;
                    APLIC_REG_TARGET_1=$3004;
                    APLIC_REG_TARGET_1023=$3ffc;
                    APLIC_DOMAINCFG_BE=1;
                    APLIC_DOMAINCFG_DM=4;
                    APLIC_DOMAINCFG_IE=256;
                    APLIC_DOMAINCFG=$80000004;
                    APLIC_SOURCECFG_DELEGATE=$400;
                    APLIC_SOURCECFG_INACTIVE=$0;
                    APLIC_SOURCECFG_DETACHED=$1;
                    APLIC_SOURCECFG_EDGE_RISE=$4;
                    APLIC_SOURCECFG_EDGE_FALL=$5;
                    APLIC_SOURCECFG_LVL_HIGH=$6;
                    APLIC_SOURCECFG_LVL_LOW=$7;
                    APLIC_SOURCECFG_MASK=$7;
                    APLIC_MSIADDRCFGH_L=TPasRISCVUInt32($80000000);
                    APLIC_SRC_LIMIT=64;
                    APLIC_SRC_REGS=APLIC_SRC_LIMIT shr 5;
              type TDomainDevice=class(TBusDevice)
                    private
                     fAPLICDevice:TAPLICDevice;
                     fAIARegFileMode:TPasRISCV.TAIARegFileMode;
                     fDelegationInvert:TPasRISCVUInt32;
                     fRootDomain:Boolean;
                     function ValidBits(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
                     function ValidSrc(const aSrc:TPasRISCVUInt64):Boolean;
                     function UngatedSrc(const aSrc:TPasRISCVUInt64):Boolean;
                     function ReadIP(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
                     function ReadIN(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
                     function ReadIE(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
                     procedure SetIPNum(const aSrc:TPasRISCVUInt64);
                     procedure SetIP(const aReg:TPasRISCVUInt64;const aBits:TPasRISCVUInt32);
                     procedure ClearIP(const aReg:TPasRISCVUInt64;const aBits:TPasRISCVUInt32);
                     procedure ClearIPNum(const aSrc:TPasRISCVUInt64);
                     procedure SetIE(const aReg:TPasRISCVUInt64;const aBits:TPasRISCVUInt32);
                     procedure SetIENum(const aSrc:TPasRISCVUInt64);
                     procedure ClearIE(const aReg:TPasRISCVUInt64;const aBits:TPasRISCVUInt32);
                     procedure ClearIENum(const aSrc:TPasRISCVUInt64);
                    public
                     constructor Create(const aAPLICDevice:TAPLICDevice;const aBase,aSize:TPasRISCVUInt64;const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aRootDomain:Boolean); reintroduce;
                     destructor Destroy; override;
                     procedure Reset; override;
                     function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
                     procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
                   end;
                   TDomainDevices=array[TPasRISCV.TAIARegFileMode] of TDomainDevice;
                   TDomainCfg=array[TPasRISCV.TAIARegFileMode] of TPasRISCVUInt32;
                   TDeviceRegisters=array[0..APLIC_SRC_REGS-1] of TPasRISCVUInt32;
                   TSources=array[0..APLIC_SRC_LIMIT-1] of TPasRISCVUInt32;
             private
              fDomainDevices:TDomainDevices;
              fDomainCfg:TDomainCfg;
              fDelegated:TDeviceRegisters;
              fRaised:TDeviceRegisters;
              fInvert:TDeviceRegisters;
              fPending:TDeviceRegisters;
              fEnabled:TDeviceRegisters;
              fSource:TSources;
              fTarget:TSources;
              procedure GenerateMSI(const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aTarget:TPasRISCVUInt32);
              function RectifiedBits(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
              function RectifiedSrc(const aSrc:TPasRISCVUInt64):Boolean;
              function DetachedSrc(const aSrc:TPasRISCVUInt64):Boolean;
              procedure NotifyInterrupt(const aSrc:TPasRISCVUInt64);
              procedure EdgeInterrupt(const aSrc:TPasRISCVUInt64);
              procedure UpdateInterrupt(const aSrc:TPasRISCVUInt64);
             public
              function SendIRQ(const aIRQ:TPasRISCVUInt32):Boolean; override;
              function RaiseIRQ(const aIRQ:TPasRISCVUInt32):Boolean; override;
              function LowerIRQ(const aIRQ:TPasRISCVUInt32):Boolean; override;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            TFrameBufferDevice=class;
            { TPLICDevice }
            TPLICDevice=class(TINTCDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($0c000000);
                    DefaultSize=TPasRISCVUInt64($208000);
                    SourcePriorityAddress=0;
                    SourcePriorityEndAddress=$fff;
                    PendingAddress=$1000;
                    PendingEndAddress=$107f;
                    EnableAddress=$2000;
                    EnableEndAddress=$1f1fff;
                    ThresholdClaimAddress=$200000;
                    ThresholdClaimEndAddress=$3ffffff;
                    ContextOffset=$1000;
                    ContentMask=$fff;
                    ContentShift=12;
                    PriorityMask=1023;
                    CTXFLAG_THRESHOLD=0;
                    CTXFLAG_COMPLETE=1;
                    PLIC_SOURCE_MAX=1024;
                    PLIC_SRC_REG_COUNT=(PLIC_SOURCE_MAX+$1f) shr 5;
                    PLIC_CONTEXT_MAX=15872;
             private
              fAllocationIRQCounter:TPasRISCVUInt32;
              fCountContexts:TPasRISCVUInt32;
              fPriority:array[0..PLIC_SOURCE_MAX-1] of TPasRISCVUInt32;
              fPending:array[0..PLIC_SRC_REG_COUNT-1] of TPasRISCVUInt32;
              fRaised:array[0..PLIC_SRC_REG_COUNT-1] of TPasRISCVUInt32;
              fEnable:array[0..PLIC_CONTEXT_MAX-1] of array[0..PLIC_SRC_REG_COUNT-1] of TPasRISCVUInt32;
              fThreshold:array[0..PLIC_CONTEXT_MAX-1] of TPasRISCVUInt32;
              function IsIRQPending(const aIRQ:TPasRISCVUInt32):Boolean;
              function IsIRQEnabled(const aContext,aIRQ:TPasRISCVUInt32):Boolean;
              function NotifyContextIRQ(const aContext,aIRQ:TPasRISCVUInt32):Boolean;
              function NotifyIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
              procedure UpdateIRQ(const aIRQ:TPasRISCVUInt32);
              procedure UpdateContextIRQRegister(const aContext,aRegister:TPasRISCVUInt32);
              function UpdateContext(const aContext:TPasRISCVUInt32;const aClaim:Boolean):TPasRISCVUInt32;
              procedure FullUpdate;
              procedure SetIRQPriority(const aIRQ,aPriority:TPasRISCVUInt32);
              procedure SetEnableBits(const aContext,aRegister,aEnable:TPasRISCVUInt32);
              procedure SetContextThreshold(const aContext,aThreshold:TPasRISCVUInt32);
              function ClaimIRQ(const aContext:TPasRISCVUInt32):TPasRISCVUInt32;
              procedure CompleteIRQ(const aContext,aIRQ:TPasRISCVUInt32);
              function AllocateIRQ:TPasRISCVUInt32;
             public
              function SendIRQ(const aIRQ:TPasRISCVUInt32):Boolean; override;
              function RaiseIRQ(const aIRQ:TPasRISCVUInt32):Boolean; override;
              function LowerIRQ(const aIRQ:TPasRISCVUInt32):Boolean; override;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TSYSCONDevice }
            TSYSCONDevice=class(TBusDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($11100000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    PowerOffValue=TPasRISCVUInt64($5555);
                    RebootValue=TPasRISCVUInt64($7777);
             private
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TMemoryDevice }
            TMemoryDevice=class(TBusDevice)
             public
             private
              fData:Pointer;
              fOwnData:Boolean;
              procedure SetSize(const aValue:TPasRISCVUInt64); override;
             public
              constructor Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64;const aData:Pointer=nil;const aOwnData:Boolean=false); reintroduce;
              destructor Destroy; override;
              function GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
              procedure LoadFromStream(const aStream:TStream);
              procedure LoadFromFile(const aFileName:TPasRISCVUTF8String);
              procedure SaveToStream(const aStream:TStream);
              procedure SaveToFile(const aFileName:TPasRISCVUTF8String);
             public
              property Data:Pointer read fData write fData;
              property OwnData:Boolean read fOwnData write fOwnData;
            end;
            TPCIBusDevice=class;
            TPCIDevice=class;
            TPCIFunc=class;
            { TPCIMemoryDevice }
            TPCIMemoryDevice=class(TMemoryDevice)
             public
              type TOnLoad=function(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64 of object;
                   TOnStore=procedure(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64) of object;
                   TOnGetDeviceDirectMemoryAccessPointer=function(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer of object;
             private
              fPCIBusDevice:TPCIBusDevice;
              fPCIDevice:TPCIDevice;
              fPCIFunc:TPCIFunc;
              fOnLoad:TOnLoad;
              fOnStore:TOnStore;
              fOnGetDeviceDirectMemoryAccessPointer:TOnGetDeviceDirectMemoryAccessPointer;
             public
              constructor Create(const aMachine:TPasRISCV;const aPCIDevice:TPCIDevice;const aPCIFunc:TPCIFunc;const aBase,aSize:TPasRISCVUInt64;const aOnLoad:TOnLoad;const aOnStore:TOnStore); reintroduce;
              destructor Destroy; override;
              function GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
             public
              property PCIBusDevice:TPCIBusDevice read fPCIBusDevice;
              property PCIDevice:TPCIDevice read fPCIDevice;
              property PCIFunc:TPCIFunc read fPCIFunc;
              property OnLoad:TOnLoad read fOnLoad write fOnLoad;
              property OnStore:TOnStore read fOnStore write fOnStore;
              property OnGetDeviceDirectMemoryAccessPointer:TOnGetDeviceDirectMemoryAccessPointer read fOnGetDeviceDirectMemoryAccessPointer write fOnGetDeviceDirectMemoryAccessPointer;
            end;
            TPCI=class
             public
              const PCI_REG_DEV_VEN_ID=$0;
                    PCI_REG_STATUS_CMD=$4;
                    PCI_REG_CLASS_REV=$8;
                    PCI_REG_BIST_HDR_LATENCY_CACHE=$c;
                    PCI_REG_BAR0=$10;
                    PCI_REG_BAR1=$14;
                    PCI_REG_BAR2=$18;
                    PCI_REG_BAR3=$1c;
                    PCI_REG_BAR4=$20;
                    PCI_REG_BAR5=$24;
                    PCI_REG_SSID_SVID=$2c;
                    PCI_REG_EXPANSION_ROM=$30;
                    PCI_REG_CAP_PTR=$34;
                    PCI_REG_IRQ_PIN_LINE=$3c;
                    PCI_CMD_IO_SPACE=$1;  // Accessible through IO ports
                    PCI_CMD_MEM_SPACE=$2;  // Accessible through MMIO
                    PCI_CMD_BUS_MASTER=$4;  // DMA
                    PCI_CMD_MWI_ENABLE=$10; // Memory Write and Invalidate
                    PCI_CMD_INTX_DISABLE=$400;
                    PCI_STATUS_INTX=$8;
{$ifdef NewPCI}
                    PCI_CMD_DEFAULT=PCI_CMD_IO_SPACE or PCI_CMD_MEM_SPACE or PCI_CMD_BUS_MASTER;// $17;
                    PCI_CMD_MASK=PCI_CMD_IO_SPACE or PCI_CMD_MEM_SPACE or PCI_CMD_BUS_MASTER or PCI_CMD_INTX_DISABLE;
                    PCI_STATUS_CAP=$10;
                    PCI_HEADER_PCI_PCI=$1;
                    PCI_HEADER_MULTIFUNC=$80;
                    PCI_BAR_IO_SPACE=$1;
                    PCI_BAR_64_BIT=$4;
                    PCI_BAR_PREFETCH=$8;
                    PCI_EXPANSION_ROM_ENABLED=$1;
                    PCI_CAP_LIST_OFF=$80;
                    PCI_MSI_CAP_OFF=$c0;
                    PCIE_CAP_PORT_ENDPOINT=$0;
                    PCIE_CAP_ROOT_PORT=$4;
                    PCIE_CAP_UPSTREAM_SWITCH=$5;
                    PCIE_CAP_DOWNSTREAM_SWITCH=$6;
                    PCIE_CAP_INTEGRATED_ENDPOINT=$9;
{$else}
                    PCI_CMD_DEFAULT=$17;
{$endif}
                    PCI_BUS_IRQS=4;
                    PCI_BUS_DEVS=32;
                    PCI_DEV_FUNCS=8;
                    PCI_FUNC_BARS=6;
                    PCI_IRQ_PIN_INTA=1;
                    PCI_IRQ_PIN_INTB=2;
                    PCI_IRQ_PIN_INTC=3;
                    PCI_IRQ_PIN_INTD=4;
                    PCI_BAR_ADDR_64=TPasRISCVUInt64($64646464);
                    PCI_BASE_DEFAULT_MMIO=TPasRISCVUInt64($30000000);
                    PCI_IO_DEFAULT_ADDR=TPasRISCVUInt64($03000000);
                    PCI_IO_DEFAULT_SIZE=TPasRISCVUInt64($00010000);
                    PCI_MEM32_DEFAULT_MMIO=TPasRISCVUInt64($40000000);
                    PCI_MEM32_DEFAULT_SIZE=TPasRISCVUInt64($40000000);
                    PCI_MEM64_DEFAULT_MMIO=TPasRISCVUInt64($4000000000);
                    PCI_MEM64_DEFAULT_SIZE=TPasRISCVUInt64($4000000000);
                    PCI_IRQs:array[0..PCI_BUS_IRQS-1] of TPasRISCVUInt32=($01,$02,$03,$04);
                    PCIExpressCapabilities:array[0..25] of TPasRISCVUInt32=
                     (
                      $0102c010, // [80] PCI Express (v2) Endpoint, IntMsgNum 0
                      $00008002, // DevCap: MaxPayload 512 bytes, RBE+
                      $00002050, // DevCtl: RlxdOrd+
                      $01800d02, // LnkCap: Speed 5GT/s, Width x16
                      $01020003, // LnkSta: Speed 5GT/s, Width x16
                      $00020060,
                      $00200028,
                      $00000000,
                      $00000000,
                      $00000000,
                      $00000000,
                      $00000002,
                      $00000000,
                      $00000000,
                      $00000000,
                      $00000000,
                      $0003d001, // [c0] Power Management version 3
                      $00000008, // NoSoftRst+
                      $00000000,
                      $00000000,
                      $01800005, // [d0] MSI: Enable- Count=1/1 Maskable+ 64bit+
                      $00000000, // Message Address Low
                      $00000000, // Message Address High
                      $00000000, // Message Data
                      $00000000, // Mask
                      $00000000  // Pending
                     );
            end;
            TPCIBARRegion=record
             fAddress:TPasRISCVUInt64;
             fSize:TPasRISCVUInt64;
             fIsIO:Boolean;
             fOnLoad:TPCIMemoryDevice.TOnLoad;
             fOnStore:TPCIMemoryDevice.TOnStore;
            end;
            PPCIBARRegion=^TPCIBARRegion;
            TPCIBARRegions=array[0..TPCI.PCI_FUNC_BARS-1] of TPCIBARRegion;
            TPCIBarMemoryDevices=array[0..TPCI.PCI_FUNC_BARS-1] of TPCIMemoryDevice;
            TPCIFuncDescriptor=record
             fVendorID:TPasRISCVUInt16;
             fDeviceID:TPasRISCVUInt16;
             fSubsystemVendorID:TPasRISCVUInt16;
             fSubsystemDeviceID:TPasRISCVUInt16;
             fClassCode:TPasRISCVUInt16;
             fProgIF:TPasRISCVUInt8;
             fRevisionID:TPasRISCVUInt8;
             fIRQPin:TPasRISCVUInt8;
             fBARRegions:TPCIBARRegions;
            end;
            PPCIFuncDescriptor=^TPCIFuncDescriptor;
            TPCIDevDescriptor=record
             fFunc:array[0..TPCI.PCI_DEV_FUNCS-1] of TPCIFuncDescriptor;
            end;
            PPCIDevDescriptor=^TPCIDevDescriptor;
            { TPCIFunc }
            TPCIFunc=class
             public
              fBus:TPCIBusDevice;
              fDevice:TPCIDevice;
              fStatus:TPasRISCVUInt32;
              fCommand:TPasRISCVUInt32;
              fIRQLine:TPasRISCVUInt32;
              fVendorID:TPasRISCVUInt16;
              fDeviceID:TPasRISCVUInt16;
              fSubsystemVendorID:TPasRISCVUInt16;
              fSubsystemDeviceID:TPasRISCVUInt16;
              fClassCode:TPasRISCVUInt16;
              fProgIF:TPasRISCVUInt8;
              fRevisionID:TPasRISCVUInt8;
              fBridgeIO:TPasRISCVUInt32;
              fBridgeMem:TPasRISCVUInt32;
              fIRQPin:TPasRISCVUInt8;
              fBARMemoryDevices:TPCIBarMemoryDevices;
              fBARIsIO:array[0..TPCI.PCI_FUNC_BARS-1] of Boolean;
              fExpansionROM:TPCIMemoryDevice;
             public
              constructor Create(const aBus:TPCIBusDevice;const aDevice:TPCIDevice;const aFuncDesc:TPCIFuncDescriptor);
              destructor Destroy; override;
              function IsUpperHalf(const aBarID:TPasRISCVSizeUInt):Boolean;
              function Is64Bit(const aBarID:TPasRISCVSizeUInt):Boolean;
              function GetEffectiveBar(const aBarID:TPasRISCVSizeUInt):TPCIMemoryDevice;
              function GetBARAddress(const aBARSize:TPasRISCVUInt64):TPasRISCVUInt64;
              function GetIOBARAddress(const aBARSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure SendIRQ(const aMSIID:TPasRISCVUInt32;const aRaiseIRQ:Boolean);
              procedure RaiseIRQ(const aMSIID:TPasRISCVUInt32);
              procedure LowerIRQ; overload;
              procedure LowerIRQ(const aMSIID:TPasRISCVUInt32); overload;
            end;
            TPCIHostBridgeDevice=class;
            { TPCIIODevice }
            TPCIIODevice=class(TBusDevice)
             public
              type TOnIOLoad=function(const aPort:TPasRISCVUInt16;const aSize:TPasRISCVUInt64):TPasRISCVUInt64 of object;
                   TOnIOStore=procedure(const aPort:TPasRISCVUInt16;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64) of object;
                   PIORange=^TIORange;
                   TIORange=record
                    fPort:TPasRISCVUInt16;
                    fSize:TPasRISCVUInt16;
                    fOnLoad:TOnIOLoad;
                    fOnStore:TOnIOStore;
                   end;
             private
              fRanges:array of TIORange;
              fCountRanges:TPasRISCVSizeInt;
              function FindRange(const aPort:TPasRISCVUInt16):PIORange;
             public
              constructor Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64); override;
              destructor Destroy; override;
              procedure RegisterIORange(const aPort,aSize:TPasRISCVUInt16;const aOnLoad:TOnIOLoad;const aOnStore:TOnIOStore);
              procedure UnregisterIORange(const aPort:TPasRISCVUInt16);
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TPCIBusDevice }
            TPCIBusDevice=class(TBusDevice)
             public
              const BusShift=20; // 20 for ECAM (PCIe), 16 for legacy PCI regular CAM
             private
              fIRQs:array[0..TPCI.PCI_BUS_IRQS-1] of TPasRISCVUInt32;
              fDevices:array[0..TPCI.PCI_BUS_DEVS-1] of TPCIDevice;
              fCountDevices:TPasRISCVUInt32;
              fIOAddr:TPasRISCVUInt64;
              fIOSize:TPasRISCVUInt64;
              fMemAddr:TPasRISCVUInt64;
              fMemSize:TPasRISCVUInt64;
              fBusID:TPasRISCVUInt8;
              fHostBridgeDevice:TPCIHostBridgeDevice;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              function GetFunc(const aBus,aDev,aFunc:TPasRISCVUInt32):TPCIFunc;
              class function GetIRQID(const aDeviceID,aIRQPin:TPasRISCVUInt32):TPasRISCVUInt32; static;
              class function PCIFuncIRQPinID(const aFunc:TPCIFunc):TPasRISCVUInt32; static;
              procedure AddBusDevice(const aDevice:TPCIDevice);
              procedure RemoveBusDevice(const aDevice:TPCIDevice);
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TPCIDevice }
            TPCIDevice=class
             public
             private
              fMachine:TPasRISCV;
              fBus:TPCIBusDevice;
              fDeviceID:TPasRISCVUInt16;
              fFuncs:array[0..TPCI.PCI_DEV_FUNCS-1] of TPCIFunc;
             public
              constructor Create(const aBus:TPCIBusDevice); reintroduce;
              destructor Destroy; override;
              procedure Reset; virtual;
              procedure SendIRQ(const aFuncID,aMSIID:TPasRISCVUInt32);
              procedure RaiseIRQ(const aFuncID,aMSIID:TPasRISCVUInt32);
              procedure LowerIRQ(const aFuncID:TPasRISCVUInt32);
              function GetGlobalDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
            end;
            { TPCIHostBridgeDevice }
            TPCIHostBridgeDevice=class(TPCIDevice)
             public
             private
             public
              constructor Create(const aBus:TPCIBusDevice); reintroduce;
              destructor Destroy; override;
            end;
            { TNVMeDevice }
            TNVMeDevice=class(TPCIDevice)
             public
              const Dummy=0;
{                   SSD_VendorID=$1f31; // Nextorage
                    SSD_DeviceID=$4512; // Nextorage NE1N NVMe SSD //}
                    SSD_VendorID=$144d; // Samsung Electronics Co Ltd
                    SSD_DeviceID=$a809; // NVM Express SSD Controller 980 //}
                    // Controller Registers
                    NVME_REG_CAP1=$00;  // Controller Capabilities (Low)
                    NVME_REG_CAP2=$04;  // Controller Capabilities (High)
                    NVME_REG_VS=$08;    // Version
                    NVME_REG_INTMS=$0c; // Interrupt Mask Set
                    NVME_REG_INTMC=$10; // Interrupt Mask Clear
                    NVME_REG_CC=$14;    // Controller Configuration
                    NVME_REG_CSTS=$1c;  // Controller Status
                    NVME_REG_AQA=$24;   // Admin Queue Attributes
                    NVME_REG_ASQ1=$28;  // Admin Submission Queue Base Address (Low)
                    NVME_REG_ASQ2=$2c;  // Admin Submission Queue Base Address (High)
                    NVME_REG_ACQ1=$30;  // Admin Completion Queue Base Address (Low)
                    NVME_REG_ACQ2=$34;  // Admin Completion Queue Base Address (High)
                    // Controller Capabilities
                    NVME_MQES=$ffff;   // Maximum Queue Entries Supported: 65536
                    NVME_CQR=$1;       // Contiguous Queues Required
                    NVME_TO=$A;        // Timeout: 5s
                    NVME_DSTRD=$0;     // Doorbell Stride (0 means 2-bit shift)
                    NVME_CSS=$1;       // Command Sets Supported (NVM Command Set)
                    NVME_MPMAX=$0;     // Max page size: 4K
                    NVME_IOQES=$46;    // IO Queue Entry Sizes (16b:64b)
                    NVME_CAP1_MQES=TPasRISCVUInt32($0000ffff); // Maximum Queue Entries Supported: 65536
                    NVME_CAP1_CQR=TPasRISCVUInt32($00010000);  // Contiguous Queues Required
                    NVME_CAP1_CQR0=NVME_CAP1_CQR; // Legacy alias
                    NVME_CAP1_TO=TPasRISCVUInt32($ff000000);   // Timeout: Max
                    NVME_CAP2_DSTRD=TPasRISCVUInt32($00000000);// Doorbell Stride (0 means 2-bit shift)
                    NVME_CAP2_CSS=TPasRISCVUInt32($00000020);  // Command Sets Supported (NVM Command Set)
                    NVME_VERSION=TPasRISCVUInt32($00010400);    // NVMe v1.4
                    // Controller Configuration
                    NVME_CC_EN=TPasRISCVUInt32($00000001);     // Enabled
                    NVME_CC_SHN=TPasRISCVUInt32($0000c000);    // Shutdown Notification
                    NVME_CC_IOQES=TPasRISCVUInt32($00460000);  // IO Queue Entry Sizes (16b:64b)
                    // Controller Status
                    NVME_CSTS_RDY=TPasRISCVUInt32($00000001);  // Ready
                    NVME_CSTS_SHST=TPasRISCVUInt32($00000008); // Shutdown Status
                    // Queue IDs
                    QUEUE_ADMIN=$00;          // Admin Queue ID
                    QUEUE_IO=$01;             // IO Queues starting ID
                    // Submission Queue Entry definitions
                    SQE_SIZE=$40;           // 64 bytes
                    SQE_SIZE_SHIFT=$06;
                    SQE_CDW0=$00;           // Command Dword 0 (Opcode, Fused, CID)
                    SQE_CID=$02;            // Command Identifier (offset within SQE)
                    SQE_NSID=$04;           // Namespace Identifier
                    SQE_MPTR=$10;           // Metadata Pointer
                    SQE_PRP1=$18;           // PRP Entry 1
                    SQE_PRP2=$20;           // PRP Entry 2
                    SQE_CDW10=$28;          // Command Dword 10 (Command-Specific)
                    SQE_CDW11=$2c;          // Command Dword 11 (Command-Specific)
                    SQE_CDW12=$30;          // Command Dword 12 (Command-Specific)
                    SQE_CDW13=$34;          // Command Dword 13 (Command-Specific)
                    SQE_CDW14=$38;          // Command Dword 14 (Command-Specific)
                    SQE_CDW15=$3c;          // Command Dword 15 (Command-Specific)
                    // Completion Queue Entry definitions
                    CQE_SIZE=$10;           // 16 bytes
                    CQE_SIZE_SHIFT=$04;
                    CQE_CS=$00;             // Command Specific
                    CQE_RSVD=$04;           // Reserved
                    CQE_SQHD_SQID=$08;     // SQ Head Pointer & SQ Identifier
                    CQE_CID_PB_SF=$0c;     // Command Identifier, Phase Bit, Status Field
                    CQE_PB_MASK=$10000;     // Phase Bit Mask
                    CQE_SF_SHIFT=$11;       // Status Field Shift (17)
                    // Admin Command Set
                    ADMIN_DELETE_IO_SQ=$00;  // Delete IO Submission Queue
                    ADMIN_CREATE_IO_SQ=$01;  // Create IO Submission Queue
                    ADMIN_GET_LOG_PAGE=$02;  // Get Log Page
                    ADMIN_DELETE_IO_CQ=$04;  // Delete IO Completion Queue
                    ADMIN_CREATE_IO_CQ=$05;  // Create IO Completion Queue
                    ADMIN_IDENTIFY=$06;      // Identify
                    ADMIN_ABORT=$08;         // Abort Command
                    ADMIN_SET_FEATURES=$09;  // Set Features
                    ADMIN_GET_FEATURES=$0a;  // Get Features
                    ADMIN_ASYNC_EVENT_REQ=$0c; // Asynchronous Event Request
                    ADMIN_NAMESPACE_MGMT=$0d; // Namespace Management (Optional)
                    ADMIN_FIRMWARE_COMM=$10;  // Firmware Commit (Optional)
                    ADMIN_FIRMWARE_DOWN=$11;  // Firmware Image Download (Optional)
                    ADMIN_SELF_TEST=$14;     // Device Self-Test (Optional)
                    ADMIN_NAMESPACE_ATCH=$15; // Namespace Attachment (Optional)
                    ADMIN_KEEP_ALIVE=$18;    // Keep Alive (Optional)
                    ADMIN_DIRECTIVE_SEND=$19; // Directive Send (Optional)
                    ADMIN_DIRECTIVE_RECV=$1a; // Directive Receive (Optional)
                    ADMIN_VIRT_MGMT=$1c;     // Virtualization Management (Optional)
                    ADMIN_NVME_MI_SEND=$1d;  // NVMe-MI Send (Optional)
                    ADMIN_NVME_MI_RECV=$1e;  // NVMe-MI Receive (Optional)
                    ADMIN_DBELL_BUFF_CFG=$7c; // Doorbell Buffer Config (Optional)
                    ADMIN_FORMAT_NVM=$80;    // Format NVM (Optional)
                    ADMIN_SECURITY_SEND=$81; // Security Send (Optional)
                    ADMIN_SECURITY_RECV=$82; // Security Receive (Optional)
                    ADMIN_SANITIZE=$84;      // Sanitize (Optional)
                    ADMIN_GET_LBA_STAT=$86;  // Get LBA Status (Optional)
                    // Completion Queue Flags
                    CQ_FLAGS_PC=$01;  // Physically Contiguous
                    CQ_FLAGS_IEN=$02; // Interrupts Enabled
                    // NVMe Get Log Page - Log Page Identifiers
                    LOG_ERROR=$01;           // Error Information
                    LOG_SMART=$02;           // SMART / Health Information
                    LOG_FIRMWARE_SLOT=$03;   // Firmware Slot Information
                    LOG_CHANGED_NS_LIST=$04; // Changed Namespace List (Optional)
                    LOG_CMD_SUPPORTED=$05;   // Commands Supported and Effects (Optional)
                    LOG_SELF_TEST=$06;       // Device Self-Test (Optional)
                    LOG_TELEMETRY_HOST=$07;  // Telemetry Host-Initiated (Optional)
                    LOG_TELEMETRY_CTRL=$08;  // Telemetry Controller-Initiated (Optional)
                    LOG_EGRP_INFO=$09;       // Endurance Group Information (Optional)
                    LOG_PRED_LAT_SET=$0a;    // Predictable Latency Per NVM Set (Optional)
                    LOG_PRED_LAT_AGGR=$0b;   // Predictable Latency Event Aggregate (Optional)
                    LOG_ASYMM_NS_ACCESS=$0c; // Asymmetric Namespace Access (Optional)
                    LOG_PERSIST_EVENT=$0d;   // Persistent Event Log (Optional)
                    LOG_LBA_STATUS=$0e;      // LBA Status Information (Optional)
                    LOG_EGRP_AGGR=$0f;       // Endurance Group Event Aggregate (Optional)
                    LOG_DISCOVERY=$70;       // Discovery (Optional)
                    LOG_RSV_NOTIFY=$80;      // Reservation Notification (Optional)
                    LOG_SANITIZE_STAT=$81;   // Sanitize Status (Optional)
                    // NVMe Identify - CNS Identifiers
                    IDENT_NS=$00;            // Identify Namespace
                    CNS_NAMESPACE=IDENT_NS;
                    IDENT_CTRL=$01;          // Identify Controller
                    CNS_CONTROLLER=IDENT_CTRL;
                    IDENT_NSLS=$02;          // Identify Namespace List
                    CNS_NSID_LIST=IDENT_NSLS;
                    IDENT_NIDS=$03;          // Identify Namespace Descriptors
                    CNS_NSID_DESC=IDENT_NIDS;
                    CNS_NVM_SET_LIST=$04;    // Identify NVM Set List (Optional)
                    CNS_ALLOC_NSID=$10;      // Identify Allocated Namespace ID List (Optional)
                    CNS_ALLOC_NAMESPACE=$11;  // Identify Allocated Namespace (Optional)
                    CNS_CTRL_NSID_LIST=$12;  // Identify Controller List attached to NSID (Optional)
                    CNS_CTRL_LIST=$13;       // Identify Controller List in NVM subsystem (Optional)
                    CNS_CTRL_CAPS=$14;       // Identify Primary Controller Capabilities (Optional)
                    CNS_CTRL_SECONDARY=$15;  // Identify Secondary Controller List (Optional)
                    CNS_NS_GRANULARITY=$16;  // Identify Namespace Granularity List (Optional)
                    CNS_UUID_LIST=$17;       // Identify UUID List (Optional)
                    // NVMe Get/Set Feature - Feature Identifiers
                    FEAT_ARBITRATION=$01;    // Arbitration
                    FEAT_POWER_MGMT=$02;     // Power Management
                    FEAT_LBA_RANGE=$03;      // LBA Range Type (Optional)
                    FEAT_TEMP_THRESH=$04;    // Temperature Threshold
                    FEAT_ERROR_RECOVER=$05;  // Error Recovery
                    FEAT_VOLATILE_WC=$06;    // Volatile Write Cache (Optional)
                    FEAT_NUM_QUEUES=$07;     // Number of Queues
                    FEAT_IRQ_COALESCE=$08;   // Interrupt Coalescing
                    FEAT_IRQ_VECTOR=$09;     // Interrupt Vector Configuration
                    FEAT_WR_ATOMIC=$0a;      // Write Atomicity Normal
                    FEAT_ASYNC_EVENT=$0b;    // Asynchronous Event Configuration
                    FEAT_AUTO_PWSTATE=$0c;   // Autonomous Power State Transition (Optional)
                    FEAT_HOST_MEM_BUFF=$0d;  // Host Memory Buffer (Optional)
                    FEAT_TIMESTAMP=$0e;      // Timestamp (Optional)
                    FEAT_KPALIVE_TIMER=$0f;  // Keep Alive Timer (Optional)
                    FEAT_HOST_THERMAL=$10;   // Host-Controlled Thermal Management (Optional)
                    FEAT_NONOP_PWR_CFG=$11;  // Non-Operational Power State Config (Optional)
                    FEAT_RDRECOVER_LVL=$12;  // Read Recovery Level Config (Optional)
                    FEAT_PRED_LAT_CFG=$13;   // Predictable Latency Mode Config (Optional)
                    FEAT_PRED_LAT_WIN=$14;   // Predictable Latency Mode Window (Optional)
                    FEAT_LBA_STAT_INF=$15;   // LBA Status Information Attributes (Optional)
                    FEAT_HOST_BEHAVIOR=$16;  // Host Behavior Support (Optional)
                    FEAT_SANITIZE_CFG=$17;   // Sanitize Config (Optional)
                    FEAT_EGRP_EVT_CFG=$18;   // Endurance Group Event Configuration (Optional)
                    FEAT_SW_PROGRESS=$80;    // Software Progress Marker (Optional)
                    FEAT_HOST_IDENT=$81;     // Host Identifier (Optional)
                    // NVMe IO Command Set
                    NVM_FLUSH=$00;           // Flush buffers
                    NVM_WRITE=$01;           // Write
                    NVM_READ=$02;            // Read
                    NVM_WRITE_UNC=$04;       // Write Uncorrectable (Optional)
                    NVM_COMPARE=$05;         // Compare (Optional)
                    NVM_WRITEZ=$08;          // Write Zeroes (Optional)
                    NVM_DTSM=$09;            // Dataset Management (Optional)
                    NVM_VERIFY=$0c;          // Verify (Optional)
                    NVM_RSV_REGISTER=$0d;    // Reservation Register (Optional)
                    NVM_RSV_REPORT=$0e;      // Reservation Report (Optional)
                    NVM_RSV_ACQUIRE=$11;     // Reservation Acquire (Optional)
                    NVM_RSV_RELEASE=$15;     // Reservation Release (Optional)
                    // NVMe Generic Status Codes - Admin command set
                    SC_SUCCESS=$00;          // Successful Completion
                    SC_BAD_OPCODE=$01;       // Invalid Command Opcode
                    SC_BAD_FIELD=$02;        // Invalid Field in Command
                    SC_ID_CONFLICT=$03;      // Command ID Conflict
                    SC_DATA_ERR=$04;         // Data Transfer Error
                    SC_POWER_LOSS=$05;       // Command Aborted due to Power Loss
                    SC_INTERNAL_ERR=$06;     // Internal Error
                    SC_ABORTED=$07;          // Command Abort Requested
                    SC_SQ_DELETED=$08;       // Command Aborted due to SQ Deletion
                    SC_FUSE_FAIL=$09;        // Command Aborted due to Failed Fused Command
                    SC_FUSE_MISSING=$0a;     // Command Aborted due to Missing Fused Command
                    SC_BAD_NAMESPACE=$0b;    // Invalid Namespace or Format
                    SC_SEQUENCE_ERR=$0c;     // Command Sequence Error
                    SC_BAD_SGL_DESC=$0d;     // Invalid SGL Segment Descriptor
                    SC_BAD_SGL_NUM=$0e;      // Invalid Number of SGL Descriptors
                    SC_BAD_SGL_DATA=$0f;     // Invalid Data SGL Length
                    SC_BAD_SGL_META=$10;     // Invalid Metadata SGL Length
                    SC_BAD_SGL_TYPE=$11;     // Invalid SGL Descriptor Type
                    SC_INVALID_CMB_USE=$12;  // Invalid Use of Controller Memory Buffer
                    SC_BAD_PRP_OFFSET=$13;   // Invalid PRP Offset
                    SC_ATOMIC_UNIT=$14;      // Atomic Write Unit Exceeded
                    SC_PERM_DENIED=$15;      // Operation Denied
                    SC_BAD_SGL_OFFSET=$16;   // Invalid SGL Offset
                    SC_BAD_HOST_ID=$18;      // Host Identifier Inconsistent Format
                    SC_KEEP_ALIVE=$19;       // Keep Alive Timer Expired
                    SC_BAD_TIMER=$1a;        // Keep Alive Timeout Invalid
                    SC_PREEMPTED=$1b;        // Command Aborted due to Preempt and Abort
                    SC_SANITIZE_FAIL=$1c;    // Sanitize Failed
                    SC_SANITIZE_NOW=$1d;     // Sanitize In Progress
                    SC_BAD_SGL_GRAN=$1e;     // Invalid SGL Data Block Granularity
                    SC_QUEUE_IN_CMB=$1f;     // Command Not Supported for Queue in CMB
                    SC_NAMESPACE_WP=$20;     // Namespace is Write Protected
                    SC_INTERRUPTED=$21;      // Command Interrupted
                    SC_TRANSPORT_ERR=$22;    // Transient Transport Error
                    // NVMe Generic Status Codes - IO command set
                    SC_LBA_RANGE=$80;        // LBA Out of Range
                    SC_NS_CAPACITY=$81;      // Capacity Exceeded
                    SC_NS_NOT_READY=$82;     // Namespace Not Ready
                    SC_RSV_CONFLICT=$83;     // Reservation Conflict
                    SC_FORMAT_NOW=$84;       // Format In Progress
                    // NVMe Command Specific Status Codes - Admin command set
                    SC_BAD_CQ=$0100;         // Completion Queue Invalid
                    SC_BAD_QUEUE_ID=$0101;   // Invalid Queue Identifier
                    SC_BAD_QUEUE_SIZE=$0102;  // Invalid Queue Size
                    SC_ABORT_LIMIT=$0103;    // Abort Command Limit Exceeded
                    SC_AER_LIMIT=$0105;      // Asynchronous Event Request Limit Exceeded
                    SC_BAD_FW_SLOT=$0106;    // Invalid Firmware Slot
                    SC_BAD_FW_IMG=$0107;     // Invalid Firmware Image
                    SC_BAD_IRQ_VEC=$0108;    // Invalid Interrupt Vector
                    SC_BAD_LOG_PAGE=$0109;   // Invalid Log Page
                    SC_BAD_FORMAT=$010a;     // Invalid Format
                    SC_FW_NEED_RST=$010b;    // Firmware Activation Requires Conventional Reset
                    SC_BAD_QUEUE_DEL=$010c;  // Invalid Queue Deletion
                    SC_FEAT_NOT_SAVEBL=$010d; // Feature Identifier Not Saveable
                    SC_FEAT_NOT_CHGBL=$010e;  // Feature Not Changeable
                    SC_FEAT_NOT_NS=$010f;    // Feature Not Namespace Specific
                    SC_FW_NEED_NRST=$0110;   // Firmware Activation Requires NVM Subsystem Reset
                    SC_FW_NEED_CRST=$0111;   // Firmware Activation Requires Controller Level Reset
                    SC_FW_NEED_MTO=$0112;    // Firmware Activation Requires Maximum Time Violation
                    SC_FW_PROHIBIT=$0113;    // Firmware Activation Prohibited
                    SC_OVERLAP_RANGE=$0114;  // Overlapping Range
                    SC_NS_NO_CAPACITY=$0115; // Namespace Insufficient Capacity
                    SC_NS_ID_UNAVAIL=$0116;  // Namespace Identifier Unavailable
                    SC_NS_ATTACHED=$0118;    // Namespace Already Attached
                    SC_NS_PRIVATE=$0119;     // Namespace Is Private
                    SC_NS_NATTACHED=$011a;   // Namespace Not Attached
                    SC_THIN_PROV_SUPP=$011b; // Thin Provisioning Not Supported
                    SC_BAD_CTRL_LIST=$011c;  // Controller List Invalid
                    SC_SELF_TEST=$011d;      // Device Self-test In Progress
                    SC_BOOT_PART_WP=$011e;   // Boot Partition Write Prohibited
                    SC_BAD_CTRL_ID=$011f;    // Invalid Controller Identifier
                    SC_BAD_CTRL_SEC=$0120;   // Invalid Secondary Controller State
                    SC_BAD_CTRL_RES=$0121;   // Invalid Number of Controller Resources
                    SC_BAD_RES_ID=$0122;     // Invalid Resource Identifier
                    SC_SANITIZE_PMR=$0123;   // Sanitize Prohibited While PMR Enabled
                    SC_ANA_GROUP_ID=$0124;   // ANA Group Identifier Invalid
                    SC_ANA_ATTACH=$0125;     // ANA Attach Failed
                    // NVMe Command Specific Status Codes - IO command set
                    SC_BAD_ATTRS=$0180;      // Conflicting Attributes
                    SC_BAD_PROT=$0181;       // Invalid Protection Information
                    SC_READONLY=$0182;       // Attempted Write to Read Only Range
                    // Implementation constants
                    NVME_PAGE_SHIFT=$0c;     // 4KB Page Shift
                    NVME_LBAS=$09;           // LBA Block Size Shift (512b blocks) - legacy alias
                    NVME_LBA_SHIFT=NVME_LBAS;
                    NVME_IO_QUEUES=$10;     // Max IO Queues (16)
                    NVME_PAGE_SIZE=TPasRISCVUInt64(TPasRISCVUInt64(1) shl NVME_PAGE_SHIFT);
                    NVME_PAGE_MASK=TPasRISCVUInt64(NVME_PAGE_SIZE-1);
                    NVME_PRP2_END=TPasRISCVUInt64($ff8);
                    NVME_LBA_SIZE=TPasRISCVUInt64(TPasRISCVUInt64(1) shl NVME_LBA_SHIFT);
                    NVME_LBA_MASK=TPasRISCVUInt64(NVME_LBA_SIZE-1);
              type TNVMeQueueData=record
                    case boolean of
                     false:(CompletionQueueID:TPasRISCVUInt32); // Used by Submission Queues
                     true:(IRQ:TPasRISCVUInt32);                // Used by Completion Queues
                   end;
                   TNVMeQueue=record
                    public
                     AddressLow:TPasRISCVUInt32;
                     AddressHigh:TPasRISCVUInt32;
                     Size:TPasRISCVUInt32;
                     Head:TPasRISCVUInt32;
                     Tail:TPasRISCVUInt32;
                     Phase:TPasRISCVUInt32;
                     Data:TNVMeQueueData;
                     class function Dequeue(var aQueue:TNVMeQueue;out aEntry:TPasRISCVUInt32):Boolean; static;
                     class function Enqueue(var aQueue:TNVMeQueue):TPasRISCVUInt32; static;
                     function GetAddress:TPasRISCVUInt64;
                     function GetSize:TPasRISCVUInt32;
                     procedure RaiseIRQ(const aNVMEDevice:TNVMEDevice);
                     procedure LowerIRQ(const aNVMEDevice:TNVMEDevice);
                     procedure Reset;
                     procedure Setup(const aNVMEDevice:TNVMEDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt32;const aData:TPasRISCVUInt32);
                   end;
                   PNVMeQueue=^TNVMeQueue;
                   TNVMePRPCtx=record
                    PRP1:TPasRISCVUInt64;
                    PRP2:TPasRISCVUInt64;
                    Size:TPasRISCVUInt64;
                    Current:TPasRISCVUInt64;
                   end;
                   PNVMePRPCtx=^TNVMePRPCtx;
                   TNVMeCommand=record
                    Ptr:Pointer;
                    PRP:TNVMePRPCtx;
                    SqHeadID:TPasRISCVUInt32;
                    CompletionQueueID:TPasRISCVUInt32;
                   end;
                   PNVMeCommand=^TNVMeCommand;
             private
              fThreads:TPasRISCVUInt32;
              fConf:TPasRISCVUInt32;
              fIRQMask:TPasRISCVUInt32;
              fTempThresh:TPasRISCVUInt32;
              fSerial:array[0..11] of TPasRISCVRawByteChar;
              fSubmissionQueues:array[0..NVME_IO_QUEUES] of TNVMeQueue;
              fCompletionQueues:array[0..NVME_IO_QUEUES] of TNVMeQueue;
              fStreamLock:TPasMPSlimReaderWriterLock;
              fStream:TStream;
             public
              constructor Create(const aBus:TPCIBusDevice); reintroduce;
              destructor Destroy; override;
              procedure ResetDevice;
              function GetSubmissionQueue(const aQueueID:TPasRISCVUInt32):PNVMeQueue;
              function GetCompletionQueue(const aQueueID:TPasRISCVUInt32):PNVMeQueue;
              procedure CompleteCommand(const aCommand:PNVMeCommand;const aStatus:TPasRISCVUInt32;const aCommandSpecific:TPasRISCVUInt32=0);
              procedure PreparePRP(const aCommand:PNVMeCommand;const aSize:TPasRISCVUInt64);
              function PRPAvail(const aCommand:PNVMeCommand):TPasRISCVUInt64;
              function ParsePRPRegion(const aCommand:PNVMeCommand):TPasRISCVUInt64;
              function GetPRPRegion(const aCommand:PNVMeCommand;out aSize:TPasRISCVUInt64):Pointer;
              procedure CopyToPRP(const aCommand:PNVMeCommand;const aData:Pointer;const aSize:TPasRISCVUInt64);
              procedure Identify(const aCommand:PNVMeCommand);
              procedure CreateIOSubmissionQueue(const aCommand:PNVMeCommand);
              procedure CreateIOCompletionQueue(const aCommand:PNVMeCommand);
              procedure DeleteIOQueue(const aCommand:PNVMeCommand;const aIsCompletionQueue:Boolean);
              procedure HandleFeature(const aCommand:PNVMeCommand;const aSet:Boolean);
              procedure GetLogPage(const aCommand:PNVMeCommand);
              procedure AdminCommand(const aCommand:PNVMeCommand);
              procedure IOCommand(const aCommand:PNVMeCommand);
              procedure ProcessCommand(const aCommand:TNVMeDeviceCommand);
              procedure ProcessQueue(const aSubmissionQueueID:TPasRISCVUInt32;const aValue:TPasRISCVUInt16;const aLocking:Boolean);
              procedure Doorbell(const aQueueID:TPasRISCVUInt32;const aValue:TPasRISCVUInt16);
              procedure CheckMaskedIRQs(const aMask:TPasRISCVUInt32);
              function OnLoad(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure OnStore(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
              procedure AttachStream(const aStream:TStream);
              procedure LoadFromStream(const aStream:TStream);
              procedure LoadFromFile(const aFileName:TPasRISCVUTF8String);
              procedure SaveToStream(const aStream:TStream);
              procedure SaveToFile(const aFileName:TPasRISCVUTF8String);
            end;
            { TIVSHMEMDevice }
            TIVSHMEMDevice=class(TPCIDevice)
             public
              const IVSHMEM_VENDOR_ID=$1af4; // Red Hat, Inc.
                    IVSHMEM_DEVICE_ID=$1110; // Inter-VM shared memory (ivshmem)
                    IVSHMEM_CLASS_CODE=$0580; // Memory controller, Other
                    IVSHMEM_REVISION=$01;
                    IVSHMEM_REG_INTMASK=$00;   // Interrupt Mask
                    IVSHMEM_REG_INTSTATUS=$04; // Interrupt Status
                    IVSHMEM_REG_IVPOSITION=$08; // IV Position
                    IVSHMEM_REG_DOORBELL=$0c;  // Doorbell
                    IVSHMEM_REG_SHM_SIZE_LO=$10; // Shared Memory Size Low
                    IVSHMEM_REG_SHM_SIZE_HI=$14; // Shared Memory Size High
                    IVSHMEM_BAR0_SIZE=$100; // 256 bytes for device registers
                    IVSHMEM_DEFAULT_SHM_SIZE=$100000; // 1 MB default shared memory size
              type TOnDoorbell=procedure(const aSender:TIVSHMEMDevice;const aValue:TPasRISCVUInt32) of object;
             private
              fIntMask:TPasRISCVUInt32;
              fIntStatus:TPasRISCVUInt32;
              fIVPosition:TPasRISCVUInt32;
              fSharedMemorySize:TPasRISCVUInt64;
              fSharedMemoryPointer:Pointer;
              fOnDoorbell:TOnDoorbell;
             public
              constructor Create(const aBus:TPCIBusDevice;const aSharedMemorySize:TPasRISCVUInt64=IVSHMEM_DEFAULT_SHM_SIZE); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              function OnLoad(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure OnStore(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
              procedure RingDoorbell;
             public
              property SharedMemory:Pointer read fSharedMemoryPointer;
             published
              property SharedMemorySize:TPasRISCVUInt64 read fSharedMemorySize;
              property OnDoorbellEvent:TOnDoorbell read fOnDoorbell write fOnDoorbell;
            end;
            { TBochsVBEDevice }
            TBochsVBEDevice=class(TPCIDevice)
             public
              const BOCHS_VBE_VENDOR_ID=$1234;
                    BOCHS_VBE_DEVICE_ID=$1111;
                    BOCHS_VBE_CLASS_CODE=$0300; // VGA compatible controller
                    BOCHS_VBE_REVISION=$02;
                    // BAR2 MMIO sub-region offsets (matching QEMU layout)
                    MMIO_EDID_BASE=$000;   // EDID data region
                    MMIO_EDID_SIZE=$100;
                    MMIO_VGA_BASE=$400;    // VGA registers
                    MMIO_VGA_SIZE=$100;
                    MMIO_VBE_BASE=$500;    // VBE DISPI registers (bochs.h: MMIO_BASE=0x500)
                    MMIO_VBE_SIZE=$020;
                    MMIO_QEXT_BASE=$600;   // QEMU extension registers
                    MMIO_QEXT_SIZE=$008;
                    // VBE DISPI registers (relative to MMIO_VBE_BASE, 16-bit each)
                    VBE_DISPI_INDEX_ID=$00;
                    VBE_DISPI_INDEX_XRES=$02;
                    VBE_DISPI_INDEX_YRES=$04;
                    VBE_DISPI_INDEX_BPP=$06;
                    VBE_DISPI_INDEX_ENABLE=$08;
                    VBE_DISPI_INDEX_BANK=$0a;
                    VBE_DISPI_INDEX_VIRT_WIDTH=$0c;
                    VBE_DISPI_INDEX_VIRT_HEIGHT=$0e;
                    VBE_DISPI_INDEX_X_OFFSET=$10;
                    VBE_DISPI_INDEX_Y_OFFSET=$12;
                    VBE_DISPI_INDEX_VIDEO_MEMORY_64K=$14;
                    // DISPI ID values
                    VBE_DISPI_ID0=$b0c0;
                    VBE_DISPI_ID1=$b0c1;
                    VBE_DISPI_ID2=$b0c2;
                    VBE_DISPI_ID3=$b0c3;
                    VBE_DISPI_ID4=$b0c4;
                    VBE_DISPI_ID5=$b0c5;
                    // Enable flags
                    VBE_DISPI_ENABLED=$01;
                    VBE_DISPI_GETCAPS=$02;
                    VBE_DISPI_8BIT_DAC=$20;
                    VBE_DISPI_LFB_ENABLED=$40;
                    VBE_DISPI_NOCLEARMEM=$80;
                    // Sizes
                    VBE_DISPI_MAX_XRES=2560;
                    VBE_DISPI_MAX_YRES=1600;
                    VBE_DISPI_MAX_BPP=32;
                    // BAR sizes
                    BOCHS_VBE_BAR0_SIZE=TPasRISCVUInt64(16*1024*1024); // 16MB framebuffer
                    BOCHS_VBE_BAR2_SIZE=TPasRISCVUInt64($1000);        // 4KB MMIO (EDID+VGA+VBE DISPI+QEXT)
                    // QEMU extension register offsets (relative to MMIO_QEXT_BASE)
                    PCI_VGA_QEXT_REG_SIZE=$00;
                    PCI_VGA_QEXT_REG_BYTEORDER=$04;
                    PCI_VGA_QEXT_SIZE=$08;
                    PCI_VGA_QEXT_LITTLE_ENDIAN=$1e1e1e1e;
                    PCI_VGA_QEXT_BIG_ENDIAN=$1e1e1e1f;
                    // VGA Attribute register
                    VGA_AR_ENABLE_DISPLAY=$20;
             private
              fFrameBuffer:TFrameBufferDevice;
              fVBEEnable:TPasRISCVUInt16;
              fVBEXRes:TPasRISCVUInt16;
              fVBEYRes:TPasRISCVUInt16;
              fVBEBPP:TPasRISCVUInt16;
              fVBEBank:TPasRISCVUInt16;
              fVBEVirtWidth:TPasRISCVUInt16;
              fVBEVirtHeight:TPasRISCVUInt16;
              fVBEXOffset:TPasRISCVUInt16;
              fVBEYOffset:TPasRISCVUInt16;
              procedure ApplyVideoMode;
             public
              constructor Create(const aBus:TPCIBusDevice;const aFrameBuffer:TFrameBufferDevice); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              function OnFBLoad(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure OnFBStore(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
              function OnFBGetDeviceDirectMemoryAccessPointer(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
              function OnVBELoad(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure OnVBEStore(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
             public
              property FrameBuffer:TFrameBufferDevice read fFrameBuffer;
            end;
            { TCirrusDevice }
            TCirrusDevice=class(TPCIDevice)
             public
              const CIRRUS_VENDOR_ID=$1013;
                    CIRRUS_DEVICE_ID=$00b8; // GD 5446
                    CIRRUS_SUBVENDOR_ID=$1af4; // Red Hat / QUMRANET
                    CIRRUS_SUBDEVICE_ID=$1100; // QEMU
                    CIRRUS_CLASS_CODE=$0300; // VGA compatible controller
                    CIRRUS_REVISION=$01;
                    // VRAM size
                    CIRRUS_VRAM_SIZE=TPasRISCVUInt64(4*1024*1024); // 4MB
                    // MMIO size
                    CIRRUS_MMIO_SIZE=TPasRISCVUInt64($1000); // 4KB
                    // MMIO register offsets (as used by the Linux driver)
                    SEQ_INDEX=$04;
                    SEQ_DATA=$05;
                    CRT_INDEX=$14;
                    CRT_DATA=$15;
                    GFX_INDEX=$0e;
                    GFX_DATA=$0f;
                    VGA_DAC_MASK=$06;
                    // Max pitch
                    CIRRUS_MAX_PITCH=(($1ff shl 3)); // (4096-1) & ~7
             private
              fFrameBuffer:TFrameBufferDevice;
              // Sequencer registers
              fSEQIndex:TPasRISCVUInt8;
              fSEQRegs:array[0..255] of TPasRISCVUInt8;
              // CRT controller registers
              fCRTIndex:TPasRISCVUInt8;
              fCRTRegs:array[0..255] of TPasRISCVUInt8;
              // Graphics controller registers
              fGFXIndex:TPasRISCVUInt8;
              fGFXRegs:array[0..255] of TPasRISCVUInt8;
              // Hidden DAC register
              fHDRReadCount:TPasRISCVUInt32;
              fHDR:TPasRISCVUInt8;
              // Derived state
              fWidth:TPasRISCVUInt32;
              fHeight:TPasRISCVUInt32;
              fBPP:TPasRISCVUInt32;
              fPitch:TPasRISCVUInt32;
              fStartAddress:TPasRISCVUInt32;
              fModeActive:Boolean;
              procedure UpdateDerivedState;
             public
              constructor Create(const aBus:TPCIBusDevice;const aFrameBuffer:TFrameBufferDevice); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              function OnFBLoad(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure OnFBStore(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
              function OnFBGetDeviceDirectMemoryAccessPointer(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
              function OnMMIOLoad(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure OnMMIOStore(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
              function OnVGAIOLoad(const aPort:TPasRISCVUInt16;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure OnVGAIOStore(const aPort:TPasRISCVUInt16;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
              procedure RegisterVGAIO;
             public
              property FrameBuffer:TFrameBufferDevice read fFrameBuffer;
            end;
            { TFM801Device }
            TFM801Device=class(TPCIDevice)
             public
              const FM801_VENDOR_ID=TPasRISCVUInt16($1319);
                    FM801_DEVICE_ID=TPasRISCVUInt16($0801);
                    FM801_PCM_VOL=$00;
                    FM801_FM_VOL=$02;
                    FM801_I2S_VOL=$04;
                    FM801_REC_SRC=$06;
                    FM801_PLAY_CTRL=$08;
                    FM801_PLAY_COUNT=$0a;
                    FM801_PLAY_BUF1=$0c;
                    FM801_PLAY_BUF2=$10;
                    FM801_CAPTURE_CTRL=$14;
                    FM801_CAPTURE_COUNT=$16;
                    FM801_CAPTURE_BUF1=$18;
                    FM801_CAPTURE_BUF2=$1c;
                    FM801_CODEC_CTRL=$22;
                    FM801_I2S_MODE=$24;
                    FM801_VOLUME=$26;
                    FM801_AC97_CMD=$2a;
                    FM801_AC97_DATA=$2c;
                    FM801_MPU401_DATA=$30;
                    FM801_MPU401_CMD=$31;
                    FM801_GPIO_CTRL=$52;
                    FM801_GEN_CTRL=$54;
                    FM801_IRQ_MASK=$56;
                    FM801_IRQ_STATUS=$5a;
                    FM801_OPL3_BANK0=$68;
                    FM801_OPL3_DATA0=$69;
                    FM801_OPL3_BANK1=$6a;
                    FM801_OPL3_DATA1=$6b;
                    FM801_POWERDOWN=$70;
                    FM801_BAR_SIZE=$80;
                    // IRQ status bits (in IRQ_STATUS register)
                    FM801_IRQ_PLAYBACK=TPasRISCVUInt16(1 shl 8);
                    FM801_IRQ_CAPTURE=TPasRISCVUInt16(1 shl 9);
                    FM801_IRQ_VOLUME=TPasRISCVUInt16(1 shl 14);
                    FM801_IRQ_MPU=TPasRISCVUInt16(1 shl 15);
                    // IRQ mask bits (in IRQ_MASK register) - SET=disabled, CLEAR=enabled
                    FM801_IRQ_MASK_PLAYBACK=TPasRISCVUInt16(1 shl 0);
                    FM801_IRQ_MASK_CAPTURE=TPasRISCVUInt16(1 shl 1);
                    FM801_IRQ_MASK_VOLUME=TPasRISCVUInt16(1 shl 6);
                    FM801_IRQ_MASK_MPU=TPasRISCVUInt16(1 shl 7);
                    FM801_IRQ_MASK_ALL=TPasRISCVUInt16($00c3);
                    // Playback/Capture control bits
                    FM801_START=TPasRISCVUInt16(1 shl 5);
                    FM801_PAUSE=TPasRISCVUInt16(1 shl 6);
                    FM801_IMMED_STOP=TPasRISCVUInt16(1 shl 7);
                    FM801_16BIT=TPasRISCVUInt16(1 shl 14);
                    FM801_STEREO=TPasRISCVUInt16(1 shl 15);
                    FM801_RATE_SHIFT=8;
                    FM801_RATE_MASK=TPasRISCVUInt16($0f shl FM801_RATE_SHIFT);
                    FM801_BUFFER1_LAST=TPasRISCVUInt16(1 shl 1);
                    FM801_BUFFER2_LAST=TPasRISCVUInt16(1 shl 2);
                    // AC97 bits
                    FM801_AC97_READ=TPasRISCVUInt16(1 shl 7);
                    FM801_AC97_VALID=TPasRISCVUInt16(1 shl 8);
                    FM801_AC97_BUSY=TPasRISCVUInt16(1 shl 9);
                    FM801_AC97_ADDR_SHIFT=10;
              type TRateEntry=record
                    Rate:TPasRISCVUInt32;
                   end;
              const FM801_RATES:array[0..10] of TPasRISCVUInt32=
                     (5500,8000,9600,11025,16000,19200,22050,32000,38400,44100,48000);
              { TOPL3 - YMF262 OPL3 FM Synthesizer }
              type TOPL3=class
                    public
                     const OPL3_NATIVE_RATE=49716; // 14.318 MHz / 288
                           OPL3_RSM_FRAC=10;
                           OPL3_KEY_NORMAL=TPasRISCVUInt8($01);
                           OPL3_KEY_DRUM=TPasRISCVUInt8($02);
                    public
                     type TOPL3EnvelopeState=
                           (
                            Attack,
                            Decay,
                            Sustain,
                            Release
                           );
                          TOPL3ChannelType=
                           (
                            TwoOp,
                            FourOp,
                            FourOpSecondary,
                            Drum
                           );
                          POPL3Slot=^TOPL3Slot;
                          TOPL3Slot=record
                           fChannelIndex:TPasRISCVUInt8;
                           fSlotIndex:TPasRISCVUInt8;
                           fOut:TPasRISCVInt16;
                           fFeedbackMod:TPasRISCVInt16;
                           fModSource:PPasRISCVInt16;
                           fPreviousOut:TPasRISCVInt16;
                           fEnvelopeRouted:TPasRISCVUInt16;
                           fEnvelopeOut:TPasRISCVUInt16;
                           fEnvelopeState:TOPL3EnvelopeState;
                           fEnvelopeKSL:TPasRISCVUInt8;
                           fTremoloSource:PPasRISCVUInt8;
                           fRegVibrato:TPasRISCVUInt8;
                           fRegSustainType:TPasRISCVUInt8;
                           fRegKSR:TPasRISCVUInt8;
                           fRegMultiplier:TPasRISCVUInt8;
                           fRegKSLMode:TPasRISCVUInt8;
                           fRegTotalLevel:TPasRISCVUInt8;
                           fRegAttackRate:TPasRISCVUInt8;
                           fRegDecayRate:TPasRISCVUInt8;
                           fRegSustainLevel:TPasRISCVUInt8;
                           fRegReleaseRate:TPasRISCVUInt8;
                           fRegWaveform:TPasRISCVUInt8;
                           fKey:TPasRISCVUInt8;
                           fPhaseReset:TPasRISCVUInt32;
                           fPhaseAccumulator:TPasRISCVUInt32;
                           fPhaseOut:TPasRISCVUInt16;
                          end;
                          POPL3Channel=^TOPL3Channel;
                          TOPL3Channel=record
                           fSlots:array[0..1] of POPL3Slot;
                           fPair:POPL3Channel;
                           fOutputSources:array[0..3] of PPasRISCVInt16;
                           fChannelType:TOPL3ChannelType;
                           fFrequencyNumber:TPasRISCVUInt16;
                           fBlock:TPasRISCVUInt8;
                           fFeedback:TPasRISCVUInt8;
                           fConnection:TPasRISCVUInt8;
                           fAlgorithm:TPasRISCVUInt8;
                           fKeyScaleValue:TPasRISCVUInt8;
                           fOutputEnableA:TPasRISCVUInt16;
                           fOutputEnableB:TPasRISCVUInt16;
                           fOutputEnableC:TPasRISCVUInt16;
                           fOutputEnableD:TPasRISCVUInt16;
                           fChannelIndex:TPasRISCVUInt8;
                          end;
                          TOPL3Channels=array[0..17] of TOPL3Channel;
                          TOPL3Slots=array[0..35] of TOPL3Slot;
                          TOPL3MixBuffer=array[0..3] of TPasRISCVInt32;
                          TOPL3StereoSamples=array[0..1] of TPasRISCVInt16;
                          TOPL3AddressLatch=array[0..1] of TPasRISCVUInt8;
                    private
                     fChannels:TOPL3Channels;
                     fSlots:TOPL3Slots;
                     fTimer:TPasRISCVUInt16;
                     fEnvelopeTimer:TPasRISCVUInt64;
                     fEnvelopeTimerRemainder:TPasRISCVUInt8;
                     fEnvelopeTimerState:TPasRISCVUInt8;
                     fEnvelopeAdd:TPasRISCVUInt8;
                     fEnvelopeTimerLow:TPasRISCVUInt8;
                     fNewMode:TPasRISCVUInt8;
                     fNoteSelect:TPasRISCVUInt8;
                     fRhythm:TPasRISCVUInt8;
                     fVibratoPosition:TPasRISCVUInt8;
                     fVibratoShift:TPasRISCVUInt8;
                     fTremolo:TPasRISCVUInt8;
                     fTremoloPosition:TPasRISCVUInt8;
                     fTremoloShift:TPasRISCVUInt8;
                     fNoiseLFSR:TPasRISCVUInt32;
                     fZeroMod:TPasRISCVInt16;
                     fMixBuffer:TOPL3MixBuffer;
                     fRhythmHHBit2:TPasRISCVUInt8;
                     fRhythmHHBit3:TPasRISCVUInt8;
                     fRhythmHHBit7:TPasRISCVUInt8;
                     fRhythmHHBit8:TPasRISCVUInt8;
                     fRhythmTCBit3:TPasRISCVUInt8;
                     fRhythmTCBit5:TPasRISCVUInt8;
                     fRateRatio:TPasRISCVInt32;
                     fSampleCounter:TPasRISCVInt32;
                     fOldSamples:TOPL3StereoSamples;
                     fCurrentSamples:TOPL3StereoSamples;
                     function CalcExp(const aLevel:TPasRISCVUInt32):TPasRISCVInt16;
                     function CalcWaveform(const aWaveform:TPasRISCVUInt8;const aPhase:TPasRISCVUInt16;const aEnvelope:TPasRISCVUInt16):TPasRISCVInt16;
                     procedure UpdateKSL(const aSlot:POPL3Slot);
                     procedure ProcessEnvelope(const aSlot:POPL3Slot);
                     procedure ProcessPhase(const aSlot:POPL3Slot);
                     procedure GenerateSlotOutput(const aSlot:POPL3Slot);
                     procedure CalculateSlotFeedback(const aSlot:POPL3Slot);
                     procedure SetupChannelAlgorithm(const aChannel:POPL3Channel);
                     procedure UpdateChannelAlgorithm(const aChannel:POPL3Channel);
                     procedure UpdateRhythmMode(const aData:TPasRISCVUInt8);
                     procedure ChannelKeyOn(const aChannel:POPL3Channel);
                     procedure ChannelKeyOff(const aChannel:POPL3Channel);
                     procedure SlotKeyOn(const aSlot:POPL3Slot;const aKeyType:TPasRISCVUInt8);
                     procedure SlotKeyOff(const aSlot:POPL3Slot;const aKeyType:TPasRISCVUInt8);
                     procedure Set4OpMode(const aData:TPasRISCVUInt8);
                     procedure WriteSlotReg20(const aSlot:POPL3Slot;const aData:TPasRISCVUInt8);
                     procedure WriteSlotReg40(const aSlot:POPL3Slot;const aData:TPasRISCVUInt8);
                     procedure WriteSlotReg60(const aSlot:POPL3Slot;const aData:TPasRISCVUInt8);
                     procedure WriteSlotReg80(const aSlot:POPL3Slot;const aData:TPasRISCVUInt8);
                     procedure WriteSlotRegE0(const aSlot:POPL3Slot;const aData:TPasRISCVUInt8);
                     procedure WriteChannelRegA0(const aChannel:POPL3Channel;const aData:TPasRISCVUInt8);
                     procedure WriteChannelRegB0(const aChannel:POPL3Channel;const aData:TPasRISCVUInt8);
                     procedure WriteChannelRegC0(const aChannel:POPL3Channel;const aData:TPasRISCVUInt8);
                     function ClipSample(const aSample:TPasRISCVInt32):TPasRISCVInt16;
                     procedure ProcessSlot(const aSlot:POPL3Slot);
                    public
                     constructor Create;
                     destructor Destroy; override;
                     procedure DoReset(const aSampleRate:TPasRISCVUInt32);
                     procedure WriteRegister(const aRegister:TPasRISCVUInt16;const aValue:TPasRISCVUInt8);
                     procedure GenerateStereo(const aBuffer:PPasRISCVInt16);
                     procedure GenerateResampledStereo(const aBuffer:PPasRISCVInt16);
                     procedure GenerateStream(const aBuffer:PPasRISCVInt16;const aCount:TPasRISCVUInt32);
                   end;
             private
              fSoundIO:TSoundIO;
              // Registers
              fPCMVol:TPasRISCVUInt16;
              fFMVol:TPasRISCVUInt16;
              fI2SVol:TPasRISCVUInt16;
              fRecSrc:TPasRISCVUInt16;
              fPlayCtrl:TPasRISCVUInt16;
              fPlayCount:TPasRISCVUInt16;
              fPlayBuffer1:TPasRISCVUInt32;
              fPlayBuffer2:TPasRISCVUInt32;
              fCaptureCtrl:TPasRISCVUInt16;
              fCaptureCount:TPasRISCVUInt16;
              fCaptureBuffer1:TPasRISCVUInt32;
              fCaptureBuffer2:TPasRISCVUInt32;
              fCodecCtrl:TPasRISCVUInt16;
              fI2SMode:TPasRISCVUInt16;
              fVolume:TPasRISCVUInt16;
              fAC97Cmd:TPasRISCVUInt16;
              fAC97Data:TPasRISCVUInt16;
              fGPIOCtrl:TPasRISCVUInt16;
              fGenCtrl:TPasRISCVUInt16;
              fIRQMask:TPasRISCVUInt16;
              fIRQStatus:TPasRISCVUInt16;
              fPowerDown:TPasRISCVUInt16;
              // OPL3
              fOPL3AddressLatch:TOPL3.TOPL3AddressLatch;
              fOPL3:TOPL3;
              // AC97 codec stub
              fAC97Regs:array[0..63] of TPasRISCVUInt16;
              // PCM DMA state
              fPlayActive:Boolean;
              fPlayBufferIndex:TPasRISCVUInt32; // 0=buf1, 1=buf2
              fPlayBuffer:TPasRISCVUInt32;
              fPlayPosition:TPasRISCVUInt32;
              fPlaySize:TPasRISCVUInt32;
              fPlayScratchBuffer:TPasRISCVFloatDynamicArray;
              fPlayResamplerPosition:TPasRISCVUInt64;
              fCaptureActive:Boolean;
              fCaptureBufferIndex:TPasRISCVUInt32;
              fCaptureBuffer:TPasRISCVUInt32;
              fCapturePosition:TPasRISCVUInt32;
              fCaptureSize:TPasRISCVUInt32;
              fCaptureScratchBuffer:TPasRISCVFloatDynamicArray;
              fCaptureResamplerPosition:TPasRISCVUInt64;
              // IO BAR callbacks
              function OnLoad(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure OnStore(const aPCIMemoryDevice:TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
              // Check if any unmasked IRQ is pending (mask bit CLEAR = enabled, status bit SET = pending)
              function IRQPending:Boolean;
             public
              constructor Create(const aBus:TPCIBusDevice;const aSoundIO:TSoundIO); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              procedure OutputAudioFillBufferCallback(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
              procedure InputAudioFillBufferCallback(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
             public
              property SoundIO:TSoundIO read fSoundIO;
            end;
            { TVirtIODevice }
            TVirtIODevice=class(TBusDevice)
             public
              const VRING_DESC_F_NEXT=1;
                    VRING_DESC_F_WRITE=2;
                    VRING_DESC_F_INDIRECT=4;
                    MAXIMUM_COUNT_QUEUES=8;
                    MAXIMUM_QUEUE_SIZE=1024;
                    MAX_CONFIG_SPACE_SIZE=256;
                    VIRTIO_PAGE_SIZE=4096;
                    VIRTIO_MMIO_MAGIC_VALUE=$000;
                    VIRTIO_MMIO_VERSION=$004;
                    VIRTIO_MMIO_DEVICE_ID=$008;
                    VIRTIO_MMIO_VENDOR_ID=$00c;
                    VIRTIO_MMIO_DEVICE_FEATURES=$010;
                    VIRTIO_MMIO_DEVICE_FEATURES_SEL=$014;
                    VIRTIO_MMIO_DRIVER_FEATURES=$020;
                    VIRTIO_MMIO_DRIVER_FEATURES_SEL=$024;
                    VIRTIO_MMIO_GUEST_PAGE_SIZE=$028;
                    VIRTIO_MMIO_QUEUE_SEL=$030;
                    VIRTIO_MMIO_QUEUE_NUM_MAX=$034;
                    VIRTIO_MMIO_QUEUE_NUM=$038;
                    VIRTIO_MMIO_QUEUE_ALIGN=$03c;
                    VIRTIO_MMIO_QUEUE_PFN=$040;
                    VIRTIO_MMIO_QUEUE_READY=$044;
                    VIRTIO_MMIO_QUEUE_NOTIFY=$050;
                    VIRTIO_MMIO_INTERRUPT_STATUS=$060;
                    VIRTIO_MMIO_INTERRUPT_ACK=$064;
                    VIRTIO_MMIO_STATUS=$070;
                    VIRTIO_MMIO_QUEUE_DESC_LOW=$080;
                    VIRTIO_MMIO_QUEUE_DESC_HIGH=$084;
                    VIRTIO_MMIO_QUEUE_AVAIL_LOW=$090;
                    VIRTIO_MMIO_QUEUE_AVAIL_HIGH=$094;
                    VIRTIO_MMIO_QUEUE_USED_LOW=$0a0;
                    VIRTIO_MMIO_QUEUE_USED_HIGH=$0a4;
                    VIRTIO_MMIO_CONFIG_GENERATION=$0fc;
                    VIRTIO_MMIO_CONFIG=$100;
                    VIRTIO_MMIO_SHM_SEL=$0ac;
                    VIRTIO_MMIO_SHM_LEN_LOW=$0b0;
                    VIRTIO_MMIO_SHM_LEN_HIGH=$0b4;
                    VIRTIO_MMIO_SHM_BASE_LOW=$0b8;
                    VIRTIO_MMIO_SHM_BASE_HIGH=$0bc;
                    VIRTIO_PCI_DEVICE_FEATURE_SEL=$000;
                    VIRTIO_PCI_DEVICE_FEATURE=$004;
                    VIRTIO_PCI_DRIVER_FEATURE_SEL=$008;
                    VIRTIO_PCI_DRIVER_FEATURE=$00c;
                    VIRTIO_PCI_MSIX_CONFIG=$010;
                    VIRTIO_PCI_NUM_QUEUES=$012;
                    VIRTIO_PCI_DEVICE_STATUS=$014;
                    VIRTIO_PCI_CONFIG_GENERATION=$015;
                    VIRTIO_PCI_QUEUE_SEL=$016;
                    VIRTIO_PCI_QUEUE_SIZE=$018;
                    VIRTIO_PCI_QUEUE_MSIX_VECTOR=$01a;
                    VIRTIO_PCI_QUEUE_ENABLE=$01c;
                    VIRTIO_PCI_QUEUE_NOTIFY_OFF=$01e;
                    VIRTIO_PCI_QUEUE_DESC_LOW=$020;
                    VIRTIO_PCI_QUEUE_DESC_HIGH=$024;
                    VIRTIO_PCI_QUEUE_AVAIL_LOW=$028;
                    VIRTIO_PCI_QUEUE_AVAIL_HIGH=$02c;
                    VIRTIO_PCI_QUEUE_USED_LOW=$030;
                    VIRTIO_PCI_QUEUE_USED_HIGH=$034;
                    VIRTIO_PCI_CFG_OFFSET=$0000;
                    VIRTIO_PCI_ISR_OFFSET=$1000;
                    VIRTIO_PCI_CONFIG_OFFSET=$2000;
                    VIRTIO_PCI_NOTIFY_OFFSET=$3000;
                    VIRTIO_PCI_CAP_LEN=16;
                    VIRTIO_CONFIG_S_ACKNOWLEDGE=1;
                    VIRTIO_CONFIG_S_DRIVER=2;
                    VIRTIO_CONFIG_S_DRIVER_OK=4;
                    VIRTIO_CONFIG_S_FEATURES_OK=8;
                    VIRTIO_CONFIG_S_FAILED=128;
                    VIRTIO_TRANSPORT_F_START=28;
                    VIRTIO_TRANSPORT_F_END=32;
                    VIRTQ_AVAIL_F_NO_INTERRUPT=1;
                    VIRTQ_USED_F_NO_NOTIFY=1;
                    VIRTIO_F_NOTIFY_ON_EMPTY=TPasRISCVUInt64(1) shl 24;
                    VIRTIO_F_INDIRECT_DESC=TPasRISCVUInt64(1) shl 28;
                    VIRTIO_F_EVENT_IDX=TPasRISCVUInt64(1) shl 29;
                    VIRTIO_F_VERSION_1=TPasRISCVUInt64(1) shl 32;
                    VIRTIO_F_ACCESS_PLATFORM=TPasRISCVUInt64(1) shl 33;
                    VIRTIO_F_RING_PACKED=TPasRISCVUInt64(1) shl 34;
                    VIRTIO_F_IN_ORDER=TPasRISCVUInt64(1) shl 35;
                    VIRTIO_F_ORDER_PLATFORM=TPasRISCVUInt64(1) shl 36;
                    VIRTIO_F_SR_IOV=TPasRISCVUInt64(1) shl 37;
                    VIRTIO_F_NOTIFICATION_DATA=TPasRISCVUInt64(1) shl 38;
                    VIRTIO_F_NOTIF_CONFIG_DATA=TPasRISCVUInt64(1) shl 39;
                    VIRTIO_F_RING_RESET=TPasRISCVUInt64(1) shl 40;
                    VIRTIO_F_ADMIN_VQ=TPasRISCVUInt64(1) shl 41;
                    VIRTIO_STATUS_ACKNOWLEDGE=TPasRISCVUInt32(1) shl 0;
                    VIRTIO_STATUS_DRIVER=TPasRISCVUInt32(1) shl 1;
                    VIRTIO_STATUS_DRIVER_OK=TPasRISCVUInt32(1) shl 2;
                    VIRTIO_STATUS_FEATURES_OK=TPasRISCVUInt32(1) shl 3;
                    VIRTIO_STATUS_DEVICE_NEEDS_RESET=TPasRISCVUInt32(1) shl 6;
                    VIRTIO_STATUS_FAILED=TPasRISCVUInt32(1) shl 7;
                    VIRTIO_INT_STATUS_USED_BUFFER=TPasRISCVUInt32(1) shl 0;
                    VIRTIO_INT_STATUS_CONFIG_CHANGE=TPasRISCVUInt32(1) shl 1;
              type TKind=
                    (
                     MMIO,
                     PCI
                    );
                   PKind=^TKind;
                   TQueueDescriptor=record
                    public
                     DescriptorIndex:TPasRISCVUInt32;
                     Offset:TPasRISCVUInt32;
                     Size:TPasRISCVUInt32;
                     Padding:TPasRISCVUInt32;
                   end;
                   PQueueDescriptor=^TQueueDescriptor;
                   TQueueDescriptors=array of TQueueDescriptor;
                   TQueue=record
                    public
                     Ready:TPasMPBool32;
                     Lock:TPasMPInt32;
                     Size:TPasRISCVUInt32;
                     UsedRingEvent:TPasMPBool32;
                     ShadowAvailableIndex:TPasRISCVUInt16;
                     ShadowUsedIndex:TPasRISCVUInt16;
                     DescriptorAddress:TPasRISCVUInt64;
                     AvailableAddress:TPasRISCVUInt64;
                     UsedAddress:TPasRISCVUInt64;
                     ManualRecv:TPasMPBool32;
                     Asynchronous:TPasMPBool32;
                     ReadDescriptors:TQueueDescriptors;
                     WriteDescriptors:TQueueDescriptors;
                     CountReadDescriptors:TPasRISCVSizeInt;
                     CountWriteDescriptors:TPasRISCVSizeInt;
                   end;
                   PQueue=^TQueue;
                   TQueues=array[0..MAXIMUM_COUNT_QUEUES-1] of TQueue;
                   PQueues=^TQueues;
                   TVirtIODescriptor=packed record
                    Address:TPasRISCVUInt64;
                    Len:TPasRISCVUInt32;
                    Flags:TPasRISCVUInt16;
                    Next:TPasRISCVUInt16;
                   end;
                   PVirtIODescriptor=^TVirtIODescriptor;
                   TConfigSpace=array[0..MAX_CONFIG_SPACE_SIZE-1] of TPasRISCVUInt8;
             private
              fKind:TKind;
              fUseQueueDescriptorCaching:Boolean;
              fIRQ:TPasRISCVUInt32;
              fIntStatus:TPasMPUInt32;
              fStatus:TPasRISCVUInt32;
              fDeviceFeatures:TPasRISCVUInt64;
              fDriverFeatures:TPasRISCVUInt64;
              fActiveFeatures:TPasRISCVUInt64;
              fDeviceFeaturesSelected:TPasRISCVUInt64;
              fDriverFeaturesSelected:TPasRISCVUInt64;
              fSelectedQueue:TPasRISCVUInt32;
              fQueues:TQueues;
              fDeviceID:TPasRISCVUInt32;
              fVendorID:TPasRISCVUInt32;
              fConfigSpaceSize:TPasRISCVUInt32;
              fConfigSpace:TConfigSpace;
              fDriverOK:Boolean;
             public
              constructor Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64;const aKind:TVirtIODevice.TKind); reintroduce;
              destructor Destroy; override;
              procedure DeviceReset; virtual;
              procedure DeviceDriverOK; virtual;
              procedure DeviceConfigWrite; virtual;
              procedure DeviceInitialize; virtual;
              function DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean; virtual;
              function Read8(const aPhysicalAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt8):Boolean;
              function Write8(const aPhysicalAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt8):Boolean;
              function Read16(const aPhysicalAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt16):Boolean;
              function Write16(const aPhysicalAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt16):Boolean;
              function Read32(const aPhysicalAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt32):Boolean;
              function Write32(const aPhysicalAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt32):Boolean;
              function Read64(const aPhysicalAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt64):Boolean;
              function Write64(const aPhysicalAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64):Boolean;
              function CopyMemoryFromRAM(const aBuf:Pointer;const aPhysicalAddress:TPasRISCVUInt64;const aCount:TPasRISCVUInt64):Boolean;
              function CopyMemoryToRAM(const aPhysicalAddress:TPasRISCVUInt64;const aBuf:Pointer;const aCount:TPasRISCVUInt64):Boolean;
              function GetDescriptor(const aDescriptor:PVirtIODescriptor;const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64):Boolean;
              function CopyMemoryFromToQueue(const aBuf:Pointer;const aQueueIndex,aDescriptorIndex,aOffset,aCount:TPasRISCVUInt64;const aToQueue:Boolean):Boolean;
              function CopyMemoryFromQueue(const aBuf:Pointer;const aQueueIndex,aDescriptorIndex,aOffset,aCount:TPasRISCVUInt64):Boolean;
              function CopyMemoryToQueue(const aQueueIndex,aDescriptorIndex,aOffset:TPasRISCVUInt64;const aBuf:Pointer;const aCount:TPasRISCVUInt64):Boolean;
              function ConsumeDescriptor(const aQueueIndex,aDescriptorIndex,aDescriptorLength:TPasRISCVUInt64):Boolean;
              function UsedRingSync(const aQueueIndex:TPasRISCVUInt64):Boolean;
              function GetDescriptors(out aReadSize,aWriteSize:TPasRISCVUInt64;const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64):Boolean;
              function AdvanceShadowAvailableIndex(const aQueueIndex:TPasRISCVUInt64):Boolean;
              procedure ProcessQueue(const aQueueIndex:TPasRISCVUInt64;const aAvailableIndex:TPasRISCVInt64);
              procedure QueueNotify(const aQueueIndex:TPasRISCVUInt64);
              procedure UpdateIRQ;
              procedure SetIRQ(const aValue:TPasRISCVUInt32);
              procedure NotifyQueueUsed;
              procedure NotifyDeviceNeedsReset;
              procedure NotifyConfigChange;
              function ConfigRead(const aOffset:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure ConfigWrite(const aOffset:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
              procedure SetStatus(const aStatus:TPasRISCVUInt32);
              function MMIORead(const aOffset:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure MMIOWrite(const aOffset:TPasRISCVUInt64;const aValue:TPasRISCVUInt32;const aSize:TPasRISCVUInt64);
              function PCIRead(const aOffset:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure PCIWrite(const aOffset:TPasRISCVUInt64;const aValue:TPasRISCVUInt32;const aSize:TPasRISCVUInt64);
              procedure Reset; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TVirtIOBlockDevice }
            TVirtIOBlockDevice=class(TVirtIODevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10050000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    DefaultIRQ=TPasRISCVUInt64($10);
                    DeviceID=$02;
                    Vendor=TPasRISCVUInt32($554d4551);
                    VIRTIO_BLK_F_BARRIER=TPasRISCVUInt64(1) shl 0; // Does host support barriers?
                    VIRTIO_BLK_F_SIZE_MAX=TPasRISCVUInt64(1) shl 1; // Indicates maximum segment size
                    VIRTIO_BLK_F_SEG_MAX=TPasRISCVUInt64(1) shl 2; // Indicates maximum # of segments
                    VIRTIO_BLK_F_GEOMETRY=TPasRISCVUInt64(1) shl 4; // Legacy geometry available
                    VIRTIO_BLK_F_RO=TPasRISCVUInt64(1) shl 5; // Disk is read-only
                    VIRTIO_BLK_F_BLK_SIZE=TPasRISCVUInt64(1) shl 6;  // Block size of disk is available
                    VIRTIO_BLK_F_SCSI=TPasRISCVUInt64(1) shl 7; // Supports scsi command passthru
                    VIRTIO_BLK_F_WCE=TPasRISCVUInt64(1) shl 9; // Writeback mode enabled after reset
                    VIRTIO_BLK_F_TOPOLOGY=TPasRISCVUInt64(1) shl 10; // Topology information is available
                    VIRTIO_BLK_F_CONFIG_WCE=TPasRISCVUInt64(1) shl 11; // Writeback mode available in config
                    VIRTIO_BLK_F_MQ=TPasRISCVUInt64(1) shl 12; // Device supports multiqueue
                    VIRTIO_BLK_F_DISCARD=TPasRISCVUInt64(1) shl 13;
                    VIRTIO_BLK_F_WRITE_ZEROES=TPasRISCVUInt64(1) shl 14;
                    VIRTIO_BLK_F_LIFETIME=TPasRISCVUInt64(1) shl 15;
                    VIRTIO_BLK_F_SECURE_ERASE=TPasRISCVUInt64(1) shl 16;
                    VIRTIO_BLK_F_ZONED=TPasRISCVUInt64(1) shl 17;
                    VIRTIO_BLK_F_FLUSH=VIRTIO_BLK_F_WCE;
                    VIRTIO_BLK_T_IN=0;
                    VIRTIO_BLK_T_OUT=1;
                    VIRTIO_BLK_T_SCSI=2;
                    VIRTIO_BLK_T_FLUSH=4;
                    VIRTIO_BLK_T_FLUSH_OUT=5;
                    VIRTIO_BLK_T_GET_ID=8;
                    VIRTIO_BLK_T_GET_LIFETIME=10;
                    VIRTIO_BLK_T_DISCARD=11;
                    VIRTIO_BLK_T_WRITE_ZEROES=13;
                    VIRTIO_BLK_T_SECURE_ERASE=14;
                    VIRTIO_BLK_S_OK=0;
                    VIRTIO_BLK_S_IOERR=1;
                    VIRTIO_BLK_S_UNSUPP=2;
                    SECTOR_SIZE=512;
              type TVirtIOBlkGeometry=packed record
                    Cylinders:TPasRISCVUInt16;
                    Heads:TPasRISCVUInt8;
                    Sectors:TPasRISCVUInt8;
                   end;
                   PVirtIOBlkGeometry=^TVirtIOBlkGeometry;
                   TVirtIOBlkTopology=packed record
                    PhysicalBlockExp:TPasRISCVUInt8;
                    AlignmentOffset:TPasRISCVUInt8;
                    MinIOSize:TPasRISCVUInt16;
                    OptIOSize:TPasRISCVUInt32;
                   end;
                   PVirtIOBlkTopology=^TVirtIOBlkTopology;
                   TVirtIOBlkZonedCharacteristics=packed record
                    ZoneSectors:TPasRISCVUInt32;
                    MaxOpenZones:TPasRISCVUInt32;
                    MaxActiveZones:TPasRISCVUInt32;
                    MaxAppendSectors:TPasRISCVUInt32;
                    WriteGranularity:TPasRISCVUInt32;
                    Model:TPasRISCVUInt8;
                   end;
                   PVirtIOBlkZonedCharacteristics=^TVirtIOBlkZonedCharacteristics;
                   TVirtIOBlkConfig=packed record
                    Capacity:TPasRISCVUInt64;
                    SizeMax:TPasRISCVUInt32;
                    SegMax:TPasRISCVUInt32;
                    Geometry:TVirtIOBlkGeometry;
                    BlkSize:TPasRISCVUInt32;
                    Topology:TVirtIOBlkTopology;
                    Writeback:TPasRISCVUInt8;
                    Unused0:TPasRISCVUInt8;
                    NumQueues:TPasRISCVUInt16;
                    MaxDiscardSectors:TPasRISCVUInt32;
                    MaxDiscardSeg:TPasRISCVUInt32;
                    DiscardSectorAlignment:TPasRISCVUInt32;
                    MaxWriteZeroesSectors:TPasRISCVUInt32;
                    MaxWriteZeroesSeg:TPasRISCVUInt32;
                    WriteZeroesMayUnmap:TPasRISCVUInt8;
                    Unused1:array[0..2] of TPasRISCVUInt8;
                    MaxSecureEraseSectors:TPasRISCVUInt32;
                    MaxSecureEraseSeg:TPasRISCVUInt32;
                    SecureEraseSectorAlignment:TPasRISCVUInt32;
                    Zoned:TVirtIOBlkZonedCharacteristics;
                   end;
                   PVirtIOBlkConfig=^TVirtIOBlkConfig;
                   TVirtIOBlkDiscardWriteZeroes=packed record
                    Sector:TPasRISCVUInt64;
                    CountSectors:TPasRISCVUInt32;
                    Flags:TPasRISCVUInt32;
                   end;
                   PVirtIOBlkDiscardWriteZeroes=^TVirtIOBlkDiscardWriteZeroes;
                   TBlockRequestHeader=packed record
                    Type_:TPasRISCVUInt32;
                    IOPrio:TPasRISCVUInt32;
                    SectorIndex:TPasRISCVUInt64;
                   end;
                   PBlockRequestHeader=^TBlockRequestHeader;
             private
              fStreamLock:TPasMPSlimReaderWriterLock;
              fStream:TStream;
              fCountSectors:TPasRISCVUInt64;
              fConfig:TVirtIOBlkConfig;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure DeviceReset; override;
              procedure DeviceConfigWrite; override;
              function ImageRead(const aSectorIndex:TPasRISCVUInt64;const aBuf:Pointer;const aCount:TPasRISCVUInt64):Boolean;
              function ImageWrite(const aSectorIndex:TPasRISCVUInt64;const aBuf:Pointer;const aCount:TPasRISCVUInt64):Boolean;
              function DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean; override;
              procedure AttachStream(const aStream:TStream);
              procedure LoadFromStream(const aStream:TStream);
              procedure LoadFromFile(const aFileName:TPasRISCVUTF8String);
              procedure SaveToStream(const aStream:TStream);
              procedure SaveToFile(const aFileName:TPasRISCVUTF8String);
            end;
            { TVirtIOInputDevice }
            TVirtIOInputDevice=class(TVirtIODevice)
             public
              const DefaultSize=TPasRISCVUInt64($1000);
                    VIRTIO_INPUT_CFG_UNSET=$00;
                    VIRTIO_INPUT_CFG_ID_NAME=$01;
                    VIRTIO_INPUT_CFG_ID_SERIAL=$02;
                    VIRTIO_INPUT_CFG_ID_DEVIDS=$03;
                    VIRTIO_INPUT_CFG_PROP_BITS=$10;
                    VIRTIO_INPUT_CFG_EV_BITS=$11;
                    VIRTIO_INPUT_CFG_ABS_INFO=$12;
                    VIRTIO_INPUT_EV_SYN=$00;
                    VIRTIO_INPUT_EV_KEY=$01;
                    VIRTIO_INPUT_EV_REL=$02;
                    VIRTIO_INPUT_EV_ABS=$03;
                    VIRTIO_INPUT_EV_REP=$14;
                    VIRTIO_INPUT_ABS_SCALE=32768;
                    BTN_LEFT=$110;
                    BTN_RIGHT=$111;
                    BTN_MIDDLE=$112;
                    BTN_GEAR_DOWN=$150;
                    BTN_GEAR_UP=$151;
                    REL_X=$00;
                    REL_Y=$01;
                    REL_Z=$02;
                    REL_WHEEL=$08;
                    ABS_X=$00;
                    ABS_Y=$01;
                    ABS_Z=$02;
                    ButtonList:array[0..2] of TPasRISCVUInt16=(BTN_LEFT,BTN_RIGHT,BTN_MIDDLE);
                    Vendor=$ffff;
                    DeviceID=$12;
              type TInputKind=
                    (
                     Keyboard,
                     Mouse,
                     Tablet
                    );
                   TKind=TInputKind;
                   PKind=^TKind;
             private
              fKind:TKind;
              fButtonState:TPasRISCVUInt32;
             public
              constructor Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64;const aKind:TVirtIOInputDevice.TKind); reintroduce;
              destructor Destroy; override;
              function HandleKeyboard(const aKeyCode:TPasRISCVUInt16;const aDown:Boolean):Boolean;
              function HandleMouse(const aDX,aDY,aDZ:TPasRISCVInt32;const aButtons:TPasRISCVUInt32):Boolean;
              procedure DeviceReset; override;
              function DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean; override;
              function QueueEvent(const aType,aCode:TPasRISCVUInt16;const aValue:TPasRISCVUInt32):Boolean;
              procedure DeviceConfigWrite; override;
            end;
            TVirtIOInputKeyboardDevice=class(TVirtIOInputDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10051000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    DefaultIRQ=TPasRISCVUInt64($11);
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              procedure DeviceInitialize; override;
            end;
            TVirtIOInputMouseDevice=class(TVirtIOInputDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10052000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    DefaultIRQ=TPasRISCVUInt64($12);
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              procedure DeviceInitialize; override;
            end;
            { TVirtIOSoundDevice }
            TVirtIOSoundDevice=class(TVirtIODevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10054000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    DefaultIRQ=TPasRISCVUInt64($14);
                    DeviceID=25;
                    VIRTIO_SOUND_VM_VERSION=1;
                    VIRTIO_SOUND_JACK_DEFAULT=0;
                    VIRTIO_SOUND_STREAM_DEFAULT=2;
                    VIRTIO_SOUND_CHMAP_DEFAULT=0;
                    VIRTIO_SOUND_HDA_FN_NID=0;
                    VIRTIO_SND_VQ_CONTROL=0;
                    VIRTIO_SND_VQ_EVENT=1;
                    VIRTIO_SND_VQ_TX=2;
                    VIRTIO_SND_VQ_RX=3;
                    VIRTIO_SND_VQ_MAX=4;
                    VIRTIO_SND_D_OUTPUT=0;
                    VIRTIO_SND_D_INPUT=1;
                    VIRTIO_SND_R_JACK_INFO=1;
                    VIRTIO_SND_R_JACK_REMAP=2;
                    VIRTIO_SND_R_PCM_INFO=$100;
                    VIRTIO_SND_R_PCM_SET_PARAMS=$101;
                    VIRTIO_SND_R_PCM_PREPARE=$102;
                    VIRTIO_SND_R_PCM_RELEASE=$103;
                    VIRTIO_SND_R_PCM_START=$104;
                    VIRTIO_SND_R_PCM_STOP=$105;
                    VIRTIO_SND_R_CHMAP_INFO=$200;
                    VIRTIO_SND_EVT_JACK_CONNECTED=$1000;
                    VIRTIO_SND_EVT_JACK_DISCONNECTED=$1001;
                    VIRTIO_SND_EVT_PCM_PERIOD_ELAPSED=$1100;
                    VIRTIO_SND_EVT_PCM_XRUN=$1101;
                    VIRTIO_SND_S_OK=$8000;
                    VIRTIO_SND_S_BAD_MSG=$8001;
                    VIRTIO_SND_S_NOT_SUPP=$8002;
                    VIRTIO_SND_S_IO_ERR=$8003;
                    VIRTIO_SND_PCM_F_SHMEM_HOST=0;
                    VIRTIO_SND_PCM_F_SHMEM_GUEST=1;
                    VIRTIO_SND_PCM_F_MSG_POLLING=2;
                    VIRTIO_SND_PCM_F_EVT_SHMEM_PERIODS=3;
                    VIRTIO_SND_PCM_F_EVT_XRUNS=4;
                    VIRTIO_SND_JACK_F_REMAP=0;
                    VIRTIO_SND_PCM_FMT_IMA_ADPCM=0; //  4 /  4 bits
                    VIRTIO_SND_PCM_FMT_MU_LAW=1; //  8 /  8 bits
                    VIRTIO_SND_PCM_FMT_A_LAW=2; //  8 /  8 bits
                    VIRTIO_SND_PCM_FMT_S8=3; //  8 /  8 bits
                    VIRTIO_SND_PCM_FMT_U8=4; //  8 /  8 bits
                    VIRTIO_SND_PCM_FMT_S16=5; // 16 / 16 bits
                    VIRTIO_SND_PCM_FMT_U16=6; // 16 / 16 bits
                    VIRTIO_SND_PCM_FMT_S18_3=7; // 18 / 24 bits
                    VIRTIO_SND_PCM_FMT_U18_3=8; // 18 / 24 bits
                    VIRTIO_SND_PCM_FMT_S20_3=9; // 20 / 24 bits
                    VIRTIO_SND_PCM_FMT_U20_3=10; // 20 / 24 bits
                    VIRTIO_SND_PCM_FMT_S24_3=11; // 24 / 24 bits
                    VIRTIO_SND_PCM_FMT_U24_3=12; // 24 / 24 bits
                    VIRTIO_SND_PCM_FMT_S20=13; // 20 / 32 bits
                    VIRTIO_SND_PCM_FMT_U20=14; // 20 / 32 bits
                    VIRTIO_SND_PCM_FMT_S24=15; // 24 / 32 bits
                    VIRTIO_SND_PCM_FMT_U24=16; // 24 / 32 bits
                    VIRTIO_SND_PCM_FMT_S32=17; // 32 / 32 bits
                    VIRTIO_SND_PCM_FMT_U32=18; // 32 / 32 bits
                    VIRTIO_SND_PCM_FMT_FLOAT=19; // 32 / 32 bits
                    VIRTIO_SND_PCM_FMT_FLOAT64=20; // 64 / 64 bits
                    VIRTIO_SND_PCM_FMT_DSD_U8=21; //  8 /  8 bits
                    VIRTIO_SND_PCM_FMT_DSD_U16=22; // 16 / 16 bits
                    VIRTIO_SND_PCM_FMT_DSD_U32=23; // 32 / 32 bits
                    VIRTIO_SND_PCM_FMT_IEC958_SUBFRAME=24; // 32 / 32 bits
                    VIRTIO_SND_PCM_RATE_5512=0;
                    VIRTIO_SND_PCM_RATE_8000=1;
                    VIRTIO_SND_PCM_RATE_11025=2;
                    VIRTIO_SND_PCM_RATE_16000=3;
                    VIRTIO_SND_PCM_RATE_22050=4;
                    VIRTIO_SND_PCM_RATE_32000=5;
                    VIRTIO_SND_PCM_RATE_44100=6;
                    VIRTIO_SND_PCM_RATE_48000=7;
                    VIRTIO_SND_PCM_RATE_64000=8;
                    VIRTIO_SND_PCM_RATE_88200=9;
                    VIRTIO_SND_PCM_RATE_96000=10;
                    VIRTIO_SND_PCM_RATE_176400=11;
                    VIRTIO_SND_PCM_RATE_192000=12;
                    VIRTIO_SND_PCM_RATE_384000=13;
                    VIRTIO_SND_CHMAP_NONE=0; // undefined
                    VIRTIO_SND_CHMAP_NA=1; // silent
                    VIRTIO_SND_CHMAP_MONO=2; // mono stream
                    VIRTIO_SND_CHMAP_FL=3; // front left
                    VIRTIO_SND_CHMAP_FR=4; // front right
                    VIRTIO_SND_CHMAP_RL=5; // rear left
                    VIRTIO_SND_CHMAP_RR=6; // rear right
                    VIRTIO_SND_CHMAP_FC=7; // front center
                    VIRTIO_SND_CHMAP_LFE=8; // low frequency (LFE)
                    VIRTIO_SND_CHMAP_SL=9; // side left
                    VIRTIO_SND_CHMAP_SR=10; // side right
                    VIRTIO_SND_CHMAP_RC=11; // rear center
                    VIRTIO_SND_CHMAP_FLC=12; // front left center
                    VIRTIO_SND_CHMAP_FRC=13; // front right center
                    VIRTIO_SND_CHMAP_RLC=14; // rear left center
                    VIRTIO_SND_CHMAP_RRC=15; // rear right center
                    VIRTIO_SND_CHMAP_FLW=16; // front left wide
                    VIRTIO_SND_CHMAP_FRW=17; // front right wide
                    VIRTIO_SND_CHMAP_FLH=18; // front left high
                    VIRTIO_SND_CHMAP_FCH=19; // front center high
                    VIRTIO_SND_CHMAP_FRH=20; // front right high
                    VIRTIO_SND_CHMAP_TC=21; // top center
                    VIRTIO_SND_CHMAP_TFL=22; // top front left
                    VIRTIO_SND_CHMAP_TFR=23; // top front right
                    VIRTIO_SND_CHMAP_TFC=24; // top front center
                    VIRTIO_SND_CHMAP_TRL=25; // top rear left
                    VIRTIO_SND_CHMAP_TRR=26; // top rear right
                    VIRTIO_SND_CHMAP_TRC=27; // top rear center
                    VIRTIO_SND_CHMAP_TFLC=28; // top front left center
                    VIRTIO_SND_CHMAP_TFRC=29; // top front right center
                    VIRTIO_SND_CHMAP_TSL=30; // top side left
                    VIRTIO_SND_CHMAP_TSR=31; // top side right
                    VIRTIO_SND_CHMAP_LLFE=32; // left LFE
                    VIRTIO_SND_CHMAP_RLFE=33; // right LFE
                    VIRTIO_SND_CHMAP_BC=34; // bottom center
                    VIRTIO_SND_CHMAP_BLC=35; // bottom left center
                    VIRTIO_SND_CHMAP_BRC=36; // bottom right center
                    VIRTIO_SND_CHMAP_MAX_SIZE=18;
                    SupportedFormats=TPasRISCVUInt64(
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_S8) or
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_U8) or
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_S16) or
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_U16) or
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_S24) or
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_U24) or
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_S32) or
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_U32) or
                                      (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_FMT_FLOAT)
                                     );
                    SupportedRates=TPasRISCVUInt64(
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_5512) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_8000) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_11025) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_16000) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_22050) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_32000) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_44100) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_48000) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_64000) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_88200) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_96000) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_176400) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_192000) or
                                     (TPasRISCVUInt64(1) shl VIRTIO_SND_PCM_RATE_384000)
                                    );
                    SampleRates:array[0..13] of TPasRISCVUInt32=(5512,8000,11025,16000,22050,32000,44100,48000,64000,88200,96000,176400,192000,384000);
              type TVirtIOSoundConfig=packed record
                    Jacks:TPasRISCVUInt32;
                    Streams:TPasRISCVUInt32;
                    ChannelMaps:TPasRISCVUInt32;
                    Controls:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundConfig=^TVirtIOSoundConfig;
                   TVirtIOSoundHeader=packed record
                    Code:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundHeader=^TVirtIOSoundHeader;
                   TVirtIOSoundEvent=packed record
                    Header:TVirtIOSoundHeader;
                    Data:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundEvent=^TVirtIOSoundEvent;
                   TVirtIOSoundQueryInfo=packed record
                    Header:TVirtIOSoundHeader;
                    StartID:TPasRISCVUInt32;
                    Count:TPasRISCVUInt32;
                    Size:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundQueryInfo=^TVirtIOSoundQueryInfo;
                   TVirtIOSoundInfo=packed record
                    HDAFunctionGroupNodeID:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundInfo=^TVirtIOSoundInfo;
                   TVirtIOSoundJackHeader=packed record
                    Header:TVirtIOSoundHeader;
                    JackID:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundJackHeader=^TVirtIOSoundJackHeader;
                   TVirtIOSoundJackInfo=packed record
                    Header:TVirtIOSoundInfo;
                    Features:TPasRISCVUInt32;
                    HDARegDefConfig:TPasRISCVUInt32;
                    HDARegCaps:TPasRISCVUInt32;
                    Connected:TPasRISCVUInt8;
                    Padding:array[0..6] of TPasRISCVUInt8;
                   end;
                   PVirtIOSoundJackInfo=^TVirtIOSoundJackInfo;
                   TVirtIOSoundJackInfos=array of TVirtIOSoundJackInfo;
                   TVirtIOSoundJackRemap=packed record
                    Header:TVirtIOSoundJackHeader;
                    Association:TPasRISCVUInt32;
                    Sequence:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundJackRemap=^TVirtIOSoundJackRemap;
                   TVirtIOSoundPCMHeader=packed record
                    Header:TVirtIOSoundHeader;
                    StreamID:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundPCMHeader=^TVirtIOSoundPCMHeader;
                   TVirtIOSoundPCMInfo=packed record
                    Header:TVirtIOSoundInfo;
                    Features:TPasRISCVUInt32;
                    Formats:TPasRISCVUInt64;
                    Rates:TPasRISCVUInt64;
                    Direction:TPasRISCVUInt8;
                    ChannelsMin:TPasRISCVUInt8;
                    ChannelsMax:TPasRISCVUInt8;
                    Padding:array[0..4] of TPasRISCVUInt8;
                   end;
                   PVirtIOSoundPCMInfo=^TVirtIOSoundPCMInfo;
                   TVirtIOSoundPCMSetParams=packed record
                    Header:TVirtIOSoundPCMHeader;
                    BufferBytes:TPasRISCVUInt32;
                    PeriodBytes:TPasRISCVUInt32;
                    Features:TPasRISCVUInt32;
                    Channels:TPasRISCVUInt8;
                    Format:TPasRISCVUInt8;
                    Rate:TPasRISCVUInt8;
                    Padding:TPasRISCVUInt8;
                   end;
                   PVirtIOSoundPCMSetParams=^TVirtIOSoundPCMSetParams;
                   TVirtIOSoundPCMXfer=packed record
                    StreamID:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundPCMXfer=^TVirtIOSoundPCMXfer;
                   TVirtIOSoundPCMStatus=packed record
                    Status:TPasRISCVUInt32;
                    LatencyBytes:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundPCMStatus=^TVirtIOSoundPCMStatus;
                   TVirtIOSoundChMapHeader=packed record
                    Header:TVirtIOSoundHeader;
                    ChannelMapID:TPasRISCVUInt32;
                   end;
                   PVirtIOSoundChMapHeader=^TVirtIOSoundChMapHeader;
                   TVirtIOSoundChMapInfo=packed record
                    Header:TVirtIOSoundInfo;
                    Direction:TPasRISCVUInt8;
                    Channels:TPasRISCVUInt8;
                    Positions:array[0..VIRTIO_SND_CHMAP_MAX_SIZE-1] of TPasRISCVUInt8;
                   end;
                   PVirtIOSoundChMapInfo=^TVirtIOSoundChMapInfo;
                   { TPCMBuffer }
                   TPCMBuffer=class
                    private
                     fDevice:TVirtIOSoundDevice;
                     fRawSize:TPasRISCVUInt64;
                     fRemainingSize:TPasRISCVUInt64;
                     fOffset:TPasRISCVUInt64;
                     fAvailableIndex:TPasRISCVInt64;
                     fPopulated:Boolean;
                     fData:TPasRISCVUInt8DynamicArray;
                     fFloatData:TPasRISCVFloatDynamicArray;
                     fResampledFloatData:TPasRISCVFloatDynamicArray;
                    public
                     constructor Create(const aDevice:TVirtIOSoundDevice); reintroduce;
                     destructor Destroy; override;
                     procedure Clear;
                   end;
                   TPCMBufferQueue=TPasRISCVDynamicQueue<TPCMBuffer>;
                   TPCMStream=class;
                   TPCMStreams=array of TPCMStream;
                   TVirtIOSoundPCMSetParamsArray=array of TVirtIOSoundPCMSetParams;
                   TPCMRingBuffer=TPasMPSingleProducerSingleConsumerRingBuffer;
                   { TPCMStream }
                   TPCMStream=class
                    public
                     type TCommand=
                           (
                            None,
                            SetParameters,
                            Prepare,
                            Start,
                            Stop,
                            Release
                           );
                     const STATE_NONE=0;
                    private
                     fDevice:TVirtIOSoundDevice;
                     fParams:TVirtIOSoundPCMSetParams;
                     fPositions:array[0..VIRTIO_SND_CHMAP_MAX_SIZE-1] of TPasRISCVUInt8;
                     fCommand:TCommand;
                     fActive:TPasMPBool32;
                     fFlushing:TPasMPBool32;
                     fCurrentBuffer:TPCMBuffer;
                     fLock:TPasMPCriticalSection;
                     fBufferQueueLock:TPasMPCriticalSection;
                     fBufferQueue:TPCMBufferQueue;
                     fBufferFreeQueue:TPCMBufferQueue;
                     fPCMRingBuffer:TPCMRingBuffer;
                     fPreviousFrameEndValues:array[0..1] of TPasRISCVFloat;
                     fResamplerPosition:TPasRISCVUInt64;
                    public
                     procedure ReturnBuffer(const aPCMBuffer:TPCMBuffer;const aLock:Boolean);
                   end;
                   TVirtIOSndControlCommand=record
                    private
                     fCtrl:TVirtIOSoundHeader;
                     fResp:TVirtIOSoundHeader;
                     fPayloadSize:PVirtIOSoundHeader;
                   end;
                   PVirtIOSndControlCommand=^TVirtIOSndControlCommand;
             private
              fSoundIO:TSoundIO;
              fSoundConfig:TVirtIOSoundConfig;
              fCommandQueueLock:TPasMPCriticalSection;
              fPCMStreams:TPCMStreams;
              fTXScratchBuffer:TPasRISCVFloatDynamicArray;
              fRXScratchBuffer:TPasRISCVFloatDynamicArray;
              fOutputWAVStreamDump:TPasRISCVAudioWAVStreamDump;
             public
              constructor Create(const aMachine:TPasRISCV;const aSoundIO:TSoundIO); reintroduce;
              destructor Destroy; override;
              function SetParams(const aStreamID:TPasRISCVUInt32;const aParams:TVirtIOSoundPCMSetParams):TPasRISCVUInt32;
              procedure DeviceReset; override;
              function DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean; override;
              procedure FreeBufferQueue(var aBufferQueue:TPCMBufferQueue);
              procedure NotifyTXBuffer(const aPCMBuffer:TPCMBuffer);
              procedure FlushTX;
              procedure FlushRX;
              procedure OutputAudioFillBufferCallback(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
              procedure InputAudioFillBufferCallback(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
             public
              property SoundIO:TSoundIO read fSoundIO;
            end;
            { TVirtIO9PDevice }
            TVirtIO9PDevice=class(TVirtIODevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10055000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    DefaultIRQ=TPasRISCVUInt64($1);
                    DeviceID=9;
                    VIRTIO_9P_MOUNT_TAG=1;
                    VIRTIO_9P_MOUNT=2;
                    VIRTIO_9P_UNMOUNT=3;
                    VIRTIO_9P_ERROR=4;
                    VIRTIO_9P_STATFS=8;
                    VIRTIO_9P_LOPEN=12;
                    VIRTIO_9P_LCREATE=14;
                    VIRTIO_9P_SYMLINK=16;
                    VIRTIO_9P_MKNOD=18;
                    VIRTIO_9P_READLINK=22;
                    VIRTIO_9P_GETATTR=24;
                    VIRTIO_9P_SETATTR=26;
                    VIRTIO_9P_XATTRWALK=30;
                    VIRTIO_9P_READDIR=40;
                    VIRTIO_9P_FSYNC=50;
                    VIRTIO_9P_LOCK=52;
                    VIRTIO_9P_GETLOCK=54;
                    VIRTIO_9P_LINK=70;
                    VIRTIO_9P_MKDIR=72;
                    VIRTIO_9P_RENAMEAT=74;
                    VIRTIO_9P_UNLINKAT=76;
                    VIRTIO_9P_VERSION=100;
                    VIRTIO_9P_ATTACH=104;
                    VIRTIO_9P_FLUSH=108;
                    VIRTIO_9P_WALK=110;
                    VIRTIO_9P_READ=116;
                    VIRTIO_9P_WRITE=118;
                    VIRTIO_9P_CLUNK=120;
              type { TFIDDescriptor }
                   TFIDDescriptor=class
                    private
                     fDevice:TVirtIO9PDevice;
                     fPrevious:TFIDDescriptor;
                     fNext:TFIDDescriptor;
                     fFID:TPasRISCVUInt32;
                     fFile:TPasRISCV9PFileSystem.TFSFile;
                    public
                   end;
                   TFIDDescriptorHashMap=TPasRISCVHashMap<TPasRISCVUInt32,TFIDDescriptor>;
                   { TFIDDescriptors }
                   TFIDDescriptors=class
                    private
                     fDevice:TVirtIO9PDevice;
                     fLock:TPasMPMultipleReaderSingleWriterLock;
                     fFirst:TFIDDescriptor;
                     fLast:TFIDDescriptor;
                     fHashMap:TFIDDescriptorHashMap;
                    public
                     constructor Create(const aDevice:TVirtIO9PDevice);
                     destructor Destroy; override;
                     function Add(const aFID:TPasRISCVUInt32;const aFile:TPasRISCV9PFileSystem.TFSFile):TFIDDescriptor;
                     function Remove(const aFID:TPasRISCVUInt32):TFIDDescriptor;
                     function Find(const aFID:TPasRISCVUInt32):TFIDDescriptor;
                   end;
                   TOpenInfo=record
                    QueueIndex:TPasRISCVUInt64;
                    DescriptorIndex:TPasRISCVUInt64;
                    Tag:TPasRISCVUInt16;
                   end;
                   POpenInfo=^TOpenInfo;
             private
              fFileSystem:TPasRISCV9PFileSystem;
              fMaximumMessageSize:TPasRISCVUInt32;
              fFIDDescriptors:TFIDDescriptors;
              fRequestInProcess:TPasMPBool32;
              fLock:TPasMPCriticalSection;
              fRecvBuffer:TPasRISCVUInt8DynamicArray;
              fSendBuffer:TPasRISCVUInt8DynamicArray;
              fTempBuffer:TPasRISCVUInt8DynamicArray;
              class function Get9POperationName(const aOperation:TPasRISCVUInt32):TPasRISCVRawByteString; static;
              procedure SendReply(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aID:TPasRISCVUInt8;const aTag:TPasRISCVUInt16;const aPayload:Pointer;const aPayloadSize:TPasRISCVUInt32);
              procedure SendError(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aTag:TPasRISCVUInt16;const aError:TPasRISCVInt32);
              procedure OpenReply(const aQID:TPasRISCV9PFileSystem.PFSQID;const aError:TPasRISCVInt32;const aOpenInfo:POpenInfo);
              procedure OpenCallback(const aFileSystem:TPasRISCV9PFileSystem;const aQID:TPasRISCV9PFileSystem.PFSQID;const aError:TPasRISCVUInt32;const aOpaque:Pointer);
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure DeviceReset; override;
              function DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean; override;
             public
              property FileSystem:TPasRISCV9PFileSystem read fFileSystem write fFileSystem;
            end;
            { TVirtIONetDevice }
            TVirtIONetDevice=class(TVirtIODevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10056000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    DefaultIRQ=TPasRISCVUInt64($16);
                    DeviceID=1;
                    VIRTIO_NET_F_CSUM=TPasRISCVUInt64(1) shl 0;
                    VIRTIO_NET_F_GUEST_CSUM=TPasRISCVUInt64(1) shl 1;
                    VIRTIO_NET_F_CTRL_GUEST_OFFLOADS=TPasRISCVUInt64(1) shl 2;
                    VIRTIO_NET_F_MTU=TPasRISCVUInt64(1) shl 3;
                    VIRTIO_NET_F_MAC=TPasRISCVUInt64(1) shl 5;
                    VIRTIO_NET_F_GUEST_TSO4=TPasRISCVUInt64(1) shl 7;
                    VIRTIO_NET_F_GUEST_TSO6=TPasRISCVUInt64(1) shl 8;
                    VIRTIO_NET_F_GUEST_ECN=TPasRISCVUInt64(1) shl 9;
                    VIRTIO_NET_F_GUEST_UFO=TPasRISCVUInt64(1) shl 10;
                    VIRTIO_NET_F_HOST_TSO4=TPasRISCVUInt64(1) shl 11;
                    VIRTIO_NET_F_HOST_TSO6=TPasRISCVUInt64(1) shl 12;
                    VIRTIO_NET_F_HOST_ECN=TPasRISCVUInt64(1) shl 13;
                    VIRTIO_NET_F_HOST_UFO=TPasRISCVUInt64(1) shl 14;
                    VIRTIO_NET_F_MRG_RXBUF=TPasRISCVUInt64(1) shl 15;
                    VIRTIO_NET_F_STATUS=TPasRISCVUInt64(1) shl 16;
                    VIRTIO_NET_F_CTRL_VQ=TPasRISCVUInt64(1) shl 17;
                    VIRTIO_NET_F_CTRL_RX=TPasRISCVUInt64(1) shl 18;
                    VIRTIO_NET_F_CTRL_VLAN=TPasRISCVUInt64(1) shl 19;
                    VIRTIO_NET_F_CTRL_RX_EXTRA=TPasRISCVUInt64(1) shl 20;
                    VIRTIO_NET_F_GUEST_ANNOUNCE=TPasRISCVUInt64(1) shl 21;
                    VIRTIO_NET_F_MQ=TPasRISCVUInt64(1) shl 22;
                    VIRTIO_NET_F_CTRL_MAC_ADDR=TPasRISCVUInt64(1) shl 23;
                    VIRTIO_NET_F_HASH_TUNNEL=TPasRISCVUInt64(1) shl 51;
                    VIRTIO_NET_F_VQ_NOTF_COAL=TPasRISCVUInt64(1) shl 52;
                    VIRTIO_NET_F_NOTF_COAL=TPasRISCVUInt64(1) shl 53;
                    VIRTIO_NET_F_GUEST_USO4=TPasRISCVUInt64(1) shl 54;
                    VIRTIO_NET_F_GUEST_USO6=TPasRISCVUInt64(1) shl 55;
                    VIRTIO_NET_F_HOST_USO=TPasRISCVUInt64(1) shl 56;
                    VIRTIO_NET_F_HASH_REPORT=TPasRISCVUInt64(1) shl 57;
                    VIRTIO_NET_F_GUEST_HDRLEN=TPasRISCVUInt64(1) shl 59;
                    VIRTIO_NET_F_RSS=TPasRISCVUInt64(1) shl 60;
                    VIRTIO_NET_F_RSC_EXT=TPasRISCVUInt64(1) shl 61;
                    VIRTIO_NET_F_STANDBY=TPasRISCVUInt64(1) shl 62;
                    VIRTIO_NET_F_SPEED_DUPLEX=TPasRISCVUInt64(1) shl 63;
                    VIRTIO_NET_HDR_F_NEEDS_CSUM=1;
                    VIRTIO_NET_HDR_F_DATA_VALID=2;
                    VIRTIO_NET_HDR_GSO_NONE=0;
                    VIRTIO_NET_HDR_GSO_TCPV4=1;
                    VIRTIO_NET_HDR_GSO_UDP=3;
                    VIRTIO_NET_HDR_GSO_TCPV6=4;
                    VIRTIO_NET_HDR_GSO_ECN=$80;
              type TVirtIONetHeader=packed record
                    Flags:TPasRISCVUInt8;
                    GSOType:TPasRISCVUInt8;
                    HDRLen:TPasRISCVUInt16;
                    GSOSize:TPasRISCVUInt16;
                    CSumStart:TPasRISCVUInt16;
                    CSumOffset:TPasRISCVUInt16;
                    NumBuffers:TPasRISCVUInt16;
                   end;
                   PVirtIONetHeader=^TVirtIONetHeader;
              const HeaderSize=SizeOf(TVirtIONetHeader);
             private
              fEthernetDevice:TPasRISCVEthernetDevice;
              fSendBuffer:TPasRISCVUInt8DynamicArray;
              fReceiveBuffer:TPasRISCVUInt8DynamicArray;
              function CanWritePacket:Boolean;
              procedure WritePacket(const aBuffer:Pointer;const aBufferSize:TPasRISCVSizeInt);
              procedure SetCarrier(const aCarrierStatus:Boolean);
              procedure SetEthernetDevice(const aEthernetDevice:TPasRISCVEthernetDevice);
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure DeviceReset; override;
              function DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean; override;
             public
              property EthernetDevice:TPasRISCVEthernetDevice read fEthernetDevice write SetEthernetDevice;
            end;
            { TVirtIORandomGeneratorDevice }
            TVirtIORandomGeneratorDevice=class(TVirtIODevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10057000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    DefaultIRQ=TPasRISCVUInt64($17);
                    DeviceID=4;
             private
              fSendBuffer:TPasRISCVUInt8DynamicArray;
              fReceiveBuffer:TPasRISCVUInt8DynamicArray;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure DeviceReset; override;
              function DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean; override;
            end;
            { TVirtIOGPUDevice }
            TVirtIOGPUDevice=class(TVirtIODevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10058000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    DefaultIRQ=TPasRISCVUInt64($18);
                    DeviceID=16;
                    // Feature bits
                    VIRTIO_GPU_F_VIRGL=TPasRISCVUInt64(1) shl 0;
                    VIRTIO_GPU_F_EDID=TPasRISCVUInt64(1) shl 1;
                    VIRTIO_GPU_F_RESOURCE_UUID=TPasRISCVUInt64(1) shl 2;
                    VIRTIO_GPU_F_RESOURCE_BLOB=TPasRISCVUInt64(1) shl 3;
                    VIRTIO_GPU_F_CONTEXT_INIT=TPasRISCVUInt64(1) shl 4;
                    // 2D Command types
                    VIRTIO_GPU_CMD_GET_DISPLAY_INFO=$0100;
                    VIRTIO_GPU_CMD_RESOURCE_CREATE_2D=$0101;
                    VIRTIO_GPU_CMD_RESOURCE_UNREF=$0102;
                    VIRTIO_GPU_CMD_SET_SCANOUT=$0103;
                    VIRTIO_GPU_CMD_RESOURCE_FLUSH=$0104;
                    VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D=$0105;
                    VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING=$0106;
                    VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING=$0107;
                    VIRTIO_GPU_CMD_GET_CAPSET_INFO=$0108;
                    VIRTIO_GPU_CMD_GET_CAPSET=$0109;
                    VIRTIO_GPU_CMD_GET_EDID=$010a;
                    // Cursor command types
                    VIRTIO_GPU_CMD_UPDATE_CURSOR=$0300;
                    VIRTIO_GPU_CMD_MOVE_CURSOR=$0301;
                    // Response types (success)
                    VIRTIO_GPU_RESP_OK_NODATA=$1100;
                    VIRTIO_GPU_RESP_OK_DISPLAY_INFO=$1101;
                    VIRTIO_GPU_RESP_OK_CAPSET_INFO=$1102;
                    VIRTIO_GPU_RESP_OK_CAPSET=$1103;
                    VIRTIO_GPU_RESP_OK_EDID=$1104;
                    // Response types (error)
                    VIRTIO_GPU_RESP_ERR_UNSPEC=$1200;
                    VIRTIO_GPU_RESP_ERR_OUT_OF_MEMORY=$1201;
                    VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID=$1202;
                    VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID=$1203;
                    VIRTIO_GPU_RESP_ERR_INVALID_CONTEXT_ID=$1204;
                    VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER=$1205;
                    // Pixel formats
                    VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM=1;
                    VIRTIO_GPU_FORMAT_B8G8R8X8_UNORM=2;
                    VIRTIO_GPU_FORMAT_A8R8G8B8_UNORM=3;
                    VIRTIO_GPU_FORMAT_X8R8G8B8_UNORM=4;
                    VIRTIO_GPU_FORMAT_R8G8B8A8_UNORM=67;
                    VIRTIO_GPU_FORMAT_X8B8G8R8_UNORM=68;
                    VIRTIO_GPU_FORMAT_A8B8G8R8_UNORM=121;
                    VIRTIO_GPU_FORMAT_R8G8B8X8_UNORM=134;
                    // Queue indices
                    VIRTIO_GPU_VQ_CONTROL=0;
                    VIRTIO_GPU_VQ_CURSOR=1;
                    // Scanout
                    VIRTIO_GPU_MAX_SCANOUTS=1;
                    // EDID
                    VIRTIO_GPU_EDID_SIZE=256;
                    // Config event flags
                    VIRTIO_GPU_EVENT_DISPLAY=(1 shl 0);
              type TVirtIOGPUCtrlHeader=packed record
                    CtrlType:TPasRISCVUInt32;
                    Flags:TPasRISCVUInt32;
                    FenceID:TPasRISCVUInt64;
                    CtxID:TPasRISCVUInt32;
                    Padding:TPasRISCVUInt32;
                   end;
                   PVirtIOGPUCtrlHeader=^TVirtIOGPUCtrlHeader;
                   TVirtIOGPURect=packed record
                    X:TPasRISCVUInt32;
                    Y:TPasRISCVUInt32;
                    Width:TPasRISCVUInt32;
                    Height:TPasRISCVUInt32;
                   end;
                   PVirtIOGPURect=^TVirtIOGPURect;
                   TVirtIOGPUDisplayOne=packed record
                    Rect:TVirtIOGPURect;
                    Enabled:TPasRISCVUInt32;
                    Flags:TPasRISCVUInt32;
                   end;
                   PVirtIOGPUDisplayOne=^TVirtIOGPUDisplayOne;
                   TVirtIOGPURespDisplayInfo=packed record
                    Header:TVirtIOGPUCtrlHeader;
                    PModes:array[0..VIRTIO_GPU_MAX_SCANOUTS-1] of TVirtIOGPUDisplayOne;
                   end;
                   PVirtIOGPURespDisplayInfo=^TVirtIOGPURespDisplayInfo;
                   TVirtIOGPUResourceCreate2D=packed record
                    Header:TVirtIOGPUCtrlHeader;
                    ResourceID:TPasRISCVUInt32;
                    Format:TPasRISCVUInt32;
                    Width:TPasRISCVUInt32;
                    Height:TPasRISCVUInt32;
                   end;
                   PVirtIOGPUResourceCreate2D=^TVirtIOGPUResourceCreate2D;
                   TVirtIOGPUResourceUnref=packed record
                    Header:TVirtIOGPUCtrlHeader;
                    ResourceID:TPasRISCVUInt32;
                    Padding:TPasRISCVUInt32;
                   end;
                   PVirtIOGPUResourceUnref=^TVirtIOGPUResourceUnref;
                   TVirtIOGPUSetScanout=packed record
                    Header:TVirtIOGPUCtrlHeader;
                    Rect:TVirtIOGPURect;
                    ScanoutID:TPasRISCVUInt32;
                    ResourceID:TPasRISCVUInt32;
                   end;
                   PVirtIOGPUSetScanout=^TVirtIOGPUSetScanout;
                   TVirtIOGPUResourceFlush=packed record
                    Header:TVirtIOGPUCtrlHeader;
                    Rect:TVirtIOGPURect;
                    ResourceID:TPasRISCVUInt32;
                    Padding:TPasRISCVUInt32;
                   end;
                   PVirtIOGPUResourceFlush=^TVirtIOGPUResourceFlush;
                   TVirtIOGPUTransferToHost2D=packed record
                    Header:TVirtIOGPUCtrlHeader;
                    Rect:TVirtIOGPURect;
                    Offset:TPasRISCVUInt64;
                    ResourceID:TPasRISCVUInt32;
                    Padding:TPasRISCVUInt32;
                   end;
                   PVirtIOGPUTransferToHost2D=^TVirtIOGPUTransferToHost2D;
                   TVirtIOGPUMemEntry=packed record
                    Addr:TPasRISCVUInt64;
                    Length:TPasRISCVUInt32;
                    Padding:TPasRISCVUInt32;
                   end;
                   PVirtIOGPUMemEntry=^TVirtIOGPUMemEntry;
                   TVirtIOGPUResourceAttachBacking=packed record
                    Header:TVirtIOGPUCtrlHeader;
                    ResourceID:TPasRISCVUInt32;
                    NrEntries:TPasRISCVUInt32;
                   end;
                   PVirtIOGPUResourceAttachBacking=^TVirtIOGPUResourceAttachBacking;
                   TVirtIOGPUResourceDetachBacking=packed record
                    Header:TVirtIOGPUCtrlHeader;
                    ResourceID:TPasRISCVUInt32;
                    Padding:TPasRISCVUInt32;
                   end;
                   PVirtIOGPUResourceDetachBacking=^TVirtIOGPUResourceDetachBacking;
                   TVirtIOGPUGetEDID=packed record
                    Header:TVirtIOGPUCtrlHeader;
                    Scanout:TPasRISCVUInt32;
                    Padding:TPasRISCVUInt32;
                   end;
                   PVirtIOGPUGetEDID=^TVirtIOGPUGetEDID;
                   TVirtIOGPURespEDID=packed record
                    Header:TVirtIOGPUCtrlHeader;
                    Size:TPasRISCVUInt32;
                    Padding:TPasRISCVUInt32;
                    EDID:array[0..VIRTIO_GPU_EDID_SIZE-1] of TPasRISCVUInt8;
                   end;
                   PVirtIOGPURespEDID=^TVirtIOGPURespEDID;
                   TVirtIOGPUCursorPos=packed record
                    ScanoutID:TPasRISCVUInt32;
                    X:TPasRISCVUInt32;
                    Y:TPasRISCVUInt32;
                    Padding:TPasRISCVUInt32;
                   end;
                   PVirtIOGPUCursorPos=^TVirtIOGPUCursorPos;
                   TVirtIOGPUUpdateCursor=packed record
                    Header:TVirtIOGPUCtrlHeader;
                    Pos:TVirtIOGPUCursorPos;
                    ResourceID:TPasRISCVUInt32;
                    HotX:TPasRISCVUInt32;
                    HotY:TPasRISCVUInt32;
                    Padding:TPasRISCVUInt32;
                   end;
                   PVirtIOGPUUpdateCursor=^TVirtIOGPUUpdateCursor;
                   TVirtIOGPUConfig=packed record
                    EventsRead:TPasRISCVUInt32;
                    EventsClear:TPasRISCVUInt32;
                    NumScanouts:TPasRISCVUInt32;
                    NumCapsets:TPasRISCVUInt32;
                   end;
                   PVirtIOGPUConfig=^TVirtIOGPUConfig;
                   TGPUBackingPage=record
                    Addr:TPasRISCVUInt64;
                    Length:TPasRISCVUInt32;
                   end;
                   TGPUBackingPages=array of TGPUBackingPage;
                   TGPUResource=class
                    public
                     ID:TPasRISCVUInt32;
                     Width:TPasRISCVUInt32;
                     Height:TPasRISCVUInt32;
                     Format:TPasRISCVUInt32;
                     BytesPerPixel:TPasRISCVUInt32;
                     Data:TPasRISCVUInt8DynamicArray;
                     BackingPages:TGPUBackingPages;
                     constructor Create;
                     destructor Destroy; override;
                   end;
                   TGPUResources=array of TGPUResource;
                   TGPUScanout=record
                    ResourceID:TPasRISCVUInt32;
                    Rect:TVirtIOGPURect;
                    Enabled:Boolean;
                   end;
                   TGPUScanouts=array[0..VIRTIO_GPU_MAX_SCANOUTS-1] of TGPUScanout;
             private
              fFrameBuffer:TFrameBufferDevice;
              fGPUConfig:TVirtIOGPUConfig;
              fResources:TGPUResources;
              fResourceCount:TPasRISCVSizeInt;
              fScanouts:TGPUScanouts;
              fRecvBuffer:TPasRISCVUInt8DynamicArray;
              fSendBuffer:TPasRISCVUInt8DynamicArray;
              function FindResource(const aResourceID:TPasRISCVUInt32):TGPUResource;
              function CreateResource(const aResourceID,aWidth,aHeight,aFormat:TPasRISCVUInt32):TGPUResource;
              procedure DestroyResource(const aResourceID:TPasRISCVUInt32);
              procedure DestroyAllResources;
              function GetFormatBytesPerPixel(const aFormat:TPasRISCVUInt32):TPasRISCVUInt32;
              procedure SendResponse(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aData:Pointer;const aSize:TPasRISCVUInt64);
              procedure SendOKNoData(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aHeader:PVirtIOGPUCtrlHeader);
              procedure SendError(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aHeader:PVirtIOGPUCtrlHeader;const aErrorCode:TPasRISCVUInt32);
              procedure HandleGetDisplayInfo(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aHeader:PVirtIOGPUCtrlHeader);
              procedure HandleResourceCreate2D(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUResourceCreate2D);
              procedure HandleResourceUnref(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUResourceUnref);
              procedure HandleSetScanout(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUSetScanout);
              procedure HandleResourceFlush(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUResourceFlush);
              procedure HandleTransferToHost2D(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUTransferToHost2D);
              procedure HandleResourceAttachBacking(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aReadSize:TPasRISCVUInt64);
              procedure HandleResourceDetachBacking(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUResourceDetachBacking);
              procedure HandleGetEDID(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUGetEDID);
              procedure HandleUpdateCursor(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUUpdateCursor);
              procedure HandleMoveCursor(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUUpdateCursor);
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure DeviceReset; override;
              function DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean; override;
             public
              property FrameBuffer:TFrameBufferDevice read fFrameBuffer;
            end;
            { TVirtIORTCDevice }
            TVirtIORTCDevice=class(TVirtIODevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($1005a000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    DefaultIRQ=TPasRISCVUInt64($1b);
                    DeviceID=17;
                    // Message types
                    VIRTIO_RTC_REQ_CFG=$1000;
                    VIRTIO_RTC_REQ_CLOCK_CAP=$1001;
                    VIRTIO_RTC_REQ_CROSS_CAP=$1002;
                    VIRTIO_RTC_REQ_READ=$0001;
                    // Status codes
                    VIRTIO_RTC_S_OK=0;
                    VIRTIO_RTC_S_EOPNOTSUPP=2;
                    VIRTIO_RTC_S_ENODEV=3;
                    VIRTIO_RTC_S_EINVAL=4;
                    VIRTIO_RTC_S_EIO=5;
                    // Clock types
                    VIRTIO_RTC_CLOCK_UTC=0;
                    VIRTIO_RTC_CLOCK_TAI=1;
                    VIRTIO_RTC_CLOCK_MONOTONIC=2;
                    // Struct sizes (packed)
                    SIZE_REQ_HEAD=8;     // le16 msg_type + u8 reserved[6]
                    SIZE_RESP_HEAD=8;    // u8 status + u8 reserved[7]
                    SIZE_REQ_CFG=8;      // just the head
                    SIZE_RESP_CFG=16;    // head(8) + le16 num_clocks + u8 reserved[6]
                    SIZE_REQ_CLOCK_CAP=16; // head(8) + le16 clock_id + u8 reserved[6]
                    SIZE_RESP_CLOCK_CAP=16; // head(8) + u8 type + u8 leap_second_smearing + u8 flags + u8 reserved[5]
                    SIZE_REQ_CROSS_CAP=16; // head(8) + le16 clock_id + u8 hw_counter + u8 reserved[5]
                    SIZE_RESP_CROSS_CAP=16; // head(8) + u8 flags + u8 reserved[7]
                    SIZE_REQ_READ=16;    // head(8) + le16 clock_id + u8 reserved[6]
                    SIZE_RESP_READ=16;   // head(8) + le64 clock_reading
             private
              fSendBuffer:TPasRISCVUInt8DynamicArray;
              fReceiveBuffer:TPasRISCVUInt8DynamicArray;
              fMonotonicEpoch:TDateTime;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure DeviceReset; override;
              function DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean; override;
            end;
            { TVirtIOVSockDevice }
            TVirtIOVSockDevice=class(TVirtIODevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10059000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    DefaultIRQ=TPasRISCVUInt64($19);
                    DefaultGuestCID=TPasRISCVUInt64(3);
                    VSOCK_DEVICE_ID=19;
                    VSOCK_CID_HOST=2;
                    VSOCK_HDR_SIZE=44;
                    VSOCK_EVENT_SIZE=4;
                    VIRTIO_VSOCK_TYPE_STREAM=1;
                    VIRTIO_VSOCK_TYPE_SEQPACKET=2;
                    VIRTIO_VSOCK_OP_INVALID=0;
                    VIRTIO_VSOCK_OP_REQUEST=1;
                    VIRTIO_VSOCK_OP_RESPONSE=2;
                    VIRTIO_VSOCK_OP_RST=3;
                    VIRTIO_VSOCK_OP_SHUTDOWN=4;
                    VIRTIO_VSOCK_OP_RW=5;
                    VIRTIO_VSOCK_OP_CREDIT_UPDATE=6;
                    VIRTIO_VSOCK_OP_CREDIT_REQUEST=7;
                    VIRTIO_VSOCK_SHUTDOWN_F_RECEIVE=1;
                    VIRTIO_VSOCK_SHUTDOWN_F_SEND=2;
                    VIRTIO_VSOCK_SEQ_EOM=1 shl 0;
                    VIRTIO_VSOCK_SEQ_EOR=1 shl 1;
                    VIRTIO_VSOCK_F_STREAM=TPasRISCVUInt64(1) shl 0;
                    VIRTIO_VSOCK_F_SEQPACKET=TPasRISCVUInt64(1) shl 1;
                    VIRTIO_VSOCK_EVENT_TRANSPORT_RESET=0;
                    VSOCK_RXQ=0;
                    VSOCK_TXQ=1;
                    VSOCK_EVQ=2;
                    VSOCK_DEFAULT_BUF_ALLOC=256*1024;
                    VSOCK_MAX_PKT_BUF_SIZE=64*1024;
              type TVSockHeader=packed record
                    SrcCID:TPasRISCVUInt64;
                    DstCID:TPasRISCVUInt64;
                    SrcPort:TPasRISCVUInt32;
                    DstPort:TPasRISCVUInt32;
                    Len:TPasRISCVUInt32;
                    SocketType:TPasRISCVUInt16;
                    Op:TPasRISCVUInt16;
                    Flags:TPasRISCVUInt32;
                    BufAlloc:TPasRISCVUInt32;
                    FwdCnt:TPasRISCVUInt32;
                   end;
                   PVSockHeader=^TVSockHeader;
                   TVSockEvent=packed record
                    ID:TPasRISCVUInt32;
                   end;
                   PVSockEvent=^TVSockEvent;
                   TVSockConnectionState=
                    (
                     Closed,
                     Connecting,
                     PeerConnecting,
                     Connected,
                     Closing
                    );
                   TVSockConnection=class
                    public
                     LocalPort:TPasRISCVUInt32;
                     RemoteCID:TPasRISCVUInt64;
                     RemotePort:TPasRISCVUInt32;
                     State:TVSockConnectionState;
                     SocketType:TPasRISCVUInt16;
                     BufAlloc:TPasRISCVUInt32;
                     FwdCnt:TPasRISCVUInt32;
                     TxCnt:TPasRISCVUInt32;
                     PeerBufAlloc:TPasRISCVUInt32;
                     PeerFwdCnt:TPasRISCVUInt32;
                     ShutdownFlags:TPasRISCVUInt32;
                     PeerShutdownFlags:TPasRISCVUInt32;
                     LastFwdCntReported:TPasRISCVUInt32;
                   end;
                   TVSockConnections=array of TVSockConnection;
                   TOnVSockConnect=procedure(const aSender:TVirtIOVSockDevice;const aLocalPort,aRemotePort:TPasRISCVUInt32;const aSocketType:TPasRISCVUInt16) of object;
                   TOnVSockConnected=procedure(const aSender:TVirtIOVSockDevice;const aLocalPort,aRemotePort:TPasRISCVUInt32;const aSocketType:TPasRISCVUInt16;const aAccepted:Boolean) of object;
                   TOnVSockDisconnect=procedure(const aSender:TVirtIOVSockDevice;const aLocalPort,aRemotePort:TPasRISCVUInt32) of object;
                   TOnVSockReceive=procedure(const aSender:TVirtIOVSockDevice;const aLocalPort,aRemotePort:TPasRISCVUInt32;const aSocketType:TPasRISCVUInt16;const aData:Pointer;const aSize:TPasRISCVUInt32;const aFlags:TPasRISCVUInt32) of object;
             private
              fGuestCID:TPasRISCVUInt64;
              fConnections:TVSockConnections;
              fConnectionCount:TPasRISCVSizeInt;
              fConnectionLock:TPasMPSlimReaderWriterLock;
              fSendBuffer:TPasRISCVUInt8DynamicArray;
              fRecvBuffer:TPasRISCVUInt8DynamicArray;
              fOnConnect:TOnVSockConnect;
              fOnConnected:TOnVSockConnected;
              fOnDisconnect:TOnVSockDisconnect;
              fOnReceive:TOnVSockReceive;
              function FindConnection(const aLocalPort:TPasRISCVUInt32;const aRemoteCID:TPasRISCVUInt64;const aRemotePort:TPasRISCVUInt32):TVSockConnection;
              function CreateConnection(const aLocalPort:TPasRISCVUInt32;const aRemoteCID:TPasRISCVUInt64;const aRemotePort:TPasRISCVUInt32;const aSocketType:TPasRISCVUInt16):TVSockConnection;
              procedure DestroyConnection(const aConnection:TVSockConnection);
              procedure DestroyAllConnections;
              procedure SendControlPacket(const aConnection:TVSockConnection;const aOp:TPasRISCVUInt16;const aFlags:TPasRISCVUInt32=0);
              procedure WriteRxPacket(const aHeader:TVSockHeader;const aData:Pointer;const aSize:TPasRISCVUInt32);
              procedure WriteEvent(const aEventID:TPasRISCVUInt32);
              procedure HandleRequest(var aHeader:TVSockHeader);
              procedure HandleResponse(var aHeader:TVSockHeader);
              procedure HandleRW(var aHeader:TVSockHeader;const aPayload:Pointer);
              procedure HandleShutdown(var aHeader:TVSockHeader);
              procedure HandleRST(var aHeader:TVSockHeader);
              procedure HandleCreditUpdate(var aHeader:TVSockHeader);
              procedure HandleCreditRequest(var aHeader:TVSockHeader);
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure DeviceReset; override;
              function DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean; override;
              procedure AcceptConnection(const aRemotePort,aLocalPort:TPasRISCVUInt32);
              procedure RejectConnection(const aRemotePort,aLocalPort:TPasRISCVUInt32);
              procedure Connect(const aLocalPort,aRemotePort:TPasRISCVUInt32;const aSocketType:TPasRISCVUInt16=VIRTIO_VSOCK_TYPE_STREAM);
              procedure CloseConnection(const aRemotePort,aLocalPort:TPasRISCVUInt32);
              procedure SendPacket(const aRemotePort,aLocalPort:TPasRISCVUInt32;const aData:Pointer;const aSize:TPasRISCVUInt32;const aFlags:TPasRISCVUInt32=0);
              procedure SendData(const aRemotePort,aLocalPort:TPasRISCVUInt32;const aData:Pointer;const aSize:TPasRISCVUInt32;const aEOR:Boolean=false);
              procedure SendTransportReset;
             published
              property GuestCID:TPasRISCVUInt64 read fGuestCID write fGuestCID;
              property OnConnect:TOnVSockConnect read fOnConnect write fOnConnect;
              property OnConnected:TOnVSockConnected read fOnConnected write fOnConnected;
              property OnDisconnect:TOnVSockDisconnect read fOnDisconnect write fOnDisconnect;
              property OnReceive:TOnVSockReceive read fOnReceive write fOnReceive;
            end;
            { TUARTDevice }
            TUARTDevice=class(TBusDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10000000);
                    DefaultSize=TPasRISCVUInt64($100);
                    DefaultIRQ=TPasRISCVUInt64($0a);
                    rhr=0;
                    thr=0;
                    dll=0;
                    ier=1;
                    dlm=1;
                    isr=2;
                    fcr=2;
                    lcr=3;
                    mcr=4;
                    lsr=5;
                    msr=6;
                    scr=7;
                    lsr_dr=$1;
                    lsr_thre=$20;
                    lsr_temt=$40;
                    ier_rdi=$01;
                    ier_thri=$02;
                    lcr_dlab=$80;
                    isr_no_int=$01;
                    isr_thri=$02;
                    isr_rdi=$04;
                    iir_none=$01;
                    iir_thr=$02;
                    iir_recv=$04;
                    iir_fifo=$c0;
              type TCharQueue=TPasMPSingleProducerSingleConsumerBoundedQueue<AnsiChar>;
{$if defined(PasRISCVUseRealConsole)}
                   { TUARTInputThread }
                   TUARTInputThread=class(TPasMPThread)
{$if defined(Windows) and not defined(fpc)}
                    private
                     fConsoleInputHandle:Windows.THANDLE;
{$ifend}
                    private
                     fUARTDevice:TUARTDevice;
                     fEvent:TEvent;
                    protected
                     procedure Execute; override;
                    public
                     constructor Create(const aUARTDevice:TUARTDevice); reintroduce;
                     destructor Destroy; override;
                     procedure Shutdown;
                   end;
                   { TUARTOutputThread }
                   TUARTOutputThread=class(TPasMPThread)
                    private
                     fUARTDevice:TUARTDevice;
                     fEvent:TEvent;
                     fBuffer:Array[0..4095] of AnsiChar;
{$if defined(Windows) and not defined(fpc)}
                     fConsoleOutputHandle:Windows.THANDLE;
{$ifend}
                    protected
                     procedure Execute; override;
                    public
                     constructor Create(const aUARTDevice:TUARTDevice); reintroduce;
                     destructor Destroy; override;
                     procedure Shutdown;
                   end;
{$ifend}
             private
              fIRQ:TPasRISCVUInt64;
              fDLL:TPasRISCVUInt32;
              fDLM:TPasRISCVUInt32;
              fISR:TPasRISCVUInt32;
              fIER:TPasRISCVUInt32;
              fFCR:TPasRISCVUInt32;
              fLCR:TPasRISCVUInt32;
              fMCR:TPasRISCVUInt32;
              fMSR:TPasRISCVUInt32;
              fSCR:TPasRISCVUInt32;
              fInputQueue:TCharQueue;
              fOutputRingBuffer:TPasMPSingleProducerSingleConsumerRingBuffer;
{$if defined(PasRISCVUseRealConsole)}
{$if defined(fpc) and defined(Unix)}
              fOriginalTerm:TTermios;
{$ifend}
              fUARTInputThread:TUARTInputThread;
              fUARTOutputThread:TUARTOutputThread;
{$else}
              fOutputEvent:TPasMPEvent;
{$ifend}
              function Poll:TPasRISCVUInt32;
              function ReadChar:TPasRISCVUInt32;
              procedure WriteChar(const aValue:TPasRISCVUInt32);
              procedure DispatchInterrupt(const aFlags:TPasRISCVUInt32);
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
              procedure Notify;
             public
              property InputQueue:TCharQueue read fInputQueue;
              property OutputRingBuffer:TPasMPSingleProducerSingleConsumerRingBuffer read fOutputRingBuffer;
{$if not defined(PasRISCVUseRealConsole)}
              property OutputEvent:TPasMPEvent read fOutputEvent;
{$ifend}
            end;
            { TDS1742Device } // DS1742 RTC
            TDS1742Device=class(TBusDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($101000);
                    DefaultSize=TPasRISCVUInt64($8);
                    REG_CTL_CENT=$0; // Control, Century
                    REG_SECONDS=$1;  // Seconds [0, 59]
                    REG_MINUTES=$2;  // Minutes [0, 59]
                    REG_HOURS=$3;    // Hours [0, 23]
                    REG_DAY=$4;      // Day of week [1, 7]
                    REG_DATE=$5;     // Day of month [1, 31]
                    REG_MONTH=$6;    // Month [1, 12]
                    REG_YEAR=$7;     // Year [0, 99]
                    DAY_BATT=$80;    // Battery OK
                    CTL_READ=$40;    // Lock registers for read
                    CTL_MASK=$c0;    // Mask of control registers
             private
              fCtl:TPasRISCVUInt8;
              fRegisters:array[0..7] of TPasRISCVUInt8;
              class function ConvertBCD(const aValue:TPasRISCVUInt8):TPasRISCVUInt8; static;
              class function ConvertFromBCD(const aValue:TPasRISCVUInt8):TPasRISCVUInt8; static;
              procedure UpdateRegisters;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TGoldfishRTCDevice }
            TGoldfishRTCDevice=class(TBusDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($101000);
                    DefaultSize=TPasRISCVUInt64($24);
                    DefaultIRQ=TPasRISCVUInt64($0b);
                    REG_TIME_LOW=$00;
                    REG_TIME_HIGH=$04;
                    REG_ALARM_LOW=$08;
                    REG_ALARM_HIGH=$0c;
                    REG_IRQ_ENABLED=$10;
                    REG_CLEAR_ALARM=$14;
                    REG_ALARM_STATUS=$18;
                    REG_CLEAR_INTERRUPT=$1c;
             private
              fIRQ:TPasRISCVUInt64;
              fTickOffset:TPasRISCVInt64;   // ns offset so that GetCount returns ns since epoch
              fTimeHigh:TPasRISCVUInt32;    // latched high word
              fAlarmNext:TPasRISCVUInt64;
              fAlarmRunning:Boolean;
              fIRQEnabled:Boolean;
              fIRQPending:Boolean;
              function GetCount:TPasRISCVUInt64;
              procedure UpdateIRQ;
              procedure CheckAlarm;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TFrameBufferDevice }
            TFrameBufferDevice=class
             public
              const CURSOR_SIZE=64;
                    CURSOR_PIXELS=CURSOR_SIZE*CURSOR_SIZE;
                    CURSOR_BYTES=CURSOR_PIXELS*4;
              type TCursor=record
                    Data:array[0..CURSOR_BYTES-1] of TPasRISCVUInt8;
                    X:TPasRISCVInt32;
                    Y:TPasRISCVInt32;
                    HotX:TPasRISCVInt32;
                    HotY:TPasRISCVInt32;
                    Visible:Boolean;
                   end;
                   PCursor=^TCursor;
             private
              fMachine:TPasRISCV;
              fLock:TPasMPMultipleReaderSingleWriterLock;
              fActive:Boolean;
              fAutomaticRefresh:Boolean;
              fWidth:TPasRISCVUInt32;
              fHeight:TPasRISCVUInt32;
              fBytesPerPixel:TPasRISCVUInt32;
              fData:TPasRISCVUInt8DynamicArray;
              fRGBA32Data:TPasRISCVUInt8DynamicArray;
              fComposited:TPasRISCVUInt8DynamicArray;
              fCursor:TCursor;
              fCursorCompositing:Boolean;
              fDirectRGBA32:Boolean;
              fSwapColorChannels:Boolean;
              fDirty:TPasMPBool32;
              fIgnoreDirty:TPasMPBool32;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure ResizeFrameBuffer(const aWidth,aHeight,aBytesPerPixel:TPasRISCVUInt32);
              procedure ClearFrameBuffer;
              function CheckDirtyAndFlush:Boolean;
              procedure MarkDirty;
              procedure SetCursorImage(const aData:Pointer;const aSize:TPasRISCVUInt32);
              procedure SetCursorPosition(const aX,aY:TPasRISCVInt32);
              procedure SetCursorHotspot(const aHotX,aHotY:TPasRISCVInt32);
              procedure SetCursorVisible(const aVisible:Boolean);
              procedure CompositeCursor;
              procedure ConvertToRGBA32(const aSrc:TPasRISCVUInt8DynamicArray);
              procedure UpdateOutputData;
              function GetOutputData:TPasRISCVUInt8DynamicArray;
             public
              property Machine:TPasRISCV read fMachine;
              property Data:TPasRISCVUInt8DynamicArray read fData write fData;
              property Composited:TPasRISCVUInt8DynamicArray read fComposited;
              property OutputData:TPasRISCVUInt8DynamicArray read GetOutputData;
              property Cursor:TCursor read fCursor;
              property CursorCompositing:Boolean read fCursorCompositing write fCursorCompositing;
              property Active:Boolean read fActive write fActive;
              property AutomaticRefresh:Boolean read fAutomaticRefresh write fAutomaticRefresh;
              property DirectRGBA32:Boolean read fDirectRGBA32 write fDirectRGBA32;
              property SwapColorChannels:Boolean read fSwapColorChannels write fSwapColorChannels;
              property Width:TPasRISCVUInt32 read fWidth;
              property Height:TPasRISCVUInt32 read fHeight;
              property BytesPerPixel:TPasRISCVUInt32 read fBytesPerPixel;
              property Lock:TPasMPMultipleReaderSingleWriterLock read fLock;
              property Dirty:TPasMPBool32 read fDirty write fDirty;
              property IgnoreDirty:TPasMPBool32 read fIgnoreDirty write fIgnoreDirty;
            end;
            { TSimpleFBDevice }
            TSimpleFBDevice=class(TBusDevice)
             public
              const FrameReadyAddress=0;
                    ActiveAddress=4;
                    ResolutionAddress=8;
                    BytesPerPixelAddress=12;
                    WidthAddress=16;
                    HeightAddress=20;
                    FrameBufferAddress=$1000;
             private
              fFrameBuffer:TFrameBufferDevice;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
             public
              property FrameBuffer:TFrameBufferDevice read fFrameBuffer;
            end;
            { TSharedMemoryDevice }
            TSharedMemoryDevice=class(TBusDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($2f000000);
                    DefaultSize=TPasRISCVUInt64($100000); // 1 MB
                    DefaultIRQ=TPasRISCVUInt64($1a); // 26
                    REG_DOORBELL=$00;
                    REG_HOST_FLAGS=$04;
                    REG_GUEST_FLAGS=$08;
                    REG_SIZE=$0C;
                    REG_IRQ_STATUS=$10;
                    REG_IRQ_ACK=$14;
                    DATA_OFFSET=$40;
              type TOnDoorbell=procedure(const aSender:TSharedMemoryDevice;const aValue:TPasRISCVUInt32) of object;
             private
              fIRQ:TPasRISCVUInt64;
              fLock:TPasMPMultipleReaderSingleWriterLock;
              fData:TPasRISCVUInt8DynamicArray;
              fDataSize:TPasRISCVUInt64;
              fHostFlags:TPasRISCVUInt32;
              fGuestFlags:TPasRISCVUInt32;
              fIRQStatus:TPasRISCVUInt32;
              fOnDoorbell:TOnDoorbell;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
              procedure RingDoorbell;
              function GetDataPointer:Pointer;
             public
              property Data:TPasRISCVUInt8DynamicArray read fData;
              property DataPointer:Pointer read GetDataPointer;
              property DataSize:TPasRISCVUInt64 read fDataSize;
              property Lock:TPasMPMultipleReaderSingleWriterLock read fLock;
             published
              property HostFlags:TPasRISCVUInt32 read fHostFlags write fHostFlags;
              property GuestFlags:TPasRISCVUInt32 read fGuestFlags;
              property OnDoorbellEvent:TOnDoorbell read fOnDoorbell write fOnDoorbell;
            end;
            { TRawKeyboardDevice }
            TRawKeyboardDevice=class(TBusDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10008000);
                    DefaultSize=TPasRISCVUInt64($1000);
                    CountKeyCodes=1024;
                    CountModifiers=8;
                    MOD_SHIFT=TPasRISCVUInt64(1) shl 0;
                    MOD_CTRL=TPasRISCVUInt64(1) shl 1;
                    MOD_ALT=TPasRISCVUInt64(1) shl 2;
                    MOD_GUI=TPasRISCVUInt64(1) shl 3;
                    MOD_CAPS=TPasRISCVUInt64(1) shl 4;
                    MOD_NUM=TPasRISCVUInt64(1) shl 5;
                    MOD_SCROLL=TPasRISCVUInt64(1) shl 6;
                    KeyArraySize=(CountKeyCodes+7) shr 3;
                    KeyArraySizeMask=KeyArraySize-1;
                    KeyArrayAddress=0;
                    ModifiersAddress=KeyArraySize;
                    ModifiersSize=(CountModifiers+7) shr 3;
              type TData=array[0..(KeyArraySize+ModifiersSize)-1] of TPasRISCVUInt8;
                   PData=^TData;
             private
              fData:TData;
              fPointerToData:PData;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
              procedure KeyDown(const aKeyCode:TPasRISCVUInt64);
              procedure KeyUp(const aKeyCode:TPasRISCVUInt64);
              procedure ModifierDown(const aModifier:TPasRISCVUInt64);
              procedure ModifierUp(const aModifier:TPasRISCVUInt64);
             public
              property Data:PData read fPointerToData;
            end;
            TI2CDevice=class;
            { TI2CBusDevice }
            TI2CBusDevice=class
             private
              fMachine:TPasRISCV;
              fI2CDevice:TI2CDevice;
              fIndex:TPasRISCVSizeInt;
              fAddress:TPasRISCVUInt16;
             public
              constructor Create(const aI2CDevice:TI2CDevice); reintroduce; virtual;
              destructor Destroy; override;
              function Start(const aIsWrite:Boolean):Boolean; virtual;
              procedure Stop; virtual;
              function Read(out aValue:TPasRISCVUInt8):Boolean; virtual;
              function Write(const aValue:TPasRISCVUInt8):Boolean; virtual;
            end;
            TI2CBusDevices=array of TI2CBusDevice;
            TI2CBusDeviceAddressMap=array[TPasRISCVUInt16] of TI2CBusDevice;
            { TI2CHIDBusDevice }
            TI2CHIDBusDevice=class(TI2CBusDevice)
             public
              const wHIDDescLength=0;
                    bcdVersion=1;
                    wReportDescLength=2;
                    wReportDescRegister=3;
                    wInputRegister=4;
                    wMaxInputLength=5;
                    wOutputRegister=6;
                    wMaxOutputLength=7;
                    wCommandRegister=8;
                    wDataRegister=9;
                    wVendorID=10;
                    wProductID=11;
                    wVersionID=12;
                    DESC_REG=1;
                    REPORT_REG=2;
                    INPUT_REG=3;
                    OUTPUT_REG=4;
                    COMMAND_REG=5;
                    DATA_REG=6;
                    COMMAND_RESET=1;
                    COMMAND_GET_REPORT=2;
                    COMMAND_SET_REPORT=3;
                    COMMAND_GET_IDLE=4;
                    COMMAND_SET_IDLE=5;
                    COMMAND_GET_PROTOCOL=6;
                    COMMAND_SET_PROTOCOL=7;
                    COMMAND_SET_POWER=8;
                    REPORT_TYPE_INPUT=1;
                    REPORT_TYPE_OUTPUT=2;
                    REPORT_TYPE_FEATURE=3;
                    HID_PROTOCOL_BOOT=0;
                    HID_PROTOCOL_REPORT=1;
                    HID_POWER_ON=0;
                    HID_POWER_SLEEP=1;
              type { TReportIDQueue }
                   TReportIDQueue=record
                    private
                     fFirst:TPasRISCVInt16;
                     fLast:TPasRISCVInt16;
                     fList:array[TPasRISCVUInt8] of TPasRISCVInt16;
                    public
                     procedure Initialize;
                     procedure Insert(const aReportID:TPasRISCVUInt8);
                     function Get:TPasRISCVInt16;
                     procedure RemoveAt(const aReportID:TPasRISCVUInt8);
                   end;
                   PReportIDQueue=^TReportIDQueue;
             private
              fLock:TPasMPSlimReaderWriterLock;
              fIRQ:TPasRISCVUInt32;
              fReportIDQueue:TReportIDQueue;
              fIsWrite:Boolean;
              fIOOffset:TPasRISCVInt32;
              fRegister:TPasRISCVUInt16;
              fCommand:TPasRISCVUInt8;
              fReportType:TPasRISCVUInt8;
              fReportID:TPasRISCVUInt8;
              fDataSize:TPasRISCVUInt16;
              fDataValue:TPasRISCVUInt16;
              fIsReset:Boolean;
              fReportDescriptor:TPasRISCVUInt8DynamicArray;
              fMaxInputSize:TPasRISCVUInt16;
              fMaxOutputSize:TPasRISCVUInt16;
              fVendorID:TPasRISCVUInt16;
              fProductID:TPasRISCVUInt16;
              fVersionID:TPasRISCVUInt16;
             public
              constructor Create(const aI2CDevice:TI2CDevice); override;
              destructor Destroy; override;
              procedure HIDReset; virtual;
              procedure HIDInputAvailable(const aReportID:TPasRISCVUInt8); virtual;
              procedure HIDReadReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;out aValue:TPasRISCVUInt8); virtual;
              procedure HIDWriteReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8); virtual;
              procedure HIDGetIdle(const aReportID:TPasRISCVUInt8;out aIdle:TPasRISCVUInt16); virtual;
              procedure HIDSetIdle(const aReportID:TPasRISCVUInt8;const aIdle:TPasRISCVUInt16); virtual;
              procedure HIDGetProtocol(out aProtocol:TPasRISCVUInt16); virtual;
              procedure HIDSetProtocol(const aProtocol:TPasRISCVUInt16); virtual;
              procedure HIDSetPower(const aPower:TPasRISCVUInt16); virtual;
              procedure Reset(const aIsInit:Boolean);
              procedure InputAvailable(const aReportID:TPasRISCVUInt8);
              function ReadDataSize(const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8):Boolean;
              procedure ReadReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;out aValue:TPasRISCVUInt8);
              function WriteReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8):Boolean;
              function ReadRegister(const aRegister:TPasRISCVUInt16;const aOffset:TPasRISCVUInt32):TPasRISCVUInt8;
              function WriteRegister(const aRegister:TPasRISCVUInt16;const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8):Boolean;
              function Start(const aIsWrite:Boolean):Boolean; override;
              procedure Stop; override;
              function Read(out aValue:TPasRISCVUInt8):Boolean; override;
              function Write(const aValue:TPasRISCVUInt8):Boolean; override;
            end;
            { TDS1307I2CBusDevice }
            TDS1307I2CBusDevice=class(TI2CBusDevice)
             public
              const DS1307_ADDRESS=$68;
                    REG_SECONDS=$00;
                    REG_MINUTES=$01;
                    REG_HOURS=$02;
                    REG_DAY=$03;
                    REG_DATE=$04;
                    REG_MONTH=$05;
                    REG_YEAR=$06;
                    REG_CONTROL=$07;
                    BIT_CH=$80; // Clock Halt (bit 7 of seconds register)
                    COUNT_REGS=8;
             private
              fRegisters:array[0..63] of TPasRISCVUInt8; // 8 time regs + 56 bytes NVRAM
              fRegPointer:TPasRISCVUInt8;
              fWriteState:TPasRISCVUInt8; // 0=expect reg pointer, 1=writing data
              class function ToBCD(const aValue:TPasRISCVUInt8):TPasRISCVUInt8; static;
              class function FromBCD(const aValue:TPasRISCVUInt8):TPasRISCVUInt8; static;
              procedure UpdateRegisters;
             public
              constructor Create(const aI2CDevice:TI2CDevice); override;
              destructor Destroy; override;
              function Start(const aIsWrite:Boolean):Boolean; override;
              procedure Stop; override;
              function Read(out aValue:TPasRISCVUInt8):Boolean; override;
              function Write(const aValue:TPasRISCVUInt8):Boolean; override;
            end;
            { TI2CHIDKeyboardBusDevice }
            TI2CHIDKeyboardBusDevice=class(TI2CHIDBusDevice)
             public
              const Address=1;
                    IRQ=TPasRISCVUInt64($0c);
                    CountMaximumPressedKeys=6;
                    ReportDescriptor:array[0..62] of TPasRISCVUInt8=
                     (
                      $05,$01,     // Usage Page (Generic Desktop)
                      $09,$06,     // Usage (Keyboard)
                      $a1,$01,     // Collection (Application)
                      $75,$01,     //   Report Size (1)
                      $95,$08,     //   Report Count (8)
                      $05,$07,     //   Usage Page (Key Codes)
                      $19,$e0,     //   Usage Minimum (224)
                      $29,$e7,     //   Usage Maximum (231)
                      $15,$00,     //   Logical Minimum (0)
                      $25,$01,     //   Logical Maximum (1)
                      $81,$02,     //   Input (Data, Variable, Absolute)
                      $95,$01,     //   Report Count (1)
                      $75,$08,     //   Report Size (8)
                      $81,$01,     //   Input (Constant)
                      $95,$05,     //   Report Count (5)
                      $75,$01,     //   Report Size (1)
                      $05,$08,     //   Usage Page (LEDs)
                      $19,$01,     //   Usage Minimum (1)
                      $29,$05,     //   Usage Maximum (5)
                      $91,$02,     //   Output (Data, Variable, Absolute)
                      $95,$01,     //   Report Count (1)
                      $75,$03,     //   Report Size (3)
                      $91,$01,     //   Output (Constant)
                      $95,$06,     //   Report Count (6)
                      $75,$08,     //   Report Size (8)
                      $15,$00,     //   Logical Minimum (0)
                      $25,$ff,     //   Logical Maximum (255)
                      $05,$07,     //   Usage Page (Key Codes)
                      $19,$00,     //   Usage Minimum (0)
                      $29,$ff,     //   Usage Maximum (255)
                      $81,$00,     //   Input (Data, Array)
                      $c0          // End Collection
                     );
             private
              fInputReport:array[0..9] of TPasRISCVUInt8;
              fOutputReport:array[0..2] of TPasRISCVUInt8;
              fKeysPressedRow:array[0..7] of TPasRISCVUInt32;
              fKeysPressed:array[0..7] of TPasRISCVUInt32;
              fLEDs:TPasRISCVUInt32;
             public
              constructor Create(const aI2CDevice:TI2CDevice); override;
              destructor Destroy; override;
              procedure HIDReset; override;
              procedure HIDFillPressedKeys(const aPressed:PPasRISCVUInt8);
              procedure HIDReadReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;out aValue:TPasRISCVUInt8); override;
              procedure HIDWriteReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8); override;
              procedure HandleKeyboard(const aKey:TPasRISCVUInt32;const aDown:Boolean);
            end;
            { TI2CDevice - base class for I2C controllers }
            TI2CDevice=class(TBusDevice)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10020000);
                    IRQ=TPasRISCVUInt64($0d);
                    AUTO_ADDR=0;
             protected
              fLock:TPasMPSlimReaderWriterLock;
              fBusDevices:TI2CBusDevices;
              fCountBusDevices:TPasRISCVSizeInt;
              fBusDeviceAddressMap:TI2CBusDeviceAddressMap;
             public
              constructor Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64); reintroduce; virtual;
              destructor Destroy; override;
              procedure AttachBusDevice(const aI2CBusDevice:TI2CBusDevice);
              procedure DetachBusDevice(const aI2CBusDevice:TI2CBusDevice);
              function GetBusDevice(const aAddress:TPasRISCVUInt16):TI2CBusDevice;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TOpenCoresI2CDevice }
            TOpenCoresI2CDevice=class(TI2CDevice)
             public
              const DefaultSize=TPasRISCVUInt64($14);
                    CLKLO=$00; // Clock prescale low byte
                    CLKHI=$04; // Clock prescale high byte
                    CTR=$08; // Control register
                    TXRXR=$0c; // Transmit & Receive register (W/R)
                    CRSR=$10; // Command & Status Register (W/R)
                    CTR_MASK=$c0; // Mask of legal bits
                    CTR_EN=$80; // Core enable bit
                    CTR_IEN=$40; // Interrupt enable bit
                    CR_STA=$80; // Generate (repeated) start condition
                    CR_STO=$40; // Generate stop condition
                    CR_RD=$20; // Read from slave
                    CR_WR=$10; // Write to slave
                    CR_ACK=$08; // Send ACK (0) or NACK (1) to master
                    CR_IACK=$01; // Interrupt acknowledge, clear a pending IRQ
                    SR_ACK=$80; // Received ACK from slave (0), NACK is 1
                    SR_BSY=$40; // I2C bus busy
                    SR_AL=$20; // Arbitration lost
                    SR_TIP=$02; // Transfer in progress
                    SR_IF=$01; // Interrupt flag
             private
              fSelectedAddress:TPasRISCVUInt16;
              fClock:TPasRISCVUInt16;
              fControl:TPasRISCVUInt8;
              fStatus:TPasRISCVUInt8;
              fTXByte:TPasRISCVUInt8;
              fRXByte:TPasRISCVUInt8;
              procedure DispatchInterrupt;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TDesignWareI2CDevice - Synopsys DesignWare I2C controller }
            TDesignWareI2CDevice=class(TI2CDevice)
             public
              const DefaultSize=TPasRISCVUInt64($100);
                    // Register offsets
                    DW_IC_CON=$00;
                    DW_IC_TAR=$04;
                    DW_IC_SAR=$08;
                    DW_IC_DATA_CMD=$10;
                    DW_IC_SS_SCL_HCNT=$14;
                    DW_IC_SS_SCL_LCNT=$18;
                    DW_IC_FS_SCL_HCNT=$1c;
                    DW_IC_FS_SCL_LCNT=$20;
                    DW_IC_INTR_STAT=$2c;
                    DW_IC_INTR_MASK=$30;
                    DW_IC_RAW_INTR_STAT=$34;
                    DW_IC_RX_TL=$38;
                    DW_IC_TX_TL=$3c;
                    DW_IC_CLR_INTR=$40;
                    DW_IC_CLR_RX_UNDER=$44;
                    DW_IC_CLR_RX_OVER=$48;
                    DW_IC_CLR_TX_OVER=$4c;
                    DW_IC_CLR_RD_REQ=$50;
                    DW_IC_CLR_TX_ABRT=$54;
                    DW_IC_CLR_RX_DONE=$58;
                    DW_IC_CLR_ACTIVITY=$5c;
                    DW_IC_CLR_STOP_DET=$60;
                    DW_IC_CLR_START_DET=$64;
                    DW_IC_CLR_GEN_CALL=$68;
                    DW_IC_ENABLE=$6c;
                    DW_IC_STATUS=$70;
                    DW_IC_TXFLR=$74;
                    DW_IC_RXFLR=$78;
                    DW_IC_SDA_HOLD=$7c;
                    DW_IC_TX_ABRT_SOURCE=$80;
                    DW_IC_SDA_SETUP=$94;
                    DW_IC_ACK_GENERAL_CALL=$98;
                    DW_IC_ENABLE_STATUS=$9c;
                    DW_IC_FS_SPKLEN=$a0;
                    DW_IC_HS_SPKLEN=$a4;
                    DW_IC_CLR_RESTART_DET=$a8;
                    DW_IC_COMP_PARAM_1=$f4;
                    DW_IC_COMP_VERSION=$f8;
                    DW_IC_COMP_TYPE=$fc;
                    // IC_CON bits
                    IC_CON_MASTER_MODE=$01;
                    IC_CON_SPEED_SS=$02;
                    IC_CON_SPEED_FS=$04;
                    IC_CON_SPEED_MASK=$06;
                    IC_CON_10BITADDR_SLAVE=$08;
                    IC_CON_10BITADDR_MASTER=$10;
                    IC_CON_RESTART_EN=$20;
                    IC_CON_SLAVE_DISABLE=$40;
                    IC_CON_STOP_DET_IFADDRESSED=$80;
                    IC_CON_TX_EMPTY_CTRL=$100;
                    // IC_DATA_CMD bits
                    IC_DATA_CMD_READ=$100;
                    IC_DATA_CMD_STOP=$200;
                    IC_DATA_CMD_RESTART=$400;
                    // Interrupt bits
                    IC_INTR_RX_UNDER=$001;
                    IC_INTR_RX_OVER=$002;
                    IC_INTR_RX_FULL=$004;
                    IC_INTR_TX_OVER=$008;
                    IC_INTR_TX_EMPTY=$010;
                    IC_INTR_RD_REQ=$020;
                    IC_INTR_TX_ABRT=$040;
                    IC_INTR_RX_DONE=$080;
                    IC_INTR_ACTIVITY=$100;
                    IC_INTR_STOP_DET=$200;
                    IC_INTR_START_DET=$400;
                    IC_INTR_GEN_CALL=$800;
                    IC_INTR_RESTART_DET=$1000;
                    // IC_STATUS bits
                    IC_STATUS_ACTIVITY=$01;
                    IC_STATUS_TFNF=$02;
                    IC_STATUS_TFE=$04;
                    IC_STATUS_RFNE=$08;
                    IC_STATUS_RFF=$10;
                    IC_STATUS_MST_ACTIVITY=$20;
                    // FIFO depth
                    RX_FIFO_DEPTH=16;
                    TX_FIFO_DEPTH=16;
                    // Component identification
                    DW_IC_COMP_TYPE_VALUE=TPasRISCVUInt32($44570140);
                    DW_IC_COMP_VERSION_VALUE=TPasRISCVUInt32($3230312a);
                    // COMP_PARAM_1: 32-bit APB, fast mode, INTR_IO, encoded params, 16-entry FIFOs
                    DW_IC_COMP_PARAM_1_VALUE=TPasRISCVUInt32($000f0faa);
             private
              fCon:TPasRISCVUInt32;
              fTar:TPasRISCVUInt16;
              fSar:TPasRISCVUInt16;
              fEnable:TPasRISCVUInt32;
              fIntrMask:TPasRISCVUInt32;
              fRawIntrStat:TPasRISCVUInt32;
              fRxTL:TPasRISCVUInt8;
              fTxTL:TPasRISCVUInt8;
              fSSHCNT:TPasRISCVUInt16;
              fSSLCNT:TPasRISCVUInt16;
              fFSHCNT:TPasRISCVUInt16;
              fFSLCNT:TPasRISCVUInt16;
              fSDAHold:TPasRISCVUInt32;
              fSDASetup:TPasRISCVUInt8;
              fTxAbrtSource:TPasRISCVUInt32;
              fFSSpkLen:TPasRISCVUInt8;
              fHSSpkLen:TPasRISCVUInt8;
              fAckGeneralCall:TPasRISCVUInt8;
              // RX FIFO
              fRxFIFO:array[0..RX_FIFO_DEPTH-1] of TPasRISCVUInt8;
              fRxFIFOHead:TPasRISCVUInt8;
              fRxFIFOTail:TPasRISCVUInt8;
              fRxFIFOCount:TPasRISCVUInt8;
              // Transaction state
              fTransactionActive:Boolean;
              fTransactionIsWrite:Boolean;
              fSelectedAddress:TPasRISCVUInt16;
              procedure RxFIFOPush(const aValue:TPasRISCVUInt8);
              function RxFIFOPop:TPasRISCVUInt8;
              procedure UpdateInterrupts;
              procedure ProcessDataCmd(const aValue:TPasRISCVUInt32);
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TPS2Device }
            TPS2Device=class(TBusDevice)
             public
              const DefaultSize=TPasRISCVUInt64($8);
                    REG_DATA=$0;
                    REG_CTRL=$4;
                    CTRL_RE=$1;
                    CTRL_RI=$100;
                    CTRL_CE=$400;
                    DATA_RVALID=$8000;
             private
              fLock:TPasMPSlimReaderWriterLock;
              fIRQ:TPasRISCVUInt32;
              fControl:TPasRISCVUInt32;
             public
              constructor Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64); reintroduce; virtual;
              destructor Destroy; override;
              function Read(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt; virtual;
              function Write(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt; virtual;
              function Poll:TPasRISCVSizeInt; virtual;
              procedure Notify(const aFlags:TPasRISCVUInt32); virtual;
              procedure Update; virtual;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64; override;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64); override;
            end;
            { TPS2KeyboardDevice }
            TPS2KeyboardDevice=class(TPS2Device)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10010000);
                    DefaultIRQ=TPasRISCVUInt64($05);
                    CMD_RESET=$ff;
                    CMD_RESEND=$fe;
                    CMD_SET_DEFAULTS=$f6;
                    CMD_DISABLE_DATA_REPORTING=$f5;
                    CMD_ENABLE_DATA_REPORTING=$f4;
                    CMD_SET_SAMPLE_RATE=$f3;
                    CMD_GET_DEV_ID=$f2;
                    CMD_SET_SCAN_CODE_SET=$f0;
                    CMD_ECHO=$ee;
                    CMD_LEDS=$ed;
                    RSP_ACK=$fa;
                    RSP_NAK=$fe;
                    STATE_CMD=$0;
                    STATE_SET_SAMPLE_RATE=$1;
                    STATE_SET_SCAN_CODE_SET=$2;
                    STATE_SET_LEDS=$3;
                    RateToRealRate:array[0..31] of TPasRISCVUInt16=(300,267,240,218,200,185,171,160,150,133,120,109,100,92,86,80,75,67,60,55,50,46,43,40,37,33,30,28,25,23,21,20);
             private
              fActive:Boolean;
              fKeyState:array[0..31] of TPasRISCVUInt8;
              fState:TPasRISCVUInt8;
              fRate:TPasRISCVUInt8;
              fDelay:TPasRISCVUInt8;
              fReporting:Boolean;
              fLastKey:TPasRISCVRawByteString;
              fRingBuffer:TPasMPSingleProducerSingleConsumerRingBuffer;
              fHIDToPS2ByteMap:array[TPasRISCVUInt8] of TPasRISCVUInt8;
              fTimer:TPasRISCV.TTimer;
              fTimeCmp:TPasRISCVUInt64;
              procedure RingBufferWrite(const aData:TPasRISCVUInt8);
              function RingBufferRead(out aData:TPasRISCVUInt8):Boolean;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              procedure Update; override;
              procedure SetRate(const aRate:TPasRISCVUInt8);
              procedure ResetToDefaults;
              function Command(const aCmd:TPasRISCVUInt8):Boolean;
              function Read(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt; override;
              function Write(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt; override;
              function HIDToPS2KeyCode(const aKey:TPasRISCVUInt32):TPasRISCVRawByteString;
              procedure HandleKeyboard(const aKey:TPasRISCVUInt32;const aPressed:Boolean);
            end;
            { TPS2MouseDevice }
            TPS2MouseDevice=class(TPS2Device)
             public
              const DefaultBaseAddress=TPasRISCVUInt64($10011000);
                    DefaultIRQ=TPasRISCVUInt64($06);
                    BTN_LEFT=1;
                    BTN_RIGHT=2;
                    BTN_MIDDLE=4;
                    CMD_RESET=$ff;
                    CMD_RESEND=$fe;
                    CMD_SET_DEFAULTS=$f6;
                    CMD_DISABLE_DATA_REPORTING=$f5;
                    CMD_ENABLE_DATA_REPORTING=$f4;
                    CMD_SET_SAMPLE_RATE=$f3;
                    CMD_GET_DEV_ID=$f2;
                    CMD_SET_REMOTE_MODE=$f0;
                    CMD_SET_WRAP_MODE=$ee;
                    CMD_RESET_WRAP_MODE=$ec;
                    CMD_READ_DATA=$eb;
                    CMD_SET_STREAM_MODE=$ea;
                    CMD_STATUS_REQ=$e9;
                    CMD_SET_RESOLUTION=$e8;
                    CMD_SET_SCALING_2_1=$e7;
                    CMD_SET_SCALING_1_1=$e6;
                    RSP_ACK=$fa;
                    RSP_NAK=$fe;
                    STATE_CMD=$0;
                    STATE_SET_SAMPLE_RATE=$1;
                    STATE_WRAP=$2;
                    STATE_SET_RESOLUTION=$3;
                    MODE_STREAM=$0;
                    MODE_REMOTE=$1;
                    MOUSE_GENERIC=$0;
                    MOUSE_WHEEL=$3;
             private
              fActive:Boolean;
              fButtons:TPasRISCVUInt32;
              fResolutionInitialized:Boolean;
              fX:TPasRISCVInt32;
              fY:TPasRISCVInt32;
              fXMovementCounter:TPasRISCVInt16;
              fYMovementCounter:TPasRISCVInt16;
              fXOverflow:Boolean;
              fYOverflow:Boolean;
              fScroll:TPasRISCVInt32;
              fMode:TPasRISCVUInt8;
              fState:TPasRISCVUInt8;
              fResolution:TPasRISCVUInt8;
              fRate:TPasRISCVUInt8;
              fWheelDetect:TPasRISCVUInt8;
              fReporting:Boolean;
              fRingBuffer:TPasMPSingleProducerSingleConsumerRingBuffer;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              procedure Reset; override;
              procedure ResetToDefaults;
              procedure Flush;
              procedure MovePacket;
              function Command(const aCmd:TPasRISCVUInt8):Boolean;
              function Read(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt; override;
              function Write(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt; override;
              procedure ButtonPress(const aButtons:TPasRISCVUInt32);
              procedure ButtonRelease(const aButtons:TPasRISCVUInt32);
              procedure Scroll(const aOffset:TPasRISCVInt32);
              procedure RelativeMove(const aDeltaX,aDeltaY:TPasRISCVInt32);
              procedure AbsoluteMove(const aX,aY:TPasRISCVInt32);
            end;
            { TBus }
            TBus=class
             public
             private
              fMachine:TPasRISCV;
              fBusDevices:TBusDeviceArray;
              fCountBusDevices:TPasRISCVUInt64;
              function LoadUnaligned(const aBusDevice:TBusDevice;const aAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
              function StoreUnaligned(const aBusDevice:TBusDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function GetAutoMemoryAddress(const aAddress,aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure AddBusDevice(const aBusDevice:TBusDevice);
              procedure RemoveBusDevice(const aBusDevice:TBusDevice);
              function FindBusDevice(const aAddress:TPasRISCVUInt64):TBusDevice;
              function GetDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
              function Fetch(const aHART:THART;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              function Load(const aHART:THART;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure Store(const aHART:THART;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
              function LoadEx(const aAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
              function StoreEx(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
              procedure Step;
            end;
            { THART }
            THART=class
             public
              type TMode=
                    (
                     User=0,
                     Supervisor=1, // Also used for HS-mode (V=0) and VS-mode (V=1) in the H-extension.
                                   // The H-extension does not introduce a separate Hypervisor privilege level;
                                   // instead, HS-mode and VS-mode are distinguished by the VirtualMode (V) bit.
                     Hypervisor=2, // Reserved/unused in the H-extension — kept for encoding compatibility only.
                     Machine=3,
                     Invalid=255
                    );
                   TExceptionValue=
                    (
                     DebuggerBreakpoint=-2,
                     None=-1,
                     InstructionAddressMisaligned=0,
                     InstructionAccessFault=1,
                     IllegalInstruction=2,
                     Breakpoint=3,
                     LoadAddressMisaligned=4,
                     LoadAccessFault=5,
                     StoreAddressMisaligned=6,
                     StoreAccessFault=7,
                     ECallUMode=8,
                     ECallSMode=9,
                     ECallVSMode=10,
                     ECallMMode=11,
                     InstructionPageFault=12,
                     LoadPageFault=13,
                     Reserved=14,
                     StorePageFault=15,
                     InstructionGuestPageFault=20,
                     LoadGuestPageFault=21,
                     VirtualInstruction=22,
                     StoreGuestPageFault=23
                    );
                   { TException }
                   TException=class(Exception)
                    private
                     fExceptionValue:TExceptionValue;
                     fExceptionData:TPasRISCVUInt64;
                     fExceptionPC:TPasRISCVUInt64;
                    public
                     constructor Create(const aExceptionValue:TExceptionValue;const aExceptionData,aExceptionPC:TPasRISCVUInt64); reintroduce;
                     destructor Destroy; override;
                    published
                     property ExceptionValue:TExceptionValue read fExceptionValue;
                     property ExceptionData:TPasRISCVUInt64 read fExceptionData;
                     property ExceptionPC:TPasRISCVUInt64 read fExceptionPC;
                   end;
                   TInterruptValue=
                    (
                     None=-1,                    // No Interrupt
                     UserSoftware=0,             // User Software Interrupt
                     SupervisorSoftware=1,       // S-mode Software Interrupt (ACLINT-SSWI)
                     HypervisorSoftware=2,       // H-mode Software Interrupt
                     MachineSoftware=3,          // M-mode Software Interrupt (ACLINT-MSWI)
                     UserTimer=4,                // User Timer Interrupt
                     SupervisorTimer=5,          // S-mode Timer Interrupt (Sstc)
                     HypervisorTimer=6,          // H-mode Timer Interrupt
                     MachineTimer=7,             // M-mode Timer Interrupt (ACLINT-MTIMER)
                     UserExternal=8,             // User External Interrupt
                     SupervisorExternal=9,       // S-mode External Interrupt (PLIC)
                     HypervisorExternal=10,      // H-mode External Interrupt
                     MachineExternal=11,         // M-mode External Interrupt (PLIC)
                     Reserved=12,                // Reserved
                     LocalCounterOverflow=13     // Local Counter Overflow (Sscofpmf)
                    );
                   PInterruptValue=^TInterruptValue;
                   TInterruptValueMasks=class
                    public
                     const UserSoftware=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.UserSoftware);
                           SupervisorSoftware=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.SupervisorSoftware);
                           HypervisorSoftware=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.HypervisorSoftware);
                           MachineSoftware=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.MachineSoftware);
                           UserTimer=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.UserTimer);
                           SupervisorTimer=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.SupervisorTimer);
                           HypervisorTimer=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.HypervisorTimer);
                           MachineTimer=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.MachineTimer);
                           UserExternal=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.UserExternal);
                           SupervisorExternal=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.SupervisorExternal);
                           HypervisorExternal=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.HypervisorExternal);
                           MachineExternal=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.MachineExternal);
                           Reserved=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.Reserved);
                           LocalCounterOverflow=TPasRISCVUInt64(1) shl TPasRISCVUInt32(TInterruptValue.LocalCounterOverflow);
                   end;
                   TFClass=class
                    public
                     const NEG_INF=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 0);
                           NEG_NORMAL=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 1);
                           NEG_SUBNORMAL=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 2);
                           NEG_ZERO=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 3);
                           POS_ZERO=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 4);
                           POS_SUBNORMAL=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 5);
                           POS_NORMAL=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 6);
                           POS_INF=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 7);
                           NAN_SIG=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 8);
                           NAN_QUIET=TPasRISCVUInt32(TPasRISCVUInt32(1) shl 9);
                   end;
                   { TCSR }
                   TCSR=record
                    public
                     const ENVCFG_CBIE=TPasRISCVUInt64(1) shl 4;
                           ENVCFG_CBCFE=TPasRISCVUInt64(1) shl 6;
                           ENVCFG_CBZE=TPasRISCVUInt64(1) shl 7;
                           ENVCFG_PMM=TPasRISCVUInt64($300000000); // bits 33:32
                           ENVCFG_ADUE=TPasRISCVUInt64(1) shl 61;
                           ENVCFG_PBMTE=TPasRISCVUInt64(1) shl 62;
                           ENVCFG_STCE=TPasRISCVUInt64(1) shl 63;
                           MSECCFG_USEED=TPasRISCVUInt64(1) shl 8;
                           MSECCFG_SSEED=TPasRISCVUInt64(1) shl 9;
                           CSR_FFLAGS_MASK=$1f;
                           CSR_FRM_MASK=$7;
                           CSR_FCSR_MASK=$ff;
                           CSR_STATUS_FS_MASK=$6000;
                           CSR_MEDELEG_MASK=TPasRISCVUInt64($f0b3ff); // H-ext: includes guest page faults (20-23) + virtual instruction (22)
                           CSR_HEDELEG_MASK=TPasRISCVUInt64($b1ff); // Same minus guest page faults and VS ecall
                           CSR_MIDELEG_MASK=TPasRISCVUInt64($2222);
                           CSR_HIDELEG_MASK=TPasRISCVUInt64($0222); // S-level IRQs delegatable to VS
                           CSR_MEIP_MASK=TPasRISCVUInt64($2aaa);
                           CSR_SEIP_MASK=TPasRISCVUInt64($2222);
                           CSR_MENVCFG_MASK=TPasRISCVUInt64($e0000003000000d0);
                           CSR_SENVCFG_MASK=TPasRISCVUInt64($3000000d0);
                           CSR_MSECCFG_MASK=$300;
                           HVICTL_VTI=TPasRISCVUInt64(1) shl 30;
                           HVICTL_IID_MASK=TPasRISCVUInt64($0fff0000); // bits [27:16]
                           HVICTL_IID_SHIFT=16;
                           HVICTL_DPR=TPasRISCVUInt64(1) shl 9;
                           HVICTL_IPRIOM=TPasRISCVUInt64(1) shl 8;
                           HVICTL_IPRIO_MASK=TPasRISCVUInt64($ff); // bits [7:0]
                           HVICTL_VALID_MASK=TPasRISCVUInt64($40ff03ff); // VTI | IID | DPR | IPRIOM | IPRIO;
                           COUNTEREN_TM=TPasRISCVUInt64($2); // Bit 1: TM (Time) counter enable
                           MNSTATUS_NMIE=$8;
                           MNSTATUS_MNPV=$80;
                           MNSTATUS_MNPP=$1800;
                           // Indirect CSRs
                           CSRI_MIPRIO_0=$30;
                           CSRI_MIPRIO_15=$3f;
                           CSRI_EIDELIVERY=$70;
                           CSRI_EITHRESHOLD=$72;
                           CSRI_EIP0=$80;
                           CSRI_EIP63=$bf;
                           CSRI_EIE0=$c0;
                           CSRI_EIE63=$ff;
                     type TAddress=class
                           public
                            const USTATUS=$0;
                                  FFLAGS=$1;
                                  FRM=$2;
                                  FCSR=$3;
                                  UVEC=$5;
                                  SEED=$15; // (Zkr)
                                  UEPC=$41;
                                  UCAUSE=$42;
                                  UTVAL=$43;
                                  SSTATUS=$100;
                                  SEDELEG=$102;
                                  SIDELEG=$103;
                                  SIE=$104;
                                  STVEC=$105;
                                  SCOUNTEREN=$106;
                                  SENVCFG=$10a;
                                  SSCRATCH=$140;
                                  SEPC=$141;
                                  SCAUSE=$142;
                                  STVAL=$143;
                                  SIP=$144;
                                  STIMECMP=$14d;
                                  SISELECT=$150;
                                  SIREG=$151;
                                  SIREG2=$152;
                                  SIREG3=$153;
                                  SIREG4=$154;
                                  SIREG5=$155;
                                  SIREG6=$156;
                                  SIREG7=$157;
                                  STOPEI=$15c;
                                  STIMECMPH=$15d;
                                  SCOUNTOVF=$da0; // Sscofpmf: Counter overflow status
                                  SATP=$180;
                                  // H-extension CSRs
                                  HSTATUS=$600;
                                  HEDELEG=$602;
                                  HIDELEG=$603;
                                  HIE=$604;
                                  HTIMEDELTA=$605;
                                  HCOUNTEREN=$606;
                                  HGEIE=$607;
                                  HVICTL=$609;
                                  HENVCFG=$60a;
                                  HENVCFGH=$61a;
                                  HTIMEDELTAH=$615;
                                  HTVAL=$643;
                                  HIP=$644;
                                  HVIP=$645;
                                  HTINST=$64a;
                                  HGATP=$680;
                                  HGEIP=$e12;
                                  // H-extension: VS-mode CSRs
                                  VSSTATUS=$200;
                                  VSIE=$204;
                                  VSTVEC=$205;
                                  VSSCRATCH=$240;
                                  VSEPC=$241;
                                  VSCAUSE=$242;
                                  VSTVAL=$243;
                                  VSIP=$244;
                                  VSTIMECMP=$24d;
                                  VSATP=$280;
                                  // Ssstateen CSRs
                                  SSTATEEN0=$10c;
                                  SSTATEEN1=$10d;
                                  SSTATEEN2=$10e;
                                  SSTATEEN3=$10f;
                                  MSTATEEN0=$30c;
                                  MSTATEEN1=$30d;
                                  MSTATEEN2=$30e;
                                  MSTATEEN3=$30f;
                                  HSTATEEN0=$60c;
                                  HSTATEEN1=$60d;
                                  HSTATEEN2=$60e;
                                  HSTATEEN3=$60f;
                                  MSTATUS=$300;
                                  MISA=$301;
                                  MEDELEG=$302;
                                  MIDELEG=$303;
                                  MIE=$304;
                                  MTVEC=$305;
                                  MCOUNTEREN=$306;
                                  MENVCFG=$30a;
                                  MSTATUSH=$310;
                                  MEDELEGH=$312;
                                  MENVCFGH=$31a;
                                  MCOUNTINHIBIT=$320;
                                  MSCRATCH=$340;
                                  MEPC=$341;
                                  MCAUSE=$342;
                                  MTVAL=$343;
                                  MIP=$344;
                                  MTINST=$34a; // H-extension: M-level trap instruction value
                                  MTVAL2=$34b; // H-extension: M-level trap value 2 (GPA >> 2)
                                  MISELECT=$350;
                                  MIREG=$351;
                                  MIREG2=$352;
                                  MIREG3=$353;
                                  MIREG4=$354;
                                  MIREG5=$355;
                                  MIREG6=$356;
                                  MIREG7=$357;
                                  MTOPEI=$35c;
                                  MNSCRATCH=$740;
                                  MNEPC=$741;
                                  MNCAUSE=$742;
                                  MNSTATUS=$744;
                                  MSECCFG=$747;
                                  MSECCFGH=$757;
                                  TSELECT=$7a0;
                                  TDATA1=$7a1;
                                  TDATA2=$7a2;
                                  TINFO=$7a4;
                                  DCSR=$7b0;
                                  DPC=$7b1;
                                  DSCRATCH0=$7b2;
                                  DSCRATCH2=$7b3;
                                  MCYCLE=$b00;
                                  MCYCLEH=$b80;
                                  MINSTRET=$b02;
                                  MINSTRETH=$b82;
                                  CYCLE=$c00;
                                  CYCLEH=$c80;
                                  INSTRET=$c02;
                                  INSTRETH=$c82;
                                  TIME=$c01;
                                  TIMEMS=$c10;
                                  TIMEH=$c81;
                                  STOPI=$db0;
                                  MVENDORID=$f11;
                                  MARCHID=$f12;
                                  MIMPID=$f13;
                                  MHARTID=$f14;
                                  MCONFIGPTR=$f15;
                                  MTOPI=$fb0;
                          end;
                          TMask=class
                           public
                            const MSTATUS=TPasRISCVUInt64($cf007fffaa); // includes MPV (39) and GVA (38)
                                  SSTATUS=TPasRISCVUInt64($3000de722);
                                  HSTATUS_MASK=TPasRISCVUInt64($007003e0); // SPV, SPVP, HU, GVA, VSBE, VTVM, VTW, VTSR (no VSXL: hardwired to 2)
                                  MSTATUS_SWAP_MASK=TPasRISCVUInt64($3000de722); // Bits swapped between HS and VS: SIE,SPIE,SPP,FS,VS,SUM,MXR,UXL
                            type TStatus=class
                                  public
                                   const SIE=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 1);
                                         MIE=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 3);
                                         SPIE=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 5);
                                         UBE=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 6);
                                         SPP=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 8);
                                         FS=TPasRISCVUInt64($6000);
                                         XS=TPasRISCVUInt64($18000);
                                         MPRV=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 17);
                                         SUM=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 18);
                                         MXR=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 19);
                                         TVM=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 20);
                                         TW=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 21);
                                         UXL=TPasRISCVUInt64($300000000);
                                         SD=TPasRISCVUInt64($8000000000000000);//TPasRISCVUInt64(TPasRISCVUInt64(1) shl 63);
                                         //SSTATUS=TPasRISCVUInt64(SIE or SPIE or UBE or SPP or FS or XS or SUM or MXR or UXL or TPasRISCVUInt64(SD));
                                 end;
                                 TSSTATUSBit=class
                                  public
                                   const SIE=1;
                                         SPIE=5;
                                         SPP=8;
                                 end;
                                 TMSTATUSBit=class
                                  public
                                   const MIE=3;
                                         MPIE=7;
                                         MPP=11;
                                         MPRV=17;
                                         SUM=18;
                                         MXR=19;
                                         TVM=20;
                                         TW=21;
                                         TSR=22;
                                         GVA=38;
                                         MPV=39;
                                 end;
                                 THSTATUSBit=class
                                  public
                                   const VSBE=5;
                                         GVA=6;
                                         SPV=7;
                                         SPVP=8;
                                         HU=9;
                                         VGEIN=12;
                                         VTVM=20;
                                         VTW=21;
                                         VTSR=22;
                                         VSXL=32;
                                 end;
                          end;
                          TMISA=class
                           public
                            type TExtension=class
                                  public
                                   const A_EXT=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 0);
                                         C_EXT=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 2);
                                         D_EXT=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 3);
                                         RV32E=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 4);
                                         F_EXT=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 5);
                                         HYPERVISOR=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 7);
                                         RV32I_64I_128I=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 8);
                                         M_EXT=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 12);
                                         N_EXT=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 13);
                                         QUAD_EXT=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 16);
                                         SUPERVISOR=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 18);
                                         USER=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 20);
                                         NON_STD_PRESENT=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 22);
                                         XLEN_32=TPasRISCVUInt64(TPasRISCVUInt64(1) shl 31);
                                         XLEN_64=TPasRISCVUInt64(TPasRISCVUInt64(2) shl 62);
                                 end;
                          end;
                          TFPUExceptionMasks=class
                           public
                            const Inexact=1 shl 0;
                                  Underflow=1 shl 1;
                                  Overflow=1 shl 2;
                                  DivByZero=1 shl 3;
                                  Invalid=1 shl 4;
                                  Mask=Inexact or Underflow or Overflow or DivByZero or Invalid;
                          end;
                          TFloatingPointRoundingModes=
                           (
                            RoundToNearestEven=0,       // RNE - Round to nearest, ties to even
                            RoundToZero=1,              // RTZ - Round to zero
                            RoundDown=2,                // RDN - Round down - towards -inf
                            RoundUp=3,                  // RUP - Round up - towards +inf
                            RoundNearestMaxMagnitude=4, // RMM - Round to nearest, ties to max magnitude
                            RoundDynamic=7,
                            Mask=1 or 2 or 4
                           );
                          TFS=class
                           public
                            const Off=0;
                                  Initial=1;
                                  Clean=2;
                                  Dirty=3;
                          end;
                    private
                     fHART:THART;
                     fData:array[0..4095] of TPasRISCVUInt64;
                    public
                     procedure Init(const aHART:THART);
                     function Load(const aAddress:TPasRISCVUInt64):TPasRISCVUInt64;
                     procedure Store(const aAddress,aValue:TPasRISCVUInt64);
                     procedure SetFPUException(const aValue:TPasRISCVUInt64);
                     procedure ClearFPUExceptions;
                     procedure SetFPURM(const aValue:TPasRISCVUInt64);
                     procedure ClearFPURM;
                     procedure SetFS(const aValue:TPasRISCVUInt64);
                     function GetFS:TPasRISCVUInt64;
                     procedure ClearFS;
                     procedure SetFSDirty; //inline;
                     function IsFPUEnabled:Boolean;
                   end;
                   PCSR=^TCSR;
                   TState=record
                    public
                     type TBounce=record
                           case TPasRISCVUInt8 of
                            0:(
                             i32:TPasRISCVInt32;
                            );
                            1:(
                             ui32:TPasRISCVUInt32;
                            );
                            2:(
                             i64:TPasRISCVUInt64;
                            );
                            3:(
                             ui64:TPasRISCVUInt64;
                            );
                            4:(
                             i128:TPasMPInt128Record;
                            );
                            5:(
                             ui128:TPasMPInt128Record;
                            );
                            6:(
                             ui8:TPasRISCVUInt8;
                            );
                            7:(
                             ui16:TPasRISCVUInt16;
                            );
                          end;
                          PBounce=^TBounce;
                    public
                     Registers:TRegisters;
                     FPURegisters:TFPURegisters;
//                   LastPC:TPasRISCVUInt64;
                     PC:TPasRISCVUInt64;
                     Mode:TPasRISCV.THART.TMode;
                     VirtualMode:TPasMPBool32; // H-extension: V bit (VS/VU mode)
                     CSR:TCSR;
                     Sleep:TPasMPBool32;
                     EnablePaging:TPasMPBool32;
                     PageTable:TPasRISCVUInt64;
                     PendingIRQs:TPasRISCVUInt64;
                     ExceptionValue:TExceptionValue;
                     ExceptionData:TPasRISCVUInt64;
                     ExceptionPC:TPasRISCVUInt64;
                     Cycle:TPasRISCVUInt64;
                     LRSC:TPasMPBool32;
                     LRSCCycle:TPasRISCVUInt64;
                     LRSCAddress:TPasRISCVUInt64;
                     LRSCCAS:TPasRISCVUInt64;
                     Bounce:TBounce;
                     CAS128OldValue:TPasMPInt128Record;
                     CAS128NewValue:TPasMPInt128Record;
                     CAS128Result:TPasMPInt128Record;
                     // H-extension: HS-mode backing store (saved while V=1)
                     HSMode_MSTATUS:TPasRISCVUInt64;
                     HSMode_STVEC:TPasRISCVUInt64;
                     HSMode_SSCRATCH:TPasRISCVUInt64;
                     HSMode_SEPC:TPasRISCVUInt64;
                     HSMode_SCAUSE:TPasRISCVUInt64;
                     HSMode_STVAL:TPasRISCVUInt64;
                     HSMode_SATP:TPasRISCVUInt64;
                   end;
                   PState=^TState;
                   TCSROperation=
                    (
                     Swap,
                     SetBits,
                     ClearBits
                    );
                   TCSRHandler=procedure(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation) of object;
                   TCSRHandlerMap=array[0..4095] of TCSRHandler;
                   { TMMU }
                   TMMU=class
                    public
                     const DIRECT_ACCESS_TLB_ENTRIES=TPasRISCVUInt64(256);
                           DIRECT_ACCESS_TLB_MASK=DIRECT_ACCESS_TLB_ENTRIES-1;
                           PAGE_SHIFT=12;
                           VPN_BITS=9;
                           PAGE_VPN_DIFF=PAGE_SHIFT-VPN_BITS;
                           VPN_MASK=$1ff;
                           PPN_BITS=10;
                           PHYSICAL_BITS=56;
                           PHYSICAL_MASK=TPasRISCVUInt64($00ffffffffffffff);
                           PHYSICAL_INVERSE_MASK=TPasRISCVUInt64($ff00000000000000);
                           PAGE_PNMASK=TPasRISCVUInt64($fffffffffffff000);
                     type TAccessType=
                           (
                            Load=0,            //  R
                            Store=1,           //  W
                            Instruction=2,     //  X
                            LoadInstruction=3, // RX - A special case for when MXR is set and the access is a load, for to distinguish it from a normal load at the MMU translation level
                            DebuggerLoad,      // For debugger access
                            DebuggerStore      // For debugger access
                           );
                          PAccessType=^TAccessType;
                          TAccessFlag=
                           (
                            NoTLBUpdate,                  // Do not update the TLB (for example for when the TLB is updated by the caller)
                            NoTrap,                       // Do not trap
                            IgnoreMMUProtection,          // Ignore MMU protection (for debugging, so that the emulator-level debugger can access all memory)
                            TranslateIntoPhysicalAddress, // Translate into physical address
                            DirectMemoryPointer           // Direct Memory Pointer (for example for atomic operations)
                           );
                          PAccessFlag=^TAccessFlag;
                          TAccessFlags=set of TAccessFlag;
                          PAccessFlags=^TAccessFlags;
                     const AccessMasks:array[TAccessType] of TPasRISCVUInt64=  // Access masks corresponding to the MMU page table entry bits
                            (
                             $02, // R-- Read
                             $04, // -W- Write
                             $08, // --X Execute
                             $0a, // R-X Read and Execute (for when MXR is set and the access is a load)
                             $0e, // RWX Read, Write and Execute (for debugger access)
                             $0e  // RWX Read, Write and Execute (for debugger access)
                            );
                           DebugAccessFlags:TAccessFlags=[TAccessFlag.NoTrap,TAccessFlag.IgnoreMMUProtection];
                           AccessWrite:array[TAccessType] of Boolean=  // Access flags corresponding to the write aspect
                            (
                             false, // R-- Read
                             true,  // -W- Write
                             false, // --X Execute
                             false, // R-X Read and Execute (for when MXR is set and the access is a load)
                             false, // RWX Read, Write and Execute (for debugger access)
                             true   // RWX Read, Write and Execute (for debugger access)
                            );
                     type TMMUMode=
                           (
                            None=$00,
                            Invalid1=$01,
                            Invalid2=$02,
                            Invalid3=$03,
                            Invalid4=$04,
                            Invalid5=$05,
                            Invalid6=$06,
                            Invalid7=$07,
                            SV39=$08,
                            SV48=$09,
                            SV57=$0a,
                            InvalidB=$0b,
                            InvalidC=$0c,
                            InvalidD=$0D,
                            InvalidE=$0e,
                            InvalidF=$0f
                           );
                         PMMUMode=^TMMUMode;
                         TPTE=TPasRISCVUInt64;
                         TPTEHelper=record helper for TPTE
                          public
                           const Valid=0;
                                 Read_=1;
                                 Write_=2;
                                 Execute=3;
                                 User=4;
                                 Global=5;
                                 Accessed=6;
                                 Dirty=7;
                         end;
                         PPTE=^TPTE;
                         TPTEMasks=record
                          public
                           const Valid=$01;
                                 Read_=$02;
                                 Write_=$04;
                                 Execute=$08;
                                 Leaf=$0a;
                                 User=$10;
                                 Global=$20;
                                 Accessed=$40;
                                 Dirty=$80;
                                 PBMT=TPasRISCVUInt64($6000000000000000);
                                 N=TPasRISCVUInt64($8000000000000000);
                                 Reserved=TPasRISCVUInt64($1fc0000000000000);
                                 PPN_MASK=TPasRISCVUInt64($3ffffffffffc00);
                                 Attr=TPasRISCVUInt64(N or PBMT);
                         end;
                         TDirectAccessTLBEntry=record
                          Read:TPasRISCVUInt64;
                          Write:TPasRISCVUInt64;
                          Execute:TPasRISCVUInt64;
{$ifdef CombinedDirectAccessTLBCache}
                          RelativeMemory:TPasRISCVPtrUInt;
{$else}
                          RelativeMemoryRead:TPasRISCVPtrUInt;
                          RelativeMemoryWrite:TPasRISCVPtrUInt;
                          RelativeMemoryExecute:TPasRISCVPtrUInt;
{$endif}
                         end;
                         PDirectAccessTLBEntry=^TDirectAccessTLBEntry;
                         TDirectAccessTLBEntries=array[0..DIRECT_ACCESS_TLB_ENTRIES-1] of TDirectAccessTLBEntry;
                         TPNArray=array[0..4] of TPasRISCVUInt64;
                     const ModeLevels:array[TMMUMode] of TPasRISCVUInt64=(0,0,0,0,0,0,0,0,3,4,5,0,0,0,0,0);
                   end;
                   { TAIARegFile }
                   TAIARegFile=class
                    public
                     const IRQ_LIMIT=256;
                           ARRAY_LENGTH=(IRQ_LIMIT+31) shr 5;
                    private
                     fMachine:TPasRISCV;
                     fHART:THART;
                     fEIDelivery:TPasRISCVUInt32;
                     fEIThreshold:TPasRISCVUInt32;
                     fEIP:array[0..ARRAY_LENGTH-1] of TPasRISCVUInt32;
                     fEIE:array[0..ARRAY_LENGTH-1] of TPasRISCVUInt32;
                    public
                     constructor Create(const aMachine:TPasRISCV;const aHART:THART); reintroduce;
                     destructor Destroy; override;
                     procedure Reset;
                   end;
                   TAIARegFiles=array[TAIARegFileMode] of TAIARegFile;
                   { TExecutionThread }
                   TExecutionThread=class(TPasMPThread)
                    private
                     fHART:THART;
                    protected
                     procedure Execute; override;
                    public
                     constructor Create(const aHART:THART); reintroduce;
                     destructor Destroy; override;
                     procedure Shutdown;
                   end;
              const ExceptionNames:array[TExceptionValue] of TPasRISCVUTF8String=
                     (
                      'Debugger breakpoint',
                      'Unknown exception',
                      'Instruction address misaligned',
                      'Instruction access fault',
                      'Illegal instruction',
                      'Breakpoint',
                      'Load address misaligned',
                      'Load access fault',
                      'Store address misaligned',
                      'Store access fault',
                      'Environment call from U-mode',
                      'Environment call from S-mode',
                      'Environment call from H-mode',
                      'Environment call from M-mode',
                      'Instruction page fault',
                      'Load page fault',
                      'Reserved',
                      'Store page fault',
                      'Reserved', // 16
                      'Reserved', // 17
                      'Reserved', // 18
                      'Reserved', // 19
                      'Instruction guest-page fault',
                      'Load guest-page fault',
                      'Virtual instruction',
                      'Store guest-page fault'
                     );
                    InterruptNames:array[TInterruptValue] of TPasRISCVUTF8String=
                     (
                      'Unknown interrupt',
                      'UserSoftware',
                      'SupervisorSoftware',
                      'HypervisorSoftware',
                      'MachineSoftware',
                      'UserTimer',
                      'SupervisorTimer',
                      'HypervisorTimer',
                      'MachineTimer',
                      'UserExternal',
                      'SupervisorExternal',
                      'HypervisorExternal',
                      'MachineExternal',
                      'Reserved',
                      'LocalCounterOverflow'
                     );
             private
              fMachine:TPasRISCV;
              fPHandle:TPasRISCVUInt32;
              fBus:TBus;
              fAIARegFiles:TAIARegFiles;
              fACLINTDevice:TACLINTDevice;
              fMTIMECMP:TPasRISCVUInt64;
              fSTIMECMP:TPasRISCVUInt64;
              fVSTIMECMP:TPasRISCVUInt64;
              fMMUMode:TMMU.TMMUMode;
              fRootPageTable:TPasRISCVUInt64;
              fDirectAccessTLBCache:TMMU.TDirectAccessTLBEntries;
              fState:TState;
              fPointerToState:PState;
              fCSRHandlerMap:TCSRHandlerMap;
              fHARTID:TPasRISCVUInt32;
              fHARTMask:TPasRISCVUInt32;
              fExecutionThread:TExecutionThread;
              fPCG32:TPCG32;
              fWasVirtual:Boolean;
              procedure UpdateMMU;
              function CheckPrivilege(const aCPUMode:THART.TMode;const aAccessType:TMMU.TAccessType):Boolean;
              function AddressTranslate(aVirtualAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType;const aAccessFlags:TMMU.TAccessFlags):TPasRISCVUInt64;
              procedure FlushTLB(const aInterrupt:Boolean);
              procedure FlushTLBPage(const aInterrupt:Boolean;const aAddress:TPasRISCVUInt64);
              procedure TLBPut(const aVirtualAddress:TPasRISCVUInt64;const aTarget:TPasRISCVPtrUInt;const aAccessType:TMMU.TAccessType);
              procedure TLBPutBusDevice(const aVirtualAddress,aPhysicalAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType);
              procedure RaisePhysicalFault(const aAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType);
              procedure RaisePageFault(const aAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType);
              procedure RaiseGuestPageFault(const aGuestAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType);
              function GStageTranslate(const aGuestPhysical:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType;const aIsImplicit:Boolean):TPasRISCVUInt64;
              function ForcedVirtualTranslate(const aGuestVA:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType):TPasRISCVUInt64;
              function Load8(const aAddress:TPasRISCVUInt64):TPasRISCVUInt8; inline;
              procedure LoadRegisterS8(const aRegister:TRegister;const aAddress:TPasRISCVUInt64); inline;
              procedure LoadRegisterU8(const aRegister:TRegister;const aAddress:TPasRISCVUInt64); inline;
              procedure Store8(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt8); inline;
              procedure StoreRegisterU8(const aAddress:TPasRISCVUInt64;const aRegister:TRegister); inline;
              function Load16(const aAddress:TPasRISCVUInt64):TPasRISCVUInt16; inline;
              procedure LoadRegisterS16(const aRegister:TRegister;const aAddress:TPasRISCVUInt64); inline;
              procedure LoadRegisterU16(const aRegister:TRegister;const aAddress:TPasRISCVUInt64); inline;
              procedure Store16(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt16); inline;
              procedure StoreRegisterU16(const aAddress:TPasRISCVUInt64;const aRegister:TRegister); inline;
              function Load32(const aAddress:TPasRISCVUInt64):TPasRISCVUInt32; inline;
              procedure LoadRegisterS32(const aRegister:TRegister;const aAddress:TPasRISCVUInt64); inline;
              procedure LoadRegisterU32(const aRegister:TRegister;const aAddress:TPasRISCVUInt64); inline;
              procedure LoadRegisterF32(const aRegister:TFPURegister;const aAddress:TPasRISCVUInt64); inline;
              procedure Store32(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt32); inline;
              procedure StoreRegisterU32(const aAddress:TPasRISCVUInt64;const aRegister:TRegister); inline;
              procedure StoreRegisterF32(const aAddress:TPasRISCVUInt64;const aRegister:TFPURegister); inline;
              function Load64(const aAddress:TPasRISCVUInt64):TPasRISCVUInt64; //inline;
              procedure LoadRegisterS64(const aRegister:TRegister;const aAddress:TPasRISCVUInt64); inline;
              procedure LoadRegisterU64(const aRegister:TRegister;const aAddress:TPasRISCVUInt64); inline;
              procedure LoadRegisterF64(const aRegister:TFPURegister;const aAddress:TPasRISCVUInt64); inline;
              procedure Store64(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64); //inline;
              procedure StoreRegisterU64(const aAddress:TPasRISCVUInt64;const aRegister:TRegister); inline;
              procedure StoreRegisterF64(const aAddress:TPasRISCVUInt64;const aRegister:TFPURegister); inline;
              function MemoryPointerTranslate(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aBounce:Pointer;const aReadOnly:Boolean):Pointer; //inline;
              procedure RMWCommit(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aBounce:Pointer); //inline;
              function Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
              procedure Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
              function LoadEx(const aAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
              function StoreEx(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
              function IsCSRENVCFGEnabled(const aMask:TPasRISCVUInt64):Boolean;
              class function CSROperation(const aOperation:TCSROperation;const aCSR,aRHS:TPasRISCVUInt64):TPasRISCVUInt64; static; inline;
              procedure CSRHandlerDefault(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerDefaultReadOnly(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerPrivileged(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerPrivilegedReadOnly(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerIllegal(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerEnforcedReadOnly(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerFCSR(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerFFLAGS(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerFRM(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerSATP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerSTATUS(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerSTIMECMP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerVSTIMECMP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerMIE(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerSIE(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerMIP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerSIP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerMTOPI(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerSTOPI(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerMTOPEI(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerSTOPEI(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              // H-extension CSR handlers
              procedure CSRHandlerHPrivileged(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerHPrivilegedReadOnly(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerHSTATUS(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerHIP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerHIE(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerHVIP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerVSCSR(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerVSSTATUS(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerVSIP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerVSIE(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CSRHandlerHGATP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              class function CSRAtomicHelper(const aValue:PPasRISCVUInt32;const aRHS:TPasRISCVUInt64;out aDest:TPasRISCVUInt64;const aOperation:TCSROperation):Boolean; static;
              function CSRAIAHelper(const aMode:TMode;const aAIARegFileMode:TAIARegFileMode;const aValue:PPasRISCVUInt32;const aRHS:TPasRISCVUInt64;out aDest:TPasRISCVUInt64;const aOperation:TCSROperation):Boolean;
              function CSRAIAPairHelper(const aMode:TMode;const aAIARegFileMode:TAIARegFileMode;const aReg:TPasRISCVUInt32;const aValue:Pointer;const aRHS:TPasRISCVUInt64;out aDest:TPasRISCVUInt64;const aOperation:TCSROperation):Boolean;
              procedure CSRHandlerIndirect(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
              procedure CheckTimers;
              procedure CheckInterrupts;
             public
              constructor Create(const aMachine:TPasRISCV;const aHARTID:TPasRISCVUInt32); reintroduce;
              destructor Destroy; override;
              procedure Init;
              procedure SetMode(const aMode:TMode);
              procedure SetException(const aExceptionValue:TExceptionValue;
                                     const aExceptionData:TPasRISCVUInt64;
                                     const aExceptionPC:TPasRISCVUInt64);
              procedure ClearException;
              procedure SetFPUExceptions(const aMask:TPasRISCVUInt32=$3f);
              procedure Breakpoint(const aInstruction:TPasRISCVUInt32);
              function FetchInstruction(const aAddress:TPasRISCVUInt64;out aInstruction:TPasRISCVUInt32):Boolean; //inline;
              function GetInstructionSize(const aInstruction:TPasRISCVUInt32):TPasRISCVUInt64; inline;
              function ExecuteInstruction(const aInstruction:TPasRISCVUInt32):TPasRISCVUInt64;
              function InterruptsRaised:TPasRISCVUInt64; inline;
              function InterruptsPending:TPasRISCVUInt64; inline;
              function InterruptsNotPending:TPasRISCVUInt64; inline;
              procedure ClearInterrupt(const aInterruptValue:TPasRISCV.THART.TInterruptValue);
              procedure RaiseInterrupt(const aInterruptValue:TPasRISCV.THART.TInterruptValue);
              function SetInterrupt(const aInterruptValue:TPasRISCV.THART.TInterruptValue):Boolean;
              procedure SendAIAIRQ(const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aIRQ:TPasRISCVUInt32);
              function UpdateAIAInternal(const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aUpdate,aClaim:Boolean):TPasRISCVUInt32;
              function UpdateAIAState(const aAIARegFileMode:TPasRISCV.TAIARegFileMode):TPasRISCVUInt32;
              function GetAIAIRQ(const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aClaim:Boolean):TPasRISCVUInt32;
              procedure HandleInterrupts;
              procedure ExecuteException;
              procedure SwapHypervisorRegs; // H-extension: swap S↔VS CSRs on V transition
              procedure SetVirtualMode(const aEnabled:Boolean); // H-extension: set V bit
              procedure SleepUntilNextInterrupt;
              procedure SleepPause;
              procedure Execute;
              procedure ThreadProc;
              procedure DumpRegisters;
             public
              property State:PState read fPointerToState;
             published
              property HARTID:TPasRISCVUInt32 read fHARTID;
              property PHandle:TPasRISCVUInt32 read fPHandle;
            end;
            { TDisassembler }
            TDisassembler=class
             public
              type TStyle=
                    (
                     ABI,
                     Raw
                    );
                   TFlag=
                    (
                     HexImmediate,
                     UppercaseMnemonic,
                     AbsoluteTargets,
                     ExplicitSP,
                     CSRNames
                    );
                   TFlags=set of TFlag;
                   TOptions=record
                    Style:TStyle;
                    Flags:TFlags;
                   end;
             private
              fMachine:TPasRISCV;
              fInstructionSet:TInstructionSetArchitecture;
              fOptions:TOptions;
              function GetRegisterName(const aRegister:TRegister):TPasRISCVUTF8String;
              function GetFPURegisterName(const aRegister:TFPURegister):TPasRISCVUTF8String;
              function FormatImmediate(const aValue:TPasRISCVInt64):TPasRISCVUTF8String;
              function FormatUnsignedImmediate(const aValue:TPasRISCVUInt64):TPasRISCVUTF8String;
              function FormatCSR(const aValue:TPasRISCVUInt32):TPasRISCVUTF8String;
              function FormatFenceFlags(const aValue:TPasRISCVUInt32):TPasRISCVUTF8String;
              function FormatRoundingMode(const aValue:TPasRISCVUInt32):TPasRISCVUTF8String;
              function FormatInstruction32(const aAddress:TPasRISCVUInt64;
                                           const aInstruction:TPasRISCVUInt32;
                                           const aDefinition:TInstructionSetArchitecture.TInstruction):TPasRISCVUTF8String;
              function FormatInstruction16(const aAddress:TPasRISCVUInt64;
                                           const aInstruction:TPasRISCVUInt32;
                                           const aDefinition:TInstructionSetArchitecture.TCompressedInstruction):TPasRISCVUTF8String;
             public
              constructor Create(const aMachine:TPasRISCV); reintroduce;
              destructor Destroy; override;
              function DisassembleInstruction(const aAddress:TPasRISCVUInt64;const aInstruction:TPasRISCVUInt32):TPasRISCVUTF8String;
              property Style:TStyle read fOptions.Style write fOptions.Style;
              property Flags:TFlags read fOptions.Flags write fOptions.Flags;
            end;
            { TDebugger }
            TDebugger=class
             public
              const GDB_MAX_PACKET_SIZE=65536;
                    SWBREAK_NONE=0;
                    SWBREAK_TRIGGERED=1;
                    SWBREAK_ACTIVE=2;
                    SWBREAK_PAUSED=3;
              type TOption=
                    (
                     GDBServer,
                     LocalDebugger,
                     LocalCLI,
                     LocalThreaded,
                     LocalInputPolling
                    );
                   TOptions=set of TOption;
                   TOnInput=function(var aString:TPasRISCVRawByteString):Boolean of object;
                   TOnOutput=procedure(const aString:TPasRISCVRawByteString) of object;
                   TOnStopped=procedure(const aReason:TPasRISCVRawByteString;const aHART:TPasRISCVUInt64;const aPC:TPasRISCVUInt64) of object;
                   TOnNotify=procedure of object;
                   TOnError=procedure(const aString:TPasRISCVRawByteString) of object;
                   TBreakpoint=record
                    Address:TPasRISCVUInt64;
                    Size:TPasRISCVUInt64;
                    Original:array[0..3] of TPasRISCVUInt8;
                    Enabled:Boolean;
                   end;
                   TBreakpointMap=TPasRISCVHashMap<TPasRISCVUInt64,TBreakpoint>;
                   TLocalCommandQueue=TPasRISCVThreadSafeDynamicQueue<TPasRISCVRawByteString>;
                   TPacketBuffer=array[0..GDB_MAX_PACKET_SIZE-1] of TPasRISCVUInt8;
                   { TClientThread }
                   TClientThread=class(TPasMPThread)
                    private
                     fDebugger:TDebugger;
                     fSocket:TRNLSocket;
                     fAddress:TRNLAddress;
                     fEvent:TRNLNetworkEvent;
                     fHART:THART;
                     fRecvBuffer:TPacketBuffer;
                     fRecvSize:TPasRISCVSizeInt;
                     fSendBufferString:TPasRISCVRawByteString;
                     class function Hexify(const aNibble:TPasRISCVUInt8):TPasRISCVRawByteChar; static;
                     class function ByteToHex(const aValue:TPasRISCVUInt8):TPasRISCVRawByteString; static;
                     class function LittleEndianBytesToHex(const aData:Pointer;const aBytes:TPasRISCVSizeInt):TPasRISCVRawByteString; static;
                     class function LittleEndianValueToHex(const aValue:TPasRISCVUInt64;const aBytes:TPasRISCVSizeInt):TPasRISCVRawByteString; static;
                     class function HexNibble(const aDigit:TPasRISCVRawByteChar):TPasRISCVUInt8; static;
                     class function HexToByte(const aString:TPasRISCVRawByteString;var aStringPosition:TPasRISCVSizeInt):TPasRISCVUInt8; static;
                     class procedure HexToLittleEndianBytes(const aData:Pointer;const aString:TPasRISCVRawByteString;var aStringPosition:TPasRISCVSizeInt;const aBytes:TPasRISCVSizeInt); static;
                     class function HexToLittleEndianValue(const aString:TPasRISCVRawByteString;var aStringPosition:TPasRISCVSizeInt;const aBytes:TPasRISCVSizeInt):TPasRISCVUInt64; static;
                     procedure Send(const aData:TPasRISCVRawByteString);
                     procedure ReplyACK;
                     procedure ReplyNAK;
                     procedure ResendReply;
                     procedure SendBufferAppend(const aString:TPasRISCVRawByteString);
                     procedure ReplyString(const aString:TPasRISCVRawByteString);
                     procedure ReplyConsole(const aString:TPasRISCVRawByteString);
                     function DecodeHexString(const aHex:TPasRISCVRawByteString;out aDecoded:TPasRISCVRawByteString):Boolean;
                     procedure MonitorOutput(const aString:TPasRISCVRawByteString);
                     procedure MonitorError(const aString:TPasRISCVRawByteString);
                     procedure ProcessMonitorCommand(const aCommand:TPasRISCVRawByteString);
                     procedure ConsumeBytes(const aBytes:TPasRISCVSizeInt);
                     procedure ProcessStep;
                     procedure ProcessContinue;
                     procedure ProcessMemory(const aPacketString:TPasRISCVRawByteString;const aWrite:Boolean);
                     procedure ProcessReadRegisters;
                     procedure ProcessWriteRegisters(const aPacketString:TPasRISCVRawByteString);
                     procedure ProcessSetThread(const aPacketString:TPasRISCVRawByteString);
                     procedure ProcessHaltReason;
                     procedure ProcessQuery(const aPacketString:TPasRISCVRawByteString);
                     procedure ProcessReset;
                     procedure HandlePacket(const aPacketString:TPasRISCVRawByteString);
                     function ParsePacket:Boolean;
                    protected
                     procedure Execute; override;
                    public
                     constructor Create(const aDebugger:TDebugger;const aSocket:TRNLSocket;const aAddress:TRNLAddress); reintroduce;
                     destructor Destroy; override;
                     procedure AfterConstruction; override;
                     procedure BeforeDestruction; override;
                     procedure Shutdown;
                   end;
                   TClientThreadDynamicArray=array of TClientThread;
                   { TServerThread }
                   TServerThread=class(TPasMPThread)
                    private
                     fDebugger:TDebugger;
                     fListenSocket:TRNLSocket;
                    protected
                     procedure Execute; override;
                    public
                     constructor Create(const aDebugger:TDebugger); reintroduce;
                     destructor Destroy; override;
                     procedure Shutdown;
                   end;
                   { TLocalThread }
                   TLocalThread=class(TPasMPThread)
                    private
                     fDebugger:TDebugger;
                    protected
                     procedure Execute; override;
                    public
                     constructor Create(const aDebugger:TDebugger); reintroduce;
                     destructor Destroy; override;
                     procedure Shutdown;
                   end;
             private
              fMachine:TPasRISCV;
              fOptions:TOptions;
              fOnInput:TOnInput;
              fOnOutput:TOnOutput;
              fOnStopped:TOnStopped;
              fOnResumed:TOnNotify;
              fOnStepDone:TOnNotify;
              fOnReset:TOnNotify;
              fOnShutdown:TOnNotify;
              fOnError:TOnError;
              fRNLInstance:TRNLInstance;
              fRNLNetwork:TRNLNetwork;
              fRNLNetworkEvent:TRNLNetworkEvent;
              fClientsInvertedSemaphore:TPasMPInvertedSemaphore;
              fServerAddress:TRNLAddress;
              fLock:TPasMPCriticalSection;
              fBreakpointsLock:TPasMPCriticalSection;
              fClientThreads:TClientThreadDynamicArray;
              fCountClientThreads:TPasRISCVSizeInt;
              fServerThread:TServerThread;
              fLocalThread:TLocalThread;
              fLocalCommandQueue:TLocalCommandQueue;
              fLocalHARTIndex:TPasRISCVUInt64;
              fLastHaltHART:THART;
              fLastHaltPC:TPasRISCVUInt64;
              fLastHaltCycle:TPasRISCVUInt64;
              fLastHaltInstruction:TPasRISCVUInt32;
              fBreakpoints:TBreakpointMap;
              fDisassembler:TDisassembler;
//            fSWBreakState:TPasRISCVInt32;
              fSuppressNotifyPaused:TPasMPInt32;
              fTerminated:Boolean;
              procedure Output(const aString:TPasRISCVRawByteString);
              procedure OutputError(const aString:TPasRISCVRawByteString);
              function DefaultOnInput(var aString:TPasRISCVRawByteString):Boolean;
              procedure DefaultOnOutput(const aString:TPasRISCVRawByteString);
              function GetHARTByIndex(const aIndex:TPasRISCVUInt64):THART;
              function GetLocalHART:THART;
              procedure SetLocalHARTIndex(const aIndex:TPasRISCVUInt64);
              class function HexNibble(const aDigit:TPasRISCVRawByteChar;out aValue:TPasRISCVUInt8):Boolean; static;
              class function ByteToHex(const aValue:TPasRISCVUInt8):TPasRISCVRawByteString; static;
              function ParseUInt64(const aToken:TPasRISCVRawByteString;out aValue:TPasRISCVUInt64):Boolean;
              function ParseAddressToken(const aHART:THART;const aToken:TPasRISCVRawByteString;out aValue:TPasRISCVUInt64):Boolean;
              function FormatFPURegisterValue(const aValue:TFPURegisterValue):TPasRISCVRawByteString;
              function NextToken(const aLine:TPasRISCVRawByteString;var aIndex:TPasRISCVSizeInt):TPasRISCVRawByteString;
              function ReadMemoryByte(const aHART:THART;const aAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt8):Boolean;
              function WriteMemoryByte(const aHART:THART;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt8):Boolean;
              function ReadInstruction(const aHART:THART;const aAddress:TPasRISCVUInt64;out aInstruction:TPasRISCVUInt32;out aSize:TPasRISCVUInt64):Boolean;
              procedure DumpRegisters(const aHART:THART);
              procedure DumpRegistersTo(const aHART:THART;const aOnOutput:TOnOutput;const aOnError:TOnError);
              procedure DumpMemory(const aHART:THART;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
              procedure DumpMemoryTo(const aHART:THART;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aOnOutput:TOnOutput;const aOnError:TOnError);
              procedure DumpStack(const aHART:THART;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
              procedure DumpStackTo(const aHART:THART;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aOnOutput:TOnOutput;const aOnError:TOnError);
              procedure DumpDisassembler(const aHART:THART;const aAddress:TPasRISCVUInt64;const aCount:TPasRISCVUInt64);
              procedure DumpDisassemblerTo(const aHART:THART;const aAddress:TPasRISCVUInt64;const aCount:TPasRISCVUInt64;const aOnOutput:TOnOutput;const aOnError:TOnError);
              procedure DumpBacktrace(const aHART:THART;const aMaxDepth:TPasRISCVUInt64);
              procedure DumpBacktraceTo(const aHART:THART;const aMaxDepth:TPasRISCVUInt64;const aOnOutput:TOnOutput;const aOnError:TOnError);
              procedure ListBreakpoints;
              function AddBreakpoint(const aHART:THART;const aAddress:TPasRISCVUInt64):Boolean;
              function RemoveBreakpoint(const aHART:THART;const aAddress:TPasRISCVUInt64):Boolean;
              procedure ClearBreakpoints;
              function EnableBreakpoint(const aHART:THART;const aAddress:TPasRISCVUInt64):Boolean;
              function DisableBreakpoint(const aHART:THART;const aAddress:TPasRISCVUInt64):Boolean;
              function StepOverBreakpointsIfNeeded(const aSuppressNotify:Boolean):Boolean;
              function ProcessCommand(const aLine:TPasRISCVRawByteString;const aOnOutput:TOnOutput;const aOnError:TOnError):Boolean;
              function ProcessLocalCommand(const aLine:TPasRISCVRawByteString):Boolean;
             public
              constructor Create(const aMachine:TPasRISCV;const aPort:TPasRISCVUInt16;const aOptions:TOptions=[TOption.GDBServer]);
              destructor Destroy; override;
              procedure Interrupt;
              procedure NotifyPaused;
              function Halt(const aHART:THART;const aPC:TPasRISCVUInt64;const aInstruction:TPasRISCVUInt32):Boolean;
              procedure Pause;
              procedure SingleStep(const aWaitUntilDone:Boolean=false);
              procedure Continue_;
              procedure Reset;
              procedure Start;
              procedure Stop;
              function PollLocal:Boolean;
              procedure EnqueueLocalCommand(const aCommand:TPasRISCVRawByteString);
              property Options:TOptions read fOptions write fOptions;
              property OnInput:TOnInput read fOnInput write fOnInput;
              property OnOutput:TOnOutput read fOnOutput write fOnOutput;
              property OnStopped:TOnStopped read fOnStopped write fOnStopped;
              property OnResumed:TOnNotify read fOnResumed write fOnResumed;
              property OnStepDone:TOnNotify read fOnStepDone write fOnStepDone;
              property OnReset:TOnNotify read fOnReset write fOnReset;
              property OnShutdown:TOnNotify read fOnShutdown write fOnShutdown;
              property OnError:TOnError read fOnError write fOnError;
              property LocalHARTIndex:TPasRISCVUInt64 read fLocalHARTIndex write SetLocalHARTIndex;
            end;
            TDisplayMode=
             (
              SimpleFB,
              VirtIOGPU,
              BochsVBE,
              Cirrus
             );
            TRTCMode=
             (
              Goldfish,
              DS1742,
              DS1307,
              VirtIO
             );
            TI2CMode=
             (
              OpenCores,
              DesignWare
             );
            TSoundMode=
             (
              VirtIO,
              FM801
             );
            { TConfiguration }
            TConfiguration=class
             private

              fDebugger:Boolean;
              fDebuggerLocal:Boolean;
              fDebuggerPort:TPasRISCVUInt16;

              fCountHARTs:TPasRISCVUInt64;

              fBootArguments:TPasRISCVRawByteString;

              fBootMemoryBase:TPasRISCVUInt64;
              fBootMemorySize:TPasRISCVUInt64;

              fMemoryBase:TPasRISCVUInt64;
              fMemorySize:TPasRISCVUInt64;

              fCLINTBase:TPasRISCVUInt64;
              fCLINTSize:TPasRISCVUInt64;

              fIMSICMachineBase:TPasRISCVUInt64;
              fIMSICMachineSizePerHART:TPasRISCVUInt64;

              fIMSICSupervisorBase:TPasRISCVUInt64;
              fIMSICSupervisorSizePerHART:TPasRISCVUInt64;

              fAPLICMachineBase:TPasRISCVUInt64;
              fAPLICMachineSize:TPasRISCVUInt64;

              fAPLICSupervisorBase:TPasRISCVUInt64;
              fAPLICSupervisorSize:TPasRISCVUInt64;

              fPLICBase:TPasRISCVUInt64;
              fPLICSize:TPasRISCVUInt64;

              fSYSCONBase:TPasRISCVUInt64;
              fSYSCONSize:TPasRISCVUInt64;

              fUARTBase:TPasRISCVUInt64;
              fUARTSize:TPasRISCVUInt64;
              fUARTIRQ:TPasRISCVUInt64;

              fVirtIOBlockBase:TPasRISCVUInt64;
              fVirtIOBlockSize:TPasRISCVUInt64;
              fVirtIOBlockIRQ:TPasRISCVUInt64;

              fRTCMode:TRTCMode;

              fGoldfishRTCBase:TPasRISCVUInt64;
              fGoldfishRTCSize:TPasRISCVUInt64;
              fGoldfishRTCIRQ:TPasRISCVUInt64;

              fDS1742Base:TPasRISCVUInt64;
              fDS1742Size:TPasRISCVUInt64;

              fFrameBufferBase:TPasRISCVUInt64;
              fFrameBufferSize:TPasRISCVUInt64;
              fFrameBufferWidth:TPasRISCVUInt64;
              fFrameBufferHeight:TPasRISCVUInt64;
              fFrameBufferBytesPerPixel:TPasRISCVUInt64;
              fFrameBufferStride:TPasRISCVUInt64;
              fFrameBufferFormat:TPasRISCVUInt64;

              fSharedMemoryBase:TPasRISCVUInt64;
              fSharedMemorySize:TPasRISCVUInt64;
              fSharedMemoryIRQ:TPasRISCVUInt64;

              fRawKeyboardBase:TPasRISCVUInt64;
              fRawKeyboardSize:TPasRISCVUInt64;

              fI2CMode:TI2CMode;

              fOpenCoresI2CBase:TPasRISCVUInt64;
              fOpenCoresI2CSize:TPasRISCVUInt64;

              fDesignWareI2CBase:TPasRISCVUInt64;
              fDesignWareI2CSize:TPasRISCVUInt64;

              fPS2KeyboardBase:TPasRISCVUInt64;
              fPS2KeyboardSize:TPasRISCVUInt64;
              fPS2KeyboardIRQ:TPasRISCVUInt64;

              fPS2MouseBase:TPasRISCVUInt64;
              fPS2MouseSize:TPasRISCVUInt64;
              fPS2MouseIRQ:TPasRISCVUInt64;

              fVirtIOInputKeyboardBase:TPasRISCVUInt64;
              fVirtIOInputKeyboardSize:TPasRISCVUInt64;
              fVirtIOInputKeyboardIRQ:TPasRISCVUInt64;

              fVirtIOInputMouseBase:TPasRISCVUInt64;
              fVirtIOInputMouseSize:TPasRISCVUInt64;
              fVirtIOInputMouseIRQ:TPasRISCVUInt64;

              fVirtIOSoundBase:TPasRISCVUInt64;
              fVirtIOSoundSize:TPasRISCVUInt64;
              fVirtIOSoundIRQ:TPasRISCVUInt64;

              fVirtIO9PBase:TPasRISCVUInt64;
              fVirtIO9PSize:TPasRISCVUInt64;
              fVirtIO9PIRQ:TPasRISCVUInt64;

              fVirtIONetBase:TPasRISCVUInt64;
              fVirtIONetSize:TPasRISCVUInt64;
              fVirtIONetIRQ:TPasRISCVUInt64;

              fVirtIORandomGeneratorBase:TPasRISCVUInt64;
              fVirtIORandomGeneratorSize:TPasRISCVUInt64;
              fVirtIORandomGeneratorIRQ:TPasRISCVUInt64;

              fVirtIOGPUBase:TPasRISCVUInt64;
              fVirtIOGPUSize:TPasRISCVUInt64;
              fVirtIOGPUIRQ:TPasRISCVUInt64;

              fVirtIOVSockBase:TPasRISCVUInt64;
              fVirtIOVSockSize:TPasRISCVUInt64;
              fVirtIOVSockIRQ:TPasRISCVUInt64;
              fVirtIOVSockGuestCID:TPasRISCVUInt64;

              fVirtIORTCBase:TPasRISCVUInt64;
              fVirtIORTCSize:TPasRISCVUInt64;
              fVirtIORTCIRQ:TPasRISCVUInt64;

              fBIOS:TMemoryStream;

              fKernel:TMemoryStream;

              fINITRD:TMemoryStream;

              fIVSHMEMSharedMemorySize:TPasRISCVUInt64;

              fAIA:Boolean;

              fVirtIOBlockEnabled:Boolean;

              fVirtIOBlockMQ:Boolean;

              fNVMeEnabled:Boolean;

              fSoundMode:TSoundMode;

              fDisplayMode:TDisplayMode;

              fLRSCMaximumCycles:TPasRISCVUInt64;

             public
              constructor Create;
              destructor Destroy; override;
              procedure Assign(const aConfiguration:TConfiguration);
              procedure LoadBIOSFromFile(const aFileName:TPasRISCVUTF8String);
              procedure LoadBIOSFromStream(const aStream:TStream);
              procedure LoadBIOSFromMemory(const aMemory:pointer;const aSize:TPasRISCVSizeInt);
              procedure LoadKernelFromFile(const aFileName:TPasRISCVUTF8String);
              procedure LoadKernelFromStream(const aStream:TStream);
              procedure LoadKernelFromMemory(const aMemory:pointer;const aSize:TPasRISCVSizeInt);
              procedure LoadINITRDFromFile(const aFileName:TPasRISCVUTF8String);
              procedure LoadINITRDFromStream(const aStream:TStream);
              procedure LoadINITRDFromMemory(const aMemory:pointer;const aSize:TPasRISCVSizeInt);
             public

              property Debugger:Boolean read fDebugger write fDebugger;
              property DebuggerLocal:Boolean read fDebuggerLocal write fDebuggerLocal;
              property DebuggerPort:TPasRISCVUInt16 read fDebuggerPort write fDebuggerPort;

              property CountHARTs:TPasRISCVUInt64 read fCountHARTs write fCountHARTs;

              property BootArguments:TPasRISCVRawByteString read fBootArguments write fBootArguments;

              property BootMemoryBase:TPasRISCVUInt64 read fBootMemoryBase write fBootMemoryBase;
              property BootMemorySize:TPasRISCVUInt64 read fBootMemorySize write fBootMemorySize;

              property MemoryBase:TPasRISCVUInt64 read fMemoryBase write fMemoryBase;
              property MemorySize:TPasRISCVUInt64 read fMemorySize write fMemorySize;

              property CLINTBase:TPasRISCVUInt64 read fCLINTBase write fCLINTBase;
              property CLINTSize:TPasRISCVUInt64 read fCLINTSize write fCLINTSize;

              property IMSICMachineBase:TPasRISCVUInt64 read fIMSICMachineBase write fIMSICMachineBase;
              property IMSICMachineSizePerHART:TPasRISCVUInt64 read fIMSICMachineSizePerHART write fIMSICMachineSizePerHART;

              property IMSICSupervisorBase:TPasRISCVUInt64 read fIMSICSupervisorBase write fIMSICSupervisorBase;
              property IMSICSupervisorSizePerHART:TPasRISCVUInt64 read fIMSICSupervisorSizePerHART write fIMSICSupervisorSizePerHART;

              property APLICMachineBase:TPasRISCVUInt64 read fAPLICMachineBase write fAPLICMachineBase;
              property APLICMachineSize:TPasRISCVUInt64 read fAPLICMachineSize write fAPLICMachineSize;

              property APLICSupervisorBase:TPasRISCVUInt64 read fAPLICSupervisorBase write fAPLICSupervisorBase;
              property APLICSupervisorSize:TPasRISCVUInt64 read fAPLICSupervisorSize write fAPLICSupervisorSize;

              property PLICBase:TPasRISCVUInt64 read fPLICBase write fPLICBase;
              property PLICSize:TPasRISCVUInt64 read fPLICSize write fPLICSize;

              property SYSCONBase:TPasRISCVUInt64 read fSYSCONBase write fSYSCONBase;
              property SYSCONSize:TPasRISCVUInt64 read fSYSCONSize write fSYSCONSize;

              property UARTBase:TPasRISCVUInt64 read fUARTBase write fUARTBase;
              property UARTSize:TPasRISCVUInt64 read fUARTSize write fUARTSize;
              property UARTIRQ:TPasRISCVUInt64 read fUARTIRQ write fUARTIRQ;

              property VirtIOBlockBase:TPasRISCVUInt64 read fVirtIOBlockBase write fVirtIOBlockBase;
              property VirtIOBlockSize:TPasRISCVUInt64 read fVirtIOBlockSize write fVirtIOBlockSize;
              property VirtIOBlockIRQ:TPasRISCVUInt64 read fVirtIOBlockIRQ write fVirtIOBlockIRQ;

              property RTCMode:TRTCMode read fRTCMode write fRTCMode;

              property GoldfishRTCBase:TPasRISCVUInt64 read fGoldfishRTCBase write fGoldfishRTCBase;
              property GoldfishRTCSize:TPasRISCVUInt64 read fGoldfishRTCSize write fGoldfishRTCSize;
              property GoldfishRTCIRQ:TPasRISCVUInt64 read fGoldfishRTCIRQ write fGoldfishRTCIRQ;

              property DS1742Base:TPasRISCVUInt64 read fDS1742Base write fDS1742Base;
              property DS1742Size:TPasRISCVUInt64 read fDS1742Size write fDS1742Size;

              property FrameBufferBase:TPasRISCVUInt64 read fFrameBufferBase write fFrameBufferBase;
              property FrameBufferSize:TPasRISCVUInt64 read fFrameBufferSize write fFrameBufferSize;
              property FrameBufferWidth:TPasRISCVUInt64 read fFrameBufferWidth write fFrameBufferWidth;
              property FrameBufferHeight:TPasRISCVUInt64 read fFrameBufferHeight write fFrameBufferHeight;
              property FrameBufferBytesPerPixel:TPasRISCVUInt64 read fFrameBufferBytesPerPixel write fFrameBufferBytesPerPixel;
              property FrameBufferStride:TPasRISCVUInt64 read fFrameBufferStride write fFrameBufferStride;
              property FrameBufferFormat:TPasRISCVUInt64 read fFrameBufferFormat write fFrameBufferFormat;

              property SharedMemoryBase:TPasRISCVUInt64 read fSharedMemoryBase write fSharedMemoryBase;
              property SharedMemorySize:TPasRISCVUInt64 read fSharedMemorySize write fSharedMemorySize;
              property SharedMemoryIRQ:TPasRISCVUInt64 read fSharedMemoryIRQ write fSharedMemoryIRQ;

              property RawKeyboardBase:TPasRISCVUInt64 read fRawKeyboardBase write fRawKeyboardBase;
              property RawKeyboardSize:TPasRISCVUInt64 read fRawKeyboardSize write fRawKeyboardSize;

              property I2CMode:TI2CMode read fI2CMode write fI2CMode;

              property OpenCoresI2CBase:TPasRISCVUInt64 read fOpenCoresI2CBase write fOpenCoresI2CBase;
              property OpenCoresI2CSize:TPasRISCVUInt64 read fOpenCoresI2CSize write fOpenCoresI2CSize;

              property DesignWareI2CBase:TPasRISCVUInt64 read fDesignWareI2CBase write fDesignWareI2CBase;
              property DesignWareI2CSize:TPasRISCVUInt64 read fDesignWareI2CSize write fDesignWareI2CSize;

              property PS2KeyboardBase:TPasRISCVUInt64 read fPS2KeyboardBase write fPS2KeyboardBase;
              property PS2KeyboardSize:TPasRISCVUInt64 read fPS2KeyboardSize write fPS2KeyboardSize;
              property PS2KeyboardIRQ:TPasRISCVUInt64 read fPS2KeyboardIRQ write fPS2KeyboardIRQ;

              property PS2MouseBase:TPasRISCVUInt64 read fPS2MouseBase write fPS2MouseBase;
              property PS2MouseSize:TPasRISCVUInt64 read fPS2MouseSize write fPS2MouseSize;
              property PS2MouseIRQ:TPasRISCVUInt64 read fPS2MouseIRQ write fPS2MouseIRQ;

              property VirtIOInputKeyboardBase:TPasRISCVUInt64 read fVirtIOInputKeyboardBase write fVirtIOInputKeyboardBase;
              property VirtIOInputKeyboardSize:TPasRISCVUInt64 read fVirtIOInputKeyboardSize write fVirtIOInputKeyboardSize;
              property VirtIOInputKeyboardIRQ:TPasRISCVUInt64 read fVirtIOInputKeyboardIRQ write fVirtIOInputKeyboardIRQ;

              property VirtIOInputMouseBase:TPasRISCVUInt64 read fVirtIOInputMouseBase write fVirtIOInputMouseBase;
              property VirtIOInputMouseSize:TPasRISCVUInt64 read fVirtIOInputMouseSize write fVirtIOInputMouseSize;
              property VirtIOInputMouseIRQ:TPasRISCVUInt64 read fVirtIOInputMouseIRQ write fVirtIOInputMouseIRQ;

              property VirtIOSoundBase:TPasRISCVUInt64 read fVirtIOSoundBase write fVirtIOSoundBase;
              property VirtIOSoundSize:TPasRISCVUInt64 read fVirtIOSoundSize write fVirtIOSoundSize;
              property VirtIOSoundIRQ:TPasRISCVUInt64 read fVirtIOSoundIRQ write fVirtIOSoundIRQ;

              property VirtIO9PBase:TPasRISCVUInt64 read fVirtIO9PBase write fVirtIO9PBase;
              property VirtIO9PSize:TPasRISCVUInt64 read fVirtIO9PSize write fVirtIO9PSize;
              property VirtIO9PIRQ:TPasRISCVUInt64 read fVirtIO9PIRQ write fVirtIO9PIRQ;

              property VirtIONetBase:TPasRISCVUInt64 read fVirtIONetBase write fVirtIONetBase;
              property VirtIONetSize:TPasRISCVUInt64 read fVirtIONetSize write fVirtIONetSize;
              property VirtIONetIRQ:TPasRISCVUInt64 read fVirtIONetIRQ write fVirtIONetIRQ;

              property VirtIORandomGeneratorBase:TPasRISCVUInt64 read fVirtIORandomGeneratorBase write fVirtIORandomGeneratorBase;
              property VirtIORandomGeneratorSize:TPasRISCVUInt64 read fVirtIORandomGeneratorSize write fVirtIORandomGeneratorSize;
              property VirtIORandomGeneratorIRQ:TPasRISCVUInt64 read fVirtIORandomGeneratorIRQ write fVirtIORandomGeneratorIRQ;

              property VirtIOGPUBase:TPasRISCVUInt64 read fVirtIOGPUBase write fVirtIOGPUBase;
              property VirtIOGPUSize:TPasRISCVUInt64 read fVirtIOGPUSize write fVirtIOGPUSize;
              property VirtIOGPUIRQ:TPasRISCVUInt64 read fVirtIOGPUIRQ write fVirtIOGPUIRQ;

              property VirtIOVSockBase:TPasRISCVUInt64 read fVirtIOVSockBase write fVirtIOVSockBase;
              property VirtIOVSockSize:TPasRISCVUInt64 read fVirtIOVSockSize write fVirtIOVSockSize;
              property VirtIOVSockIRQ:TPasRISCVUInt64 read fVirtIOVSockIRQ write fVirtIOVSockIRQ;
              property VirtIOVSockGuestCID:TPasRISCVUInt64 read fVirtIOVSockGuestCID write fVirtIOVSockGuestCID;

              property VirtIORTCBase:TPasRISCVUInt64 read fVirtIORTCBase write fVirtIORTCBase;
              property VirtIORTCSize:TPasRISCVUInt64 read fVirtIORTCSize write fVirtIORTCSize;
              property VirtIORTCIRQ:TPasRISCVUInt64 read fVirtIORTCIRQ write fVirtIORTCIRQ;

              property BIOS:TMemoryStream read fBIOS;

              property Kernel:TMemoryStream read fKernel;

              property INITRD:TMemoryStream read fINITRD;

              property IVSHMEMSharedMemorySize:TPasRISCVUInt64 read fIVSHMEMSharedMemorySize write fIVSHMEMSharedMemorySize;

              property AIA:Boolean read fAIA write fAIA;

              property VirtIOBlockEnabled:Boolean read fVirtIOBlockEnabled write fVirtIOBlockEnabled;

              property VirtIOBlockMQ:Boolean read fVirtIOBlockMQ write fVirtIOBlockMQ;

              property NVMeEnabled:Boolean read fNVMeEnabled write fNVMeEnabled;

              property SoundMode:TSoundMode read fSoundMode write fSoundMode;

              property DisplayMode:TDisplayMode read fDisplayMode write fDisplayMode;

              property LRSCMaximumCycles:TPasRISCVUInt64 read fLRSCMaximumCycles write fLRSCMaximumCycles;

            end;
            TOnReboot=procedure of object;
            TOnNewFrame=procedure of object;
            TOnCPUException=function(const aHART:THART;const aExceptionValue:THART.TExceptionValue;const aExceptionData:TPasRISCVUInt64;const aExceptionPC:TPasRISCVUInt64):Boolean of object;
      private

       fConfiguration:TConfiguration;

       fAtomicCriticalSection:TCriticalSection;

       fOnCPUException:TOnCPUException;

       fJobManager:TJobManager;

       fFDT:TFDT;

       fFDTStream:TMemoryStream;

       fStartStackPointer:TPasRiscVUInt64;

       fFDTMemoryOffset:TPasRiscVUInt64;

       fSoundIO:TSoundIO;

       fBus:TBus;

       fInterrupts:TInterrupts;

       fBootMemoryDevice:TMemoryDevice;

       fMemoryDevice:TMemoryDevice;

       fACLINTDevice:TACLINTDevice;

       fIMSICMachineDevice:TIMSICDevice;

       fIMSICSupervisorDevice:TIMSICDevice;

       fAPLICDevice:TAPLICDevice;

       fPLICDevice:TPLICDevice;

       fINTCDevice:TINTCDevice;

       fSYSCONDevice:TSYSCONDevice;

       fVirtIOBlockDevice:TVirtIOBlockDevice;

       fUARTDevice:TUARTDevice;

       fGoldfishRTCDevice:TGoldfishRTCDevice;

       fDS1742Device:TDS1742Device;

       fDS1307Device:TDS1307I2CBusDevice;

       fPCIBusDevice:TPCIBusDevice;

       fPCIIODevice:TPCIIODevice;

       fNVMeDevice:TNVMeDevice;

       fIVSHMEMDevice:TIVSHMEMDevice;

       fBochsVBEDevice:TBochsVBEDevice;

       fCirrusDevice:TCirrusDevice;

       fFrameBufferDevice:TFrameBufferDevice;

       fSimpleFBDevice:TSimpleFBDevice;

       fSharedMemoryDevice:TSharedMemoryDevice;

       fRawKeyboardDevice:TRawKeyboardDevice;

       fI2CDevice:TI2CDevice;

       fI2CHIDKeyboardBusDevice:TI2CHIDKeyboardBusDevice;

       fPS2KeyboardDevice:TPS2KeyboardDevice;

       fPS2MouseDevice:TPS2MouseDevice;

       fFM801Device:TFM801Device;

       fVirtIOInputKeyboardDevice:TVirtIOInputKeyboardDevice;

       fVirtIOInputMouseDevice:TVirtIOInputMouseDevice;

       fVirtIOSoundDevice:TVirtIOSoundDevice;

       fVirtIO9PDevice:TVirtIO9PDevice;

       fVirtIONetDevice:TVirtIONetDevice;

       fVirtIORandomGeneratorDevice:TVirtIORandomGeneratorDevice;

       fVirtIOGPUDevice:TVirtIOGPUDevice;

       fVirtIOVSockDevice:TVirtIOVSockDevice;

       fVirtIORTCDevice:TVirtIORTCDevice;

       fCountHARTs:TPasRISCVSizeInt;

       fHART:THART;

       fHARTs:THARTs;

       fRunState:TPasMPUInt32;

       fFlushTLBHARTMask:TPasRISCVUInt32;

       fHARTActiveMask:TPasMPUInt32;
       fHARTRunningMask:TPasMPUInt32;

{$ifdef PasRISCVSingleStepCounter}
       fSingleStepCounter:TPasMPUInt32;
{$endif}

       fAllHARTMask:TPasRISCVUInt32;

       fLRSCMaximumCycles:TPasRISCVUInt64;

       fHARTWakeUpConditionVariableLock:TPasMPConditionVariableLock;
       fHARTWakeUpConditionVariable:TPasMPConditionVariable;

       fHARTStatusChangeConditionVariableLock:TPasMPConditionVariableLock;
       fHARTStatusChangeConditionVariable:TPasMPConditionVariable;

       fOnReboot:TOnReboot;

       fOnNewFrame:TOnNewFrame;

       fPHandleCounter:TPasMPUInt32;

       fRandomGeneratorLock:TPasMPSlimReaderWriterLock;
       fRandomGenerator:TRNLRandomGenerator;

       fPCG32Lock:TPasMPSlimReaderWriterLock;
       fPCG32:TPasRISCV.TPCG32;

       fKernelOffset:TPasRISCVUInt64;
       fKernelSize:TPasRISCVUInt64;

       fINITRDOffset:TPasRISCVUInt64;
       fINITRDSize:TPasRISCVUInt64;

       fWakeUpConditionVariableLock:TPasMPConditionVariableLock;
       fWakeUpConditionVariable:TPasMPConditionVariable;

       fDebugger:TDebugger;

       procedure ShutdownCPUs;

       procedure InitializeFDT;

      public

       function LoadELFIntoMemory(const aBinary:TMemoryStream;const aOffset:TPasRISCVUInt64;out aSize:TPasRISCVUInt64;const aObjCopy:Boolean):Boolean;

       function LoadBinaryIntoMemory(const aBinary:TMemoryStream;const aOffset:TPasRISCVUInt64;out aSize:TPasRISCVUInt64;const aCanELF:Boolean;const aObjCopy:Boolean):Boolean;

       function LoadINITRDIntoMemory(const aBinary:TMemoryStream;const aOffset:TPasRISCVUInt64;out aSize:TPasRISCVUInt64):Boolean;

       function GetRunning:Boolean;

      public

       constructor Create(const aConfiguration:TConfiguration=nil); reintroduce;
       destructor Destroy; override;
       function AllocatePHandle:TPasRISCVUInt32;
       procedure Reset;
       procedure Execute(const aSingleStep:Boolean);
       procedure Step;
       procedure Run;
       procedure Reboot;
       procedure PowerOff;
       procedure FlushTLB;
       procedure Interrupt;
       procedure WakeUp;
       procedure InterruptAndWakeUp;
       function QueuePause(const aWaitUntilHalted:Boolean):Boolean;
       procedure Pause(const aWaitUntilHalted:Boolean);
       procedure Resume(const aWaitUntilRunning:Boolean);
       procedure SingleStep(const aWaitUntilDone:Boolean);

      published

       property FDT:TFDT read fFDT;

       property FDTStream:TMemoryStream read fFDTStream;

       property Configuration:TConfiguration read fConfiguration;

       property SoundIO:TSoundIO read fSoundIO;

       property Bus:TBus read fBus;

       property Interrupts:TInterrupts read fInterrupts;

       property BootMemoryDevice:TMemoryDevice read fBootMemoryDevice;

       property ACLINTDevice:TACLINTDevice read fACLINTDevice;

       property IMSICMachineDevice:TIMSICDevice read fIMSICMachineDevice;

       property IMSICSupervisorDevice:TIMSICDevice read fIMSICSupervisorDevice;

       property APLICDevice:TAPLICDevice read fAPLICDevice;

       property PLICDevice:TPLICDevice read fPLICDevice;

       property INTCDevice:TINTCDevice read fINTCDevice;

       property MemoryDevice:TMemoryDevice read fMemoryDevice;

       property VirtIOBlockDevice:TVirtIOBlockDevice read fVirtIOBlockDevice;

       property UARTDevice:TUARTDevice read fUARTDevice;

       property GoldfishRTCDevice:TGoldfishRTCDevice read fGoldfishRTCDevice;

       property DS1742Device:TDS1742Device read fDS1742Device;

       property DS1307Device:TDS1307I2CBusDevice read fDS1307Device;

       property PCIBusDevice:TPCIBusDevice read fPCIBusDevice;

       property PCIIODevice:TPCIIODevice read fPCIIODevice;

       property NVMeDevice:TNVMeDevice read fNVMeDevice;

       property IVSHMEMDevice:TIVSHMEMDevice read fIVSHMEMDevice;

       property BochsVBEDevice:TBochsVBEDevice read fBochsVBEDevice;

       property CirrusDevice:TCirrusDevice read fCirrusDevice;

       property FrameBufferDevice:TFrameBufferDevice read fFrameBufferDevice;

       property SimpleFBDevice:TSimpleFBDevice read fSimpleFBDevice;

       property SharedMemoryDevice:TSharedMemoryDevice read fSharedMemoryDevice;

       property RawKeyboardDevice:TRawKeyboardDevice read fRawKeyboardDevice;

       property I2CDevice:TI2CDevice read fI2CDevice;

       property I2CHIDKeyboardBusDevice:TI2CHIDKeyboardBusDevice read fI2CHIDKeyboardBusDevice;

       property PS2KeyboardDevice:TPS2KeyboardDevice read fPS2KeyboardDevice;

       property PS2MouseDevice:TPS2MouseDevice read fPS2MouseDevice;

       property FM801Device:TFM801Device read fFM801Device;

       property VirtIOInputKeyboardDevice:TVirtIOInputKeyboardDevice read fVirtIOInputKeyboardDevice;

       property VirtIOInputMouseDevice:TVirtIOInputMouseDevice read fVirtIOInputMouseDevice;

       property VirtIOSoundDevice:TVirtIOSoundDevice read fVirtIOSoundDevice;

       property VirtIO9PDevice:TVirtIO9PDevice read fVirtIO9PDevice;

       property VirtIONetDevice:TVirtIONetDevice read fVirtIONetDevice;

       property VirtIORandomGeneratorDevice:TVirtIORandomGeneratorDevice read fVirtIORandomGeneratorDevice;

       property VirtIOGPUDevice:TVirtIOGPUDevice read fVirtIOGPUDevice;

       property VirtIOVSockDevice:TVirtIOVSockDevice read fVirtIOVSockDevice;

       property VirtIORTCDevice:TVirtIORTCDevice read fVirtIORTCDevice;

       property Debugger:TDebugger read fDebugger;

      public

       property HART:THART read fHART;

       property HARTs:THARTs read fHARTs;

      published

       property Running:Boolean read GetRunning;

       property OnReboot:TOnReboot read fOnReboot write fOnReboot;

       property OnNewFrame:TOnNewFrame read fOnNewFrame write fOnNewFrame;

       property OnCPUException:TOnCPUException read fOnCPUException write fOnCPUException;

     end;

const fmCreateTemporary=4;

{$ifndef fpc}
      feInvalidHandle=TPasRISCVInt32(-1);
{$endif}

      CPUFeatures_X86_F16C_Mask=1 shl 0;
      CPUFeatures_X86_SSE42_Mask=1 shl 1;
      CPUFeatures_X86_PCLMUL_Mask=1 shl 2;

var CPUFeatures:TPasRISCVCPUFeatures=0;

    FloatToHalfFloatBaseTable:array[0..511] of TPasRISCVUInt16;
    FloatToHalfFloatShiftTable:array[0..511] of TPasRISCVUInt8;

    HalfFloatToFloatMantissaTable:array[0..2047] of TPasRISCVUInt32;
    HalfFloatToFloatExponentTable:array[0..63] of TPasRISCVUInt32;
    HalfFloatToFloatOffsetTable:array[0..63] of TPasRISCVUInt32;

function IntLog2(x:TPasRISCVUInt32):TPasRISCVUInt32; {$ifdef fpc}{$ifdef CAN_INLINE}inline;{$endif}{$endif}
function IntLog264(x:TPasRISCVUInt64):TPasRISCVUInt32; {$ifdef fpc}{$ifdef CAN_INLINE}inline;{$endif}{$endif}

implementation

type TZeroBuffer=array[0..65535] of TPasRISCVUInt8;

var ZeroBuffer:TZeroBuffer;

const PasRISCVFLITable:array[0..31] of TPasRISCVUInt32=
       (
        $bf800000, // -1.0
        $00800000, // Minimum positive normal
        $37800000, // 1.0 x 2^-16
        $38000000, // 1.0 x 2^-15
        $3b800000, // 1.0 x 2^-8
        $3c000000, // 1.0 x 2^-7
        $3d800000, // 0.0625
        $3e000000, // 0.125
        $3e800000, // 0.25
        $3ea00000, // 0.3125
        $3ec00000, // 0.375
        $3ee00000, // 0.4375
        $3f000000, // 0.5
        $3f200000, // 0.625
        $3f400000, // 0.75
        $3f600000, // 0.875
        $3f800000, // 1.0
        $3fa00000, // 1.25
        $3fc00000, // 1.5
        $3fe00000, // 1.75
        $40000000, // 2.0
        $40200000, // 2.5
        $40400000, // 3.0
        $40800000, // 4.0
        $41000000, // 8.0
        $41800000, // 16.0
        $43000000, // 128.0
        $43800000, // 256.0
        $47000000, // 2^15
        $47800000, // 2^16
        $7f800000, // +Infinity
        $7fc00000  // Canonical NaN
       );

{$if defined(PasRISCVCPUDebug)}
var IgnoreInterrupts:boolean=false;
    DumpDebug:boolean=false;
{$ifend}

function FlushStream(const aStream:TStream):Boolean;
{$if defined(fpc)}
begin
 if assigned(aStream) then begin
  if aStream is TFileStream then begin
   result:=TFileStream(aStream).Flush;
  end else if aStream is TPasRISCVFileMappedStream then begin
   result:=TPasRISCVFileMappedStream(aStream).Flush;
  end else begin
   result:=false;
  end;
 end else begin
  result:=false;
 end;
end;
{$elseif defined(Windows)}
begin
 if assigned(aStream) then begin
  if aStream is TFileStream then begin
   result:=FlushFileBuffers(TFileStream(aStream).Handle);
  end else if aStream is TPasRISCVFileMappedStream then begin
   result:=TPasRISCVFileMappedStream(aStream).Flush;
  end else begin
   result:=false;
  end;
 end else begin
  result:=false;
 end;
end;
{$else}
begin
 if assigned(aStream) then begin
  if aStream is TPasRISCVFileMappedStream then begin
   result:=TPasRISCVFileMappedStream(aStream).Flush;
  end else begin
   result:=false;
  end;
 end else begin
  result:=false;
 end;
end;
{$ifend}

procedure FastDecodeDate(const aDate:TPasRISCVInt32;out aYear,aMonth,aDay:TPasRISCVInt32); // Epoch is 0000-Mar-01
var n1,c,nc,n2,z,ny,y,n3,m,d,j:TPasRISCVUInt32;
    p2:TPasRISCVUInt64;
begin

 // Faster than the classic method, because no branches and no lookup tables

 // Century
 n1:=(aDate*4)+3;
 c:=n1 div 146097;
 nc:=(n1 mod 146097) div 4;

 // Year
 n2:=(nc*4)+3;
 p2:=n2*UInt64(2939745);
 z:=p2 div 4294967296;
 ny:=((p2 mod 4294967296) div 2939745) div 4;
 j:=((ny-305) shr 31) and 1; // j:=ord(ny>=306) and 1; // j:=IfThen(ny>=306,1,0);
 aYear:=((c*100)+z)+j;

 // Month and day
 n3:=(ny*2141)+197913;
 aMonth:=(n3 div 65536)-(j*12);
 aDay:=((n3 mod 65536) div 2141)+1;

end;

function FastEncodeDate(const aYear,aMonth,aDay:TPasRISCVInt32):TPasRISCVInt32; // Epoch is 0000-Mar-01
var t,j,y,m,d:TPasRISCVInt32;
begin

 j:=1-(((m-3) shr 31) and 1); // t:=ord(m<3) and 1; // t:=IfThen(m>2,0,1);
 y:=aYear-j;
 if j<>0 then begin
  m:=aMonth+12;
 end else begin
  m:=aMonth;
 end;

{j:=((ny-305) shr 31) and 1; // j:=ord(ny>=306) and 1; // j:=IfThen(ny>=306,1,0);

 t:=1-(((m-3) shr 31) and 1); // t:=ord(m<3) and 1; // t:=IfThen(m>2,0,1);
 y:=aYear-(t+j);
 m:=aMonth-((t-j)*12);}

 d:=aDay-1;

 y:=(((y*1461) div 4)-(y div 100))+(y div 400);
 m:=((m*153)-457) div 5;

 result:=y+m+d;

end;

function IsLeapYear(const aYear:TPasRISCVUInt32):Boolean;
var d:TPasRISCVUInt32;
begin
 // Always does two divisibility checks, 3x faster than the classic method, because lower entropy helps the branch predictor of the CPU
 d:=IfThen((aYear mod 400)<>0,4,16); // 4 shl (ord((aYear mod 100)=0) shl 1); // 4 or 16, 16 isn't wrong here, because if a number is multiple of 100 and 400 at the same time, it's also multiple of 16, and power of two is much cheaper to evaluate,
 result:=(aYear mod d)=0;
end;

function GetLastDayOfMonth(const aYear,aMonth:TPasRISCVInt32):TPasRISCVInt32;
begin
 // Without lookup tables
 case aMonth of
  2:begin
   result:=28+(ord(IsLeapYear(aYear)) and 1);
  end;
  else begin
   result:=30 or (aMonth xor (aMonth shr 3));  // Alternative: result:=30 or ((9*aMonth) div 8);
  end;
 end;
end;

function RoundUpTo32(const aValue,aRoundTo:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=aValue;
 if (aValue and (aRoundTo-1))<>0 then begin
  inc(result,aRoundTo-(aValue and (aRoundTo-1)));
 end;
end;

function FDTHex64(const aValue:TPasRISCVUInt64):TPasRISCVRawByteString;
const HexChars:array[0..15] of TPasRISCVRawByteChar=('0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f');
var Index:TPasRISCVSizeInt;
    Value:TPasRISCVUInt8;
begin
 result:='';
 for Index:=15 downto 0 do begin
  Value:=(aValue shr (Index shl 2)) and $f;
  if (Value<>0) or (length(result)>0) then begin
   result:=result+HexChars[Value];
  end;
 end;
end;

function StrToUIntBase(const aStr:TPasRISCVRawByteString;var aIndex:TPasRISCVSizeInt;out aLen:TPasRISCVSizeInt;const aBase:TPasRISCVUInt8):TPasRISCVUInt64;
var Value:TPasRISCVUInt64;
    Size:TPasRISCVSizeInt;
    DigitValue:TPasRISCVUInt8;
    Base:TPasRISCVUInt8;
begin
 if aBase=0 then begin
  Base:=10;
  if (aIndex<=length(aStr)) and (aStr[aIndex]=TPasRISCVRawByteChar('0')) then begin
   Base:=8;
   if (aIndex+1)<=length(aStr) then begin
    case aStr[aIndex+1] of
     'o','O':begin
      inc(aIndex);
      Base:=8;
     end;
     'x','X':begin
      inc(aIndex);
      Base:=16;
     end;
     'b','B':begin
      inc(aIndex);
      Base:=2;
     end;
    end;
   end;
  end;
 end else begin
  Base:=aBase;
 end;
 if (Base>=2) and (Base<=36) then begin
  Value:=0;
  Size:=0;
  while aIndex<=length(aStr) do begin
   DigitValue:=TPasRISCVUInt8(aStr[aIndex]);
   case DigitValue of
    TPasRISCVUInt8(TPasRISCVRawByteChar('0'))..TPasRISCVUInt8(TPasRISCVRawByteChar('9')):begin
     DigitValue:=DigitValue-TPasRISCVUInt8(TPasRISCVRawByteChar('0'));
    end;
    TPasRISCVUInt8(TPasRISCVRawByteChar('a'))..TPasRISCVUInt8(TPasRISCVRawByteChar('z')):begin
     DigitValue:=DigitValue-TPasRISCVUInt8(TPasRISCVRawByteChar('a'))+10;
    end;
    TPasRISCVUInt8(TPasRISCVRawByteChar('A'))..TPasRISCVUInt8(TPasRISCVRawByteChar('Z')):begin
     DigitValue:=DigitValue-TPasRISCVUInt8(TPasRISCVRawByteChar('A'))+10;
    end;
    else begin
     break;
    end;
   end;
   Value:=(Value*Base)+DigitValue;
   inc(Size);
   inc(aIndex);
  end;
  aLen:=Size;
  result:=Value;
 end else begin
  aLen:=0;
  result:=0;
 end;
end;

{$if not declared(SARLongint)}
function SARLongint(aValue,aShift:TPasRISCVInt32):TPasRISCVInt32;
{$if defined(cpux64) and defined(Windows) and not defined(fpc)}
asm
.noframe
 mov eax,ecx
 mov ecx,edx
 and cl,31
 sar eax,cl
end;
{$else}
begin
 aShift:=aShift and 31;
 if ((TPasRISCVUInt32(aValue) and TPasRISCVUInt32($80000000))<>0) and (aShift<>0) then begin
  result:=TPasRISCVInt32(TPasRISCVUInt32((TPasRISCVUInt32(aValue) shr aShift) or (TPasRISCVUInt32($ffffffff) shl (32-aShift))));
 end else begin
  result:=TPasRISCVUInt32(TPasRISCVUInt32(aValue) shr aShift);
 end;
end;
{$ifend}
{$ifend}

{$if not declared(SARInt64)}
function SARInt64(const aValue:TPasRISCVInt64;aShift:TPasRISCVInt32):TPasRISCVInt64;
{$if defined(cpux64) and defined(Windows) and not defined(fpc)}
asm
.noframe
 mov rax,rcx
 mov ecx,edx
 and cl,63
 sar rax,cl
end;
{$else}
begin
 aShift:=aShift and 63;
 if ((TPasRISCVUInt64(aValue) and TPasRISCVUInt64($8000000000000000))<>0) and (aShift<>0) then begin
  result:=TPasRISCVInt64(TPasRISCVUInt64((TPasRISCVUInt64(aValue) shr aShift) or (TPasRISCVUInt64($ffffffffffffffff) shl (64-aShift))));
 end else begin
  result:=TPasRISCVUInt64(TPasRISCVUInt64(aValue) shr aShift);
 end;
end;
{$ifend}
{$ifend}

{$if not declared(BSRQWord)}
function BSRQWord(const aValue:TPasRISCVUInt64):TPasRISCVUInt64;
var Debruijn64Multiplicator:TPasRISCVUInt64=TPasRISCVUInt64($03f79d71b4cb0a89);
    Debruijn64Shift=58;
    Debruijn64Mask=63;
    Debruijn64Table:array[0..63] of TPasRISCVUInt64=(0,47,1,56,48,27,2,60,57,49,41,37,28,16,3,61,54,58,35,52,50,42,21,44,38,32,29,23,17,11,4,62,
                                                     46,55,26,59,40,36,15,53,34,51,20,43,31,22,10,45,25,39,14,33,19,30,9,24,13,18,8,12,7,6,5,63);
begin
 if Value=0 then begin
  result:=255;
 end else begin
  Value:=Value or (Value shr 1);
  Value:=Value or (Value shr 2);
  Value:=Value or (Value shr 4);
  Value:=Value or (Value shr 8);
  Value:=Value or (Value shr 16);
  Value:=Value or (Value shr 32);
  result:=Debruijn64Table[((Value*Debruijn64Multiplicator) shr Debruijn64Shift) and Debruijn64Mask];
 end;
end;
{$ifend}

{$if not declared(ROLDWord)}
function ROLDWord(const aValue,aAmount:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=(aValue shl (aAmount and $1f)) or (aValue shr (32-(aAmount and $1f)));
end;
{$ifend}

{$if not declared(ROLQWord)}
function ROLQWord(const aValue,aAmount:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 result:=(aValue shl (aAmount and $3f)) or (aValue shr (64-(aAmount and $3f)));
end;
{$ifend}

{$if not declared(RORDWord)}
function RORDWord(const aValue,aAmount:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=(aValue shr (aAmount and $1f)) or (aValue shl (32-(aAmount and $1f)));
end;
{$ifend}

{$if not declared(RORQWord)}
function RORQWord(const aValue,aAmount:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 result:=(aValue shr (aAmount and $3f)) or (aValue shl (64-(aAmount and $3f)));
end;
{$ifend}

{$if defined(fpc) and declared(BSFQWord) and declared(BSRQWord) and declared(PopCnt)}
function CTZQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32;
begin
 if aValue=0 then begin
  result:=64;
 end else begin
  result:=BSFQWord(aValue);
 end;
end;

function CLZQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32;
begin
 if aValue=0 then begin
  result:=64;
 end else begin
  result:=63 xor BSRQWord(aValue);
 end;
end;

function POPCNTDWord(aValue:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=PopCnt(aValue);
end;

function POPCNTQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32;
begin
 result:=PopCnt(aValue);
end;

{$elseif defined(cpu386)}
function CTZQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32; assembler; stdcall; {$ifdef fpc}nostackframe;{$endif}
asm
 bsf eax,dword ptr [aValue+0]
 jnz @Done
 bsf eax,dword ptr [aValue+4]
 jz @Fail
 add eax,32
 jmp @Done
@Fail:
 xor eax,eax
 not eax
@Done:
end;

function CLZQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32; assembler; stdcall; {$ifdef fpc}nostackframe;{$endif}
asm
 bsr edx,dword ptr [aValue+4]
 jz @LowPart
 add edx,32
 jmp @Done
@LowPart:
 bsr edx,dword ptr [aValue+0]
 jnz @Done
 xor edx,edx
 not edx
@Done:
 mov eax,63
 sub eax,edx
end;

function POPCNTDWord(aValue:TPasRISCVUInt32):TPasRISCVUInt32; assembler; register;
asm
 // result:=Value-((Value shr 1) and $55555555);
 mov edx,eax
 shr eax,1
 and eax,$55555555
 sub edx,eax

 // result:=(result and $33333333)+((result shr 2) and $33333333);
 mov eax,edx
 shr edx,2
 and eax,$33333333
 and edx,$33333333
 add eax,edx

 // result:=(result+(result shr 4)) and $0f0f0f0f;
 mov edx,eax
 shr eax,4
 add eax,edx
 and eax,$0f0f0f0f

 // inc(result,result shr 8);
 mov edx,eax
 shr edx,8
 add eax,edx

 // inc(result,result shr 16);
 mov edx,eax
 shr edx,16
 add eax,edx

 // result:=result and $3f;
 and eax,$3f
end;

function POPCNTQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32; assembler; stdcall;
asm
 mov eax,dword [aValue+0]
 mov ecx,dword [aValue+4]

 // result:=Value-((Value shr 1) and $55555555);
 mov edx,eax
 shr eax,1
 and eax,$55555555
 sub edx,eax

 // result:=(result and $33333333)+((result shr 2) and $33333333);
 mov eax,edx
 shr edx,2
 and eax,$33333333
 and edx,$33333333
 add eax,edx

 // result:=(result+(result shr 4)) and $0f0f0f0f;
 mov edx,eax
 shr eax,4
 add eax,edx
 and eax,$0f0f0f0f

 // inc(result,result shr 8);
 mov edx,eax
 shr edx,8
 add eax,edx

 // inc(result,result shr 16);
 mov edx,eax
 shr edx,16
 add eax,edx

 // result:=result and $3f;
 and eax,$3f

 xchg ecx,eax

 // result:=Value-((Value shr 1) and $55555555);
 mov edx,eax
 shr eax,1
 and eax,$55555555
 sub edx,eax

 // result:=(result and $33333333)+((result shr 2) and $33333333);
 mov eax,edx
 shr edx,2
 and eax,$33333333
 and edx,$33333333
 add eax,edx

 // result:=(result+(result shr 4)) and $0f0f0f0f;
 mov edx,eax
 shr eax,4
 add eax,edx
 and eax,$0f0f0f0f

 // inc(result,result shr 8);
 mov edx,eax
 shr edx,8
 add eax,edx

 // inc(result,result shr 16);
 mov edx,eax
 shr edx,16
 add eax,edx

 // result:=result and $3f;
 and eax,$3f

 add eax,ecx
end;
{$elseif defined(cpuamd64)}
function CTZQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32; assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
{$ifndef fpc}
 .NOFRAME
{$endif}
{$ifdef Windows}
 bsf rax,rcx
{$else}
 bsf rax,rdi
{$endif}
 jnz @Done
 mov eax,64
@Done:
end;

function CLZQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32; assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
{$ifndef fpc}
 .NOFRAME
{$endif}
{$ifdef Windows}
 bsr rcx,rcx
 jnz @Done
 xor rcx,rcx
 not rcx
@Done:
 mov rax,63
 sub rax,rcx
{$else}
 bsr rdi,rdi
 jnz @Done
 xor rdi,rdi
 not rdi
@Done:
 mov rax,63
 sub rax,rdi
{$endif}
end;

function POPCNTDWord(aValue:TPasRISCVUInt32):TPasRISCVUInt64; assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
{$ifndef fpc}
 .NOFRAME
{$endif}
{$ifdef Windows}
 mov eax,ecx
{$else}
 mov eax,edi
{$endif}

 // result:=Value-((Value shr 1) and $55555555);
 mov edx,eax
 shr eax,1
 and eax,$55555555
 sub edx,eax

 // result:=(result and $33333333)+((result shr 2) and $33333333);
 mov eax,edx
 shr edx,2
 and eax,$33333333
 and edx,$33333333
 add eax,edx

 // result:=(result+(result shr 4)) and $0f0f0f0f;
 mov edx,eax
 shr eax,4
 add eax,edx
 and eax,$0f0f0f0f

 // inc(result,result shr 8);
 mov edx,eax
 shr edx,8
 add eax,edx

 // inc(result,result shr 16);
 mov edx,eax
 shr edx,16
 add eax,edx

 // result:=result and $3f;
 and eax,$3f
end;

function POPCNTQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32; assembler; register; {$ifdef fpc}nostackframe;{$endif}
asm
{$ifndef fpc}
 .NOFRAME
{$endif}
{$ifdef Windows}
 mov rax,rcx
{$else}
 mov rax,rdi
{$endif}

 // result:=Value-((Value shr 1) and $5555555555555555);
 mov rdx,rax
 shr rax,1
 mov r8,$5555555555555555
 and rax,r8
 sub rdx,rax

 // result:=(result and $3333333333333333)+((result shr 2) and $3333333333333333);
 mov rax,rdx
 shr rdx,2
 mov r8,$3333333333333333
 and rax,r8
 and rdx,r8
 add rax,rdx

 // result:=(result+(result shr 4)) and $0f0f0f0f0f0f0f0f;
 mov rdx,rax
 shr rax,4
 add rax,rdx
 mov r8,$0f0f0f0f0f0f0f0f
 and rax,r8

 // inc(result,result shr 8);
 mov rdx,rax
 shr rdx,8
 add rax,rdx

 // inc(result,result shr 16);
 mov rdx,rax
 shr rdx,16
 add rax,rdx

 // inc(result,result shr 32);
 mov rdx,rax
 shr rdx,32
 add rax,rdx

 // result:=result and $7f;
 and rax,$7f
end;
{$else}
function CTZQWord(aValue:TPasRISCVUInt64):TPasRISCVInt32;
const PasRISCVCTZDebruijn64Multiplicator:TPasRISCVUInt64=TPasRISCVUInt64($07edd5e59a4e28c2);
      PasRISCVCTZDebruijn64Shift=58;
      PasRISCVCTZDebruijn64Mask=63;
      PasRISCVCTZDebruijn64Table:array[0..63] of TPasRISCVInt32=(63,0,58,1,59,47,53,2,60,39,48,27,54,33,42,3,61,51,37,40,49,18,28,20,55,30,34,11,43,14,22,4,
                                                           62,57,46,52,38,26,32,41,50,36,17,19,29,10,13,21,56,45,25,31,35,16,9,12,44,24,15,8,23,7,6,5);

begin
 if aValue=0 then begin
  result:=64;
 end else begin
  result:=PasRISCVCTZDebruijn64Table[(((aValue and (-aValue))*PasRISCVCTZDebruijn64Multiplicator) shr PasRISCVCTZDebruijn64Shift) and PasRISCVCTZDebruijn64Mask];
 end;
end;

function CLZQWord(aValue:TPasRISCVUInt64):TPasRISCVInt32;
const PasRISCVCLZDebruijn64Multiplicator:TPasRISCVUInt64=TPasRISCVUInt64($03f79d71b4cb0a89);
      PasRISCVCLZDebruijn64Shift=58;
      PasRISCVCLZDebruijn64Mask=63;
      PasRISCVCLZDebruijn64Table:array[0..63] of TPasRISCVInt32=(63,16,62,7,15,36,61,3,6,14,22,26,35,47,60,2,9,5,28,11,13,21,42,19,25,31,34,40,46,52,59,1,
                                                           17,8,37,4,23,27,48,10,29,12,43,20,32,41,53,18,38,24,49,30,44,33,54,39,50,45,55,51,56,57,58,0);
begin
 if aValue=0 then begin
  result:=64;
 end else begin
  aValue:=aValue or (aValue shr 1);
  aValue:=aValue or (aValue shr 2);
  aValue:=aValue or (aValue shr 4);
  aValue:=aValue or (aValue shr 8);
  aValue:=aValue or (aValue shr 16);
  aValue:=aValue or (aValue shr 32);
  result:=PasRISCVCLZDebruijn64Table[((aValue*PasRISCVCLZDebruijn64Multiplicator) shr PasRISCVCLZDebruijn64Shift) and PasRISCVCLZDebruijn64Mask];
 end;
end;

function POPCNTDWord(aValue:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 aValue:=aValue-((aValue shr 1) and TPasRISCVUInt32($55555555));
 aValue:=(aValue and TPasRISCVUInt32($33333333))+((aValue shr 2) and TPasRISCVUInt32($33333333));
 aValue:=(aValue+(aValue shr 4)) and TPasRISCVUInt32($0f0f0f0f);
 inc(aValue,aValue shr 8);
 inc(aValue,aValue shr 16);
 result:=aValue and $3f;
end;

function POPCNTQWord(aValue:TPasRISCVUInt64):TPasRISCVUInt32;
begin
 aValue:=aValue-((aValue shr 1) and TPasRISCVUInt64($5555555555555555));
 aValue:=(aValue and TPasRISCVUInt64($3333333333333333))+((aValue shr 2) and TPasRISCVUInt64($3333333333333333));
 aValue:=(aValue+(aValue shr 4)) and TPasRISCVUInt64($0f0f0f0f0f0f0f0f);
 inc(aValue,aValue shr 8);
 inc(aValue,aValue shr 16);
 inc(aValue,aValue shr 32);
 result:=aValue and $7f;
end;
{$ifend}

function BitwiseOrCombine(aValue:TPasRISCVUInt64):TPasRISCVUInt64; {$if defined(fpc) and defined(cpuamd64)} assembler; {$if defined(fpc)}nostackframe; {$if defined(Windows)}ms_abi_default;{$else}sysv_abi_default;{$ifend}{$ifend}
asm
{$if not defined(fpc)}
 .noframe
{$ifend}
{$if defined(Windows)}
 // Win64 ABI: rcx, rdx, r8, r9
 movq xmm0,rcx
{$else}
 // SysV ABI: rdi, rsi, rdx, rcx, r8, r9
 movq xmm0,rdi
{$ifend}
 xorps xmm1,xmm1
 pcmpeqb xmm0,xmm1
 pcmpeqb xmm0,xmm1
 movq rax,xmm0
end;
{$else}
begin
 result:=((((aValue or TPasRISCVUInt64($8080808080808080))-TPasRISCVUInt64($0101010101010101)) or aValue) and TPasRISCVUInt64($8080808080808080)) shr 7;
 result:=(result shl 8)-result;
{aValue:=aValue or (((aValue shr 1) or (aValue shl 1)) and TPasRISCVUInt64($7e7e7e7e7e7e7e7e));
 aValue:=aValue or (((aValue shr 2) or (aValue shl 2)) and TPasRISCVUInt64($3c3c3c3c3c3c3c3c));
 aValue:=aValue or ((aValue shr 4) and TPasRISCVUInt64($0f0f0f0f0f0f0f0f));
 result:=aValue or ((aValue shl 4) and TPasRISCVUInt64($f0f0f0f0f0f0f0f0));}
end;
{$ifend}

function ByteSwap32(aValue:TPasRISCVUInt32):TPasRISCVUInt32; {$if defined(fpc) and defined(cpuamd64)} assembler; {$if defined(fpc)}nostackframe; {$if defined(Windows)}ms_abi_default;{$else}sysv_abi_default;{$ifend}{$ifend}
asm
{$if not defined(fpc)}
 .noframe
{$ifend}
{$if defined(Windows)}
 // Win64 ABI: rcx, rdx, r8, r9
 mov eax,ecx
{$else}
 // SysV ABI: rdi, rsi, rdx, rcx, r8, r9
 mov eax,edi
{$ifend}
 bswap eax
end;
{$else}
begin
{result:=((aValue shr 8) and TPasRISCVUInt32($00ff00ff)) or ((aValue and TPasRISCVUInt32($00ff00ff)) shl 8);
 result:=((result shr 16) and TPasRISCVUInt32($0000ffff)) or ((result and TPasRISCVUInt32($0000ffff)) shl 16);}
 result:=((aValue and TPasRISCVUInt64($00000000ff000000)) shr 24) or
         ((aValue and TPasRISCVUInt64($0000000000ff0000)) shr 8) or
         ((aValue and TPasRISCVUInt64($000000000000ff00)) shl 8) or
         ((aValue and TPasRISCVUInt64($00000000000000ff)) shl 24);
end;
{$ifend}

function ByteSwap64(aValue:TPasRISCVUInt64):TPasRISCVUInt64; {$if defined(fpc) and defined(cpuamd64)} assembler; {$if defined(fpc)}nostackframe; {$if defined(Windows)}ms_abi_default;{$else}sysv_abi_default;{$ifend}{$ifend}
asm
{$if not defined(fpc)}
 .noframe
{$ifend}
{$if defined(Windows)}
 // Win64 ABI: rcx, rdx, r8, r9
 mov rax,rcx
{$else}
 // SysV ABI: rdi, rsi, rdx, rcx, r8, r9
 mov rax,rdi
{$ifend}
 bswap rax
end;
{$else}
begin
 result:=((aValue shr 8) and TPasRISCVUInt64($00ff00ff00ff00ff)) or ((aValue and TPasRISCVUInt64($00ff00ff00ff00ff)) shl 8);
 result:=((result shr 16) and TPasRISCVUInt64($0000ffff0000ffff)) or ((result and TPasRISCVUInt64($0000ffff0000ffff)) shl 16);
 result:=((result shr 32) and TPasRISCVUInt64($00000000ffffffff)) or ((result and TPasRISCVUInt64($00000000ffffffff)) shl 32);
{result:=((aValue and TPasRISCVUInt64($ff00000000000000)) shr 56) or
         ((aValue and TPasRISCVUInt64($00ff000000000000)) shr 40) or
         ((aValue and TPasRISCVUInt64($0000ff0000000000)) shr 24) or
         ((aValue and TPasRISCVUInt64($000000ff00000000)) shr 8) or
         ((aValue and TPasRISCVUInt64($00000000ff000000)) shl 8) or
         ((aValue and TPasRISCVUInt64($0000000000ff0000)) shl 24) or
         ((aValue and TPasRISCVUInt64($000000000000ff00)) shl 40) or
         ((aValue and TPasRISCVUInt64($00000000000000ff)) shl 56);}
end;
{$ifend}

function CLMul64(a,b:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 result:=0;
 repeat
  if (b and 1)<>0 then begin
   result:=result xor a;
  end;
  b:=b shr 1;
  a:=a shl 1;
 until a=0;
end;

function CLMulH64(a,b:TPasRISCVUInt64):TPasRISCVUInt64;
var Index:TPasRISCVUInt64;
begin
 result:=0;
 Index:=63;
 repeat
  b:=b shr 1;
  if (b and 1)<>0 then begin
   result:=result xor (a shr Index);
  end;
  dec(Index);
 until b=0;
end;

function CLMulR64(a,b:TPasRISCVUInt64):TPasRISCVUInt64;
var Index:TPasRISCVUInt64;
begin
 result:=0;
 Index:=63;
 repeat
  if (b and 1)<>0 then begin
   result:=result xor (a shr Index);
  end;
  b:=b shr 1;
  dec(Index);
 until b=0;
end;

function RoundDownToPowerOfTwo(x:TPasRISCVUInt32):TPasRISCVUInt32;
begin

 if x=0 then begin

  // Handle zero case
  result:=0;

 end else begin

  // / Propagate the highest bit to the right
  x:=x or (x shr 1);
  x:=x or (x shr 2);
  x:=x or (x shr 4);
  x:=x or (x shr 8);
  x:=x or (x shr 16);

  // Subtract half of the value to get the previous power of 2
  result:=x-(x shr 1);

 end;

end;

function RoundDownToPowerOfTwo64(x:TPasRISCVUInt64):TPasRISCVUInt64;
begin

 if x=0 then begin

  // Handle zero case
  result:=0;

 end else begin

  // / Propagate the highest bit to the right
  x:=x or (x shr 1);
  x:=x or (x shr 2);
  x:=x or (x shr 4);
  x:=x or (x shr 8);
  x:=x or (x shr 16);
  x:=x or (x shr 32);

  // Subtract half of the value to get the previous power of 2
  result:=x-(x shr 1);

 end;

end;

function RoundDownToPowerOfTwoSizeUInt(x:TPasRISCVSizeUInt):TPasRISCVSizeUInt;
begin

 if x=0 then begin

  // Handle zero case
  result:=0;

 end else begin

  // / Propagate the highest bit to the right
  x:=x or (x shr 1);
  x:=x or (x shr 2);
  x:=x or (x shr 4);
  x:=x or (x shr 8);
  x:=x or (x shr 16);
{$ifdef CPU64}
  x:=x or (x shr 32);
{$endif}

  // Subtract half of the value to get the previous power of 2
  result:=x-(x shr 1);

 end;

end;

function RoundUpToPowerOfTwo(x:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 dec(x);
 x:=x or (x shr 1);
 x:=x or (x shr 2);
 x:=x or (x shr 4);
 x:=x or (x shr 8);
 x:=x or (x shr 16);
 result:=x+1;
end;

function RoundUpToPowerOfTwo64(x:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 dec(x);
 x:=x or (x shr 1);
 x:=x or (x shr 2);
 x:=x or (x shr 4);
 x:=x or (x shr 8);
 x:=x or (x shr 16);
 x:=x or (x shr 32);
 result:=x+1;
end;

function RoundUpToPowerOfTwoSizeUInt(x:TPasRISCVSizeUInt):TPasRISCVSizeUInt;
begin
 dec(x);
 x:=x or (x shr 1);
 x:=x or (x shr 2);
 x:=x or (x shr 4);
 x:=x or (x shr 8);
 x:=x or (x shr 16);
{$ifdef CPU64}
 x:=x or (x shr 32);
{$endif}
 result:=x+1;
end;

function RoundNearestToPowerOfTwo(x:TPasRISCVUInt32):TPasRISCVUInt32;
var a,b:TPasRISCVUInt32;
begin
 a:=RoundDownToPowerOfTwo(x);
 b:=RoundUpToPowerOfTwo(x);
 if (x-a)<(b-x) then begin
  result:=a;
 end else begin
  result:=b;
 end;
end;

function RoundNearestToPowerOfTwo64(x:TPasRISCVUInt64):TPasRISCVUInt64;
var a,b:TPasRISCVUInt64;
begin
 a:=RoundDownToPowerOfTwo64(x);
 b:=RoundUpToPowerOfTwo64(x);
 if (x-a)<(b-x) then begin
  result:=a;
 end else begin
  result:=b;
 end;
end;

function RoundNearestToPowerOfTwoSizeUInt(x:TPasRISCVSizeUInt):TPasRISCVSizeUInt;
var a,b:TPasRISCVUInt32;
begin
 a:=RoundDownToPowerOfTwoSizeUInt(x);
 b:=RoundUpToPowerOfTwoSizeUInt(x);
 if (x-a)<(b-x) then begin
  result:=a;
 end else begin
  result:=b;
 end;
end;

function RoundUp(x,y:TPasRISCVUInt32):TPasRISCVUInt32;
var m:TPasRISCVUInt32;
begin
 m:=y-1;
 if (y and m)=0 then begin
  result:=(x+m) and not TPasRISCVUInt32(m);
 end else begin
  result:=((x+m) div y)*y;
 end;
end;

function RoundUp64(x,y:TPasRISCVUInt64):TPasRISCVUInt64;
var m:TPasRISCVUInt64;
begin
 m:=y-1;
 if (y and m)=0 then begin
  result:=(x+m) and not TPasRISCVUInt64(m);
 end else begin
  result:=((x+m) div y)*y;
 end;
end;

function RoundUpSizeUInt(x,y:TPasRISCVSizeUInt):TPasRISCVSizeUInt;
var m:TPasRISCVSizeUInt;
begin
 m:=y-1;
 if (y and m)=0 then begin
  result:=(x+m) and not TPasRISCVSizeUInt(m);
 end else begin
  result:=((x+m) div y)*y;
 end;
end;

function IntLog2(x:TPasRISCVUInt32):TPasRISCVUInt32; {$if defined(fpc)}{$ifdef CAN_INLINE}inline;{$endif}
begin
 if x<>0 then begin
  result:=BSRDWord(x);
 end else begin
  result:=0;
 end;
end;
{$elseif defined(cpu386)}
asm
 test eax,eax
 jz @Done
 bsr eax,eax
 @Done:
end;
{$elseif defined(cpux86_64)}
asm
{$ifndef fpc}
 .NOFRAME
{$endif}
{$ifdef Windows}
 bsr eax,ecx
{$else}
 bsr eax,edi
{$endif}
 jnz @Done
 xor eax,eax
@Done:
end;
{$else}
begin
 x:=x or (x shr 1);
 x:=x or (x shr 2);
 x:=x or (x shr 4);
 x:=x or (x shr 8);
 x:=x or (x shr 16);
 x:=x shr 1;
 dec(x,(x shr 1) and $55555555);
 x:=((x shr 2) and $33333333)+(x and $33333333);
 x:=((x shr 4)+x) and $0f0f0f0f;
 inc(x,x shr 8);
 inc(x,x shr 16);
 result:=x and $3f;
end;
{$ifend}

function IntLog264(x:TPasRISCVUInt64):TPasRISCVUInt32; {$if defined(fpc)}{$ifdef CAN_INLINE}inline;{$endif}
begin
 if x<>0 then begin
  result:=BSRQWord(x);
 end else begin
  result:=0;
 end;
end;
{$elseif defined(cpu386)}
asm
 bsr eax,dword ptr [x+4]
 jz @LowPart
 add eax,32
 jmp @Done
@LowPart:
 xor ecx,ecx
 bsr eax,dword ptr [x+0]
 jnz @Done
 xor eax,eax
@Done:
end;
{$elseif defined(cpux86_64)}
asm
{$ifndef fpc}
 .NOFRAME
{$endif}
{$ifdef Windows}
 bsr rax,rcx
{$else}
 bsr rax,rdi
{$endif}
 jnz @Done
 xor eax,eax
@Done:
end;
{$else}
begin
 x:=x or (x shr 1);
 x:=x or (x shr 2);
 x:=x or (x shr 4);
 x:=x or (x shr 8);
 x:=x or (x shr 16);
 x:=x or (x shr 32);
 x:=x shr 1;
 dec(x,(x shr 1) and $5555555555555555);
 x:=((x shr 2) and $3333333333333333)+(x and $3333333333333333);
 x:=((x shr 4)+x) and $0f0f0f0f0f0f0f0f;
 inc(x,x shr 8);
 inc(x,x shr 16);
 inc(x,x shr 32);
 result:=x and $7f;
end;
{$ifend}

function SignExtend(const aValue,aBits:TPasRISCVUInt64):TPasRISCVInt64; inline;
begin
 result:=SarInt64(TPasRISCVInt64(aValue shl (64-aBits)),64-aBits);
end;

function BitCut(const aValue,aBit,aBits:TPasRISCVUInt64):TPasRISCVUInt64; inline;
begin
 result:=(aValue shr aBit) and TPasRISCVUInt64(TPasRISCVUInt64(TPasRISCVUInt64(1) shl aBits)-1);
end;

function ReadRawFloatUI32(const aValue):TPasRISCVUInt32; inline;
begin
 result:=PPasRISCVUInt32(Pointer(@aValue))^;
end;

function ReadRawFloatF32(const aValue):TPasRISCVFloat; inline;
begin
 result:=PPasRISCVFloat(Pointer(@aValue))^;
end;

function ReadNormalizedFloatUI32(const aValue):TPasRISCVUInt32; inline;
var ui64:TPasRISCVUInt64;
begin
 ui64:=PPasRISCVUInt64(Pointer(@aValue))^;
 if (ui64 and TPasRISCVUInt64($ffffffff00000000))=TPasRISCVUInt64($ffffffff00000000) then begin
  result:=TPasRISCVUInt32(ui64);
 end else begin
  result:=TPasRISCVUInt32($7fc00000);
 end;
end;

function ReadNormalizedFloatF32(const aValue):TPasRISCVFloat;
var ui64:TPasRISCVUInt64;
begin
 ui64:=PPasRISCVUInt64(Pointer(@aValue))^;
 if (ui64 and TPasRISCVUInt64($ffffffff00000000))=TPasRISCVUInt64($ffffffff00000000) then begin
  PPasRISCVUInt32(Pointer(@result))^:=TPasRISCVUInt32(ui64);
 end else begin
  PPasRISCVUInt32(Pointer(@result))^:=TPasRISCVUInt32($7fc00000);
 end;
end;

function ReadNormalizedFloatUI16(const aValue):TPasRISCVUInt16; inline;
var ui64:TPasRISCVUInt64;
begin
 ui64:=PPasRISCVUInt64(Pointer(@aValue))^;
 if (ui64 and TPasRISCVUInt64($ffffffffffff0000))=TPasRISCVUInt64($ffffffffffff0000) then begin
  result:=TPasRISCVUInt16(ui64);
 end else begin
  result:=TPasRISCVUInt16($7e00); // Canonical f16 NaN
 end;
end;

function ReadNormalizedFloatF16(const aValue):TPasRISCVHalfFloat;
var ui64:TPasRISCVUInt64;
begin
 ui64:=PPasRISCVUInt64(Pointer(@aValue))^;
 if (ui64 and TPasRISCVUInt64($ffffffffffff0000))=TPasRISCVUInt64($ffffffffffff0000) then begin
  result.Value:=TPasRISCVUInt16(ui64);
 end else begin
  result.Value:=TPasRISCVUInt16($7e00); // Canonical f16 NaN
 end;
end;

function GetCountAudioSamples(const aInputSize,aInputChannels,aInputFormat:TPasRISCVSizeInt):TPasRISCVSizeInt;
var BitsPerSample:TPasRISCVSizeInt;
begin
 case aInputFormat of
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_IMA_ADPCM:begin
   BitsPerSample:=4;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_MU_LAW:begin
   BitsPerSample:=8;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_A_LAW:begin
   BitsPerSample:=8;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S8:begin
   BitsPerSample:=8;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U8:begin
   BitsPerSample:=8;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S16:begin
   BitsPerSample:=16;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U16:begin
   BitsPerSample:=16;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S18_3:begin
   BitsPerSample:=24;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U18_3:begin
   BitsPerSample:=24;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S20_3:begin
   BitsPerSample:=24;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U20_3:begin
   BitsPerSample:=24;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S24_3:begin
   BitsPerSample:=24;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U24_3:begin
   BitsPerSample:=24;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S24:begin
   BitsPerSample:=24;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U24:begin
   BitsPerSample:=24;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S32:begin
   BitsPerSample:=32;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U32:begin
   BitsPerSample:=32;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT:begin
   BitsPerSample:=32;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT64:begin
   BitsPerSample:=64;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U8:begin
   BitsPerSample:=8;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U16:begin
   BitsPerSample:=16;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U32:begin
   BitsPerSample:=32;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_IEC958_SUBFRAME:begin
   BitsPerSample:=32;
  end;
  else begin
   BitsPerSample:=0;
  end;
 end;
 if BitsPerSample=0 then begin
  result:=0;
 end else begin
  result:=aInputSize div (((BitsPerSample+7) shr 3)*aInputChannels);
 end;
end;

// Input Format => 32-bit float (as intermedate format for the conversion process) => Output Format
// First format conversion, then channel count conversion
function ConvertAudio(const aInput:Pointer;const aInputChannels,aInputFormat:TPasRISCVSizeInt;const aOutput:Pointer;const aOutputChannels,aOutputFormat:TPasRISCVSizeInt;const aScratchBuffer:PPasRISCVFloatArray;const aCountSamples:TPasRISCVSizeInt):Boolean;
var SampleIndex,ChannelIndex,CountTotalSamples,Offset:TPasRISCVSizeInt;
    Sample:TPasRISCVFloat;
    Value:TPasRISCVInt32;
begin

 // Input Format => 32-bit float (as intermedate format for the conversion process)
 CountTotalSamples:=aCountSamples*aInputChannels;
 case aInputFormat of
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_IMA_ADPCM:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_MU_LAW:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_A_LAW:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S8:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    aScratchBuffer^[SampleIndex]:=TPasRISCVInt32(PPasRISCVInt8Array(aInput)^[SampleIndex])/128.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U8:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    aScratchBuffer^[SampleIndex]:=(TPasRISCVInt32(PPasRISCVUInt8Array(aInput)^[SampleIndex])-128)/128.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S16:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    aScratchBuffer^[SampleIndex]:=TPasRISCVInt32(PPasRISCVInt16Array(aInput)^[SampleIndex])/32768.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U16:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    aScratchBuffer^[SampleIndex]:=TPasRISCVInt32(PPasRISCVUInt16Array(aInput)^[SampleIndex])/32768.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S18_3:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U18_3:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S20_3:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U20_3:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S24_3:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=TPasRISCVInt32((TPasRISCVUInt32(PPasRISCVUInt8Array(aInput)^[(SampleIndex*3)+0]) shl 8) or
                          (TPasRISCVUInt32(PPasRISCVUInt8Array(aInput)^[(SampleIndex*3)+1]) shl 16) or
                          (TPasRISCVUInt32(PPasRISCVUInt8Array(aInput)^[(SampleIndex*3)+2]) shl 24));
    aScratchBuffer^[SampleIndex]:=Value/2147483648.0;
   end;
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U24_3:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=TPasRISCVInt32((TPasRISCVUInt32(PPasRISCVUInt8Array(aInput)^[(SampleIndex*3)+0]) shl 8) or
                          (TPasRISCVUInt32(PPasRISCVUInt8Array(aInput)^[(SampleIndex*3)+1]) shl 16) or
                          (TPasRISCVUInt32(PPasRISCVUInt8Array(aInput)^[(SampleIndex*3)+2]) shl 24))-2147483648;
    aScratchBuffer^[SampleIndex]:=Value/2147483648.0;
   end;
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S20:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=TPasRISCVInt32(PPasRISCVInt32Array(aInput)^[SampleIndex]);
    if Value<-524288 then begin
     Value:=-524288;
    end else if Value>524288 then begin
     Value:=524288;
    end;
    aScratchBuffer^[SampleIndex]:=Value/524288.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U20:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=TPasRISCVInt32(PPasRISCVUInt32Array(aInput)^[SampleIndex])-524288;
    if Value<-524288 then begin
     Value:=-524288;
    end else if Value>524288 then begin
     Value:=524288;
    end;
    aScratchBuffer^[SampleIndex]:=Value/524288.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S24:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=TPasRISCVInt32(PPasRISCVInt32Array(aInput)^[SampleIndex]);
    if Value<-8388608 then begin
     Value:=-8388608;
    end else if Value>8388608 then begin
     Value:=8388608;
    end;
    aScratchBuffer^[SampleIndex]:=Value/8388608.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U24:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=TPasRISCVInt32(PPasRISCVUInt32Array(aInput)^[SampleIndex])-8388608;
    if Value<-8388608 then begin
     Value:=-8388608;
    end else if Value>8388608 then begin
     Value:=8388608;
    end;
    aScratchBuffer^[SampleIndex]:=Value/8388608.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S32:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    aScratchBuffer^[SampleIndex]:=TPasRISCVInt32(PPasRISCVInt32Array(aInput)^[SampleIndex])/2147483648.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U32:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    aScratchBuffer^[SampleIndex]:=(TPasRISCVInt32(PPasRISCVUInt32Array(aInput)^[SampleIndex])-2147483648)/2147483648.0;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    aScratchBuffer^[SampleIndex]:=TPasRISCVFloat(PPasRISCVFloatArray(aInput)^[SampleIndex]);
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT64:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    aScratchBuffer^[SampleIndex]:=PPasRISCVDoubleArray(aInput)^[SampleIndex];
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U8:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U16:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U32:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_IEC958_SUBFRAME:begin
   result:=false; // Not implemented
   exit;
  end;
  else begin
   result:=false;
   exit;
  end;
 end;

 // Channel count conversion, but only if the channel count differs
 if (aInputChannels<>aOutputChannels) and (aInputChannels>0) and (aOutputChannels>0) then begin
  Offset:=aCountSamples*aInputChannels;
  if aInputChannels<aOutputChannels then begin
   // Expand channels
   if (aInputChannels=1) and (aOutputChannels=2) then begin
    for SampleIndex:=0 to aCountSamples-1 do begin
     aScratchBuffer^[Offset+(SampleIndex*aOutputChannels)+0]:=aScratchBuffer^[SampleIndex];
     aScratchBuffer^[Offset+(SampleIndex*aOutputChannels)+1]:=aScratchBuffer^[SampleIndex];
    end;
   end else begin
    for ChannelIndex:=0 to aInputChannels-1 do begin
     for SampleIndex:=0 to aCountSamples-1 do begin
      aScratchBuffer^[Offset+(SampleIndex*aOutputChannels)+ChannelIndex]:=aScratchBuffer^[(SampleIndex*aInputChannels)+ChannelIndex];
     end;
    end;
    for ChannelIndex:=aInputChannels to aOutputChannels-1 do begin
     for SampleIndex:=0 to aCountSamples-1 do begin
      aScratchBuffer^[Offset+(SampleIndex*aOutputChannels)+ChannelIndex]:=0.0;
     end;
    end;
    // Exception, if input channels are 1 and output channels are 2 or more, we must duplicate the channel to the second channel
    if (aInputChannels=1) and (aOutputChannels>=2) then begin
     for SampleIndex:=0 to aCountSamples-1 do begin
      aScratchBuffer^[Offset+(SampleIndex*aOutputChannels)+1]:=aScratchBuffer^[Offset+(SampleIndex*aOutputChannels)+0];
     end;
    end;
   end;
  end else begin
   // Reduce channels
   if aOutputChannels=1 then begin
    // Exception, if input channels are 2 and output channels are 1, we must mix the channels to mono, don't matter how many other input channels are there
    for SampleIndex:=0 to aCountSamples-1 do begin
     aScratchBuffer^[Offset+(SampleIndex*aOutputChannels)+0]:=(aScratchBuffer^[(SampleIndex*aInputChannels)+0]+aScratchBuffer^[(SampleIndex*aInputChannels)+1])*0.5;
    end;
   end else begin
    for ChannelIndex:=0 to aOutputChannels-1 do begin
     for SampleIndex:=0 to aCountSamples-1 do begin
      aScratchBuffer^[Offset+(SampleIndex*aOutputChannels)+ChannelIndex]:=aScratchBuffer^[(SampleIndex*aInputChannels)+ChannelIndex];
     end;
    end;
   end;
  end;
 end else begin
  Offset:=0;
 end;

 // Clipping if the output format is not float or float64 to prevent integer overflow in the next step
 if (aOutputFormat<>TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT) and (aOutputFormat<>TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT64) then begin
  CountTotalSamples:=aCountSamples*aOutputChannels;
  for SampleIndex:=0 to CountTotalSamples-1 do begin
   Sample:=aScratchBuffer^[Offset+SampleIndex];
   if Sample<-1.0 then begin
    Sample:=-1.0;
   end else if Sample>1.0 then begin
    Sample:=1.0;
   end;
   aScratchBuffer^[Offset+SampleIndex]:=Sample;
  end;
 end;

 // Output Format
 CountTotalSamples:=aCountSamples*aOutputChannels;
 case aOutputFormat of
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_IMA_ADPCM:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_MU_LAW:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_A_LAW:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S8:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round(aScratchBuffer^[Offset+SampleIndex]*128.0);
    if Value<-128 then begin
     Value:=-128;
    end else if Value>127 then begin
     Value:=127;
    end;
    PPasRISCVInt8Array(aOutput)^[SampleIndex]:=TPasRISCVInt8(Value);
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U8:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round((aScratchBuffer^[Offset+SampleIndex]*128.0)+128);
    if Value<0 then begin
     Value:=0;
    end else if Value>255 then begin
     Value:=255;
    end;
    PPasRISCVUInt8Array(aOutput)^[SampleIndex]:=TPasRISCVUInt8(Value);
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S16:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round(aScratchBuffer^[Offset+SampleIndex]*32768.0);
    if Value<-32768 then begin
     Value:=-32768;
    end else if Value>32767 then begin
     Value:=32767;
    end;
    PPasRISCVInt16Array(aOutput)^[SampleIndex]:=TPasRISCVInt16(Value);
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U16:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round((aScratchBuffer^[Offset+Offset+SampleIndex]*32768.0)+32768);
    if Value<0 then begin
     Value:=0;
    end else if Value>65535 then begin
     Value:=65535;
    end;
    PPasRISCVUInt16Array(aOutput)^[SampleIndex]:=TPasRISCVUInt16(Value);
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S18_3:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U18_3:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S20_3:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U20_3:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S24_3:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round(aScratchBuffer^[Offset+SampleIndex]*2147483648.0);
    PPasRISCVUInt8Array(aOutput)^[(SampleIndex*3)+0]:=TPasRISCVUInt8((Value shr 8) and $ff);
    PPasRISCVUInt8Array(aOutput)^[(SampleIndex*3)+1]:=TPasRISCVUInt8((Value shr 16) and $ff);
    PPasRISCVUInt8Array(aOutput)^[(SampleIndex*3)+2]:=TPasRISCVUInt8((Value shr 24) and $ff);
   end;
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U24_3:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round((aScratchBuffer^[Offset+SampleIndex]*2147483648.0)+2147483648);
    PPasRISCVUInt8Array(aOutput)^[(SampleIndex*3)+0]:=TPasRISCVUInt8((Value shr 8) and $ff);
    PPasRISCVUInt8Array(aOutput)^[(SampleIndex*3)+1]:=TPasRISCVUInt8((Value shr 16) and $ff);
    PPasRISCVUInt8Array(aOutput)^[(SampleIndex*3)+2]:=TPasRISCVUInt8((Value shr 24) and $ff);
   end;
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S20:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round(aScratchBuffer^[Offset+SampleIndex]*524288.0);
    if Value<-524288 then begin
     Value:=-524288;
    end else if Value>524287 then begin
     Value:=524287;
    end;
    PPasRISCVInt32Array(aOutput)^[SampleIndex]:=Value;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U20:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round((aScratchBuffer^[Offset+SampleIndex]*524288.0)+524288);
    if Value<0 then begin
     Value:=0;
    end else if Value>1048575 then begin
     Value:=1048575;
    end;
    PPasRISCVUInt32Array(aOutput)^[SampleIndex]:=Value;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S24:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round(aScratchBuffer^[Offset+SampleIndex]*8388608.0);
    if Value<-8388608 then begin
     Value:=-8388608;
    end else if Value>8388607 then begin
     Value:=8388607;
    end;
    PPasRISCVInt32Array(aOutput)^[SampleIndex]:=Value;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U24:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    Value:=round((aScratchBuffer^[Offset+SampleIndex]*8388608.0)+8388608);
    if Value<0 then begin
     Value:=0;
    end else if Value>16777215 then begin
     Value:=16777215;
    end;
    PPasRISCVUInt32Array(aOutput)^[SampleIndex]:=Value;
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_S32:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    PPasRISCVInt32Array(aOutput)^[SampleIndex]:=round(aScratchBuffer^[Offset+SampleIndex]*2147483648.0);
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_U32:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    PPasRISCVUInt32Array(aOutput)^[SampleIndex]:=round((aScratchBuffer^[Offset+SampleIndex]*2147483648.0)+2147483648);
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    PPasRISCVFloatArray(aOutput)^[SampleIndex]:=aScratchBuffer^[Offset+SampleIndex];
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT64:begin
   for SampleIndex:=0 to CountTotalSamples-1 do begin
    PPasRISCVDoubleArray(aOutput)^[SampleIndex]:=aScratchBuffer^[Offset+SampleIndex];
   end;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U8:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U16:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_DSD_U32:begin
   result:=false; // Not implemented
   exit;
  end;
  TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_IEC958_SUBFRAME:begin
   result:=false; // Not implemented
   exit;
  end;
  else begin
   result:=false;
   exit;
  end;
 end;

 // We are done

 result:=true;

end;

// 32-bit float linear resampling, with start frame values from the end of the previous frame, for continuous resampling
function ResampleLinear(const aInput:PPasRISCVFloatArray;const aInputSamples:TPasRISCVSizeInt;const aOutput:PPasRISCVFloatArray;const aOutputSamples,aChannels:TPasRISCVSizeInt;const aPreviousFrameEndValues:PPasRISCVFloatArray;var aPosition:TPasRISCVUInt64;const aPositionIncrement:TPasRISCVUInt64):Boolean;
const Div32Bit=1.0/4294967296.0;
var ChannelIndex,OutputSampleIndex,InputSampleIndex,PreviousInputSampleIndex:TPasRISCVSizeInt;
    Sample,PreviousSample,Alpha:TPasRISCVFloat;
    Position:TPasRISCVUInt64;
begin
 Position:=aPosition;
 for ChannelIndex:=0 to aChannels-1 do begin
  Position:=aPosition and TPasRISCVUInt64($ffffffff); // 32.32 fixed point
  for OutputSampleIndex:=0 to aOutputSamples-1 do begin
   InputSampleIndex:=Position shr 32;
   if InputSampleIndex>=aInputSamples then begin
    InputSampleIndex:=aInputSamples-1;
   end;
   PreviousInputSampleIndex:=InputSampleIndex-1;
   if PreviousInputSampleIndex<0 then begin
    PreviousSample:=aPreviousFrameEndValues^[ChannelIndex];
   end else begin
    PreviousSample:=aInput^[(PreviousInputSampleIndex*aChannels)+ChannelIndex];
   end;
   Alpha:=(Position and TPasRISCVUInt64($ffffffff))*Div32Bit;
   Sample:=(PreviousSample*(1.0-Alpha))+(aInput^[(InputSampleIndex*aChannels)+ChannelIndex]*Alpha);
   aOutput^[(OutputSampleIndex*aChannels)+ChannelIndex]:=Sample;
   inc(Position,aPositionIncrement);
  end;
 end;
 for ChannelIndex:=0 to aChannels-1 do begin
  aPreviousFrameEndValues^[ChannelIndex]:=aInput^[((aInputSamples-1)*aChannels)+ChannelIndex];
 end;
 aPosition:=Position;
 result:=true;
end;

function Marshall(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt;var aPOffset:TPasRISCVSizeInt;const aFmt:TPasRISCVRawByteString;const aArgs:array of pointer):Boolean;
var FmtIndex,ArgIndex,Len:TPasRISCVSizeInt;
    BufferBegin,BufferEnd,BufferCurrent:PPasRISCVUInt8;
    c:AnsiChar;
begin
 if aPOffset<aSize then begin
  BufferBegin:=@PPasRISCVUInt8Array(aBuffer)^[aPOffset];
  BufferEnd:=@PPasRISCVUInt8Array(aBuffer)^[aSize];
  BufferCurrent:=BufferBegin;
  FmtIndex:=1;
  while (TPasRISCVPtrUInt(BufferCurrent)<TPasRISCVPtrUInt(BufferEnd)) and (FmtIndex<=length(aFmt)) do begin
   ArgIndex:=FmtIndex-1;
   c:=aFmt[FmtIndex];
   inc(FmtIndex);
   case c of
    'b':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt8))<=TPasRISCVPtrUInt(BufferEnd) then begin
      PPasRISCVUInt8(BufferCurrent)^:=PPasRISCVUInt8(aArgs[ArgIndex])^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt8));
     end else begin
      result:=false;
      exit;
     end;
    end;
    'h':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt16))<=TPasRISCVPtrUInt(BufferEnd) then begin
      PPasRISCVUInt16(BufferCurrent)^:=PPasRISCVUInt16(aArgs[ArgIndex])^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt16));
     end else begin
      result:=false;
      exit;
     end;
    end;
    'w':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt32))<=TPasRISCVPtrUInt(BufferEnd) then begin
      PPasRISCVUInt32(BufferCurrent)^:=PPasRISCVUInt32(aArgs[ArgIndex])^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt32));
     end else begin
      result:=false;
      exit;
     end;
    end;
    'd':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt64))<=TPasRISCVPtrUInt(BufferEnd) then begin
      PPasRISCVUInt64(BufferCurrent)^:=PPasRISCVUInt64(aArgs[ArgIndex])^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt64));
     end else begin
      result:=false;
      exit;
     end;
    end;
    's':begin
     Len:=length(PPasRISCVRawByteString(aArgs[ArgIndex])^);
     if (Len<=65535) and ((TPasRISCVPtrUInt(BufferCurrent)+Len+2)<=TPasRISCVPtrUInt(BufferEnd)) then begin
      PPasRISCVUInt16(BufferCurrent)^:=Len;
      inc(BufferCurrent,sizeof(TPasRISCVUInt16));
      if Len>0 then begin
       Move(PPasRISCVRawByteString(aArgs[ArgIndex])^[1],BufferCurrent^,Len);
       inc(BufferCurrent,Len);
      end;
     end else begin
      result:=false;
      exit;
     end;
    end;
    'Q':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+13)<=TPasRISCVPtrUInt(BufferEnd) then begin
      Move(aArgs[ArgIndex]^,BufferCurrent^,13);
      inc(BufferCurrent,13);
     end else begin
      result:=false;
      exit;
     end;
    end;
    else begin
     result:=false;
     exit;
    end;
   end;
  end;
  inc(aPOffset,TPasRISCVPtrUInt(BufferCurrent)-TPasRISCVPtrUInt(BufferBegin));
  result:=true;
 end;
end;

function Unmarshall(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt;var aPOffset:TPasRISCVSizeInt;const aFmt:TPasRISCVRawByteString;const aArgs:array of pointer):Boolean;
var FmtIndex,ArgIndex,Len:TPasRISCVSizeInt;
    BufferBegin,BufferEnd,BufferCurrent:PPasRISCVUInt8;
    c:AnsiChar;
begin
 if aPOffset<aSize then begin
  BufferBegin:=@PPasRISCVUInt8Array(aBuffer)^[aPOffset];
  BufferEnd:=@PPasRISCVUInt8Array(aBuffer)^[aSize];
  BufferCurrent:=BufferBegin;
  FmtIndex:=1;
  while (TPasRISCVPtrUInt(BufferCurrent)<TPasRISCVPtrUInt(BufferEnd)) and (FmtIndex<=length(aFmt)) do begin
   ArgIndex:=FmtIndex-1;
   c:=aFmt[FmtIndex];
   inc(FmtIndex);
   case c of
    'b':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt8))<=TPasRISCVPtrUInt(BufferEnd) then begin
      PPasRISCVUInt8(aArgs[ArgIndex])^:=PPasRISCVUInt8(BufferCurrent)^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt8));
     end else begin
      result:=false;
      exit;
     end;
    end;
    'h':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt16))<=TPasRISCVPtrUInt(BufferEnd) then begin
      PPasRISCVUInt16(aArgs[ArgIndex])^:=PPasRISCVUInt16(BufferCurrent)^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt16));
     end else begin
      result:=false;
      exit;
     end;
    end;
    'w':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt32))<=TPasRISCVPtrUInt(BufferEnd) then begin
      PPasRISCVUInt32(aArgs[ArgIndex])^:=PPasRISCVUInt32(BufferCurrent)^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt32));
     end else begin
      result:=false;
      exit;
     end;
    end;
    'd':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt64))<=TPasRISCVPtrUInt(BufferEnd) then begin
      PPasRISCVUInt64(aArgs[ArgIndex])^:=PPasRISCVUInt64(BufferCurrent)^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt64));
     end else begin
      result:=false;
      exit;
     end;
    end;
    's':begin
     PPasRISCVRawByteString(aArgs[ArgIndex])^:='';
     if (TPasRISCVPtrUInt(BufferCurrent)+sizeof(TPasRISCVUInt16))<=TPasRISCVPtrUInt(BufferEnd) then begin
      Len:=PPasRISCVUInt16(BufferCurrent)^;
      inc(BufferCurrent,sizeof(TPasRISCVUInt16));
      SetLength(PPasRISCVRawByteString(aArgs[ArgIndex])^,Len);
      if Len>0 then begin
       if (TPasRISCVPtrUInt(BufferCurrent)+Len)<=TPasRISCVPtrUInt(BufferEnd) then begin
        Move(BufferCurrent^,PPasRISCVRawByteString(aArgs[ArgIndex])^[1],Len);
        inc(BufferCurrent,Len);
       end else begin
        result:=false;
        exit;
       end;
      end;
     end else begin
      result:=false;
      exit;
     end;
    end;
    'Q':begin
     if (TPasRISCVPtrUInt(BufferCurrent)+13)<=TPasRISCVPtrUInt(BufferEnd) then begin
      Move(BufferCurrent^,aArgs[ArgIndex]^,13);
      inc(BufferCurrent,13);
     end else begin
      result:=false;
      exit;
     end;
    end;
    else begin
     result:=false;
     exit;
    end;
   end;
  end;
  inc(aPOffset,TPasRISCVPtrUInt(BufferCurrent)-TPasRISCVPtrUInt(BufferBegin));
  result:=true;
 end else begin
  result:=false;
 end;
end;

function DoInflate(const aInData:Pointer;aInLen:TPasRISCVSizeUInt;var aDestData:Pointer;var aDestLen:TPasRISCVSizeUInt;const aParseHeader:Boolean):Boolean;
{$if not defined(fpc)}
const OutChunkSize=65536;
var d_stream:z_stream;
    r:TPasRISCVInt32;
    Allocated,Have:TPasRISCVSizeUInt;
begin
 result:=false;
 aDestLen:=0;
 Allocated:=0;
 aDestData:=nil;
 FillChar(d_stream,SizeOf(z_stream),AnsiChar(#0));
 d_stream.next_in:=aInData;
 d_stream.avail_in:=aInLen;
 if aParseHeader then begin
  r:=inflateInit(d_stream);
 end else begin
  r:=inflateInit2(d_stream,-15{MAX_WBITS});
 end;
 try
  if r=Z_OK then begin
   try
    Allocated:=RoundUpToPowerOfTwo(aInLen);
    if Allocated<OutChunkSize then begin
     Allocated:=OutChunkSize;
    end;
    GetMem(aDestData,Allocated);
    repeat
     repeat
      if Allocated<(aDestLen+OutChunkSize) then begin
       Allocated:=RoundUpToPowerOfTwo(aDestLen+OutChunkSize);
       if assigned(aDestData) then begin
        ReallocMem(aDestData,Allocated);
       end else begin
        GetMem(aDestData,Allocated);
       end;
      end;
      d_stream.next_out:=@PPasRISCVUInt8Array(aDestData)^[aDestLen];
      d_stream.avail_out:=OutChunkSize;
      r:=Inflate(d_stream,Z_NO_FLUSH);
      if r<Z_OK then begin
       break;
      end;
      if d_stream.avail_out<OutChunkSize then begin
       inc(aDestLen,OutChunkSize-d_stream.avail_out);
      end;
     until d_stream.avail_out<>0;
    until (r<Z_OK) or (r=Z_STREAM_END);
   finally
    if r=Z_STREAM_END then begin
     r:=InflateEnd(d_stream);
    end else begin
     InflateEnd(d_stream);
    end;
   end;
  end;
 finally
  if (r=Z_OK) or (r=Z_STREAM_END) then begin
   if assigned(aDestData) then begin
    ReallocMem(aDestData,aDestLen);
   end else begin
    aDestLen:=0;
   end;
   result:=true;
  end else begin
   if assigned(aDestData) then begin
    FreeMem(aDestData);
   end;
   aDestData:=nil;
  end;
 end;
end;
{$elseif defined(fpc) and (defined(Linux) or defined(Android))}
const OutChunkSize=65536;
var d_stream:z_stream;
    r:TPasRISCVInt32;
    Allocated,Have:TPasRISCVSizeUInt;
begin
 result:=false;
 aDestLen:=0;
 Allocated:=0;
 aDestData:=nil;
 FillChar(d_stream,SizeOf(z_stream),AnsiChar(#0));
 d_stream.next_in:=aInData;
 d_stream.avail_in:=aInLen;
 if aParseHeader then begin
  r:=inflateInit(d_stream);
 end else begin
  r:=inflateInit2(d_stream,-15{MAX_WBITS});
 end;
 try
  if r=Z_OK then begin
   try
    Allocated:=RoundUpToPowerOfTwo(aInLen);
    if Allocated<OutChunkSize then begin
     Allocated:=OutChunkSize;
    end;
    GetMem(aDestData,Allocated);
    repeat
     repeat
      if Allocated<(aDestLen+OutChunkSize) then begin
       Allocated:=RoundUpToPowerOfTwo(aDestLen+OutChunkSize);
       if assigned(aDestData) then begin
        ReallocMem(aDestData,Allocated);
       end else begin
        GetMem(aDestData,Allocated);
       end;
      end;
      d_stream.next_out:=@PPasRISCVUInt8Array(aDestData)^[aDestLen];
      d_stream.avail_out:=OutChunkSize;
      r:=Inflate(d_stream,Z_NO_FLUSH);
      if r<Z_OK then begin
       break;
      end;
      if d_stream.avail_out<OutChunkSize then begin
       inc(aDestLen,OutChunkSize-d_stream.avail_out);
      end;
     until d_stream.avail_out<>0;
    until (r<Z_OK) or (r=Z_STREAM_END);
   finally
    if r=Z_STREAM_END then begin
     r:=InflateEnd(d_stream);
    end else begin
     InflateEnd(d_stream);
    end;
   end;
  end;
 finally
  if (r=Z_OK) or (r=Z_STREAM_END) then begin
   if assigned(aDestData) then begin
    ReallocMem(aDestData,aDestLen);
   end else begin
    aDestLen:=0;
   end;
   result:=true;
  end else begin
   if assigned(aDestData) then begin
    FreeMem(aDestData);
   end;
   aDestData:=nil;
  end;
 end;
end;
{$else}
const CLCIndex:array[0..18] of TPasRISCVUInt8=(16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15);
type PTree=^TTree;
     TTree=packed record
      Table:array[0..15] of TPasRISCVUInt16;
      Translation:array[0..287] of TPasRISCVUInt16;
     end;
     PBuffer=^TBuffer;
     TBuffer=array[0..65535] of TPasRISCVUInt8;
     PLengths=^TLengths;
     TLengths=array[0..288+32-1] of TPasRISCVUInt8;
     POffsets=^TOffsets;
     TOffsets=array[0..15] of TPasRISCVUInt16;
     PBits=^TBits;
     TBits=array[0..29] of TPasRISCVUInt8;
     PBase=^TBase;
     TBase=array[0..29] of TPasRISCVUInt16;
var Tag,BitCount,DestSize:TPasRISCVUInt32;
    SymbolLengthTree,DistanceTree,FixedSymbolLengthTree,FixedDistanceTree:PTree;
    LengthBits,DistanceBits:PBits;
    LengthBase,DistanceBase:PBase;
    Source,SourceEnd:PPasRISCVRawByteChar;
    Dest:PPasRISCVRawByteChar;
 procedure IncSize(length:TPasRISCVUInt32);
 var j:TPasRISCVUInt32;
 begin
  if (aDestLen+length)>=DestSize then begin
   if DestSize=0 then begin
    DestSize:=1;
   end;
   while (aDestLen+length)>=DestSize do begin
    inc(DestSize,DestSize);
   end;
   j:=TPasRISCVPtrUInt(Dest)-TPasRISCVPtrUInt(aDestData);
   ReAllocMem(aDestData,DestSize);
   TPasRISCVPtrUInt(Dest):=TPasRISCVPtrUInt(aDestData)+j;
  end;
 end;
 function Adler32(data:Pointer;length:TPasRISCVSizeUInt):TPasRISCVUInt32;
 const BASE=65521;
       NMAX=5552;
 var buf:PPasRISCVRawByteChar;
     s1,s2:TPasRISCVUInt32;
     k,i:TPasRISCVSizeUInt;
 begin
  s1:=1;
  s2:=0;
  buf:=data;
  while length>0 do begin
   if length<NMAX then begin
    k:=length;
   end else begin
    k:=NMAX;
   end;
   dec(length,k);
   for i:=1 to k do begin
    inc(s1,TPasRISCVUInt8(buf^));
    inc(s2,s1);
    inc(buf);
   end;
   s1:=s1 mod BASE;
   s2:=s2 mod BASE;
  end;
  result:=(s2 shl 16) or s1;
 end;
 procedure BuildBitsBase(Bits:PPasRISCVRawByteChar;Base:PPasRISCVUInt16;Delta,First:TPasRISCVInt32);
 var i,Sum:TPasRISCVInt32;
 begin
  for i:=0 to Delta-1 do begin
   Bits[i]:=TPasRISCVRawByteChar(#0);
  end;
  for i:=0 to (30-Delta)-1 do begin
   Bits[i+Delta]:=TPasRISCVRawByteChar(TPasRISCVUInt8(i div Delta));
  end;
  Sum:=First;
  for i:=0 to 29 do begin
   Base^:=Sum;
   inc(Base);
   inc(Sum,1 shl TPasRISCVUInt8(Bits[i]));
  end;
 end;
 procedure BuildFixedTrees(var lt,dt:TTree);
 var i:TPasRISCVInt32;
 begin
  for i:=0 to 6 do begin
   lt.Table[i]:=0;
  end;
  lt.Table[7]:=24;
  lt.Table[8]:=152;
  lt.Table[9]:=112;
  for i:=0 to 23 do begin
   lt.Translation[i]:=256+i;
  end;
  for i:=0 to 143 do begin
   lt.Translation[24+i]:=i;
  end;
  for i:=0 to 7 do begin
   lt.Translation[168+i]:=280+i;
  end;
  for i:=0 to 111 do begin
   lt.Translation[176+i]:=144+i;
  end;
  for i:=0 to 4 do begin
   dt.Table[i]:=0;
  end;
  dt.Table[5]:=32;
  for i:=0 to 31 do begin
   dt.Translation[i]:=i;
  end;
 end;
 procedure BuildTree(var t:TTree;Lengths:PPasRISCVRawByteChar;Num:TPasRISCVInt32);
 var Offsets:POffsets;
     i:TPasRISCVInt32;
     Sum:TPasRISCVUInt32;
 begin
  New(Offsets);
  try
   for i:=0 to 15 do begin
    t.Table[i]:=0;
   end;
   for i:=0 to Num-1 do begin
    inc(t.Table[TPasRISCVUInt8(Lengths[i])]);
   end;
   t.Table[0]:=0;
   Sum:=0;
   for i:=0 to 15 do begin
    Offsets^[i]:=Sum;
    inc(Sum,t.Table[i]);
   end;
   for i:=0 to Num-1 do begin
    if lengths[i]<>TPasRISCVRawByteChar(#0) then begin
     t.Translation[Offsets^[TPasRISCVUInt8(lengths[i])]]:=i;
     inc(Offsets^[TPasRISCVUInt8(lengths[i])]);
    end;
   end;
  finally
   Dispose(Offsets);
  end;
 end;
 function GetBit:TPasRISCVUInt32;
 begin
  if BitCount=0 then begin
   Tag:=TPasRISCVUInt8(Source^);
   inc(Source);
   BitCount:=7;
  end else begin
   dec(BitCount);
  end;
  result:=Tag and 1;
  Tag:=Tag shr 1;
 end;
 function ReadBits(Num,Base:TPasRISCVUInt32):TPasRISCVUInt32;
 var Limit,Mask:TPasRISCVUInt32;
 begin
  result:=0;
  if Num<>0 then begin
   Limit:=1 shl Num;
   Mask:=1;
   while Mask<Limit do begin
    if GetBit<>0 then begin
     inc(result,Mask);
    end;
    Mask:=Mask shl 1;
   end;
  end;
  inc(result,Base);
 end;
 function DecodeSymbol(var t:TTree):TPasRISCVUInt32;
 var Sum,c,l:TPasRISCVInt32;
 begin
  Sum:=0;
  c:=0;
  l:=0;
  repeat
   c:=(c*2)+TPasRISCVInt32(GetBit);
   inc(l);
   inc(Sum,t.Table[l]);
   dec(c,t.Table[l]);
  until not (c>=0);
  result:=t.Translation[Sum+c];
 end;
 procedure DecodeTrees(var lt,dt:TTree);
 var CodeTree:PTree;
     Lengths:PLengths;
     hlit,hdist,hclen,i,num,length,clen,Symbol,Prev:TPasRISCVUInt32;
 begin
  New(CodeTree);
  New(Lengths);
  try
   FillChar(CodeTree^,sizeof(TTree),TPasRISCVRawByteChar(#0));
   FillChar(Lengths^,sizeof(TLengths),TPasRISCVRawByteChar(#0));
   hlit:=ReadBits(5,257);
   hdist:=ReadBits(5,1);
   hclen:=ReadBits(4,4);
   for i:=0 to 18 do begin
    lengths^[i]:=0;
   end;
   for i:=1 to hclen do begin
    clen:=ReadBits(3,0);
    lengths^[CLCIndex[i-1]]:=clen;
   end;
   BuildTree(CodeTree^,PPasRISCVRawByteChar(Pointer(@lengths^[0])),19);
   num:=0;
   while num<(hlit+hdist) do begin
    Symbol:=DecodeSymbol(CodeTree^);
    case Symbol of
     16:begin
      prev:=lengths^[num-1];
      length:=ReadBits(2,3);
      while length>0 do begin
       lengths^[num]:=prev;
       inc(num);
       dec(length);
      end;
     end;
     17:begin
      length:=ReadBits(3,3);
      while length>0 do begin
       lengths^[num]:=0;
       inc(num);
       dec(length);
      end;
     end;
     18:begin
      length:=ReadBits(7,11);
      while length>0 do begin
       lengths^[num]:=0;
       inc(num);
       dec(length);
      end;
     end;
     else begin
      lengths^[num]:=Symbol;
      inc(num);
     end;
    end;
   end;
   BuildTree(lt,PPasRISCVRawByteChar(Pointer(@lengths^[0])),hlit);
   BuildTree(dt,PPasRISCVRawByteChar(Pointer(@lengths^[hlit])),hdist);
  finally
   Dispose(CodeTree);
   Dispose(Lengths);
  end;
 end;
 function InflateBlockData(var lt,dt:TTree):Boolean;
 var Symbol:TPasRISCVUInt32;
     Length,Distance,Offset,i:TPasRISCVInt32;
 begin
  result:=false;
  while (Source<SourceEnd) or (BitCount>0) do begin
   Symbol:=DecodeSymbol(lt);
   if Symbol=256 then begin
    result:=true;
    break;
   end;
   if Symbol<256 then begin
    IncSize(1);
    Dest^:=TPasRISCVRawByteChar(TPasRISCVUInt8(Symbol));
    inc(Dest);
    inc(aDestLen);
   end else begin
    dec(Symbol,257);
    Length:=ReadBits(LengthBits^[Symbol],LengthBase^[Symbol]);
    Distance:=DecodeSymbol(dt);
    Offset:=ReadBits(DistanceBits^[Distance],DistanceBase^[Distance]);
    IncSize(length);
    for i:=0 to length-1 do begin
     Dest[i]:=Dest[i-Offset];
    end;
    inc(Dest,Length);
    inc(aDestLen,Length);
   end;
  end;
 end;
 function InflateUncompressedBlock:Boolean;
 var length,invlength:TPasRISCVUInt32;
 begin
  result:=false;
  length:=(TPasRISCVUInt8(source[1]) shl 8) or TPasRISCVUInt8(source[0]);
  invlength:=(TPasRISCVUInt8(source[3]) shl 8) or TPasRISCVUInt8(source[2]);
  if length<>((not invlength) and $ffff) then begin
   exit;
  end;
  IncSize(length);
  inc(Source,4);
  if Length>0 then begin
   Move(Source^,Dest^,Length);
   inc(Source,Length);
   inc(Dest,Length);
  end;
  BitCount:=0;
  inc(aDestLen,Length);
  result:=true;
 end;
 function InflateFixedBlock:Boolean;
 begin
  result:=InflateBlockData(FixedSymbolLengthTree^,FixedDistanceTree^);
 end;
 function InflateDynamicBlock:Boolean;
 begin
  DecodeTrees(SymbolLengthTree^,DistanceTree^);
  result:=InflateBlockData(SymbolLengthTree^,DistanceTree^);
 end;
 function Uncompress:Boolean;
 var Final,r:Boolean;
     BlockType:TPasRISCVUInt32;
 begin
  result:=false;
  BitCount:=0;
  Final:=false;
  while not Final do begin
   Final:=GetBit<>0;
   BlockType:=ReadBits(2,0);
   case BlockType of
    0:begin
     r:=InflateUncompressedBlock;
    end;
    1:begin
     r:=InflateFixedBlock;
    end;
    2:begin
     r:=InflateDynamicBlock;
    end;
    else begin
     r:=false;
    end;
   end;
   if not r then begin
    exit;
   end;
  end;
  result:=true;
 end;
 function UncompressZLIB:Boolean;
 var cmf,flg:TPasRISCVUInt8;
     a32:TPasRISCVUInt32;
 begin
  result:=false;
  Source:=aInData;
  cmf:=TPasRISCVUInt8(Source[0]);
  flg:=TPasRISCVUInt8(Source[1]);
  if ((((cmf shl 8)+flg) mod 31)<>0) or ((cmf and $f)<>8) or ((cmf shr 4)>7) or ((flg and $20)<>0) then begin
   exit;
  end;
  a32:=(TPasRISCVUInt8(Source[aInLen-4]) shl 24) or (TPasRISCVUInt8(Source[aInLen-3]) shl 16) or (TPasRISCVUInt8(Source[aInLen-2]) shl 8) or (TPasRISCVUInt8(Source[aInLen-1]) shl 0);
  inc(Source,2);
  dec(aInLen,6);
  SourceEnd:=@Source[aInLen];
  result:=Uncompress;
  if not result then begin
   exit;
  end;
  result:=Adler32(aDestData,aDestLen)=a32;
 end;
 function UncompressDirect:Boolean;
 begin
  Source:=aInData;
  SourceEnd:=@Source[aInLen];
  result:=Uncompress;
 end;
begin
 aDestData:=nil;
 LengthBits:=nil;
 DistanceBits:=nil;
 LengthBase:=nil;
 DistanceBase:=nil;
 SymbolLengthTree:=nil;
 DistanceTree:=nil;
 FixedSymbolLengthTree:=nil;
 FixedDistanceTree:=nil;
 try
  New(LengthBits);
  New(DistanceBits);
  New(LengthBase);
  New(DistanceBase);
  New(SymbolLengthTree);
  New(DistanceTree);
  New(FixedSymbolLengthTree);
  New(FixedDistanceTree);
  try
   begin
    FillChar(LengthBits^,sizeof(TBits),TPasRISCVRawByteChar(#0));
    FillChar(DistanceBits^,sizeof(TBits),TPasRISCVRawByteChar(#0));
    FillChar(LengthBase^,sizeof(TBase),TPasRISCVRawByteChar(#0));
    FillChar(DistanceBase^,sizeof(TBase),TPasRISCVRawByteChar(#0));
    FillChar(SymbolLengthTree^,sizeof(TTree),TPasRISCVRawByteChar(#0));
    FillChar(DistanceTree^,sizeof(TTree),TPasRISCVRawByteChar(#0));
    FillChar(FixedSymbolLengthTree^,sizeof(TTree),TPasRISCVRawByteChar(#0));
    FillChar(FixedDistanceTree^,sizeof(TTree),TPasRISCVRawByteChar(#0));
   end;
   begin
    BuildFixedTrees(FixedSymbolLengthTree^,FixedDistanceTree^);
    BuildBitsBase(PPasRISCVRawByteChar(Pointer(@LengthBits^[0])),PPasRISCVUInt16(Pointer(@LengthBase^[0])),4,3);
    BuildBitsBase(PPasRISCVRawByteChar(Pointer(@DistanceBits^[0])),PPasRISCVUInt16(Pointer(@DistanceBase^[0])),2,1);
    LengthBits^[28]:=0;
    LengthBase^[28]:=258;
   end;
   begin
    GetMem(aDestData,4096);
    DestSize:=4096;
    Dest:=aDestData;
    aDestLen:=0;
    if aParseHeader then begin
     result:=UncompressZLIB;
    end else begin
     result:=UncompressDirect;
    end;
    if result then begin
     ReAllocMem(aDestData,aDestLen);
    end else if assigned(aDestData) then begin
     FreeMem(aDestData);
     aDestData:=nil;
    end;
   end;
  finally
   if assigned(LengthBits) then begin
    Dispose(LengthBits);
   end;
   if assigned(DistanceBits) then begin
    Dispose(DistanceBits);
   end;
   if assigned(LengthBase) then begin
    Dispose(LengthBase);
   end;
   if assigned(DistanceBase) then begin
    Dispose(DistanceBase);
   end;
   if assigned(SymbolLengthTree) then begin
    Dispose(SymbolLengthTree);
   end;
   if assigned(DistanceTree) then begin
    Dispose(DistanceTree);
   end;
   if assigned(FixedSymbolLengthTree) then begin
    Dispose(FixedSymbolLengthTree);
   end;
   if assigned(FixedDistanceTree) then begin
    Dispose(FixedDistanceTree);
   end;
  end;
 except
  result:=false;
 end;
end;
{$ifend}

function ConvertScale(const aValue,aFromScale,aToScale:TPasRISCVUInt64):TPasRISCVUInt64;
var FromScaleRemainder:TPasRISCVUInt64;
begin
 FromScaleRemainder:=aValue mod aFromScale;
 result:=((aValue div aFromScale)*aToScale)+((FromScaleRemainder*aToScale) div aFromScale);
end;

const CLOCK_FREQUENCY=TPasRISCV.CLOCK_FREQUENCY;

{$if defined(Windows)}
type TCreateWaitableTimerExW=function(lpTimerAttributes:Pointer;lpTimerName:LPCWSTR;dwFlags,dwDesiredAccess:DWORD):THandle; {$ifdef cpu386}stdcall;{$endif}

     TNtDelayExecution=function(Alertable:BOOL;var Interval:TLargeInteger):LONG{NTSTATUS}; {$ifdef cpu386}stdcall;{$endif}
     TNtQueryTimerResolution=function(var MinimumResolution,MaximumResolution,CurrentResolution:ULONG):LONG{NTSTATUS}; {$ifdef cpu386}stdcall;{$endif}
     TNtSetTimerResolution=function(var DesiredResolution:ULONG;SetResolution:BOOL;var CurrentResolution:ULONG):LONG{NTSTATUS}; {$ifdef cpu386}stdcall;{$endif}

var KERNEL32LibHandle:HMODULE=HMODULE(0);
    CreateWaitableTimerExW:TCreateWaitableTimerExW=nil;

    NTDLLLibHandle:HMODULE=HMODULE(0);
    NtDelayExecution:TNtDelayExecution=nil;
    NtQueryTimerResolution:TNtQueryTimerResolution=nil;
    NtSetTimerResolution:TNtSetTimerResolution=nil;

    MinimumResolution:ULONG=0;
    MaximumResolution:ULONG=0;
    CurrentResolution:ULONG=0;

//function NtDelayExecution(Alertable:BOOL;var Interval:TLargeInteger):LONG{NTSTATUS}; {$ifdef cpu386}stdcall;{$endif} external 'ntdll.dll' name 'NtDelayExecution';
{$ifend}

var GlobalSleepGranularity:TPasRISCVUInt64=5000;
    GlobalSleepThreshold:TPasRISCVUInt64=20000;

{$if defined(fpc) and defined(Unix)}
{$if not declared(clock_gettime)}

const CLOCK_REALTIME=0;
      CLOCK_MONOTONIC=1;
      CLOCK_PROCESS_CPUTIME_ID=2;
      CLOCK_THREAD_CPUTIME_ID=3;
      CLOCK_MONOTONIC_RAW=4;
      CLOCK_REALTIME_COARSE=5;
      CLOCK_MONOTONIC_COARSE=6;

function clock_gettime(clk_id:TPasRISCVInt32;tp:ptimespec):cint; cdecl; external 'c' name 'clock_gettime';
{$ifend}

function GetCurrentTime:TPasRISCVUInt64;
var Now:TTimeSpec;
begin
 clock_gettime(CLOCK_MONOTONIC,@Now);
{$if CLOCK_FREQUENCY=10000000}
 result:=(TPasRISCVUInt64(Now.tv_sec)*10000000)+(TPasRISCVUInt64(Now.tv_nsec) div TPasRISCVUInt64(100));
{$elseif CLOCK_FREQUENCY=1000000}
 result:=(TPasRISCVUInt64(Now.tv_sec)*1000000)+(TPasRISCVUInt64(Now.tv_nsec) div TPasRISCVUInt64(1000));
{$elseif CLOCK_FREQUENCY=100000}
 result:=(TPasRISCVUInt64(Now.tv_sec)*100000)+(TPasRISCVUInt64(Now.tv_nsec) div TPasRISCVUInt64(10000));
{$elseif CLOCK_FREQUENCY=10000}
 result:=(TPasRISCVUInt64(Now.tv_sec)*10000)+(TPasRISCVUInt64(Now.tv_nsec) div TPasRISCVUInt64(100000));
{$elseif CLOCK_FREQUENCY=1000}
 result:=(TPasRISCVUInt64(Now.tv_sec)*1000)+(TPasRISCVUInt64(Now.tv_nsec) div TPasRISCVUInt64(1000000));
{$else}
 result:=(TPasRISCVUInt64(Now.tv_sec)*TPasRISCV.CLOCK_FREQUENCY)+((TPasRISCVUInt64(Now.tv_nsec)*TPasRISCV.CLOCK_FREQUENCY) div TPasRISCVUInt64(1000000000));
{$ifend}
end;

function GetCurrentFrequencyTime(const aFrequency:TPasRISCVUInt64):TPasRISCVUInt64;
var Now:TTimeSpec;
begin
 clock_gettime(CLOCK_MONOTONIC,@Now);
 result:=(TPasRISCVUInt64(Now.tv_sec)*aFrequency)+((TPasRISCVUInt64(Now.tv_nsec)*aFrequency) div TPasRISCVUInt64(1000000000));
end;

{$elseif defined(Windows)}
var QPCLock:TPasMPUInt32=0;
    QPCLast:TPasMPUInt64=0;
    QPCFrequency:TPasMPUInt64=0;
    QPCFrequencyShift:TPasMPUInt32=0;

function GetCurrentTime:TPasRISCVUInt64;
var QPCNow:TPasMPUInt64;
    Value:TPasMPInt64;
begin
 result:=TPasMPInterlocked.Read(QPCLast);
 if TPasMPInterlocked.CompareExchange(QPCLock,1,0)=0 then begin
  if QPCFrequency=0 then begin
   if QueryPerformanceFrequency(Value) and (Value<>0) then begin
    QPCFrequency:=Value;
    while (QPCFrequency and $ffffffffe0000000)<>0 do begin
     QPCFrequency:=QPCFrequency shr 1;
     inc(QPCFrequencyShift);
    end;
   end else begin
    QPCFrequency:=1000;
   end;
  end;
  QueryPerformanceCounter(Value);
  QPCNow:=TPasMPUInt64(Value) shr QPCFrequencyShift;
  if result<=QPCNow then begin
   result:=QPCNow;
   TPasMPInterlocked.Write(QPCLast,result);
  end;
  TPasMPInterlocked.Write(QPCLock,0);
 end;
 if QPCFrequency<>TPasRISCV.CLOCK_FREQUENCY then begin
  result:=ConvertScale(result,QPCFrequency,TPasRISCV.CLOCK_FREQUENCY);
 end;
end;

function GetCurrentFrequencyTime(const aFrequency:TPasRISCVUInt64):TPasRISCVUInt64;
var QPCNow:TPasMPUInt64;
    Value:TPasMPInt64;
begin
 result:=TPasMPInterlocked.Read(QPCLast);
 if TPasMPInterlocked.CompareExchange(QPCLock,1,0)=0 then begin
  if QPCFrequency=0 then begin
   if QueryPerformanceFrequency(Value) and (Value<>0) then begin
    QPCFrequency:=Value;
    while (QPCFrequency and $ffffffffe0000000)<>0 do begin
     QPCFrequency:=QPCFrequency shr 1;
     inc(QPCFrequencyShift);
    end;
   end else begin
    QPCFrequency:=1000;
   enD;
  end;
  QueryPerformanceCounter(Value);
  QPCNow:=TPasMPUInt64(Value) shr QPCFrequencyShift;
  if result<=QPCNow then begin
   result:=QPCNow;
   TPasMPInterlocked.Write(QPCLast,result);
  end;
  TPasMPInterlocked.Write(QPCLock,0);
 end;
 if QPCFrequency<>aFrequency then begin
  result:=ConvertScale(result,QPCFrequency,aFrequency);
 end;
end;

{$else}
function GetCurrentTime:TPasRISCVUInt64;
begin
{$if CLOCK_FREQUENCY=1000}
 result:=GetTickCount64;
{$elseif CLOCK_FREQUENCY=10000}
 result:=GetTickCount64*10;
{$elseif CLOCK_FREQUENCY=100000}
 result:=GetTickCount64*100;
{$elseif CLOCK_FREQUENCY=1000000}
 result:=GetTickCount64*1000;
{$elseif CLOCK_FREQUENCY=10000000}
 result:=GetTickCount64*10000;
{$else}
 result:=ConvertScale(GetTickCount64,1000,TPasRISCV.CLOCK_FREQUENCY);
{$ifend}
end;

function GetCurrentFrequencyTime(const aFrequency:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 result:=ConvertScale(GetTickCount64,1000,aFrequency);
end;
{$ifend}

procedure WaitTime(const aDuration:TPasRISCVUInt64);
var SleepThreshold,TimeA,TimeB,Remaining,WaitForDuration,Difference:TPasRISCVUInt64;
begin

 SleepThreshold:=GlobalSleepThreshold;
 if GlobalSleepGranularity<>0 then begin
  inc(SleepThreshold,aDuration div 6);
 end;

 Remaining:=aDuration;

 TimeA:=GetCurrentTime;

 // Sleep for a while to avoid busy waiting
 while Remaining>SleepThreshold do begin
  WaitForDuration:=ConvertScale(Remaining-SleepThreshold,CLOCK_FREQUENCY,1000);
  if WaitForDuration>0 then begin
   Sleep(WaitForDuration);
  end;
  TimeB:=GetCurrentTime;
  Difference:=TimeB-TimeA;
  if Remaining>Difference then begin
   dec(Remaining,Difference);
  end else begin
   Remaining:=0;
  end;
  TimeA:=TimeB;
 end;

 // Busy wait for the remaining time for more precise timing
 while Remaining>0 do begin
  TimeB:=GetCurrentTime;
  Difference:=TimeB-TimeA;
  if Remaining>Difference then begin
   dec(Remaining,Difference);
  end else begin
   Remaining:=0;
  end;
  TimeA:=TimeB;
 end;

end;

{$if defined(cpu386)}
function feclearexcept(aExceptions:TPasRISCVUInt32=$3f):TPasRISCVUInt32; assembler; register;
asm
 xor eax,eax
 mov ecx,eax
 and ecx,$3f
 fnstsw ax
 test ecx,eax
 jz @SkipFPU
 fnclex
@SkipFPU:
 stmxcsr dword ptr [esp-8]
 and eax,$3f
 or dword ptr [esp-8],eax
 test dword ptr [esp-8],ecx
 jz @SkipSSE
 not ecx
 and dword ptr [esp-8],ecx
 ldmxcsr dword ptr [esp-8]
@SkipSSE:
 xor eax,eax
end;

function fetestexcept(aExceptions:TPasRISCVUInt32=$3f):TPasRISCVUInt32; assembler; register;
asm
 mov ecx,eax
 and ecx,$3f
 push edx
 stmxcsr dword ptr [esp]
 pop edx
 fnstsw ax
 or eax,edx
 and eax,ecx
end;
{$elseif defined(cpuamd64) or defined(cpux64)}
function feclearexcept(aExceptions:TPasRISCVUInt32=$3f):TPasRISCVUInt32; assembler; {$ifdef fpc}ms_abi_default; nostackframe;{$endif}
asm
{$ifndef fpc}
.noframe
{$endif}
 xor rax,rax
 and ecx,$3f
 fnstsw ax
 test ecx,eax
 jz @SkipFPU
 fnclex
@SkipFPU:
 stmxcsr dword ptr [rsp-8]
 and eax,$3f
 or dword ptr [rsp-8],eax
 test dword ptr [rsp-8],ecx
 jz @SkipSSE
 not ecx
 and dword ptr [rsp-8],ecx
 ldmxcsr dword ptr [rsp-8]
@SkipSSE:
 xor rax,rax
end;

function fetestexcept(aExceptions:TPasRISCVUInt32=$3f):TPasRISCVUInt32; assembler; {$ifdef fpc}ms_abi_default; nostackframe;{$endif}
asm
{$ifndef fpc}
.noframe
{$endif}
 and rcx,$3f
 push rdx
 stmxcsr dword ptr [rsp]
 pop rdx
 fnstsw ax
 or eax,edx
 and eax,ecx
end;
{$else}
function feclearexcept(aExceptions:TPasRISCVUInt32=$3f):TPasRISCVUInt32;
begin
 result:=0;
end;

function fetestexcept(aExceptions:TPasRISCVUInt32=$3f):TPasRISCVUInt32;
begin
 result:=0;
end;
{$ifend}

{$if defined(cpuamd64)}
function MULHU(a,b:TPasRISCVUInt64):TPasRISCVUInt64; assembler; {$if defined(fpc)}nostackframe; {$if defined(Windows)}ms_abi_default;{$else}sysv_abi_default;{$ifend}{$ifend}
asm
{$if not defined(fpc)}
 .noframe
{$ifend}
{$if defined(Windows)}
 // Win64 ABI: rcx, rdx, r8, r9
 mov rax,rcx
 mul rdx
 mov rax,rdx
{$else}
 // SysV ABI: rdi, rsi, rdx, rcx, r8, r9
 mov rax,rdi
 mul rsi
 mov rax,rdx
{$ifend}
end;
{$else}
function MULHU(const a,b:TPasRISCVUInt64):TPasRISCVUInt64;
var LoLo,HiLo,LoHi,HiHi,Cross:TPasRISCVUInt64;
begin
 LoLo:=(a and TPasRISCVUInt64($ffffffff))*(b and TPasRISCVUInt64($ffffffff));
 HiLo:=(a shr 32)*(b and TPasRISCVUInt64($ffffffff));
 LoHi:=(a and TPasRISCVUInt64($ffffffff))*(b shr 32);
 HiHi:=(a shr 32)*(b shr 32);
 Cross:=(LoLo shr 32)+((HiLo and TPasRISCVUInt64($ffffffff))+LoHi);
 result:=(HiLo shr 32)+((Cross shr 32)+HiHi);
end;
{$ifend}

function MULH(const a,b:TPasRISCVInt64):TPasRISCVUInt64;
begin
 result:=MULHU(a,b);
 if a<0 then begin
  dec(result,b);
 end;
 if b<0 then begin
  dec(result,a);
 end;
end;

function MULHSU(const a:TPasRISCVInt64;const b:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 result:=MULHU(a,b);
 if a<0 then begin
  dec(result,b);
 end;
end;

function IsFloat32NaNOrInfinite(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt32($7f800000))=TPasRISCVUInt32($7f800000);
end;

function IsFloat32NaN(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=((Casted and TPasRISCVUInt32($7f800000))=TPasRISCVUInt32($7f800000)) and ((Casted and TPasRISCVUInt32($007fffff))<>0);
end;

function IsFloat32QuietNaN(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt32($7fc00000))=TPasRISCVUInt32($7fc00000);
end;

function IsFloat32SignalingNaN(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=((Casted and TPasRISCVUInt32($7fc00000))=TPasRISCVUInt32($7f800000)) and ((Casted and TPasRISCVUInt32($003fffff))<>0);
end;

function IsFloat32CanonicalNaN(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=Casted=TPasRISCVUInt32($7fc00000);
end;

function IsFloat32Infinite(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt32($7fffffff))=TPasRISCVUInt32($7f800000);
end;

function IsFloat32Negative(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt32($80000000))<>0;
end;

function IsFloat32SubNormal(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt32($7fffffff))<TPasRISCVUInt32($00800000);
end;

function IsFloat32Normal(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=((Casted and TPasRISCVUInt32($7fffffff))>=TPasRISCVUInt32($00800000)) and
         ((Casted and TPasRISCVUInt32($7f800000))<>TPasRISCVUInt32($7f800000));
end;

function IsFloat32Zero(const aValue:TPasRISCVFloat):Boolean;
var Casted:TPasRISCVUInt32 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt32($7fffffff))=0;
end;

function Float32Classify(const aValue:TPasRISCVFloat):TPasRISCVFPType;
var Casted:TPasRISCVUInt32;
begin
 Casted:=TPasRISCVUInt32(Pointer(@aValue)^) and $7fffffff; // Mask out sign bit
 if (Casted and $7f800000)=$7f800000 then begin
  if (Casted and $007fffff)=0 then begin
   result:=TPasRISCVFPType.Infinite;
  end else if (Casted and $7fc00000)<>TPasRISCVUInt32($7fc00000) then begin
   result:=TPasRISCVFPType.SignalingNaN;
  end else begin
   result:=TPasRISCVFPType.QuietNaN;
  end;
 end else begin
  if Casted>=$00800000 then begin
   result:=TPasRISCVFPType.Normal;
  end else if Casted=0 then begin
   result:=TPasRISCVFPType.Zero;
  end else begin
   result:=TPasRISCVFPType.Subnormal;
  end;
 end;
end;

procedure SplitFloat32(const aValue:TPasRISCVFloat;out aIntPart,aFracPart:TPasRISCVFloat);
var Casted,Mask:TPasRISCVUInt32;
    Exponent:TPasRISCVInt32;
begin

 Casted:=TPasRISCVUInt32(Pointer(@aValue)^);
 Exponent:=TPasRISCVInt32((Casted shr 23) and $ff)-$7f;

 // No fractional part
 if Exponent>=23 then begin
  aIntPart:=aValue;
  if (Exponent=$80) and ((Casted and TPasRISCVUInt32($007fffff))<>0) then begin
   // NaN
   aFracPart:=aValue;
   exit;
  end;
  Casted:=Casted and TPasRISCVUInt32($80000000); // Signed zero
  aFracPart:=TPasRISCVFloat(Pointer(@Casted)^);
  exit;
 end;

 // No integral part
 if Exponent<0 then begin
  Casted:=Casted and TPasRISCVUInt32($80000000); // Signed zero
  aIntPart:=TPasRISCVFloat(Pointer(@Casted)^);
  aFracPart:=aValue;
  exit;
 end;

 Mask:=TPasRISCVUInt32($007fffff) shr Exponent;
 if (Casted and Mask)=0 then begin
  aIntPart:=aValue;
  Casted:=Casted and TPasRISCVUInt32($80000000); // Signed zero
  aFracPart:=TPasRISCVFloat(Pointer(@Casted)^);
  exit;
 end;

 Casted:=Casted and not Mask;
 aIntPart:=TPasRISCVFloat(Pointer(@Casted)^);
 aFracPart:=aValue-aIntPart;

end;

function RoundToNearestTiesToEven32(const aValue:TPasRISCVFloat):TPasRISCVFloat;
var Fraction,AbsFraction:TPasRISCVFloat;
begin
 case Float32Classify(aValue) of
  TPasRISCVFPType.Infinite:begin
   result:=Trunc(aValue);
  end;
  TPasRISCVFPType.QuietNaN,
  TPasRISCVFPType.SignalingNaN:begin
   result:=aValue;
  end;
  TPasRISCVFPType.Normal,
  TPasRISCVFPType.Subnormal:begin
   SplitFloat32(aValue,result,Fraction);
   AbsFraction:=abs(Fraction);
   if AbsFraction>0.5 then begin
    if Fraction>0.0 then begin
     result:=result+1.0;
    end else begin
     result:=result-1.0;
    end;
   end else if AbsFraction<0.5 then begin
    // Do nothing
   end else begin
    if (Trunc(result) and 1)<>0 then begin
     if Fraction>0.0 then begin
      result:=result+1.0;
     end else begin
      result:=result-1.0;
     end;
    end;
   end;
  end;
  else {TPasRISCVFPType.Zero:}begin
   result:=0.0;
  end;
 end;
end;

function RoundToNearestTiesToMaxMagnitude32(const aValue:TPasRISCVFloat):TPasRISCVFloat;
var Fraction:TPasRISCVFloat;
begin
 case Float32Classify(aValue) of
  TPasRISCVFPType.Infinite:begin
   result:=Trunc(aValue);
  end;
  TPasRISCVFPType.QuietNaN,
  TPasRISCVFPType.SignalingNaN:begin
   result:=aValue;
  end;
  TPasRISCVFPType.Normal,
  TPasRISCVFPType.Subnormal:begin
   SplitFloat32(aValue,result,Fraction);
   if Fraction>=0.5 then begin
    result:=result+1.0;
   end else if Fraction<=-0.5 then begin
    result:=result-1.0;
   end;
  end;
  else {TPasRISCVFPType.Zero:}begin
   result:=0.0;
  end;
 end;
end;

function IsFloat64NaNOrInfinite(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt64($7ff0000000000000))=TPasRISCVUInt64($7ff0000000000000);
end;

function IsFloat64NaN(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=((Casted and TPasRISCVUInt64($7ff0000000000000))=TPasRISCVUInt64($7ff0000000000000)) and ((Casted and TPasRISCVUInt64($000fffffffffffff))<>0);
end;

function IsFloat64QuietNaN(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt64($7ff8000000000000))=TPasRISCVUInt64($7ff8000000000000);
end;

function IsFloat64SignalingNaN(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=((Casted and TPasRISCVUInt64($7ff8000000000000))=TPasRISCVUInt64($7ff0000000000000)) and ((Casted and TPasRISCVUInt64($0007ffffffffffff))<>0);
end;

function IsFloat64CanonicalNaN(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=Casted=TPasRISCVUInt64($7ff8000000000000);
end;

function IsFloat64Infinite(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt64($7fffffffffffffff))=TPasRISCVUInt64($7ff0000000000000);
end;

function IsFloat64Negative(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt64($8000000000000000))<>0;
end;

function IsFloat64SubNormal(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt64($7fffffffffffffff))<TPasRISCVUInt64($0010000000000000);
end;

function IsFloat64Normal(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=((Casted and TPasRISCVUInt64($7fffffffffffffff))>=TPasRISCVUInt64($0010000000000000)) and
         ((Casted and TPasRISCVUInt64($7ff0000000000000))<>TPasRISCVUInt64($7ff0000000000000));
end;

function IsFloat64Zero(const aValue:TPasRISCVDouble):Boolean;
var Casted:TPasRISCVUInt64 absolute aValue;
begin
 result:=(Casted and TPasRISCVUInt64($7fffffffffffffff))=0;
end;

function Float64Classify(const aValue:TPasRISCVDouble):TPasRISCVFPType;
var Casted:TPasRISCVUInt64;
begin
 Casted:=TPasRISCVUInt64(Pointer(@aValue)^) and TPasRISCVUInt64($7fffffffffffffff); // Mask out sign bit
 if (Casted and TPasRISCVUInt64($7ff0000000000000))=TPasRISCVUInt64($7ff0000000000000) then begin
  if (Casted and TPasRISCVUInt64($000fffffffffffff))=0 then begin
   result:=TPasRISCVFPType.Infinite;
  end else if (Casted and TPasRISCVUInt64($7ff8000000000000))<>TPasRISCVUInt64($7ff8000000000000) then begin
   result:=TPasRISCVFPType.SignalingNaN;
  end else begin
   result:=TPasRISCVFPType.QuietNaN;
  end;
 end else begin
  if Casted>=TPasRISCVUInt64($0010000000000000) then begin
   result:=TPasRISCVFPType.Normal;
  end else if Casted=0 then begin
   result:=TPasRISCVFPType.Zero;
  end else begin
   result:=TPasRISCVFPType.Subnormal;
  end;
 end;
end;

procedure SplitFloat64(const aValue:TPasRISCVDouble;out aIntPart,aFracPart:TPasRISCVDouble);
var Casted,Mask:TPasRISCVUInt64;
    Exponent:TPasRISCVInt64;
begin

 Casted:=TPasRISCVUInt64(Pointer(@aValue)^);
 Exponent:=TPasRISCVInt64((Casted shr 52) and $7ff)-$3ff;

 // No fractional part
 if Exponent>=52 then begin
  aIntPart:=aValue;
  if (Exponent=$400) and ((Casted and TPasRISCVUInt64($000fffffffffffff))<>0) then begin
   // NaN
   aFracPart:=aValue;
   exit;
  end;
  Casted:=Casted and TPasRISCVUInt64($8000000000000000); // Signed zero
  aFracPart:=TPasRISCVDouble(Pointer(@Casted)^);
  exit;
 end;

 // No integral part
 if Exponent<0 then begin
  Casted:=Casted and TPasRISCVUInt64($8000000000000000); // Signed zero
  aIntPart:=TPasRISCVDouble(Pointer(@Casted)^);
  aFracPart:=aValue;
  exit;
 end;

 Mask:=TPasRISCVUInt64($000fffffffffffff) shr Exponent;
 if (Casted and Mask)=0 then begin
  aIntPart:=aValue;
  Casted:=Casted and TPasRISCVUInt64($8000000000000000); // Signed zero
  aFracPart:=TPasRISCVDouble(Pointer(@Casted)^);
  exit;
 end;

 Casted:=Casted and not Mask;
 aIntPart:=TPasRISCVDouble(Pointer(@Casted)^);
 aFracPart:=aValue-aIntPart;

end;

function RoundToNearestTiesToEven64(const aValue:TPasRISCVDouble):TPasRISCVDouble;
var Fraction,AbsFraction:TPasRISCVDouble;
begin
 case Float64Classify(aValue) of
  TPasRISCVFPType.Infinite:begin
   result:=Trunc(aValue);
  end;
  TPasRISCVFPType.QuietNaN,
  TPasRISCVFPType.SignalingNaN:begin
   result:=aValue;
  end;
  TPasRISCVFPType.Normal,
  TPasRISCVFPType.Subnormal:begin
   SplitFloat64(aValue,result,Fraction);
   AbsFraction:=abs(Fraction);
   if AbsFraction>0.5 then begin
    if Fraction>0.0 then begin
     result:=result+1.0;
    end else begin
     result:=result-1.0;
    end;
   end else if AbsFraction<0.5 then begin
    // Do nothing
   end else begin
    if (Trunc(result) and 1)<>0 then begin
     if Fraction>0.0 then begin
      result:=result+1.0;
     end else begin
      result:=result-1.0;
     end;
    end;
   end;
  end;
  else {TPasRISCVFPType.Zero:}begin
   result:=0.0;
  end;
 end;
end;

function RoundToNearestTiesToMaxMagnitude64(const aValue:TPasRISCVDouble):TPasRISCVDouble;
var Fraction:TPasRISCVDouble;
begin
 case Float64Classify(aValue) of
  TPasRISCVFPType.Infinite:begin
   result:=Trunc(aValue);
  end;
  TPasRISCVFPType.QuietNaN,
  TPasRISCVFPType.SignalingNaN:begin
   result:=aValue;
  end;
  TPasRISCVFPType.Normal,
  TPasRISCVFPType.Subnormal:begin
   SplitFloat64(aValue,result,Fraction);
   if Fraction>=0.5 then begin
    result:=result+1.0;
   end else if Fraction<=-0.5 then begin
    result:=result-1.0;
   end;
  end;
  else {TPasRISCVFPType.Zero:}begin
   result:=0.0;
  end;
 end;
end;

{ TPasRISCVHalfFloat }

class function TPasRISCVHalfFloat.FromFloat(const aValue:TPasRISCVFloat):TPasRISCVHalfFloat;
{$if defined(cpu386)}{$ifdef fpc}assembler; nostackframe;{$endif}
{$if defined(PasRISCVPICCode)}
asm

 mov ecx,dword ptr aValue

 mov edx,ecx

 and ecx,$80000000

 xor edx,ecx

 cmp edx,$7f800000
 jb @NormalCase

//@InfNANCase:

 mov eax,$7f800000
 cmp eax,edx
 sbb eax,eax

 and eax,$200
 add eax,$7c00

 jmp @Done

@NormalCase:

 and edx,$fffff000
 mov dword ptr [esp-4],edx

 mov edx,$0f800000
 movss xmm0,dword ptr [esp-4]
 mov dword ptr [esp-8],15 shl 23 // $07800000
 mulss xmm0,dword ptr [esp-8]
 movss dword ptr [esp-4],xmm0
 mov eax,dword ptr [esp-4]
 add eax,4096
 cmp eax,edx
 cmova eax,edx

 shr eax,13

@Done:

 shr ecx,16
 or ax,cx
 movzx eax,ax

end;
{$else}
const Magic:TPasRISCVUInt32=TPasRISCVUInt32(TPasRISCVUInt32(15) shl 23);
asm

 test dword ptr [CPUFeatures],CPUFeatures_X86_F16C_Mask
 jz @Bittwiddling

//@x86_F16C:
 movss xmm0,dword ptr aValue
 db $c4,$e3,$79,$1d,$c0,$00 // vcvtps2ph xmm0,xmm0,0
 movss dword ptr [esp-4],xmm0
 movzx eax,word ptr [esp-4]
 jmp @Done

@Bittwiddling:
 mov ecx,dword ptr aValue

 mov edx,ecx

 and ecx,$80000000

 xor edx,ecx

 cmp edx,$7f800000
 jb @NormalCase

//@InfNANCase:

 mov eax,$7f800000
 cmp eax,edx
 sbb eax,eax

 and eax,$200
 add eax,$7c00

 jmp @BittwiddlingDone

@NormalCase:

 and edx,$fffff000
 mov dword ptr [esp-4],edx

 mov edx,$0f800000
 movss xmm0,dword ptr [esp-4]
 mulss xmm0,dword ptr Magic
 movss dword ptr [esp-4],xmm0
 mov eax,dword ptr [esp-4]
 add eax,4096
 cmp eax,edx
 cmova eax,edx

 shr eax,13

@BittwiddlingDone:

 shr ecx,16
 or ax,cx
 movzx eax,ax

@Done:

end;
{$ifend}
{$elseif defined(cpuamd64) or defined(cpux64) or defined(cpux86_64)}
const Magic:TPasRISCVUInt32=TPasRISCVUInt32(TPasRISCVUInt32(15) shl 23);
var TemporaryValue:TPasRISCVUInt32;
asm

{$ifdef fpc}
 test dword ptr [rip+CPUFeatures],CPUFeatures_X86_F16C_Mask
{$else}
 test dword ptr [rel CPUFeatures],CPUFeatures_X86_F16C_Mask
{$endif}
 jz @Bittwiddling

//@x86_F16C:
 db $c4,$e3,$79,$1d,$c0,$00 // vcvtps2ph xmm0,xmm0,0
 movss dword ptr TemporaryValue,xmm0
 movzx eax,word ptr TemporaryValue
 jmp @Done

@Bittwiddling:
 movss dword ptr TemporaryValue,xmm0

 mov ecx,dword ptr TemporaryValue

 mov edx,ecx

 and ecx,$80000000

 xor edx,ecx

 cmp edx,$7f800000
 jb @NormalCase

//@InfNANCase:

 mov eax,$7f800000
 cmp eax,edx
 sbb eax,eax

 and eax,$200
 add eax,$7c00

 jmp @BittwiddlingDone

@NormalCase:

 and edx,$fffff000
 mov dword ptr TemporaryValue,edx

 mov edx,$0f800000
 movss xmm0,dword ptr TemporaryValue
{$ifdef fpc}
 mulss xmm0,dword ptr [rip+Magic]
{$else}
 mulss xmm0,dword ptr [rel Magic]
{$endif}
 movss dword ptr TemporaryValue,xmm0
 mov eax,dword ptr TemporaryValue
 add eax,4096
 cmp eax,edx
 cmova eax,edx

 shr eax,13

@BittwiddlingDone:

 shr ecx,16
 or ax,cx
 movzx eax,ax

@Done:

end;
{$else}
{$if true}
var CastedValue:TPasRISCVUInt32 absolute aValue;
begin
 result.Value:=FloatToHalfFloatBaseTable[CastedValue shr 23]+TPasRISCVUInt16((CastedValue and $007fffff) shr FloatToHalfFloatShiftTable[CastedValue shr 23]);
end;
{$else}
const Magic:TPasRISCVUInt32=TPasRISCVUInt32(TPasRISCVUInt32(15) shl 23);
var FloatValue:TPasRISCVFloat;
    CastedFloatValue:TPasRISCVUInt32 absolute FloatValue;
    SignValue:TPasRISCVUInt32;
begin
 FloatValue:=aValue;
 SignValue:=CastedFloatValue and $80000000;
 CastedFloatValue:=CastedFloatValue xor SignValue;
 if CastedFloatValue>=$7f800000 then begin
  result.Value:=($7c00+((ord(CastedFloatValue>$7f800000) and 1) shl 9)) or (SignValue shr 16);
 end else begin
  CastedFloatValue:=CastedFloatValue and $fffff000;
  FloatValue:=FloatValue*TPasRISCVFloat(pointer(@Magic)^);
  dec(CastedFloatValue,$fffff000);
  if CastedFloatValue>$0f800000 then begin
   CastedFloatValue:=$0f800000;
  end;
  result.Value:=(CastedFloatValue shr 13) or (SignValue shr 16);
 end;
end;
{$ifend}
{$ifend}

constructor TPasRISCVHalfFloat.Create(const aValue:TPasRISCVFloat);
begin
 self:=TPasRISCVHalfFloat.FromFloat(aValue);
end;

function TPasRISCVHalfFloat.ToFloat:TPasRISCVFloat;
{$if defined(cpu386)}{$ifdef fpc}assembler; nostackframe;{$endif}
{$if defined(PasRISCVPICCode)}
asm

 movzx ecx,word ptr [eax+TPasRISCVHalfFloat.Value]

 mov eax,ecx
 and eax,$7fff
 shl eax,13

 mov dword ptr [esp-4],eax

 fld dword ptr [esp-4]
 mov dword ptr [esp-8],(254-15) shl 23
 mov dword ptr [esp-16],(127+16) shl 23
 fmul dword ptr [esp-8]
 fld dword ptr [esp-16]
 xor eax,eax
 mov edx,$7f800000
 fcomip st(0),st(1)
 cmova edx,eax
 fstp dword ptr [esp-4]
 mov eax,dword ptr [esp-4]
 or eax,edx

 and ecx,$8000
 shl ecx,16
 or eax,ecx

 mov dword ptr [esp-4],eax

 fld dword ptr [esp-4]

end;
{$else}
const ToFloatMagic:TPasRISCVUInt32=TPasRISCVUInt32(TPasRISCVUInt32(254-15) shl 23);
      ToFloatWasInfNAN:TPasRISCVUInt32=TPasRISCVUInt32(TPasRISCVUInt32(127+16) shl 23);
asm

 movzx ecx,word ptr [eax+TPasRISCVHalfFloat.Value]

 test dword ptr [CPUFeatures],CPUFeatures_X86_F16C_Mask
 jz @Bittwiddling

 mov dword ptr [esp-4],ecx
 movss xmm0,dword ptr [esp-4]
 db $c4,$e2,$79,$13,$c0 // vcvtph2ps xmm0,xmm0
 movss dword ptr [esp-4],xmm0
 jmp @Done

@Bittwiddling:

 mov eax,ecx
 and eax,$7fff
 shl eax,13

 mov dword ptr [esp-4],eax

 fld dword ptr [esp-4]
 fmul dword ptr ToFloatMagic
 fld dword ptr ToFloatWasInfNAN
 xor eax,eax
 mov edx,$7f800000
 fcomip st(0),st(1)
 cmova edx,eax
 fstp dword ptr [esp-4]
 mov eax,dword ptr [esp-4]
 or eax,edx

 and ecx,$8000
 shl ecx,16
 or eax,ecx

 mov dword ptr [esp-4],eax

@Done:

 fld dword ptr [esp-4]

end;
{$ifend}
{$elseif defined(cpuamd64) or defined(cpux64) or defined(cpux86_64)}
const ToFloatMagic:TPasRISCVUInt32=TPasRISCVUInt32(TPasRISCVUInt32(254-15) shl 23);
      ToFloatWasInfNAN:TPasRISCVUInt32=TPasRISCVUInt32(TPasRISCVUInt32(127+16) shl 23);
var TemporaryValue:TPasRISCVUInt32;
asm

{$if defined(Windows)}
 movzx ecx,word ptr [rcx+TPasRISCVHalfFloat.Value]
{$else}
 movzx ecx,word ptr [rdi+TPasRISCVHalfFloat.Value]
{$ifend}

{$ifdef fpc}
 test dword ptr [rip+CPUFeatures],CPUFeatures_X86_F16C_Mask
{$else}
 test dword ptr [rel CPUFeatures],CPUFeatures_X86_F16C_Mask
{$endif}
 jz @Bittwiddling

//@x86_F16C:
 mov dword ptr TemporaryValue,ecx
 movss xmm0,dword ptr TemporaryValue
 db $c4,$e2,$79,$13,$c0 // vcvtph2ps xmm0,xmm0
 jmp @Done

@Bittwiddling:

 mov eax,ecx
 and eax,$7fff
 shl eax,13

 mov dword ptr TemporaryValue,eax

 movss xmm0,dword ptr TemporaryValue
{$ifdef fpc}
 mulss xmm0,dword ptr [rip+ToFloatMagic]
{$else}
 mulss xmm0,dword ptr [rel ToFloatMagic]
{$endif}
 xor eax,eax
 mov edx,$7f800000
{$ifdef fpc}
 comiss xmm0,dword ptr [rip+ToFloatWasInfNAN]
{$else}
 comiss xmm0,dword ptr [rel ToFloatWasInfNAN]
{$endif}
 cmovb edx,eax
 movss dword ptr TemporaryValue,xmm0
 mov eax,dword ptr TemporaryValue
 or eax,edx

 and ecx,$8000
 shl ecx,16
 or eax,ecx

 mov dword ptr TemporaryValue,eax

 movss xmm0,dword ptr TemporaryValue

@Done:

end;
{$else}
var f:TPasRISCVUInt32;
begin
{$if true}
 f:=HalfFloatToFloatMantissaTable[HalfFloatToFloatOffsetTable[Value shr 10]+
                                  (Value and $3ff)]+
    HalfFloatToFloatExponentTable[Value shr 10];
{$else}
 f:=(Value and $7fff) shl 13; // exponent/mantissa bits
 TPasRISCVFloat(pointer(@f)^):=TPasRISCVFloat(pointer(@f)^)*TPasRISCVFloat(pointer(@TPasRISCVHalfFloat.ToFloatMagic)^); // exponent adjust
 if TPasRISCVFloat(pointer(@f)^)>=TPasRISCVFloat(pointer(@TPasRISCVHalfFloat.ToFloatWasInfNAN)^) then begin // make sure Inf/NaN survive
  f:=f or TPasRISCVUInt32(TPasRISCVUInt32(255) shl 23);
 end;
 f:=f or ((Value and $8000) shl 16); // sign bit
{$ifend}
 result:=TPasRISCVFloat(pointer(@f)^);
end;
{$ifend}

class operator TPasRISCVHalfFloat.Implicit(const a:TPasRISCVFloat):TPasRISCVHalfFloat;
begin
 result:=TPasRISCVHalfFloat.FromFloat(a);
end;

class operator TPasRISCVHalfFloat.Implicit(const a:TPasRISCVHalfFloat):TPasRISCVFloat;
begin
 result:=a.ToFloat;
end;

class operator TPasRISCVHalfFloat.Explicit(const a:TPasRISCVFloat):TPasRISCVHalfFloat;
begin
 result:=TPasRISCVHalfFloat.FromFloat(a);
end;

class operator TPasRISCVHalfFloat.Explicit(const a:TPasRISCVHalfFloat):TPasRISCVFloat;
begin
 result:=a.ToFloat;
end;

class operator TPasRISCVHalfFloat.Equal(const a,b:TPasRISCVHalfFloat):boolean;
begin
 result:=a.ToFloat=b.ToFloat;
end;

class operator TPasRISCVHalfFloat.Equal(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):boolean;
begin
 result:=a.ToFloat=b;
end;

class operator TPasRISCVHalfFloat.Equal(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):boolean;
begin
 result:=a=b.ToFloat;
end;

class operator TPasRISCVHalfFloat.NotEqual(const a,b:TPasRISCVHalfFloat):boolean;
begin
 result:=a.ToFloat=b.ToFloat;
end;

class operator TPasRISCVHalfFloat.NotEqual(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):boolean;
begin
 result:=a.ToFloat<>b;
end;

class operator TPasRISCVHalfFloat.NotEqual(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):boolean;
begin
 result:=a<>b.ToFloat;
end;

class operator TPasRISCVHalfFloat.GreaterThan(const a,b:TPasRISCVHalfFloat):boolean;
begin
 result:=a.ToFloat>b.ToFloat;
end;

class operator TPasRISCVHalfFloat.GreaterThan(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):boolean;
begin
 result:=a.ToFloat>b;
end;

class operator TPasRISCVHalfFloat.GreaterThan(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):boolean;
begin
 result:=a>b.ToFloat;
end;

class operator TPasRISCVHalfFloat.GreaterThanOrEqual(const a,b:TPasRISCVHalfFloat):boolean;
begin
 result:=a.ToFloat>=b.ToFloat;
end;

class operator TPasRISCVHalfFloat.GreaterThanOrEqual(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):boolean;
begin
 result:=a.ToFloat>=b;
end;

class operator TPasRISCVHalfFloat.GreaterThanOrEqual(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):boolean;
begin
 result:=a>=b.ToFloat;
end;

class operator TPasRISCVHalfFloat.LessThan(const a,b:TPasRISCVHalfFloat):boolean;
begin
 result:=a.ToFloat<b.ToFloat;
end;

class operator TPasRISCVHalfFloat.LessThan(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):boolean;
begin
 result:=a.ToFloat<b;
end;

class operator TPasRISCVHalfFloat.LessThan(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):boolean;
begin
 result:=a<b.ToFloat;
end;

class operator TPasRISCVHalfFloat.LessThanOrEqual(const a,b:TPasRISCVHalfFloat):boolean;
begin
 result:=a.ToFloat<=b.ToFloat;
end;

class operator TPasRISCVHalfFloat.LessThanOrEqual(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):boolean;
begin
 result:=a.ToFloat<=b;
end;

class operator TPasRISCVHalfFloat.LessThanOrEqual(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):boolean;
begin
 result:=a<=b.ToFloat;
end;

class operator TPasRISCVHalfFloat.Inc(const a:TPasRISCVHalfFloat):TPasRISCVHalfFloat;
begin
 result:=TPasRISCVHalfFloat.FromFloat(a.ToFloat+1.0);
end;

class operator TPasRISCVHalfFloat.Dec(const a:TPasRISCVHalfFloat):TPasRISCVHalfFloat;
begin
 result:=TPasRISCVHalfFloat.FromFloat(a.ToFloat-1.0);
end;

class operator TPasRISCVHalfFloat.Add(const a,b:TPasRISCVHalfFloat):TPasRISCVFloat;
begin
 result:=a.ToFloat+b.ToFloat;
end;

class operator TPasRISCVHalfFloat.Add(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):TPasRISCVFloat;
begin
 result:=a.ToFloat+b;
end;

class operator TPasRISCVHalfFloat.Add(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):TPasRISCVFloat;
begin
 result:=a+b.ToFloat;
end;

class operator TPasRISCVHalfFloat.Subtract(const a,b:TPasRISCVHalfFloat):TPasRISCVFloat;
begin
 result:=a.ToFloat-b.ToFloat;
end;

class operator TPasRISCVHalfFloat.Subtract(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):TPasRISCVFloat;
begin
 result:=a.ToFloat-b;
end;

class operator TPasRISCVHalfFloat.Subtract(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):TPasRISCVFloat;
begin
 result:=a-b.ToFloat;
end;

class operator TPasRISCVHalfFloat.Multiply(const a,b:TPasRISCVHalfFloat):TPasRISCVFloat;
begin
 result:=a.ToFloat*b.ToFloat;
end;

class operator TPasRISCVHalfFloat.Multiply(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):TPasRISCVFloat;
begin
 result:=a.ToFloat*b;
end;

class operator TPasRISCVHalfFloat.Multiply(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):TPasRISCVFloat;
begin
 result:=a*b.ToFloat;
end;

class operator TPasRISCVHalfFloat.Divide(const a,b:TPasRISCVHalfFloat):TPasRISCVFloat;
begin
 result:=a.ToFloat/b.ToFloat;
end;

class operator TPasRISCVHalfFloat.Divide(const a:TPasRISCVHalfFloat;const b:TPasRISCVFloat):TPasRISCVFloat;
begin
 result:=a.ToFloat/b;
end;

class operator TPasRISCVHalfFloat.Divide(const a:TPasRISCVFloat;const b:TPasRISCVHalfFloat):TPasRISCVFloat;
begin
 result:=a/b.ToFloat;
end;

class operator TPasRISCVHalfFloat.Modulus(const a,b:TPasRISCVHalfFloat):TPasRISCVFloat;
var x,y:TPasRISCVFloat;
begin
 x:=a.ToFloat;
 y:=b.ToFloat;
 result:=x-(floor(x/y)*y);
end;

class operator TPasRISCVHalfFloat.Negative(const a:TPasRISCVHalfFloat):TPasRISCVHalfFloat;
begin
 result.Value:=a.Value xor $8000;
end;

class operator TPasRISCVHalfFloat.Positive(const a:TPasRISCVHalfFloat):TPasRISCVHalfFloat;
begin
 result:=a;
end;

function TPasRISCVHalfFloat.Abs:TPasRISCVHalfFloat;
begin
 result.Value:=Value and $7fff;
end;

function TPasRISCVHalfFloat.IsNaN:boolean;
begin
 result:=(Value and $7fff)>$7c00;
end;

function TPasRISCVHalfFloat.IsInfinity:boolean;
begin
 result:=(Value and $7fff)=$7c00;
end;

function TPasRISCVHalfFloat.IsNegativeInfinity:boolean;
begin
 result:=Value=$fc00;
end;

function TPasRISCVHalfFloat.IsPositiveInfinity:boolean;
begin
 result:=Value=$7c00;
end;

{ TPasRISCVDynamicQueue<T> }

procedure TPasRISCVDynamicQueue<T>.Initialize;
begin
 Items:=nil;
 Head:=0;
 Tail:=0;
 Count:=0;
 Size:=0;
end;

procedure TPasRISCVDynamicQueue<T>.Finalize;
begin
 Clear;
end;

procedure TPasRISCVDynamicQueue<T>.GrowResize(const aSize:TPasRISCVSizeInt);
var Index,OtherIndex:TPasRISCVSizeInt;
    NewItems:TQueueItems;
begin
 SetLength(NewItems,aSize);
 OtherIndex:=Head;
 for Index:=0 to Count-1 do begin
  NewItems[Index]:=Items[OtherIndex];
  inc(OtherIndex);
  if OtherIndex>=Size then begin
   OtherIndex:=0;
  end;
 end;
 Items:=NewItems;
 Head:=0;
 Tail:=Count;
 Size:=aSize;
end;

procedure TPasRISCVDynamicQueue<T>.Clear;
begin
 while Count>0 do begin
  dec(Count);
  System.Finalize(Items[Head]);
  inc(Head);
  if Head>=Size then begin
   Head:=0;
  end;
 end;
 Items:=nil;
 Head:=0;
 Tail:=0;
 Count:=0;
 Size:=0;
end;

function TPasRISCVDynamicQueue<T>.IsEmpty:boolean;
begin
 result:=Count=0;
end;

procedure TPasRISCVDynamicQueue<T>.EnqueueAtFront(const aItem:T);
var Index:TPasRISCVSizeInt;
begin
 if Size<=Count then begin
  GrowResize(Count+1);
 end;
 dec(Head);
 if Head<0 then begin
  inc(Head,Size);
 end;
 Index:=Head;
 Items[Index]:=aItem;
 inc(Count);
end;

procedure TPasRISCVDynamicQueue<T>.Enqueue(const aItem:T);
var Index:TPasRISCVSizeInt;
begin
 if Size<=Count then begin
  GrowResize(Count+1);
 end;
 Index:=Tail;
 inc(Tail);
 if Tail>=Size then begin
  Tail:=0;
 end;
 Items[Index]:=aItem;
 inc(Count);
end;

function TPasRISCVDynamicQueue<T>.Dequeue(out aItem:T):boolean;
begin
 result:=Count>0;
 if result then begin
  dec(Count);
  aItem:=Items[Head];
  System.Finalize(Items[Head]);
  FillChar(Items[Head],SizeOf(T),#0);
  if Count=0 then begin
   Head:=0;
   Tail:=0;
  end else begin
   inc(Head);
   if Head>=Size then begin
    Head:=0;
   end;
  end;
 end;
end;

function TPasRISCVDynamicQueue<T>.Dequeue:boolean;
begin
 result:=Count>0;
 if result then begin
  dec(Count);
  System.Finalize(Items[Head]);
  FillChar(Items[Head],SizeOf(T),#0);
  if Count=0 then begin
   Head:=0;
   Tail:=0;
  end else begin
   inc(Head);
   if Head>=Size then begin
    Head:=0;
   end;
  end;
 end;
end;

function TPasRISCVDynamicQueue<T>.Peek(out aItem:T):boolean;
begin
 result:=Count>0;
 if result then begin
  aItem:=Items[Head];
 end;
end;

{ TPasRISCVDynamicQueue<T> }

constructor TPasRISCVThreadSafeDynamicQueue<T>.Create;
begin
 inherited Create;
 fLock:=TPasMPSlimReaderWriterLock.Create;
 fItems:=nil;
 fHead:=0;
 fTail:=0;
 fCount:=0;
 fSize:=0;
end;

destructor TPasRISCVThreadSafeDynamicQueue<T>.Destroy;
begin
 Clear;
 FreeAndNil(fLock);
 inherited Destroy;
end;

procedure TPasRISCVThreadSafeDynamicQueue<T>.GrowResize(const aSize:TPasRISCVSizeInt);
var Index,OtherIndex:TPasRISCVSizeInt;
    NewItems:TQueueItems;
begin
 SetLength(NewItems,aSize);
 OtherIndex:=fHead;
 for Index:=0 to fCount-1 do begin
  NewItems[Index]:=fItems[OtherIndex];
  inc(OtherIndex);
  if OtherIndex>=fSize then begin
   OtherIndex:=0;
  end;
 end;
 fItems:=NewItems;
 fHead:=0;
 fTail:=fCount;
 fSize:=aSize;
end;

procedure TPasRISCVThreadSafeDynamicQueue<T>.Clear;
begin
 fLock.Acquire;
 try
  while fCount>0 do begin
   dec(fCount);
   System.Finalize(fItems[fHead]);
   inc(fHead);
   if fHead>=fSize then begin
    fHead:=0;
   end;
  end;
  fItems:=nil;
  fHead:=0;
  fTail:=0;
  fCount:=0;
  fSize:=0;
 finally
  fLock.Release;
 end;
end;

function TPasRISCVThreadSafeDynamicQueue<T>.IsEmpty:boolean;
begin
 fLock.Acquire;
 try
  result:=fCount=0;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCVThreadSafeDynamicQueue<T>.EnqueueAtFront(const aItem:T);
var Index:TPasRISCVSizeInt;
begin
 fLock.Acquire;
 try
  if fSize<=fCount then begin
   GrowResize(fCount+1);
  end;
  dec(fHead);
  if fHead<0 then begin
   inc(fHead,fSize);
  end;
  Index:=fHead;
  fItems[Index]:=aItem;
  inc(fCount);
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCVThreadSafeDynamicQueue<T>.Enqueue(const aItem:T);
var Index:TPasRISCVSizeInt;
begin
 fLock.Acquire;
 try
  if fSize<=fCount then begin
   GrowResize(fCount+1);
  end;
  Index:=fTail;
  inc(fTail);
  if fTail>=fSize then begin
   fTail:=0;
  end;
  fItems[Index]:=aItem;
  inc(fCount);
 finally
  fLock.Release;
 end;
end;

function TPasRISCVThreadSafeDynamicQueue<T>.Dequeue(out aItem:T):boolean;
begin
 while not TryDequeue(aItem) do begin
  TPasMP.Yield;
 end;
 result:=true;
end;

function TPasRISCVThreadSafeDynamicQueue<T>.Dequeue:boolean;
begin
 while not TryDequeue do begin
  TPasMP.Yield;
 end;
 result:=true;
end;

function TPasRISCVThreadSafeDynamicQueue<T>.TryDequeue(out aItem:T):boolean;
begin
 fLock.Acquire;
 try
  result:=fCount>0;
  if result then begin
   dec(fCount);
   aItem:=fItems[fHead];
   System.Finalize(fItems[fHead]);
   FillChar(fItems[fHead],SizeOf(T),#0);
   if fCount=0 then begin
    fHead:=0;
    fTail:=0;
   end else begin
    inc(fHead);
    if fHead>=fSize then begin
     fHead:=0;
    end;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

function TPasRISCVThreadSafeDynamicQueue<T>.TryDequeue:boolean;
begin
 fLock.Acquire;
 try
  result:=fCount>0;
  if result then begin
   dec(fCount);
   System.Finalize(fItems[fHead]);
   FillChar(fItems[fHead],SizeOf(T),#0);
   if fCount=0 then begin
    fHead:=0;
    fTail:=0;
   end else begin
    inc(fHead);
    if fHead>=fSize then begin
     fHead:=0;
    end;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

function TPasRISCVThreadSafeDynamicQueue<T>.Peek(out aItem:T):boolean;
begin
 fLock.Acquire;
 try
  result:=fCount>0;
  if result then begin
   aItem:=fItems[fHead];
  end;
 finally
  fLock.Release;
 end;
end;

{ TPasRISCVHashMap }

{$warnings off}
{$hints off}

constructor TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TEntityEnumerator.Create(const aHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
begin
 fHashMap:=aHashMap;
 fIndex:=-1;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TEntityEnumerator.GetCurrent:TEntity;
begin
 result:=fHashMap.fEntities[fIndex];
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TEntityEnumerator.MoveNext:boolean;
begin
 repeat
  inc(fIndex);
  if fIndex<fHashMap.fSize then begin
   if fHashMap.fEntities[fIndex].State=TEntity.Used then begin
    result:=true;
    exit;
   end;
  end else begin
   break;
  end;
 until false;
 result:=false;
end;

constructor TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TKeyEnumerator.Create(const aHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
begin
 fHashMap:=aHashMap;
 fIndex:=-1;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TKeyEnumerator.GetCurrent:TPasRISCVHashMapKey;
begin
 result:=fHashMap.fEntities[fIndex].Key;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TKeyEnumerator.MoveNext:boolean;
begin
 repeat
  inc(fIndex);
  if fIndex<fHashMap.fSize then begin
   if fHashMap.fEntities[fIndex].State=TEntity.Used then begin
    result:=true;
    exit;
   end;
  end else begin
   break;
  end;
 until false;
 result:=false;
end;

constructor TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TPasRISCVHashMapValueEnumerator.Create(const aHashMap:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
begin
 fHashMap:=aHashMap;
 fIndex:=-1;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TPasRISCVHashMapValueEnumerator.GetCurrent:TPasRISCVHashMapValue;
begin
 result:=fHashMap.fEntities[fIndex].Value;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TPasRISCVHashMapValueEnumerator.MoveNext:boolean;
begin
 repeat
  inc(fIndex);
  if fIndex<fHashMap.fSize then begin
   if fHashMap.fEntities[fIndex].State=TEntity.Used then begin
    result:=true;
    exit;
   end;
  end else begin
   break;
  end;
 until false;
 result:=false;
end;

constructor TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TEntitiesObject.Create(const aOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
begin
 inherited Create;
 fOwner:=aOwner;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TEntitiesObject.GetEnumerator:TEntityEnumerator;
begin
 result:=TEntityEnumerator.Create(fOwner);
end;

constructor TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TKeysObject.Create(const aOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
begin
 inherited Create;
 fOwner:=aOwner;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TKeysObject.GetEnumerator:TKeyEnumerator;
begin
 result:=TKeyEnumerator.Create(fOwner);
end;

constructor TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TValuesObject.Create(const aOwner:TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>);
begin
 inherited Create;
 fOwner:=aOwner;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TValuesObject.GetEnumerator:TPasRISCVHashMapValueEnumerator;
begin
 result:=TPasRISCVHashMapValueEnumerator.Create(fOwner);
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TValuesObject.GetValue(const aKey:TPasRISCVHashMapKey):TPasRISCVHashMapValue;
begin
 result:=fOwner.GetValue(aKey);
end;

procedure TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TValuesObject.SetValue(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue);
begin
 fOwner.SetValue(aKey,aValue);
end;

constructor TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.Create(const aDefaultValue:TPasRISCVHashMapValue);
begin
 inherited Create;
 fSize:=0;
 fLogSize:=0;
 fCountNonEmptyEntites:=0;
 fCountDeletedEntites:=0;
 fEntities:=nil;
 fDefaultValue:=aDefaultValue;
 fCanShrink:=true;
 fEntitiesObject:=TEntitiesObject.Create(self);
 fKeysObject:=TKeysObject.Create(self);
 fValuesObject:=TValuesObject.Create(self);
 Resize;
end;

destructor TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.Destroy;
var Index:TPasRISCVSizeInt;
begin
 Clear;
 for Index:=0 to length(fEntities)-1 do begin
  Finalize(fEntities[Index].Key);
  Finalize(fEntities[Index].Value);
 end;
 fEntities:=nil;
 FreeAndNil(fEntitiesObject);
 FreeAndNil(fKeysObject);
 FreeAndNil(fValuesObject);
 inherited Destroy;
end;

procedure TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.Clear(const aCanFree:Boolean);
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to length(fEntities)-1 do begin
  Finalize(fEntities[Index].Key);
  Finalize(fEntities[Index].Value);
 end;
 fCountNonEmptyEntites:=0;
 fCountDeletedEntites:=0;
 if fCanShrink and aCanFree then begin
  fSize:=0;
  fLogSize:=0;
  fEntities:=nil;
  Resize;
 end else begin
  for Index:=0 to length(fEntities)-1 do begin
   fEntities[Index].State:=TEntity.Empty;
  end;
 end;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.HashData(const aData:TPasRISCVPointer;const aDataLength:TPasRISCVUInt32):TPasRISCVUInt32;
// xxHash32
const PRIME32_1=TPasRISCVUInt32(2654435761);
      PRIME32_2=TPasRISCVUInt32(2246822519);
      PRIME32_3=TPasRISCVUInt32(3266489917);
      PRIME32_4=TPasRISCVUInt32(668265263);
      PRIME32_5=TPasRISCVUInt32(374761393);
      Seed=TPasRISCVUInt32($1337c0d3);
      v1Initialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVUInt64(Seed)+TPasRISCVUInt64(PRIME32_1)+TPasRISCVUInt64(PRIME32_2)));
      v2Initialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVUInt64(Seed)+TPasRISCVUInt64(PRIME32_2)));
      v3Initialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVUInt64(Seed)+TPasRISCVUInt64(0)));
      v4Initialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Seed)-TPasRISCVInt64(PRIME32_1))));
      HashInitialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVUInt64(Seed)+TPasRISCVUInt64(PRIME32_5)));
var v1,v2,v3,v4:TPasRISCVUInt32;
    p,e,Limit:PPasRISCVUInt8;
begin
 p:=aData;
 if aDataLength>=16 then begin
  v1:=v1Initialization;
  v2:=v2Initialization;
  v3:=v3Initialization;
  v4:=v4Initialization;
  e:=@PPasRISCVUInt8Array(aData)^[aDataLength-16];
  repeat
{$if defined(fpc) and declared(ROLDWord)}
   v1:=ROLDWord(v1+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2)),13)*TPasRISCVUInt32(PRIME32_1);
{$else}
   inc(v1,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2));
   v1:=((v1 shl 13) or (v1 shr 19))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
   inc(p,SizeOf(TPasRISCVUInt32));
{$if defined(fpc) and declared(ROLDWord)}
   v2:=ROLDWord(v2+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2)),13)*TPasRISCVUInt32(PRIME32_1);
{$else}
   inc(v2,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2));
   v2:=((v2 shl 13) or (v2 shr 19))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
   inc(p,SizeOf(TPasRISCVUInt32));
{$if defined(fpc) and declared(ROLDWord)}
   v3:=ROLDWord(v3+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2)),13)*TPasRISCVUInt32(PRIME32_1);
{$else}
   inc(v3,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2));
   v3:=((v3 shl 13) or (v3 shr 19))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
   inc(p,SizeOf(TPasRISCVUInt32));
{$if defined(fpc) and declared(ROLDWord)}
   v4:=ROLDWord(v4+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2)),13)*TPasRISCVUInt32(PRIME32_1);
{$else}
   inc(v4,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2));
   v4:=((v4 shl 13) or (v4 shr 19))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
   inc(p,SizeOf(TPasRISCVUInt32));
  until {%H-}TPasRISCVPtrUInt(p)>{%H-}TPasRISCVPtrUInt(e);
{$if defined(fpc) and declared(ROLDWord)}
  result:=ROLDWord(v1,1)+ROLDWord(v2,7)+ROLDWord(v3,12)+ROLDWord(v4,18);
{$else}
  result:=((v1 shl 1) or (v1 shr 31))+
          ((v2 shl 7) or (v2 shr 25))+
          ((v3 shl 12) or (v3 shr 20))+
          ((v4 shl 18) or (v4 shr 14));
{$ifend}
 end else begin
  result:=HashInitialization;
 end;
 inc(result,aDataLength);
 e:=@PPasRISCVUInt8Array(aData)^[aDataLength];
 while ({%H-}TPasRISCVPtrUInt(p)+SizeOf(TPasRISCVUInt32))<={%H-}TPasRISCVPtrUInt(e) do begin
{$if defined(fpc) and declared(ROLDWord)}
  result:=ROLDWord(result+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_3)),17)*TPasRISCVUInt32(PRIME32_4);
{$else}
  inc(result,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_3));
  result:=((result shl 17) or (result shr 15))*TPasRISCVUInt32(PRIME32_4);
{$ifend}
  inc(p,SizeOf(TPasRISCVUInt32));
 end;
 while {%H-}TPasRISCVPtrUInt(p)<{%H-}TPasRISCVPtrUInt(e) do begin
{$if defined(fpc) and declared(ROLDWord)}
  result:=ROLDWord(result+(TPasRISCVUInt8(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_5)),11)*TPasRISCVUInt32(PRIME32_1);
{$else}
  inc(result,TPasRISCVUInt8(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_5));
  result:=((result shl 11) or (result shr 21))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
  inc(p,SizeOf(TPasRISCVUInt8));
 end;
 result:=(result xor (result shr 15))*TPasRISCVUInt32(PRIME32_2);
 result:=(result xor (result shr 13))*TPasRISCVUInt32(PRIME32_3);
 result:=result xor (result shr 16);
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.HashKey(const aKey:TPasRISCVHashMapKey):TPasRISCVUInt32;
var p:TPasRISCVUInt64;
begin
 // We're hoping here that the compiler is here so smart, so that the compiler optimizes the
 // unused if-branches away
{$ifndef ExtraStringHashMap}
 if (SizeOf(TPasRISCVHashMapKey)=SizeOf(AnsiString)) and
    (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(AnsiString)) then begin
  result:=HashData(PPasRISCVUInt8(@AnsiString(TPasRISCVPointer(@aKey)^)[1]),length(AnsiString(TPasRISCVPointer(@aKey)^))*SizeOf(AnsiChar));
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(UTF8String)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(UTF8String)) then begin
  result:=HashData(PPasRISCVUInt8(@UTF8String(TPasRISCVPointer(@aKey)^)[1]),length(UTF8String(TPasRISCVPointer(@aKey)^))*SizeOf(AnsiChar));
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(RawByteString)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(RawByteString)) then begin
  result:=HashData(PPasRISCVUInt8(@RawByteString(TPasRISCVPointer(@aKey)^)[1]),length(RawByteString(TPasRISCVPointer(@aKey)^))*SizeOf(AnsiChar));
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(WideString)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(WideString)) then begin
  result:=HashData(PPasRISCVUInt8(@WideString(TPasRISCVPointer(@aKey)^)[1]),length(WideString(TPasRISCVPointer(@aKey)^))*SizeOf(WideChar));
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(UnicodeString)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(UnicodeString)) then begin
  result:=HashData(PPasRISCVUInt8(@UnicodeString(TPasRISCVPointer(@aKey)^)[1]),length(UnicodeString(TPasRISCVPointer(@aKey)^))*SizeOf(WideChar));
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(String)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(String)) then begin
  result:=HashData(PPasRISCVUInt8(@String(TPasRISCVPointer(@aKey)^)[1]),length(String(TPasRISCVPointer(@aKey)^))*SizeOf(Char));
 end else{$endif}begin
  case SizeOf(TPasRISCVHashMapKey) of
   SizeOf(UInt16):begin
    // 16-bit big => use 16-bit integer-rehashing
    result:=TPasRISCVUInt16(TPasRISCVPointer(@aKey)^);
    result:=(result or (((not result) and $ffff) shl 16));
    dec(result,result shl 6);
    result:=result xor (result shr 17);
    dec(result,result shl 9);
    result:=result xor (result shl 4);
    dec(result,result shl 3);
    result:=result xor (result shl 10);
    result:=result xor (result shr 15);
   end;
   SizeOf(TPasRISCVUInt32):begin
    // 32-bit big => use 32-bit integer-rehashing
    result:=TPasRISCVUInt32(TPasRISCVPointer(@aKey)^);
    dec(result,result shl 6);
    result:=result xor (result shr 17);
    dec(result,result shl 9);
    result:=result xor (result shl 4);
    dec(result,result shl 3);
    result:=result xor (result shl 10);
    result:=result xor (result shr 15);
   end;
   SizeOf(TPasRISCVUInt64):begin
    // 64-bit big => use 64-bit to 32-bit integer-rehashing
    p:=TPasRISCVUInt64(TPasRISCVPointer(@aKey)^);
    p:=(not p)+(p shl 18); // p:=((p shl 18)-p-)1;
    p:=p xor (p shr 31);
    p:=p*21; // p:=(p+(p shl 2))+(p shl 4);
    p:=p xor (p shr 11);
    p:=p+(p shl 6);
    result:=TPasRISCVUInt32(TPasRISCVPtrUInt(p xor (p shr 22)));
   end;
   else begin
    result:=HashData(PPasRISCVUInt8(TPasRISCVPointer(@aKey)),SizeOf(TPasRISCVHashMapKey));
   end;
  end;
 end;
{$if defined(CPU386) or defined(CPUAMD64)}
 // Special case: The hash value may be never zero
 result:=result or (-TPasRISCVUInt32(ord(result=0) and 1));
{$else}
 if result=0 then begin
  // Special case: The hash value may be never zero
  result:=$ffffffff;
 end;
{$ifend}
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.CompareKey(const aKeyA,aKeyB:TPasRISCVHashMapKey):boolean;
var Index:TPasRISCVInt32;
    pA,pB:PPasRISCVUInt8Array;
begin
 // We're hoping also here that the compiler is here so smart, so that the compiler optimizes the
 // unused if-branches away
{$ifndef ExtraStringHashMap}
 if (SizeOf(TPasRISCVHashMapKey)=SizeOf(AnsiString)) and
    (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(AnsiString)) then begin
  result:=AnsiString(TPasRISCVPointer(@aKeyA)^)=AnsiString(TPasRISCVPointer(@aKeyB)^);
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(UTF8String)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(UTF8String)) then begin
  result:=UTF8String(TPasRISCVPointer(@aKeyA)^)=UTF8String(TPasRISCVPointer(@aKeyB)^);
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(RawByteString)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(RawByteString)) then begin
  result:=RawByteString(TPasRISCVPointer(@aKeyA)^)=RawByteString(TPasRISCVPointer(@aKeyB)^);
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(WideString)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(WideString)) then begin
  result:=WideString(TPasRISCVPointer(@aKeyA)^)=WideString(TPasRISCVPointer(@aKeyB)^);
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(UnicodeString)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(UnicodeString)) then begin
  result:=UnicodeString(TPasRISCVPointer(@aKeyA)^)=UnicodeString(TPasRISCVPointer(@aKeyB)^);
 end else if (SizeOf(TPasRISCVHashMapKey)=SizeOf(String)) and
             (TypeInfo(TPasRISCVHashMapKey)=TypeInfo(String)) then begin
  result:=String(TPasRISCVPointer(@aKeyA)^)=String(TPasRISCVPointer(@aKeyB)^);
 end else{$endif}begin
  case SizeOf(TPasRISCVHashMapKey) of
   SizeOf(TPasRISCVUInt8):begin
    result:=UInt8(TPasRISCVPointer(@aKeyA)^)=UInt8(TPasRISCVPointer(@aKeyB)^);
   end;
   SizeOf(TPasRISCVUInt16):begin
    result:=UInt16(TPasRISCVPointer(@aKeyA)^)=UInt16(TPasRISCVPointer(@aKeyB)^);
   end;
   SizeOf(TPasRISCVUInt32):begin
    result:=TPasRISCVUInt32(TPasRISCVPointer(@aKeyA)^)=TPasRISCVUInt32(TPasRISCVPointer(@aKeyB)^);
   end;
   SizeOf(TPasRISCVUInt64):begin
    result:=TPasRISCVUInt64(TPasRISCVPointer(@aKeyA)^)=TPasRISCVUInt64(TPasRISCVPointer(@aKeyB)^);
   end;
{$ifdef fpc}
   SizeOf(TPasRISCVHashMapUInt128):begin
    result:=(TPasRISCVHashMapUInt128(TPasRISCVPointer(@aKeyA)^)[0]=TPasRISCVHashMapUInt128(TPasRISCVPointer(@aKeyB)^)[0]) and
            (TPasRISCVHashMapUInt128(TPasRISCVPointer(@aKeyA)^)[1]=TPasRISCVHashMapUInt128(TPasRISCVPointer(@aKeyB)^)[1]);
   end;
{$endif}
   else begin
    Index:=0;
    pA:=@aKeyA;
    pB:=@aKeyB;
    while (Index+SizeOf(TPasRISCVUInt32))<SizeOf(TPasRISCVHashMapKey) do begin
     if TPasRISCVUInt32(TPasRISCVPointer(@pA^[Index])^)<>TPasRISCVUInt32(TPasRISCVPointer(@pB^[Index])^) then begin
      result:=false;
      exit;
     end;
     inc(Index,SizeOf(TPasRISCVUInt32));
    end;
    while (Index+SizeOf(UInt8))<SizeOf(TPasRISCVHashMapKey) do begin
     if UInt8(TPasRISCVPointer(@pA^[Index])^)<>UInt8(TPasRISCVPointer(@pB^[Index])^) then begin
      result:=false;
      exit;
     end;
     inc(Index,SizeOf(UInt8));
    end;
    result:=true;
   end;
  end;
 end;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.FindEntity(const aKey:TPasRISCVHashMapKey):PEntity;
var Index,HashCode,Mask,Step:TPasRISCVSizeUInt;
begin
 HashCode:=HashKey(aKey);
 Mask:=(2 shl fLogSize)-1;
 Step:=((HashCode shl 1)+1) and Mask;
 Index:=HashCode shr (32-fLogSize);
 repeat
  result:=@fEntities[Index];
  if (result^.State=TEntity.Empty) or ((result^.State=TEntity.Used) and CompareKey(result^.Key,aKey)) then begin
   exit;
  end;
  Index:=(Index+Step) and Mask;
 until false;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.FindEntityForAdd(const aKey:TPasRISCVHashMapKey):PEntity;
var Index,HashCode,Mask,Step:TPasRISCVSizeUInt;
    DeletedEntity:PEntity;
begin
 HashCode:=HashKey(aKey);
 Mask:=(2 shl fLogSize)-1;
 Step:=((HashCode shl 1)+1) and Mask;
 Index:=HashCode shr (32-fLogSize);
 DeletedEntity:=nil;
 repeat
  result:=@fEntities[Index];
  case result^.State of
   TEntity.Empty:begin
    break;
   end;
   TEntity.Deleted:begin
    if not assigned(DeletedEntity) then begin
     DeletedEntity:=result;
    end;
   end;
   else {TEntity.Used:}begin
    if CompareKey(result^.Key,aKey) then begin
     exit;
    end;
   end;
  end;
  Index:=(Index+Step) and Mask;
 until false;
 if assigned(DeletedEntity) then begin
  result:=DeletedEntity;
 end;
end;

procedure TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.Resize;
var Index:TPasRISCVSizeInt;
    OldEntities:TEntities;
    OldEntity:PEntity;
begin

 fLogSize:={$ifdef cpu64}IntLog264{$else}IntLog2{$endif}(fCountNonEmptyEntites)+1;

 fSize:=2 shl fLogSize;

 fCountNonEmptyEntites:=0;

 fCountDeletedEntites:=0;

 OldEntities:=fEntities;

 fEntities:=nil;
 SetLength(fEntities,fSize);

 for Index:=0 to length(fEntities)-1 do begin
  fEntities[Index].State:=TEntity.Empty;
 end;

 if length(OldEntities)>0 then begin
  try
   for Index:=0 to length(OldEntities)-1 do begin
    OldEntity:=@OldEntities[Index];
    if OldEntity^.State=TEntity.Used then begin
     Add(OldEntity^.Key,OldEntity^.Value);
    end;
{   Finalize(OldEntity^.Key);
    Finalize(OldEntity^.Value);}
   end;
  finally
   OldEntities:=nil;
  end;
 end;

end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.Add(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue):PEntity;
begin
 while fCountNonEmptyEntites>=(1 shl fLogSize) do begin
  Resize;
 end;
 result:=FindEntityForAdd(aKey);
 case result^.State of
  TEntity.Empty:begin
   inc(fCountNonEmptyEntites);
  end;
  TEntity.Deleted:begin
   dec(fCountDeletedEntites);
  end;
  else begin
  end;
 end;
 result^.State:=TEntity.Used;
 result^.Key:=aKey;
 result^.Value:=aValue;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.Get(const aKey:TPasRISCVHashMapKey;const aCreateIfNotExist:boolean):PEntity;
var Value:TPasRISCVHashMapValue;
begin
 result:=FindEntity(aKey);
 case result^.State of
  TEntity.Used:begin
  end;
  else {TEntity.Empty,TEntity.Deleted:}begin
   if aCreateIfNotExist then begin
    Initialize(Value);
    result:=Add(aKey,Value);
   end else begin
    result:=nil;
   end;
  end;
 end;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.TryGet(const aKey:TPasRISCVHashMapKey;out aValue:TPasRISCVHashMapValue):boolean;
var Entity:PEntity;
begin
 Entity:=FindEntity(aKey);
 result:=Entity^.State=TEntity.Used;
 if result then begin
  aValue:=Entity^.Value;
 end else begin
  Initialize(aValue);
 end;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.ExistKey(const aKey:TPasRISCVHashMapKey):boolean;
begin
 result:=FindEntity(aKey)^.State=TEntity.Used;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.Delete(const aKey:TPasRISCVHashMapKey):boolean;
var Entity:PEntity;
begin
 Entity:=FindEntity(aKey);
 result:=Entity^.State=TEntity.Used;
 if result then begin
  Entity^.State:=TEntity.Deleted;
  Finalize(Entity^.Key);
  Finalize(Entity^.Value);
  inc(fCountDeletedEntites);
  if fCanShrink and (fSize>=8) and (fCountDeletedEntites>=((fSize+3) shr 2)) then begin
   dec(fCountNonEmptyEntites,fCountDeletedEntites);
   Resize;
  end;
 end;
end;

function TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.GetValue(const aKey:TPasRISCVHashMapKey):TPasRISCVHashMapValue;
var Entity:PEntity;
begin
 Entity:=FindEntity(aKey);
 if Entity^.State=TEntity.Used then begin
  result:=Entity^.Value;
 end else begin
  result:=fDefaultValue;
 end;
end;

procedure TPasRISCVHashMap<TPasRISCVHashMapKey,TPasRISCVHashMapValue>.SetValue(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue);
begin
 Add(aKey,aValue);
end;

{$ifdef ExtraStringHashMap}
{ TPasRISCVStringHashMap }

constructor TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TEntityEnumerator.Create(const aHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
begin
 fHashMap:=aHashMap;
 fIndex:=-1;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TEntityEnumerator.GetCurrent:TEntity;
begin
 result:=fHashMap.fEntities[fIndex];
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TEntityEnumerator.MoveNext:boolean;
begin
 repeat
  inc(fIndex);
  if fIndex<fHashMap.fSize then begin
   if fHashMap.fEntities[fIndex].State=TEntity.Used then begin
    result:=true;
    exit;
   end;
  end else begin
   break;
  end;
 until false;
 result:=false;
end;

constructor TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TKeyEnumerator.Create(const aHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
begin
 fHashMap:=aHashMap;
 fIndex:=-1;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TKeyEnumerator.GetCurrent:TPasRISCVHashMapKey;
begin
 result:=fHashMap.fEntities[fIndex].Key;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TKeyEnumerator.MoveNext:boolean;
begin
 repeat
  inc(fIndex);
  if fIndex<fHashMap.fSize then begin
   if fHashMap.fEntities[fIndex].State=TEntity.Used then begin
    result:=true;
    exit;
   end;
  end else begin
   break;
  end;
 until false;
 result:=false;
end;

constructor TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TPasRISCVHashMapValueEnumerator.Create(const aHashMap:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
begin
 fHashMap:=aHashMap;
 fIndex:=-1;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TPasRISCVHashMapValueEnumerator.GetCurrent:TPasRISCVHashMapValue;
begin
 result:=fHashMap.fEntities[fIndex].Value;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TPasRISCVHashMapValueEnumerator.MoveNext:boolean;
begin
 repeat
  inc(fIndex);
  if fIndex<fHashMap.fSize then begin
   if fHashMap.fEntities[fIndex].State=TEntity.Used then begin
    result:=true;
    exit;
   end;
  end else begin
   break;
  end;
 until false;
 result:=false;
end;

constructor TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TEntitiesObject.Create(const aOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
begin
 inherited Create;
 fOwner:=aOwner;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TEntitiesObject.GetEnumerator:TEntityEnumerator;
begin
 result:=TEntityEnumerator.Create(fOwner);
end;

constructor TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TKeysObject.Create(const aOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
begin
 inherited Create;
 fOwner:=aOwner;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TKeysObject.GetEnumerator:TKeyEnumerator;
begin
 result:=TKeyEnumerator.Create(fOwner);
end;

constructor TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TValuesObject.Create(const aOwner:TPasRISCVStringHashMap<TPasRISCVHashMapValue>);
begin
 inherited Create;
 fOwner:=aOwner;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TValuesObject.GetEnumerator:TPasRISCVHashMapValueEnumerator;
begin
 result:=TPasRISCVHashMapValueEnumerator.Create(fOwner);
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TValuesObject.GetValue(const aKey:TPasRISCVHashMapKey):TPasRISCVHashMapValue;
begin
 result:=fOwner.GetValue(aKey);
end;

procedure TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TValuesObject.SetValue(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue);
begin
 fOwner.SetValue(aKey,aValue);
end;

constructor TPasRISCVStringHashMap<TPasRISCVHashMapValue>.Create(const aDefaultValue:TPasRISCVHashMapValue);
begin
 inherited Create;
 fSize:=0;
 fLogSize:=0;
 fCountNonEmptyEntites:=0;
 fCountDeletedEntites:=0;
 fEntities:=nil;
 fDefaultValue:=aDefaultValue;
 fCanShrink:=true;
 fEntitiesObject:=TEntitiesObject.Create(self);
 fKeysObject:=TKeysObject.Create(self);
 fValuesObject:=TValuesObject.Create(self);
 Resize;
end;

destructor TPasRISCVStringHashMap<TPasRISCVHashMapValue>.Destroy;
var Index:TPasRISCVSizeInt;
begin
 Clear;
 for Index:=0 to length(fEntities)-1 do begin
  Finalize(fEntities[Index].Key);
  Finalize(fEntities[Index].Value);
 end;
 fEntities:=nil;
 FreeAndNil(fEntitiesObject);
 FreeAndNil(fKeysObject);
 FreeAndNil(fValuesObject);
 inherited Destroy;
end;

procedure TPasRISCVStringHashMap<TPasRISCVHashMapValue>.Clear(const aCanFree:Boolean);
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to length(fEntities)-1 do begin
  Finalize(fEntities[Index].Key);
  Finalize(fEntities[Index].Value);
 end;
 fCountNonEmptyEntites:=0;
 fCountDeletedEntites:=0;
 if fCanShrink and aCanFree then begin
  fSize:=0;
  fLogSize:=0;
  fEntities:=nil;
  Resize;
 end else begin
  for Index:=0 to length(fEntities)-1 do begin
   fEntities[Index].State:=TEntity.Empty;
  end;
 end;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.HashKey(const aKey:TPasRISCVHashMapKey):TPasRISCVUInt32;
// xxHash32
const PRIME32_1=TPasRISCVUInt32(2654435761);
      PRIME32_2=TPasRISCVUInt32(2246822519);
      PRIME32_3=TPasRISCVUInt32(3266489917);
      PRIME32_4=TPasRISCVUInt32(668265263);
      PRIME32_5=TPasRISCVUInt32(374761393);
      Seed=TPasRISCVUInt32($1337c0d3);
      v1Initialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVUInt64(Seed)+TPasRISCVUInt64(PRIME32_1)+TPasRISCVUInt64(PRIME32_2)));
      v2Initialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVUInt64(Seed)+TPasRISCVUInt64(PRIME32_2)));
      v3Initialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVUInt64(Seed)+TPasRISCVUInt64(0)));
      v4Initialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Seed)-TPasRISCVInt64(PRIME32_1))));
      HashInitialization=TPasRISCVUInt32(TPasRISCVUInt64(TPasRISCVUInt64(Seed)+TPasRISCVUInt64(PRIME32_5)));
var v1,v2,v3,v4,DataLength:TPasRISCVUInt32;
    p,e,Limit:PPasRISCVUInt8;
begin
 p:=TPasRISCVPointer(@aKey[1]);
 DataLength:=length(aKey)*SizeOf(aKey[1]);
 if DataLength>=16 then begin
  v1:=v1Initialization;
  v2:=v2Initialization;
  v3:=v3Initialization;
  v4:=v4Initialization;
  e:=@PPasRISCVUInt8Array(TPasRISCVPointer(@aKey[1]))^[DataLength-16];
  repeat
{$if defined(fpc) and declared(ROLDWord)}
   v1:=ROLDWord(v1+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2)),13)*TPasRISCVUInt32(PRIME32_1);
{$else}
   inc(v1,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2));
   v1:=((v1 shl 13) or (v1 shr 19))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
   inc(p,SizeOf(TPasRISCVUInt32));
{$if defined(fpc) and declared(ROLDWord)}
   v2:=ROLDWord(v2+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2)),13)*TPasRISCVUInt32(PRIME32_1);
{$else}
   inc(v2,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2));
   v2:=((v2 shl 13) or (v2 shr 19))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
   inc(p,SizeOf(TPasRISCVUInt32));
{$if defined(fpc) and declared(ROLDWord)}
   v3:=ROLDWord(v3+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2)),13)*TPasRISCVUInt32(PRIME32_1);
{$else}
   inc(v3,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2));
   v3:=((v3 shl 13) or (v3 shr 19))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
   inc(p,SizeOf(TPasRISCVUInt32));
{$if defined(fpc) and declared(ROLDWord)}
   v4:=ROLDWord(v4+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2)),13)*TPasRISCVUInt32(PRIME32_1);
{$else}
   inc(v4,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_2));
   v4:=((v4 shl 13) or (v4 shr 19))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
   inc(p,SizeOf(TPasRISCVUInt32));
  until {%H-}TPasRISCVPtrUInt(p)>{%H-}TPasRISCVPtrUInt(e);
{$if defined(fpc) and declared(ROLDWord)}
  result:=ROLDWord(v1,1)+ROLDWord(v2,7)+ROLDWord(v3,12)+ROLDWord(v4,18);
{$else}
  result:=((v1 shl 1) or (v1 shr 31))+
          ((v2 shl 7) or (v2 shr 25))+
          ((v3 shl 12) or (v3 shr 20))+
          ((v4 shl 18) or (v4 shr 14));
{$ifend}
 end else begin
  result:=HashInitialization;
 end;
 inc(result,DataLength);
 e:=@PPasRISCVUInt8Array(TPasRISCVPointer(@aKey[1]))^[DataLength];
 while ({%H-}TPasRISCVPtrUInt(p)+SizeOf(TPasRISCVUInt32))<={%H-}TPasRISCVPtrUInt(e) do begin
{$if defined(fpc) and declared(ROLDWord)}
  result:=ROLDWord(result+(TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_3)),17)*TPasRISCVUInt32(PRIME32_4);
{$else}
  inc(result,TPasRISCVUInt32(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_3));
  result:=((result shl 17) or (result shr 15))*TPasRISCVUInt32(PRIME32_4);
{$ifend}
  inc(p,SizeOf(TPasRISCVUInt32));
 end;
 while {%H-}TPasRISCVPtrUInt(p)<{%H-}TPasRISCVPtrUInt(e) do begin
{$if defined(fpc) and declared(ROLDWord)}
  result:=ROLDWord(result+(TPasRISCVUInt8(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_5)),11)*TPasRISCVUInt32(PRIME32_1);
{$else}
  inc(result,TPasRISCVUInt8(TPasRISCVPointer(p)^)*TPasRISCVUInt32(PRIME32_5));
  result:=((result shl 11) or (result shr 21))*TPasRISCVUInt32(PRIME32_1);
{$ifend}
  inc(p,SizeOf(TPasRISCVUInt8));
 end;
 result:=(result xor (result shr 15))*TPasRISCVUInt32(PRIME32_2);
 result:=(result xor (result shr 13))*TPasRISCVUInt32(PRIME32_3);
 result:=result xor (result shr 16);
{$if defined(CPU386) or defined(CPUAMD64)}
 // Special case: The hash value may be never zero
 result:=result or (-TPasRISCVUInt32(ord(result=0) and 1));
{$else}
 if result=0 then begin
  // Special case: The hash value may be never zero
  result:=$ffffffff;
 end;
{$ifend}
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.FindEntity(const aKey:TPasRISCVHashMapKey):PEntity;
var Index,HashCode,Mask,Step:TPasRISCVSizeUInt;
begin
 HashCode:=HashKey(aKey);
 Mask:=(2 shl fLogSize)-1;
 Step:=((HashCode shl 1)+1) and Mask;
 Index:=HashCode shr (32-fLogSize);
 repeat
  result:=@fEntities[Index];
  if (result^.State=TEntity.Empty) or ((result^.State=TEntity.Used) and (result^.Key=aKey)) then begin
   exit;
  end;
  Index:=(Index+Step) and Mask;
 until false;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.FindEntityForAdd(const aKey:TPasRISCVHashMapKey):PEntity;
var Index,HashCode,Mask,Step:TPasRISCVSizeUInt;
    DeletedEntity:PEntity;
begin
 HashCode:=HashKey(aKey);
 Mask:=(2 shl fLogSize)-1;
 Step:=((HashCode shl 1)+1) and Mask;
 Index:=HashCode shr (32-fLogSize);
 DeletedEntity:=nil;
 repeat
  result:=@fEntities[Index];
  case result^.State of
   TEntity.Empty:begin
    break;
   end;
   TEntity.Deleted:begin
    if not assigned(DeletedEntity) then begin
     DeletedEntity:=result;
    end;
   end;
   else {TEntity.Used:}begin
    if result^.Key=aKey then begin
     exit;
    end;
   end;
  end;
  Index:=(Index+Step) and Mask;
 until false;
 if assigned(DeletedEntity) then begin
  result:=DeletedEntity;
 end;
end;

procedure TPasRISCVStringHashMap<TPasRISCVHashMapValue>.Resize;
var Index:TPasRISCVSizeInt;
    OldEntities:TEntities;
    OldEntity:PEntity;
begin

 fLogSize:={$ifdef cpu64}IntLog264{$else}IntLog2{$endif}(fCountNonEmptyEntites)+1;

 fSize:=2 shl fLogSize;

 fCountNonEmptyEntites:=0;

 fCountDeletedEntites:=0;

 OldEntities:=fEntities;

 fEntities:=nil;
 SetLength(fEntities,fSize);

 for Index:=0 to length(fEntities)-1 do begin
  fEntities[Index].State:=TEntity.Empty;
 end;

 if length(OldEntities)>0 then begin
  try
   for Index:=0 to length(OldEntities)-1 do begin
    OldEntity:=@OldEntities[Index];
    if OldEntity^.State=TEntity.Used then begin
     Add(OldEntity^.Key,OldEntity^.Value);
    end;
{   Finalize(OldEntity^.Key);
    Finalize(OldEntity^.Value);}
   end;
  finally
   OldEntities:=nil;
  end;
 end;

end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.Add(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue):PEntity;
begin
 while fCountNonEmptyEntites>=(1 shl fLogSize) do begin
  Resize;
 end;
 result:=FindEntityForAdd(aKey);
 case result^.State of
  TEntity.Empty:begin
   inc(fCountNonEmptyEntites);
  end;
  TEntity.Deleted:begin
   dec(fCountDeletedEntites);
  end;
  else begin
  end;
 end;
 result^.State:=TEntity.Used;
 result^.Key:=aKey;
 result^.Value:=aValue;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.Get(const aKey:TPasRISCVHashMapKey;const aCreateIfNotExist:boolean):PEntity;
var Value:TPasRISCVHashMapValue;
begin
 result:=FindEntity(aKey);
 case result^.State of
  TEntity.Used:begin
  end;
  else {TEntity.Empty,TEntity.Deleted:}begin
   if aCreateIfNotExist then begin
    Initialize(Value);
    result:=Add(aKey,Value);
   end else begin
    result:=nil;
   end;
  end;
 end;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.TryGet(const aKey:TPasRISCVHashMapKey;out aValue:TPasRISCVHashMapValue):boolean;
var Entity:PEntity;
begin
 Entity:=FindEntity(aKey);
 result:=Entity^.State=TEntity.Used;
 if result then begin
  aValue:=Entity^.Value;
 end else begin
  Initialize(aValue);
 end;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.ExistKey(const aKey:TPasRISCVHashMapKey):boolean;
begin
 result:=FindEntity(aKey)^.State=TEntity.Used;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.Delete(const aKey:TPasRISCVHashMapKey):boolean;
var Entity:PEntity;
begin
 Entity:=FindEntity(aKey);
 result:=Entity^.State=TEntity.Used;
 if result then begin
  Entity^.State:=TEntity.Deleted;
  Finalize(Entity^.Key);
  Finalize(Entity^.Value);
  inc(fCountDeletedEntites);
  if fCanShrink and (fSize>=8) and (fCountDeletedEntites>=((fSize+3) shr 2)) then begin
   dec(fCountNonEmptyEntites,fCountDeletedEntites);
   Resize;
  end;
 end;
end;

function TPasRISCVStringHashMap<TPasRISCVHashMapValue>.GetValue(const aKey:TPasRISCVHashMapKey):TPasRISCVHashMapValue;
var Entity:PEntity;
begin
 Entity:=FindEntity(aKey);
 if Entity^.State=TEntity.Used then begin
  result:=Entity^.Value;
 end else begin
  result:=fDefaultValue;
 end;
end;

procedure TPasRISCVStringHashMap<TPasRISCVHashMapValue>.SetValue(const aKey:TPasRISCVHashMapKey;const aValue:TPasRISCVHashMapValue);
begin
 Add(aKey,aValue);
end;
{$endif}

{ TPasRISCVFileMappedStream }

constructor TPasRISCVFileMappedStream.Create(const aFileName:String;aMode:TPasRISCVUInt16;const aMappingWholeFile:Boolean);
{$ifdef unix}
const Access:array[0..4] of TPasRISCVUInt32=(O_RdOnly,O_WrOnly,O_RdWr,O_RdWr,O_RdWr);
      CreateFlag:array[0..4] of TPasRISCVUInt32=(0,0,0,O_Creat,O_Creat);
var StatInfo:BaseUnix.Stat;
    ModeEx:TPasRISCVUInt32;
begin
 inherited Create;
 fAllocationGranularity:=65536;
 fFileName:=aFileName;
 ModeEx:=aMode and not (fmShareExclusive or fmShareExclusive or fmShareDenyRead or fmShareDenyWrite or fmShareDenyNone);
 fCurrentViewOffset:=0;
 fCurrentViewSize:=0;
 if aMappingWholeFile then begin
  fViewSize:=TPasRISCVInt64($4000000000000000);
 end else begin
  fViewSize:=DefaultViewSize;
 end;
 fViewMask:=fViewSize-1;
 fReadOnly:=ModeEx=0;
 FTemporary:=ModeEx=fmCreateTemporary;
 if aMode=fmCreate then begin
  ModeEx:=3;
 end;
 fFileHandle:=fpOpen(PChar(fFileName),Access[ModeEx] or CreateFlag[ModeEx]);
 if fFileHandle<>feInvalidHandle then begin
  if fpfstat(fFileHandle,StatInfo)<>0 then begin
   raise Exception.Create('Cann''t access file');
  end;
  fSize:=StatInfo.st_size;
  if fSize<1 then begin
   FpLseek(fFileHandle,1,Seek_Set);
   fSize:=1;
  end;
  CreateMapView;
 end else begin
  raise Exception.Create('Can''t access file');
 end;
end;
{$else}
const Access:array[0..4] of TPasRISCVUInt32=(GENERIC_READ,GENERIC_WRITE,GENERIC_READ or GENERIC_WRITE,GENERIC_READ or GENERIC_WRITE,GENERIC_READ or GENERIC_WRITE);
      CreateFlag:array[0..4] of TPasRISCVUInt32=(OPEN_EXISTING,OPEN_EXISTING,OPEN_EXISTING,CREATE_ALWAYS,CREATE_ALWAYS);
var ModeEx,FileFlags,ShareFlags:TPasRISCVUInt32;
    SystemInfo:TSystemInfo;
begin
 inherited Create;
 GetSystemInfo(SystemInfo);
 fAllocationGranularity:=SystemInfo.dwAllocationGranularity;
 fFileName:=aFileName;
 ModeEx:=aMode and not (fmShareExclusive or fmShareExclusive or fmShareDenyRead or fmShareDenyWrite or fmShareDenyNone);
 fCurrentViewOffset:=0;
 fCurrentViewSize:=0;
 if aMappingWholeFile then begin
  fViewSize:=TPasRISCVInt64($4000000000000000);
 end else begin
  fViewSize:=DefaultViewSize;
 end;
 fViewMask:=fViewSize-1;
 fReadOnly:=ModeEx=0;
 if aMode=fmCreate then begin
  ModeEx:=3;
 end;
 if ModeEx<>4 then begin
  FileFlags:=FILE_ATTRIBUTE_NORMAL;
 end else begin
  FileFlags:=FILE_FLAG_DELETE_ON_CLOSE;
 end;
 ShareFlags:=FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE;
 if (aMode and fmShareDenyNone)=0 then begin
  if (aMode and fmShareExclusive)<>0 then begin
   ShareFlags:=0;
  end else begin
   if (aMode and fmShareDenyRead)<>0 then begin
    ShareFlags:=ShareFlags and not FILE_SHARE_READ;
   end;
   if (aMode and fmShareDenyWrite)<>0 then begin
    ShareFlags:=ShareFlags and not (FILE_SHARE_WRITE or FILE_SHARE_DELETE);
   end;
  end;
 end;
 fFileHandle:=CreateFile(PChar(fFileName),Access[ModeEx],ShareFlags,nil,CreateFlag[ModeEx],FileFlags,0);
 if fFileHandle<>INVALID_HANDLE_VALUE then begin
  fSize:=GetFileSize(fFileHandle,nil);
  if fSize<1 then begin
   SetFilePointer(fFileHandle,1,nil,FILE_BEGIN);
   SetEndOfFile(fFileHandle);
   fSize:=1;
  end;
  CreateMapView;
 end else begin
  raise Exception.Create(SysErrorMessage(GetLastError));
 end;
end;
{$endif}

destructor TPasRISCVFileMappedStream.Destroy;
begin
 CloseMapView;
{$ifdef unix}
 if fFileHandle<>feInvalidHandle then begin
  fpclose(fFileHandle);
  fFileHandle:=feInvalidHandle;
 end;
 if FTemporary then begin
  FpUnlink(fFileName);
 end;
{$else}
 if fFileHandle<>INVALID_HANDLE_VALUE then begin
  CloseHandle(fFileHandle);
  fFileHandle:=INVALID_HANDLE_VALUE;
 end;
{$endif}
 inherited Destroy;
end;

procedure TPasRISCVFileMappedStream.CreateMapView;
{$ifdef unix}
var StatInfo:BaseUnix.Stat;
begin
 if fpfstat(fFileHandle,StatInfo)<>0 then begin
  CloseMapView;
  raise Exception.Create('Cannot create map view.');
  exit;
 end;
 fSize:=StatInfo.st_size;
 if fSize=0 then begin
  CloseMapView;
  raise Exception.Create('Cannot create map view.');
  exit;
 end;
 fCurrentViewSize:=fViewSize;
 if (fCurrentViewOffset+fCurrentViewSize)>fSize then begin
  fCurrentViewSize:=fSize-fCurrentViewOffset;
 end;
 if ReadOnly then begin
  fMemory:=fpmmap(nil,fCurrentViewSize,PROT_READ,MAP_PRIVATE,fFileHandle,fCurrentViewOffset);
 end else begin
  fMemory:=fpmmap(nil,fCurrentViewSize,PROT_READ or PROT_WRITE,MAP_SHARED,fFileHandle,fCurrentViewOffset);
 end;
 if TPasRISCVPtrUInt(fMemory)=TPasRISCVPtrUInt(TPasRISCVPtrInt(-1)) then begin
  fMemory:=nil;
  CloseMapView;
  raise Exception.Create('Cannot create map view.');
 end;
end;
{$else}
begin
 if ReadOnly then begin
  fMapHandle:=CreateFileMapping(fFileHandle,nil,PAGE_READONLY,0,fSize,nil);
 end else begin
  fMapHandle:=CreateFileMapping(fFileHandle,nil,PAGE_READWRITE,0,fSize,nil);
 end;
 if fMapHandle=0 then begin
  raise Exception.Create(SysErrorMessage(GetLastError));
 end;
 fCurrentViewSize:=fViewSize;
 if (fCurrentViewOffset+fCurrentViewSize)>fSize then begin
  fCurrentViewSize:=fSize-fCurrentViewOffset;
 end;
 if ReadOnly then begin
  fMemory:=MapViewOfFile(fMapHandle,FILE_MAP_READ,TPasRISCVUInt32(fCurrentViewOffset shr 32),TPasRISCVUInt32(fCurrentViewOffset),fCurrentViewSize);
 end else begin
  fMemory:=MapViewOfFile(fMapHandle,FILE_MAP_READ or FILE_MAP_WRITE,TPasRISCVUInt32(fCurrentViewOffset shr 32),TPasRISCVUInt32(fCurrentViewOffset),fCurrentViewSize);
 end;
 if not assigned(fMemory) then begin
  raise Exception.Create(SysErrorMessage(GetLastError));
 end;
end;
{$endif}

procedure TPasRISCVFileMappedStream.UpdateMapView;
begin
 if (fPosition<fCurrentViewOffset) or ((fCurrentViewOffset+fCurrentViewSize)<fPosition) then begin
  if (fAllocationGranularity and (fAllocationGranularity-1))<>0 then begin
   fCurrentViewOffset:=fPosition;
   if (fCurrentViewOffset mod fAllocationGranularity)<>0 then begin
    dec(fCurrentViewOffset,fCurrentViewOffset mod fAllocationGranularity);
   end;
   fCurrentViewSize:=fViewSize;
   if (fCurrentViewSize mod fAllocationGranularity)<>0 then begin
    inc(fCurrentViewSize,fAllocationGranularity-(fCurrentViewOffset mod fAllocationGranularity));
   end;
  end else begin
   fCurrentViewOffset:=fPosition and not (fAllocationGranularity-1);
   fCurrentViewSize:=(fViewSize+(fAllocationGranularity-1)) and not (fAllocationGranularity-1);
  end;
  if fCurrentViewOffset<0 then begin
   fCurrentViewOffset:=0;
  end;
  if (fCurrentViewOffset+fCurrentViewSize)>fSize then begin
   fCurrentViewSize:=fSize-fCurrentViewOffset;
  end;
{$ifdef unix}
  if assigned(fMemory) then begin
   fpmunmap(fMemory,fCurrentViewSize);
   fMemory:=nil;
  end;
  if ReadOnly then begin
   fMemory:=fpmmap(nil,fCurrentViewSize,PROT_READ,MAP_PRIVATE,fFileHandle,fCurrentViewOffset);
  end else begin
   fMemory:=fpmmap(nil,fCurrentViewSize,PROT_READ or PROT_WRITE,MAP_SHARED,fFileHandle,fCurrentViewOffset);
  end;
  if TPasRISCVPtrUInt(fMemory)=TPasRISCVPtrUInt(TPasRISCVPtrInt(-1)) then begin
   fMemory:=nil;
   CloseMapView;
   raise Exception.Create('Cannot create map view.');
  end;
{$else}
  if assigned(fMemory) then begin
   UnmapViewOfFile(fMemory);
   fMemory:=nil;
  end;
  if ReadOnly then begin
   fMemory:=MapViewOfFile(fMapHandle,FILE_MAP_READ,TPasRISCVUInt32(fCurrentViewOffset shr 32),TPasRISCVUInt32(fCurrentViewOffset),fCurrentViewSize);
  end else begin
   fMemory:=MapViewOfFile(fMapHandle,FILE_MAP_READ or FILE_MAP_WRITE,TPasRISCVUInt32(fCurrentViewOffset shr 32),TPasRISCVUInt32(fCurrentViewOffset),fCurrentViewSize);
  end;
  if not assigned(fMemory) then begin
   raise Exception.Create(SysErrorMessage(GetLastError));
  end;
{$endif}
 end;
end;

procedure TPasRISCVFileMappedStream.CloseMapView;
begin
{$ifdef unix}
 if assigned(fMemory) then begin
  fpmunmap(fMemory,fCurrentViewSize);
  fMemory:=nil;
 end;
{if fFileHandle<>feInvalidHandle then begin
  fpClose(fFileHandle);
  fFileHandle:=feInvalidHandle;
 end;}
{$else}
 if assigned(fMemory) then begin
  UnmapViewOfFile(fMemory);
  fMemory:=nil;
 end;
 if fMapHandle<>0 then begin
  CloseHandle(fMapHandle);
 end;
{$endif}
end;

procedure TPasRISCVFileMappedStream.SetSize(aNewSize:TPasRISCVInt32);
begin
 SetSize(TPasRISCVInt64(aNewSize));
end;

procedure TPasRISCVFileMappedStream.SetSize(const aNewSize:TPasRISCVInt64);
begin
 CloseMapView;
{$ifdef unix}
 FpLseek(fFileHandle,aNewSize,Seek_Set);
{$else}
 SetFilePointer(fFileHandle,aNewSize,nil,FILE_BEGIN);
 SetEndOfFile(fFileHandle);
{$endif}
 if fCurrentViewOffset>aNewSize then begin
  fCurrentViewOffset:=(aNewSize-1) and fViewMask;
 end;
 if fCurrentViewOffset<0 then begin
  fCurrentViewOffset:=0;
 end;
 fSize:=aNewSize;
 CreateMapView;
end;

procedure TPasRISCVFileMappedStream.Clear;
begin
 SetSize(1);
 fPosition:=0;
 fCurrentViewOffset:=0;
end;

function TPasRISCVFileMappedStream.Flush:Boolean;
begin
{$ifdef unix}
 // At freepascal is no fpmsync or msync, so we must do it over this workaround
 CloseMapView;
 result:=fpfsync(fFileHandle)=0;
 CreateMapView;
{$else}
 if assigned(fMemory) then begin
  FlushViewOfFile(fMemory,fCurrentViewSize);
  result:=FlushFileBuffers(fFileHandle);
 end else begin
  CloseMapView;
  result:=FlushFileBuffers(fFileHandle);
  CreateMapView;
 end;
{$endif}
end;

function TPasRISCVFileMappedStream.Seek(const aOffset:TPasRISCVInt64;aOrigin:TSeekOrigin):TPasRISCVInt64;
begin
 case aOrigin of
  soBeginning:begin
   fPosition:=aOffset;
  end;
  soCurrent:begin
   fPosition:=fPosition+aOffset;
  end;
  soEnd:begin
   fPosition:=fSize+aOffset;
  end;
 end;
 if fPosition>fSize then begin
  SetSize(fPosition);
 end;
 UpdateMapView;
 result:=fPosition;
end;

function TPasRISCVFileMappedStream.Read(var aBuffer;aCount:TPasRISCVInt32):TPasRISCVInt32;
var Remain,ToDo:TPasRISCVInt32;
    BufferPointer:PAnsiChar;
begin
 if assigned(fMemory) then begin
  if (fPosition+aCount)>Size then begin
   aCount:=fSize-fPosition;
  end;
  Remain:=aCount;
  BufferPointer:=@aBuffer;
  while Remain>0 do begin
   UpdateMapView;
   ToDo:=Remain;
   if (fPosition+ToDo)>(fCurrentViewOffset+fCurrentViewSize) then begin
    ToDo:=(fCurrentViewOffset+fCurrentViewSize)-fPosition;
   end;
   Move(PPasRISCVUInt8Array(fMemory)^[fPosition-fCurrentViewOffset],BufferPointer^,ToDo);
   inc(fPosition,ToDo);
   inc(BufferPointer,ToDo);
   dec(Remain,ToDo);
  end;
  result:=aCount;
 end else begin
  raise Exception.Create('No data available');
 end;
end;

function TPasRISCVFileMappedStream.Write(const aBuffer;aCount:TPasRISCVInt32):TPasRISCVInt32;
var Remain,ToDo:TPasRISCVInt32;
    BufferPointer:PAnsiChar;
begin
 if assigned(fMemory) and not ReadOnly then begin
  if (fPosition+aCount)>fSize then begin
   SetSize(fPosition+aCount);
  end;
  Remain:=aCount;
  BufferPointer:=@aBuffer;
  while Remain>0 do begin
   UpdateMapView;
   ToDo:=Remain;
   if (fPosition+ToDo)>(fCurrentViewOffset+fCurrentViewSize) then begin
    ToDo:=(fCurrentViewOffset+fCurrentViewSize)-fPosition;
   end;
   Move(BufferPointer^,PPasRISCVUInt8Array(fMemory)^[fPosition-fCurrentViewOffset],ToDo);
   inc(fPosition,ToDo);
   inc(BufferPointer,ToDo);
   dec(Remain,ToDo);
  end;
  result:=aCount;
 end else begin
  raise Exception.Create('Cannot access memory data');
 end;
end;

{ TPasRISCVAudioWAVStreamDump }

constructor TPasRISCVAudioWAVStreamDump.Create(const aSampleRate:TPasRISCVInt32;const aStream:TStream;const aDoFreeStream:boolean=true);
begin
 inherited Create;

 fStream:=aStream;

 fDoFreeStream:=aDoFreeStream;

 fSampleRate:=aSampleRate;

 fChannels:=2;

 fBitsPerSample:=32;

 fWaveFileHeader.Signature:=TPasRISCVAudioWAVFormat.RIFFSignature;
 fWaveFileHeader.Size:=0;
 fWaveFileHeader.WAVESignature:=TPasRISCVAudioWAVFormat.WAVESignature;

 fWaveFormatHeader.FormatTag:=3;
 fWaveFormatHeader.Channels:=fChannels;
 fWaveFormatHeader.SamplesPerSecond:=fSampleRate;
 fWaveFormatHeader.AvgBytesPerSecond:=((fSampleRate*fChannels*fBitsPerSample)+7) shr 3;
 fWaveFormatHeader.SampleSize:=((fChannels*fBitsPerSample)+7) shr 3;
 fWaveFormatHeader.BitsPerSample:=fBitsPerSample;

 fWaveFormatChunkHeader.Signature:=TPasRISCVAudioWAVFormat.FMTSignature;
 fWaveFormatChunkHeader.Size:=SizeOf(TPasRISCVAudioWAVFormat.TWaveFormatHeader);

 fWaveDataChunkHeader.Signature:=TPasRISCVAudioWAVFormat.DATASignature;
 fWaveDataChunkHeader.Size:=0;

 fFileHeaderOffset:=fStream.Position;
 fStream.WriteBuffer(fWaveFileHeader,SizeOf(TPasRISCVAudioWAVFormat.TWaveFileHeader));

 fFormatChunkHeaderOffset:=fStream.Position;
 fStream.WriteBuffer(fWaveFormatChunkHeader,SizeOf(TPasRISCVAudioWAVFormat.TWaveChunkHeader));
 fStream.WriteBuffer(fWaveFormatHeader,SizeOf(TPasRISCVAudioWAVFormat.TWaveFormatHeader));

 fDataChunkHeaderOffset:=fStream.Position;
 fStream.WriteBuffer(fWaveDataChunkHeader,SizeOf(TPasRISCVAudioWAVFormat.TWaveChunkHeader));

 fDataOffset:=fStream.Position;

 fDataSize:=0;

 fBufferFloats:=nil;

 SetLength(fBufferFloats,65536);

end;

destructor TPasRISCVAudioWAVStreamDump.Destroy;
begin
 Flush;
 if fDoFreeStream then begin
  FreeAndNil(fStream);
 end;
 fBufferFloats:=nil;
 inherited Destroy;
end;

procedure TPasRISCVAudioWAVStreamDump.Flush;
begin

 if assigned(fStream) and (fDataSize>0) then begin

  fStream.Seek(fDataChunkHeaderOffset,soFromBeginning);
  fWaveDataChunkHeader.Size:=fDataSize;
  fStream.WriteBuffer(fWaveDataChunkHeader,SizeOf(TPasRISCVAudioWAVFormat.TWaveChunkHeader));

  fStream.Seek(fFileHeaderOffset,soFromBeginning);
  fWaveFileHeader.Size:=SizeOf(TPasRISCVAudioWAVFormat.TWaveChunkHeader)+
                        SizeOf(TPasRISCVAudioWAVFormat.TWaveFormatHeader)+
                        SizeOf(TPasRISCVAudioWAVFormat.TWaveChunkHeader)+
                        fDataSize;
  fStream.WriteBuffer(fWaveFileHeader,SizeOf(TPasRISCVAudioWAVFormat.TWaveFileHeader));

  fStream.Seek(0,soFromEnd);

 end;

end;

procedure TPasRISCVAudioWAVStreamDump.Dump(const aData:TPasRISCVPointer;const aDataSize:TPasRISCVSizeInt;const aFloat:Boolean);
var CountSamples,Index:TPasRISCVSizeInt;
begin

 if assigned(fStream) and (aDataSize>=SizeOf(TPasRISCVUInt32)) then begin

  if aFloat then begin
   CountSamples:=aDataSize shr 2; // Mono-wise 32 bit stereo samples
  end else begin
   CountSamples:=aDataSize shr 1; // Mono-wise 16 bit stereo samples
  end;

  // Check if buffer is big enough, if not, resize it
  if length(fBufferFloats)<CountSamples then begin
   SetLength(fBufferFloats,CountSamples*2);
  end;

  // Transfer samples
  if aFloat then begin
   for Index:=0 to CountSamples-1 do begin
    fBufferFloats[Index]:=PPasRISCVFloatArray(aData)^[Index];
   end;
  end else  begin
   for Index:=0 to CountSamples-1 do begin
    fBufferFloats[Index]:=PPasRISCVInt16Array(aData)^[Index]/32768.0;
   end;
  end;

  fStream.Seek(fDataOffset+fDataSize,soFromBeginning);
  fStream.WriteBuffer(fBufferFloats[0],aDataSize); // same byte size as aDataSize since uint32 = 4 bytes like float32 as well

  inc(fDataSize,aDataSize);

  Flush; // Flush every time, because we can't know when the stream is closed, so that the header is valid anyway

 end;

end;

{ TPasRISCV9PFileSystem }

constructor TPasRISCV9PFileSystem.Create;
begin
 inherited Create;
end;

destructor TPasRISCV9PFileSystem.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV9PFileSystem.Delete(const aFile:TPasRISCV9PFileSystem.TFSFile);
begin
end;

procedure TPasRISCV9PFileSystem.StatFS(out aStatFS:TPasRISCV9PFileSystem.TFSStatFS);
begin
end;

function TPasRISCV9PFileSystem.Attach(out aFile:TPasRISCV9PFileSystem.TFSFile;const aQID:TPasRISCV9PFileSystem.PFSQID;const aUID:TPasRISCVUInt32;const aUName,aAName:TPasRISCVRawByteString):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.Walk(out aFiles:TPasRISCV9PFileSystem.TFSFile;const aQIDs:TPasRISCV9PFileSystem.PFSQIDArray;const aFile:TPasRISCV9PFileSystem.TFSFile;const aCount:TPasRISCVSizeInt;const aNames:array of TPasRISCVRawByteString):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.MkDir(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.Open(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aFlags:TPasRISCVUInt32;const aOnOpenCompletion:TPasRISCV9PFileSystem.TOnOpenCompletion;const aOpaque:Pointer):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.Create_(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aFlags:TPasRISCVUInt32;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.ReadDir(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.Read(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.Write(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
begin
 result:=P9_ENOTSUP;
end;

procedure TPasRISCV9PFileSystem.Close(const aFile:TPasRISCV9PFileSystem.TFSFile);
begin
end;

function TPasRISCV9PFileSystem.Stat(const aFile:TPasRISCV9PFileSystem.TFSFile;out aStat:TPasRISCV9PFileSystem.TFSStat):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.SetAttr(const aFile:TPasRISCV9PFileSystem.TFSFile;const aMask,aMode,aUID,aGID:TPasRISCVUInt32;const aSize,aATimeSec,aATimeNSec,aMTimeSec,aMTimeNSec,aCTimeSec,aCTimeNSec:TPasRISCVUInt64):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.Link(const aDestFile,aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.SymLink(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName,aTarget:TPasRISCVRawByteString;const aGID:TPasRISCVUInt32):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.MkNod(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aMajor,aMinor,aGID:TPasRISCVUInt32):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.ReadLink(const aBuffer:Pointer;const aSize:TPasRISCVInt64;const aFile:TPasRISCV9PFileSystem.TFSFile):TPasRISCVInt64;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.RenameAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aNewFile:TPasRISCV9PFileSystem.TFSFile;const aNewName:TPasRISCVRawByteString):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.UnlinkAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.Lock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

function TPasRISCV9PFileSystem.GetLock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32;
begin
 result:=P9_ENOTSUP;
end;

{$if defined(fpc) and defined(Unix)}

{ TPasRISCV9PFileSystemPOSIX }

procedure RewindDir(dirp:PDIR); cdecl; external 'c' name 'rewinddir';
function MkNod_(pathname:PAnsiChar;Mode:mode_t;dev:dev_t):cint; cdecl; external 'c' name 'mknod';
function lchown(pathname:PAnsiChar;uid:UID_T;gid:gid_t):cint; cdecl; external 'c' name 'lchown';
function Remove_(pathname:PAnsiChar):cint; cdecl; external 'c' name 'remove';

constructor TPasRISCV9PFileSystemPOSIX.Create(const aRootPath:TPasRISCVRawByteString);
begin
 inherited Create;
 fRootPath:=aRootPath;
end;

destructor TPasRISCV9PFileSystemPOSIX.Destroy;
begin
 fRootPath:='';
 inherited Destroy;
end;

function TPasRISCV9PFileSystemPOSIX.POSIXErrorCodeToP9ErrorCode(const aErrorCode:TPasRISCVInt32):TPasRISCVInt32;
begin
 case aErrorCode of
  0:begin
   result:=0;
  end;
  ESysEPERM:begin
   result:=P9_EPERM;
  end;
  ESysENOENT:begin
   result:=P9_ENOENT;
  end;
  ESysEIO:begin
   result:=P9_EIO;
  end;
  ESysEEXIST:begin
   result:=P9_EEXIST;
  end;
  ESysEINVAL:begin
   result:=P9_EINVAL;
  end;
  ESysENOSPC:begin
   result:=P9_ENOSPC;
  end;
  ESysENOTEMPTY:begin
   result:=P9_ENOTEMPTY;
  end;
  ESysEPROTO:begin
   result:=P9_EPROTO;
  end;
  ESysEOPNOTSUPP:begin
   result:=P9_ENOTSUP;
  end;
  else begin
   result:=P9_EINVAL;
  end;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.P9OpenFlagsToPOSIXOpenFlags(const aFlags:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=aFlags and P9_O_NOACCESS;
 if (aFlags and P9_O_CREAT)<>0 then begin
  result:=result or O_CREAT;
 end;
 if (aFlags and P9_O_EXCL)<>0 then begin
  result:=result or O_EXCL;
 end;
{if (aFlags and P9_O_NOCTTY)<>0 then begin
  result:=result or O_NOCTTY;
 end;}
 if (aFlags and P9_O_TRUNC)<>0 then begin
  result:=result or O_TRUNC;
 end;
 if (aFlags and P9_O_APPEND)<>0 then begin
  result:=result or O_APPEND;
 end;
 if (aFlags and P9_O_NONBLOCK)<>0 then begin
  result:=result or O_NONBLOCK;
 end;
 if (aFlags and P9_O_DSYNC)<>0 then begin
  result:=result or O_SYNC; //O_DSYNC
 end;
{if (aFlags and P9_O_FASYNC)<>0 then begin
  result:=result or O_FASYNC;
 end;
 if (aFlags and P9_O_DIRECT)<>0 then begin
  result:=result or O_DIRECT;
 end;
 if (aFlags and P9_O_LARGEFILE)<>0 then begin
  result:=result or O_LARGEFILE;
 end;
 if (aFlags and P9_O_DIRECTORY)<>0 then begin
  result:=result or O_DIRECTORY;
 end;}
 if (aFlags and P9_O_NOFOLLOW)<>0 then begin
  result:=result or O_NOFOLLOW;
 end;
{if (aFlags and P9_O_NOATIME)<>0 then begin
  result:=result or O_NOATIME;
 end;
 if (aFlags and P9_O_CLOEXEC)<>0 then begin
  result:=result or O_CLOEXEC;
 end;}
 if (aFlags and P9_O_SYNC)<>0 then begin
  result:=result or O_SYNC;
 end;
end;

procedure TPasRISCV9PFileSystemPOSIX.StatToQID(const aQID:TPasRISCV9PFileSystem.PFSQID;const aStat:PStat);
begin
 aQID^.Type_:=0;
 if (aStat.st_mode and S_IFDIR)<>0 then begin
  aQID^.Type_:=aQID^.Type_ or P9_QTDIR;
 end;
 if (aStat.st_mode and S_IFLNK)<>0 then begin
  aQID^.Type_:=aQID^.Type_ or P9_QTSYMLINK;
 end;
 aQID^.Version:=0; // no caching on client
 aQID^.Path:=aStat.st_ino;
end;

function TPasRISCV9PFileSystemPOSIX.ComposePath(const aPath,aName:TPasRISCVRawByteString):TPasRISCVRawByteString;
const DirectorySeparator='/';
begin
 result:=aPath;
 if (length(result)>0) and (result[length(result)]<>DirectorySeparator) then begin
  result:=result+DirectorySeparator;
 end;
 result:=result+aName;
end;

function TPasRISCV9PFileSystemPOSIX.CreateFileObject(const aPath:TPasRISCVRawByteString;const aUID:TPasRISCVUInt32):TPasRISCV9PFileSystem.TFSFile;
begin
 result:=TFSFile.Create;
 result.fPath:=aPath;
 result.fUID:=aUID;
 result.fIsOpened:=false;
 result.fIsDirectory:=false;
 result.fStream:=nil;
 result.fFile:=-1;
 result.fDirectory:=nil;
end;

procedure TPasRISCV9PFileSystemPOSIX.Delete(const aFile:TPasRISCV9PFileSystem.TFSFile);
begin
 if assigned(aFile) then begin
  if aFile.fIsOpened then begin
   Close(aFile);
  end;
  aFile.fIsOpened:=false;
  aFile.fIsDirectory:=false;
  aFile.fPath:='';
  if assigned(aFile.fStream) then begin
   FreeAndNil(aFile.fStream);
  end;
  if assigned(aFile.fDirectory) then begin
   try
    FreeMem(aFile.fDirectory);
   finally
    aFile.fDirectory:=nil;
   end;
  end;
  aFile.Free;
 end;
end;

procedure TPasRISCV9PFileSystemPOSIX.StatFS(out aStatFS:TPasRISCV9PFileSystem.TFSStatFS);
var StatFSData:TStatFS;
begin
 if fpStatFS(PAnsiChar(fRootPath),@StatFSData)=0 then begin
  aStatFS.BSize:=StatFSData.bsize;
  aStatFS.Blocks:=StatFSData.blocks;
  aStatFS.BFree:=StatFSData.bfree;
  aStatFS.BAvail:=StatFSData.bavail;
  aStatFS.Files:=StatFSData.files;
  aStatFS.FFree:=StatFSData.ffree;
 end else begin
  FillChar(aStatFS,SizeOf(TFSStatFS),#0);
 end;
end;

function TPasRISCV9PFileSystemPOSIX.Attach(out aFile:TPasRISCV9PFileSystem.TFSFile;const aQID:TPasRISCV9PFileSystem.PFSQID;const aUID:TPasRISCVUInt32;const aUName,aAName:TPasRISCVRawByteString):TPasRISCVInt32;
var StatData:TStat;
begin
 if fpLStat(PAnsiChar(fRootPath),@StatData)=0 then begin
  aFile:=CreateFileObject(fRootPath,aUID);
  StatToQID(aQID,@StatData);
  result:=0;
 end else begin
  aFile:=nil;
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end;
end;

function TPasRISCV9PFileSystemPOSIX.Walk(out aFiles:TPasRISCV9PFileSystem.TFSFile;const aQIDs:TPasRISCV9PFileSystem.PFSQIDArray;const aFile:TPasRISCV9PFileSystem.TFSFile;const aCount:TPasRISCVSizeInt;const aNames:array of TPasRISCVRawByteString):TPasRISCVInt32;
var Path,Path1:TPasRISCVRawByteString;
    StatData:TStat;
    Index:TPasRISCVSizeInt;
begin
 Path:=aFile.fPath;
 result:=0;
 for Index:=0 to aCount-1 do begin
  Path1:=ComposePath(Path,aNames[Index]);
  if fpLStat(PAnsiChar(Path1),@StatData)=0 then begin
   Path:=Path1;
   StatToQID(@aQIDs[Index],@StatData);
   inc(result);
  end else begin
   break;
  end;
 end;
 aFiles:=CreateFileObject(Path,aFile.fUID);
end;

function TPasRISCV9PFileSystemPOSIX.MkDir(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32;
var Path:TPasRISCVRawByteString;
    StatData:TStat;
begin
 Path:=ComposePath(aFile.fPath,aName);
 if fpMkDir(PAnsiChar(Path),aMode)<0 then begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end else begin
  if fpLStat(PAnsiChar(Path),@StatData)=0 then begin
   StatToQID(aQID,@StatData);
   result:=0;
  end else begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
  end;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.Open(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aFlags:TPasRISCVUInt32;const aOnOpenCompletion:TPasRISCV9PFileSystem.TOnOpenCompletion;const aOpaque:Pointer):TPasRISCVInt32;
var StatData:TStat;
    Flags:TPasRISCVUInt32;
begin
 if fpLStat(PAnsiChar(aFile.fPath),@StatData)=0 then begin
  StatToQID(aQID,@StatData);
  Flags:=P9OpenFlagsToPOSIXOpenFlags(aFlags);
  if (aFlags and P9_O_DIRECTORY)<>0 then begin
   aFile.fDirectory:=FpOpenDir(PAnsiChar(aFile.fPath));
   if assigned(aFile.fDirectory) then begin
    aFile.fIsOpened:=true;
    aFile.fIsDirectory:=true;
    result:=0;
   end else begin
    result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
   end;
  end else begin
   aFile.fFile:=fpOpen(PAnsiChar(aFile.fPath),Flags and not O_CREAT);
   if aFile.fFile>=0 then begin
    aFile.fIsOpened:=true;
    aFile.fIsDirectory:=false;
    result:=0;
   end else begin
    result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
   end;
  end;
 end else begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end;
end;

function TPasRISCV9PFileSystemPOSIX.Create_(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aFlags:TPasRISCVUInt32;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32;
var StatData:TStat;
    ret,fd:cint;
    Mode,Flags:TPasRISCVUInt32;
    Path:TPasRISCVRawByteString;
begin
 Close(aFile);
 Path:=ComposePath(aFile.fPath,aName);
 Flags:=P9OpenFlagsToPOSIXOpenFlags(aFlags);
 Mode:=aMode and (O_RdOnly or O_WRONLY or O_RDWR);
 Mode:=(Flags or Mode) and (O_RdOnly or O_WRONLY or O_RDWR);
 Flags:=Flags or Mode;
 fd:=fpOpen(PAnsiChar(Path),Flags or O_CREAT,Mode);
 if fd<0 then begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end else begin
  ret:=fpLStat(PAnsiChar(Path),@StatData);
  if ret=0 then begin
   StatToQID(aQID,@StatData);
   aFile.fPath:=Path;
   aFile.fIsOpened:=true;
   aFile.fIsDirectory:=false;
   aFile.fFile:=fd;
   result:=0;
  end else begin
   fpClose(fd);
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
  end;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.ReadDir(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
var de:Pdirent;
    len,pos,name_len,dflags:TPasRISCVSizeInt;
    StatData:TStat;
    Path:TPasRISCVRawByteString;
    Offset:TOff;
begin
 if (not aFile.fIsOpened) or (not aFile.fIsDirectory) then begin
  result:=-P9_EPROTO;
 end else begin
  result:=0;
{ if aOffset=0 then begin
   RewindDir(aFile.fDirectory);
  end else begin
   SeekDir(aFile.fDirectory,aOffset);
  end;}
  SeekDir(aFile.fDirectory,aOffset);
  pos:=0;
  repeat
   de:=fpReadDir(aFile.fDirectory^);
   if assigned(de) then begin
    name_len:=StrLen(de^.d_name);
    Len:=13+8+1+2+name_len;
    if (pos+len)<=aSize then begin
     Offset:=TellDir(aFile.fDirectory);
     dflags:=0;
     if de^.d_type=DT_UNKNOWN then begin
      Path:=ComposePath(aFile.fPath,de^.d_name);
      if fpLStat(PAnsiChar(Path),@StatData)=0 then begin
       if (StatData.st_mode and S_IFDIR)<>0 then begin
        dflags:=dflags or P9_QTDIR;
       end;
       if (StatData.st_mode and S_IFLNK)<>0 then begin
        dflags:=dflags or P9_QTSYMLINK;
       end;
      end;
     end else begin
      if (de^.d_type and (S_IFDIR shr 12))<>0 then begin
       dflags:=dflags or P9_QTDIR;
      end;
      if (de^.d_type and (S_IFLNK shr 12))<>0 then begin
       dflags:=dflags or P9_QTSYMLINK;
      end;
     end;
     PPasRISCVUInt8Array(aBuffer)^[pos]:=dflags; inc(pos);
     PPasRISCVUInt32(@PPasRISCVUInt8Array(aBuffer)^[pos])^:=0; inc(pos,SizeOf(TPasRISCVUInt32));
     PPasRISCVUInt64(@PPasRISCVUInt8Array(aBuffer)^[pos])^:=de^.d_fileno; inc(pos,SizeOf(TPasRISCVUInt64));
     PPasRISCVUInt64(@PPasRISCVUInt8Array(aBuffer)^[pos])^:=Offset; inc(pos,SizeOf(TPasRISCVUInt64));
     PPasRISCVUInt8Array(aBuffer)^[pos]:=dflags; inc(pos);
     PPasRISCVUInt16(@PPasRISCVUInt8Array(aBuffer)^[pos])^:=name_len; inc(pos,SizeOf(TPasRISCVUInt16));
     Move(de^.d_name,PPasRISCVUInt8Array(aBuffer)^[pos],name_len); inc(pos,name_len);
    end else begin
     break;
    end;
   end else begin
    break;
   end;
  until false;
  result:=pos;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.Read(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
begin
 if (not aFile.fIsOpened) or (aFile.fIsDirectory) then begin
  result:=-P9_EPROTO;
 end else begin
  result:=fpPRead(aFile.fFile,aBuffer,aSize,aOffset);
  if result<0 then begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
  end;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.Write(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
begin
 if (not aFile.fIsOpened) or (aFile.fIsDirectory) then begin
  result:=-P9_EPROTO;
 end else begin
  result:=fpPWrite(aFile.fFile,aBuffer,aSize,aOffset);
  if result<0 then begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
  end;
 end;
end;

procedure TPasRISCV9PFileSystemPOSIX.Close(const aFile:TPasRISCV9PFileSystem.TFSFile);
begin
 if aFile.fIsOpened then begin
  if aFile.fIsDirectory then begin
   fpCloseDir(aFile.fDirectory^);
  end else begin
   fpClose(aFile.fFile);
  end;
  aFile.fIsOpened:=false;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.Stat(const aFile:TPasRISCV9PFileSystem.TFSFile;out aStat:TPasRISCV9PFileSystem.TFSStat):TPasRISCVInt32;
var StatData:TStat;
begin
 if fpLStat(PAnsiChar(aFile.fPath),@StatData)=0 then begin
  StatToQID(@aStat.qid,@StatData);
  aStat.Mode:=StatData.st_mode;
  aStat.UID:=StatData.st_uid;
  aStat.GID:=StatData.st_gid;
  aStat.NLink:=StatData.st_nlink;
  aStat.RDev:=StatData.st_rdev;
  aStat.Size:=StatData.st_size;
  aStat.BlkSize:=StatData.st_blksize;
  aStat.Blocks:=StatData.st_blocks;
  aStat.ATimeSec:=StatData.st_atime;
  aStat.ATimeNSec:=StatData.st_atime_nsec;
  aStat.MTimeSec:=StatData.st_mtime;
  aStat.MTimeNSec:=StatData.st_mtime_nsec;
  aStat.CTimeSec:=StatData.st_ctime;
  aStat.CTimeNSec:=StatData.st_ctime_nsec;
  result:=0;
 end else begin
  result:=-P9_ENOENT;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.SetAttr(const aFile:TPasRISCV9PFileSystem.TFSFile;const aMask,aMode,aUID,aGID:TPasRISCVUInt32;const aSize,aATimeSec,aATimeNSec,aMTimeSec,aMTimeNSec,aCTimeSec,aCTimeNSec:TPasRISCVUInt64):TPasRISCVInt32;
var //StatData:TStat;
    ts:tkernel_timespecs;
    ctime_updated:boolean;
    UID,GID:TPasRISCVInt32;
    fd:cint;
begin

 if (aMask and (P9_SETATTR_UID or P9_SETATTR_GID))<>0 then begin
  if (aMask and P9_SETATTR_UID)<>0 then begin
   UID:=aUID;
  end else begin
   UID:=-1;
  end;
  if (aMask and P9_SETATTR_GID)<>0 then begin
   GID:=aGID;
  end else begin
   GID:=-1;
  end;
  if LChOwn(PAnsiChar(aFile.fPath),UID,GID)<0 then begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
   exit;
  end;
  ctime_updated:=true;
 end else begin
  ctime_updated:=false;
 end;

 if (aMask and P9_SETATTR_MODE)<>0 then begin
  if fpChMod(PAnsiChar(aFile.fPath),aMode)<0 then begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
   exit;
  end;
  ctime_updated:=true;
 end;

 if (aMask and P9_SETATTR_SIZE)<>0 then begin
  if aFile.fIsOpened then begin
   if fpFTruncate(aFile.fFile,aSize)<0 then begin
    result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
    exit;
   end;
  end else begin
   fd:=fpOpen(PAnsiChar(aFile.fPath),O_WRONLY);
   if fd<0 then begin
    result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
    exit;
   end;
   if fpFTruncate(fd,aSize)<0 then begin
    fpClose(fd);
    result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
    exit;
   end;
   fpClose(fd);
  end;
{if fpTruncate(PAnsiChar(aFile.fPath),aSize)<0 then begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
   exit;
  end;}
  ctime_updated:=true;
 end;

 if (aMask and (P9_SETATTR_ATIME or P9_SETATTR_MTIME))<>0 then begin
  if (aMask and P9_SETATTR_ATIME)<>0 then begin
   if (aMask and P9_SETATTR_ATIME_SET)<>0 then begin
    ts[0].tv_sec:=aATimeSec;
    ts[0].tv_nsec:=aATimeNSec;
   end else begin
    ts[0].tv_sec:=0;
    ts[0].tv_nsec:=UTIME_NOW;
   end;
  end else begin
   ts[0].tv_sec:=0;
   ts[0].tv_nsec:=UTIME_OMIT;
  end;
  if (aMask and P9_SETATTR_MTIME)<>0 then begin
   if (aMask and P9_SETATTR_MTIME_SET)<>0 then begin
    ts[1].tv_sec:=aMTimeSec;
    ts[1].tv_nsec:=aMTimeNSec;
   end else begin
    ts[1].tv_sec:=0;
    ts[1].tv_nsec:=UTIME_NOW;
   end;
  end else begin
   ts[1].tv_sec:=0;
   ts[1].tv_nsec:=UTIME_OMIT;
  end;
  if utimensat(AT_FDCWD,PAnsiChar(aFile.fPath),ts,AT_SYMLINK_NOFOLLOW)<0 then begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
   exit;
  end;
  ctime_updated:=true;
 end;

 if ((aMask and P9_SETATTR_CTIME)<>0) and not ctime_updated then begin
  if LChown(PAnsiChar(aFile.fPath),TUID(-1),TGID(-1))<0 then begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
   exit;
  end;
 end;

 result:=0;

end;

function TPasRISCV9PFileSystemPOSIX.Link(const aDestFile,aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32;
var Path:TPasRISCVRawByteString;
begin
 Path:=ComposePath(aDestFile.fPath,aName);
 if fpLink(PAnsiChar(aFile.fPath),PAnsiChar(Path))<0 then begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end else begin
  result:=0;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.SymLink(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName,aTarget:TPasRISCVRawByteString;const aGID:TPasRISCVUInt32):TPasRISCVInt32;
var Path:TPasRISCVRawByteString;
    StatData:TStat;
begin
 Path:=ComposePath(aFile.fPath,aName);
 if fpSymLink(PAnsiChar(aTarget),PAnsiChar(Path))<0 then begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end else begin
  if fpLStat(PAnsiChar(Path),@StatData)=0 then begin
   StatToQID(aQID,@StatData);
   result:=0;
  end else begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
  end;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.MkNod(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aMajor,aMinor,aGID:TPasRISCVUInt32):TPasRISCVInt32;
var Path:TPasRISCVRawByteString;
    StatData:TStat;
begin
 Path:=ComposePath(aFile.fPath,aName);
 if MkNod_(PAnsiChar(Path),aMode,((aMajor and $fff) shl 8) or (aMinor and $ff))<0 then begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end else begin
  if fpLStat(PAnsiChar(Path),@StatData)=0 then begin
   StatToQID(aQID,@StatData);
   result:=0;
  end else begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
  end;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.ReadLink(const aBuffer:Pointer;const aSize:TPasRISCVInt64;const aFile:TPasRISCV9PFileSystem.TFSFile):TPasRISCVInt64;
begin
 result:=fpReadLink(PAnsiChar(aFile.fPath),aBuffer,aSize-1);
 if result<0 then begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end else begin
  PPasRISCVUInt8Array(aBuffer)^[result]:=0;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.RenameAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aNewFile:TPasRISCV9PFileSystem.TFSFile;const aNewName:TPasRISCVRawByteString):TPasRISCVInt32;
var Path,NewPath:TPasRISCVRawByteString;
begin
 Path:=ComposePath(aFile.fPath,aName);
 NewPath:=ComposePath(aNewFile.fPath,aNewName);
 if fpRename(PAnsiChar(Path),PAnsiChar(NewPath))<0 then begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end else begin
  result:=0;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.UnlinkAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32;
var Path:TPasRISCVRawByteString;
begin
 Path:=ComposePath(aFile.fPath,aName);
 if Remove_(PAnsiChar(Path))<0 then begin
  result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
 end else begin
  result:=0;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.Lock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32;
var fl:FLock;
    errno:cint;
begin
 if (not aFile.fIsOpened) or (aFile.fIsDirectory) then begin
  result:=-P9_EPROTO;
 end else begin
  fl.l_type:=aLock^.Type_;
  fl.l_whence:=SEEK_SET;
  fl.l_start:=aLock^.Start;
  fl.l_len:=aLock^.Length;
  if fpFcntl(aFile.fFile,F_SETLK,fl)=0 then begin
   result:=P9_LOCK_SUCCESS;
  end else begin
   errno:=fpGetErrNo;
   if (errno=ESysEAGAIN) or (errno=ESysEACCES) then begin
    result:=P9_LOCK_BLOCKED;
   end else begin
    result:=-POSIXErrorCodeToP9ErrorCode(errno);
   end;
  end;
 end;
end;

function TPasRISCV9PFileSystemPOSIX.GetLock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32;
var fl:Flock;
begin
 if (not aFile.fIsOpened) or (aFile.fIsDirectory) then begin
  result:=-P9_EPROTO;
 end else begin
  fl.l_type:=aLock^.Type_;
  fl.l_whence:=SEEK_SET;
  fl.l_start:=aLock^.Start;
  fl.l_len:=aLock^.Length;
  if fpFcntl(aFile.fFile,F_GETLK,fl)=0 then begin
   aLock^.Type_:=fl.l_type;
   aLock^.Start:=fl.l_start;
   aLock^.Length:=fl.l_len;
   result:=0;
  end else begin
   result:=-POSIXErrorCodeToP9ErrorCode(fpGetErrNo);
  end;
 end;
end;

{$elseif defined(Windows)}

{ TPasRISCV9PFileSystemWindows }

constructor TPasRISCV9PFileSystemWindows.Create(const aRootPath:TPasRISCVRawByteString);
begin
 inherited Create;
 fRootPath:=aRootPath;
end;

destructor TPasRISCV9PFileSystemWindows.Destroy;
begin
 fRootPath:='';
 inherited Destroy;
end;

function TPasRISCV9PFileSystemWindows.FileTimeToUnixTime(const aFileTime:TFileTime):TPasRISCVUInt64;
var SystemTime:TSystemTime;
    DateTime:TDateTime;
begin
 // Convert FILETIME to SYSTEMTIME
 if FileTimeToSystemTime(aFileTime,SystemTime) then begin
  DateTime:=SystemTimeToDateTime(SystemTime);
  result:=DateTimeToUnix(DateTime);
 end else begin
  result:=0;
 end;
end;

function TPasRISCV9PFileSystemWindows.UnixTimeToFileTime(const aUnixTime:TPasRISCVUInt64):TFileTime;
var DateTime:TDateTime;
    SystemTime:TSystemTime;
begin
 DateTime:=UnixToDateTime(aUnixTime);
 DateTimeToSystemTime(DateTime,SystemTime);
 SystemTimeToFileTime(SystemTime,result);
end;

function TPasRISCV9PFileSystemWindows.Win32FileAttributesToP9Mode(const aFileAttributes:DWORD):TPasRISCVUInt32;
begin
 result:=P9_S_IRWXUGO; // Default permissions for Windows files since they are not POSIX compliant, so just use RWX for all for now
 if (aFileAttributes and FILE_ATTRIBUTE_DIRECTORY)<>0 then begin
  result:=result or P9_S_IFDIR;
 end else begin
  result:=result or P9_S_IFREG;
 end;
 if (aFileAttributes and FILE_ATTRIBUTE_REPARSE_POINT)<>0 then begin
  result:=result or P9_S_IFLNK;
 end;
 if (aFileAttributes and FILE_ATTRIBUTE_READONLY)<>0 then begin
  result:=result and not P9_S_IWOGU; // Remove write permissions for owner, group, and others, as the file is read-only
 end;
{if (aFileAttributes and FILE_ATTRIBUTE_HIDDEN)<>0 then begin
  result:=result and not P9_S_IROGU; // Remove read permissions for owner, group, and others, as the file is hidden
 end;
 if (aFileAttributes and FILE_ATTRIBUTE_SYSTEM)<>0 then begin
  result:=result and not P9_S_IXOGU; // Remove execute permissions for owner, group, and others, as the file is a system file
 end;}
end;

function TPasRISCV9PFileSystemWindows.Win32ErrorCodeToP9ErrorCode(const aErrorCode:DWORD):TPasRISCVInt32;
begin
 case aErrorCode of
  ERROR_SUCCESS:begin
   result:=0;
  end;
  ERROR_ACCESS_DENIED:begin
   result:=-P9_EPERM;
  end;
  ERROR_FILE_NOT_FOUND:begin
   result:=-P9_ENOENT;
  end;
  ERROR_IO_DEVICE,
  ERROR_IO_PENDING,
  ERROR_GEN_FAILURE:begin
   result:=-P9_EIO;
  end;
  ERROR_ALREADY_EXISTS:begin
   result:=-P9_EEXIST;
  end;
  ERROR_PATH_NOT_FOUND,
  ERROR_DIRECTORY:begin
   result:=-P9_ENOTDIR;
  end;
  ERROR_INVALID_PARAMETER,
  ERROR_INVALID_HANDLE:begin
   result:=-P9_EINVAL;
  end;
  ERROR_DISK_FULL:begin
   result:=-P9_ENOSPC;
  end;
  ERROR_DIR_NOT_EMPTY:begin
   result:=-P9_ENOTEMPTY;
  end;
  ERROR_PROTOCOL_UNREACHABLE:begin
   result:=-P9_EPROTO;
  end;
  ERROR_NOT_SUPPORTED:begin
   result:=-P9_ENOTSUP;
  end;
  else begin
   result:=-P9_EINVAL;
  end;
 end;
end;

function TPasRISCV9PFileSystemWindows.P9OpenFlagsToWin32OpenFlags(const aFlags:TPasRISCVUInt32):DWORD;
const FILE_FLAG_OPEN_REPARSE_POINT=$200000;
var Access:DWORD;
    CreationDisposition:DWORD;
    FlagsAndAttributes:DWORD;
begin

 // Initialize Access based on P9_O_NOACCESS (acting as O_ACCMODE mask)
 case aFlags and P9_O_NOACCESS of
  P9_O_RDONLY:begin
   Access:=GENERIC_READ;
  end;
  P9_O_WRONLY:begin
   Access:=GENERIC_WRITE;
  end;
  P9_O_RDWR:begin
   Access:=GENERIC_READ or GENERIC_WRITE;
  end;
  else begin
   Access:=0; // Default or undefined access
  end;
 end;

 // Determine CreationDisposition
 if (aFlags and P9_O_CREAT)<>0 then begin
  if (aFlags and P9_O_EXCL)<>0 then begin
   CreationDisposition:=CREATE_NEW;
  end else begin
   CreationDisposition:=CREATE_ALWAYS;
  end;
 end else begin
  CreationDisposition:=OPEN_EXISTING;
 end;

 // Initialize FlagsAndAttributes with default
 FlagsAndAttributes:=FILE_ATTRIBUTE_NORMAL;

 // Map additional flags
 if (aFlags and P9_O_TRUNC)<>0 then begin
  FlagsAndAttributes:=FlagsAndAttributes or TRUNCATE_EXISTING;
 end;
 if (aFlags and P9_O_APPEND)<>0 then begin
  FlagsAndAttributes:=FlagsAndAttributes or FILE_APPEND_DATA;
 end;
 if (aFlags and P9_O_NONBLOCK)<>0 then begin
  FlagsAndAttributes:=FlagsAndAttributes or FILE_FLAG_OVERLAPPED;
 end;
 if (aFlags and P9_O_DSYNC)<>0 then begin
  FlagsAndAttributes:=FlagsAndAttributes or FILE_FLAG_WRITE_THROUGH;
 end;
 if (aFlags and P9_O_SYNC)<>0 then begin
  FlagsAndAttributes:=FlagsAndAttributes or FILE_FLAG_WRITE_THROUGH;
 end;
 if (aFlags and P9_O_DIRECT)<>0 then begin
  FlagsAndAttributes:=FlagsAndAttributes or FILE_FLAG_NO_BUFFERING;
 end;
 if (aFlags and P9_O_DIRECTORY)<>0 then begin
  FlagsAndAttributes:=FlagsAndAttributes or FILE_FLAG_BACKUP_SEMANTICS;
 end;
 if (aFlags and P9_O_NOFOLLOW)<>0 then begin
  FlagsAndAttributes:=FlagsAndAttributes or FILE_FLAG_OPEN_REPARSE_POINT;
 end;

 // Combine Access, CreationDisposition, and FlagsAndAttributes
 result:=Access or CreationDisposition or FlagsAndAttributes;

 // Note: The following flags are ignored as they have no direct Win32 equivalents:
 // P9_O_NOCTTY, P9_O_FASYNC, P9_O_LARGEFILE, P9_O_NOATIME, P9_O_CLOEXEC

end;

procedure TPasRISCV9PFileSystemWindows.StatToQID(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFileInfo:BY_HANDLE_FILE_INFORMATION);
begin
 aQID^.Type_:=0;
 if (aFileInfo.dwFileAttributes and FILE_ATTRIBUTE_DIRECTORY)<>0 then begin
  aQID^.Type_:=aQID^.Type_ or P9_QTDIR;
 end;
 if (aFileInfo.dwFileAttributes and FILE_ATTRIBUTE_REPARSE_POINT)<>0 then begin
  aQID^.Type_:=aQID^.Type_ or P9_QTSYMLINK;
 end;
 if (aFileInfo.dwFileAttributes and FILE_ATTRIBUTE_TEMPORARY)<>0 then begin
  aQID^.Type_:=aQID^.Type_ or P9_QTTMP;
 end;
 aQID^.Version:=0; // No caching on client
 aQID^.Path:=(TPasRISCVUInt64(aFileInfo.nFileIndexHigh) shl 32) or aFileInfo.nFileIndexLow;
end;

function TPasRISCV9PFileSystemWindows.ComposePath(const aPath,aName:TPasRISCVRawByteString):TPasRISCVRawByteString;
const DirectorySeparator='\';
begin
 result:=aPath;
 if (length(result)>0) and (result[length(result)]<>DirectorySeparator) then begin
  result:=result+DirectorySeparator;
 end;
 result:=result+aName;
end;

function TPasRISCV9PFileSystemWindows.CreateFileObject(const aPath:TPasRISCVRawByteString;const aUID:TPasRISCVUInt32):TPasRISCV9PFileSystem.TFSFile;
begin
 result:=TFSFile.Create;
 result.fPath:=aPath;
 result.fUID:=aUID;
 result.fIsOpened:=false;
 result.fIsDirectory:=false;
 result.fStream:=nil; // unused
 result.fFileHandle:=INVALID_HANDLE_VALUE;
 result.fDirectoryHandle:=INVALID_HANDLE_VALUE;
 result.fIsOverlapped:=false;
end;

procedure TPasRISCV9PFileSystemWindows.Delete(const aFile:TPasRISCV9PFileSystem.TFSFile);
begin

 if assigned(aFile) then begin

  if aFile.fIsOpened then begin
   Close(aFile);
  end;

  aFile.fIsOpened:=false;
  aFile.fIsDirectory:=false;
  aFile.fPath:='';

  if aFile.fFileHandle<>INVALID_HANDLE_VALUE then begin
   CloseHandle(aFile.fFileHandle);
   aFile.fFileHandle:=INVALID_HANDLE_VALUE;
  end;

  if aFile.fDirectoryHandle<>INVALID_HANDLE_VALUE then begin
   CloseHandle(aFile.fDirectoryHandle);
   aFile.fDirectoryHandle:=INVALID_HANDLE_VALUE;
  end;

  aFile.Free;

 end;

end;

procedure TPasRISCV9PFileSystemWindows.StatFS(out aStatFS:TPasRISCV9PFileSystem.TFSStatFS);
var FreeBytesAvailable,TotalNumberOfBytes,TotalNumberOfFreeBytes:ULONGLONG;
begin
 if GetDiskFreeSpaceExA(PAnsiChar(RawByteString(fRootPath)),@FreeBytesAvailable,@TotalNumberOfBytes,@TotalNumberOfFreeBytes) then begin
  aStatFS.BSize:=4096; // Typically, Windows uses 4096 bytes as block size
  aStatFS.Blocks:=(TotalNumberOfBytes+(aStatFS.BSize-1)) div aStatFS.BSize;
  aStatFS.BFree:=(TotalNumberOfFreeBytes+(aStatFS.BSize-1)) div aStatFS.BSize;
  aStatFS.BAvail:=(FreeBytesAvailable+(aStatFS.BSize-1)) div aStatFS.BSize;
  aStatFS.Files:=$2000000; // Windows does not provide a direct count
  aStatFS.FFree:=$1000000; // Windows does not provide a direct count
 end else begin
  FillChar(aStatFS,SizeOf(TFSStatFS),#0);
 end;
end;

function TPasRISCV9PFileSystemWindows.Attach(out aFile:TPasRISCV9PFileSystem.TFSFile;const aQID:TPasRISCV9PFileSystem.PFSQID;const aUID:TPasRISCVUInt32;const aUName,aAName:TPasRISCVRawByteString):TPasRISCVInt32;
var Handle:THandle;
    FileInfo:BY_HANDLE_FILE_INFORMATION;
begin

 Handle:=CreateFileA(PAnsiChar(RawByteString(fRootPath)),
                     GENERIC_READ,
                     FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE,
                     nil,
                     OPEN_EXISTING,
                     FILE_FLAG_BACKUP_SEMANTICS,
                     0);

 if Handle=INVALID_HANDLE_VALUE then begin

  aFile:=nil;
  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);

 end else begin

  try
   if GetFileInformationByHandle(Handle,FileInfo) then begin
    aFile:=CreateFileObject(fRootPath,aUID);
    StatToQID(aQID,FileInfo);
    result:=0;
   end else begin
    aFile:=nil;
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
   end;
  finally
   CloseHandle(Handle);
  end;

 end;

end;

function TPasRISCV9PFileSystemWindows.Walk(out aFiles:TPasRISCV9PFileSystem.TFSFile;const aQIDs:TPasRISCV9PFileSystem.PFSQIDArray;const aFile:TPasRISCV9PFileSystem.TFSFile;const aCount:TPasRISCVSizeInt;const aNames:array of TPasRISCVRawByteString):TPasRISCVInt32;
var CurrentPath,NewPath:TPasRISCVRawByteString;
    FileInfo:BY_HANDLE_FILE_INFORMATION;
    Index:TPasRISCVSizeInt;
    Handle:THandle;
begin

 CurrentPath:=aFile.fPath;
 result:=0;

 for Index:=0 to aCount-1 do begin

  NewPath:=ComposePath(CurrentPath,aNames[Index]);

  Handle:=CreateFileA(PAnsiChar(RawByteString(NewPath)),
                      GENERIC_READ,
                      FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE,
                      nil,
                      OPEN_EXISTING,
                      FILE_FLAG_BACKUP_SEMANTICS,
                      0);

  if Handle=INVALID_HANDLE_VALUE then begin
   break;
  end;

  try
   if GetFileInformationByHandle(Handle,FileInfo) then begin
    StatToQID(@aQIDs[Index],FileInfo);
    inc(result);
    CurrentPath:=NewPath;
   end else begin
    break;
   end;
  finally
   CloseHandle(Handle);
  end;

 end;

 aFiles:=CreateFileObject(CurrentPath,aFile.fUID);

end;

function TPasRISCV9PFileSystemWindows.MkDir(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32;
var Path:TPasRISCVRawByteString;
    Success:BOOL;
    Handle:THandle;
    FileInfo:BY_HANDLE_FILE_INFORMATION;
begin

 Path:=ComposePath(aFile.fPath,aName);
 Success:=CreateDirectoryA(PAnsiChar(RawByteString(Path)),nil);

 if Success then begin

  Handle:=CreateFileA(PAnsiChar(RawByteString(Path)),
                      GENERIC_READ,
                      FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE,
                      nil,
                      OPEN_EXISTING,
                      FILE_FLAG_BACKUP_SEMANTICS,
                      0);

  if Handle<>INVALID_HANDLE_VALUE then begin

   try
    if GetFileInformationByHandle(Handle,FileInfo) then begin
     StatToQID(aQID,FileInfo);
     result:=0;
    end else begin
     result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
    end;
   finally
    CloseHandle(Handle);
   end;

  end else begin

   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);

  end;

 end else begin

  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);

 end;

end;

function TPasRISCV9PFileSystemWindows.Open(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aFlags:TPasRISCVUInt32;const aOnOpenCompletion:TPasRISCV9PFileSystem.TOnOpenCompletion;const aOpaque:Pointer):TPasRISCVInt32;
var DesiredAccess,ShareMode,CreationDisposition,FlagsAndAttributes:DWORD;
    Handle:THandle;
    FileInfo:BY_HANDLE_FILE_INFORMATION;
begin

 // Map 9P open flags to Win32 flags
 DesiredAccess:=P9OpenFlagsToWin32OpenFlags(aFlags);

 // Define share mode to allow other processes to read/write/delete
 ShareMode:=FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE;

 // Determine creation disposition based on flags
{if (aFlags and P9_O_CREAT)<>0 then begin
  if (aFlags and P9_O_EXCL)<>0 then begin
   CreationDisposition:=CREATE_NEW;
  end else begin
   CreationDisposition:=CREATE_ALWAYS;
  end;
 end else begin}
  CreationDisposition:=OPEN_EXISTING;
{end;//}

 // Define additional flags and attributes based on the mapping
 FlagsAndAttributes:=0; // Already included in P9OpenFlagsToWin32OpenFlags

 // Open the file or directory
 Handle:=CreateFileA(PAnsiChar(RawByteString(aFile.fPath)),
                     DesiredAccess,
                     ShareMode,
                     nil,
                     CreationDisposition,
                     FlagsAndAttributes or FILE_FLAG_BACKUP_SEMANTICS,
                     0);

 // Check if the handle is valid
 if Handle<>INVALID_HANDLE_VALUE then begin

  try

   // Retrieve file information to populate QID
   if GetFileInformationByHandle(Handle,FileInfo) then begin

    StatToQID(aQID,FileInfo);
    aFile.fIsOpened:=true;
    aFile.fIsDirectory:=(FileInfo.dwFileAttributes and FILE_ATTRIBUTE_DIRECTORY)<>0;
    aFile.fFileHandle:=INVALID_HANDLE_VALUE;
    aFile.fDirectoryHandle:=INVALID_HANDLE_VALUE;

    aFile.fIsOverlapped:=(FlagsAndAttributes and FILE_FLAG_OVERLAPPED)<>0;

    // Assign the appropriate handle
    if aFile.fIsDirectory then begin
     aFile.fDirectoryHandle:=Handle;
    end else begin
     aFile.fFileHandle:=Handle;
    end;

    result:=0;

   end else begin

    // If file information retrieval failed, close the handle and return an error

    // Close the handle
    CloseHandle(Handle);

    // Return error code
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);

   end;

  except
   // If an exception occurred, close the handle and re-raise the exception
   CloseHandle(Handle);
   raise;
  end;

 end else begin

  // If the handle is invalid, return an error code
  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);

 end;

end;

function TPasRISCV9PFileSystemWindows.Create_(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aFlags:TPasRISCVUInt32;const aMode,aGID:TPasRISCVUInt32):TPasRISCVInt32;
var Path:TPasRISCVRawByteString;
    DesiredAccess,ShareMode,CreationDisposition,FlagsAndAttributes:DWORD;
    Handle:THandle;
    FileInfo:BY_HANDLE_FILE_INFORMATION;
begin

 // Compose the full path for the new file
 Path:=ComposePath(aFile.fPath,aName);

 // Map 9P open flags to Win32 flags
 DesiredAccess:=P9OpenFlagsToWin32OpenFlags(aFlags);

{// Share mode set to exclusive access (no sharing)
 ShareMode:=0;}

 // Define share mode to allow other processes to read/write/delete
 ShareMode:=FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE;

 // Determine creation disposition based on flags
{if (aFlags and P9_O_CREAT)<>0 then begin}
  if (aFlags and P9_O_EXCL)<>0 then begin
   CreationDisposition:=CREATE_NEW;
  end else begin
   CreationDisposition:=CREATE_ALWAYS;
  end;
{end else begin
  CreationDisposition:=OPEN_EXISTING;
 end;}

 // Flags and Attributes are already included in P9OpenFlagsToWin32OpenFlags
 FlagsAndAttributes:=0;

 // Create or open the file
 Handle:=CreateFileA(PAnsiChar(RawByteString(Path)),
                     DesiredAccess,
                     ShareMode,
                     nil,
                     CreationDisposition,
                     FlagsAndAttributes,
                     0);

 if Handle<>INVALID_HANDLE_VALUE then begin

  try
   // Retrieve file information to populate QID
   if GetFileInformationByHandle(Handle,FileInfo) then begin

    StatToQID(aQID,FileInfo);
    aFile.fIsOpened:=true;
    aFile.fIsDirectory:=(FileInfo.dwFileAttributes and FILE_ATTRIBUTE_DIRECTORY)<>0;
    aFile.fFileHandle:=INVALID_HANDLE_VALUE;
    aFile.fDirectoryHandle:=INVALID_HANDLE_VALUE;

    aFile.fIsOverlapped:=(FlagsAndAttributes and FILE_FLAG_OVERLAPPED)<>0;

    // Assign the appropriate handle
    if aFile.fIsDirectory then begin
     aFile.fDirectoryHandle:=Handle;
    end else begin
     aFile.fFileHandle:=Handle;
    end;

    result:=0;

   end else begin

    // If file information retrieval failed, close the handle and return an error

    // Close the handle
    CloseHandle(Handle);

    // Return error code
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);

   end;

  except
   // If an exception occurred, close the handle and re-raise the exception
   CloseHandle(Handle);
   raise;
  end;

 end else begin

  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);

 end;

end;

function TPasRISCV9PFileSystemWindows.ReadDir(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
var FindHandle:THandle;
    FindData:WIN32_FIND_DATAA;
    Path:TPasRISCVRawByteString;
    EntryOffset,RequiredSize:TPasRISCVSizeInt;
    BytesWritten:TPasRISCVSizeInt;
    NameLen:TPasRISCVUInt16;
    EntryType:TPasRISCVUInt8;
    PathU64:TPasRISCVUInt64;
    FileInfo:BY_HANDLE_FILE_INFORMATION;
    FileName:TPasRISCVUTF8String;
    Handle:THandle;
begin

 // Check if the file is a directory
 if not aFile.fIsDirectory then begin
  result:=-P9_EPROTO;
  exit;
 end;

 // Compose the search path with wildcard
 Path:=ComposePath(aFile.fPath,'*');

 // Initiate the directory search
 FindHandle:=Windows.FindFirstFileA(PAnsiChar(RawByteString(Path)),FindData);
 if FindHandle=INVALID_HANDLE_VALUE then begin
  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
  exit;
 end;

 try

  BytesWritten:=0;

  EntryOffset:=0;

  result:=0;

  PathU64:=0;

  repeat

   // Skip '.' and '..'
{  if (RawByteString(FindData.cFileName)='.') or (RawByteString(FindData.cFileName)='..') then begin
    continue;
   end;}

   // Skip entries before offset
   if EntryOffset<aOffset then begin
    inc(EntryOffset);
    continue;
   end;

   inc(EntryOffset);

   // Calculate required space: Type (1) + Version (4) + Path (8) + Name length (2) + Name
   NameLen:=Length(PAnsiChar(Pointer(@FindData.cFileName)));
   RequiredSize:=13+8+1+2+NameLen;
   if (BytesWritten+RequiredSize)>aSize then begin
    break;
   end;

   // Determine Type
   EntryType:=0;

   if (FindData.dwFileAttributes and FILE_ATTRIBUTE_DIRECTORY)<>0 then begin
    EntryType:=EntryType or P9_QTDIR;
   end;

   if (FindData.dwFileAttributes and FILE_ATTRIBUTE_REPARSE_POINT)<>0 then begin
    EntryType:=EntryType or P9_QTSYMLINK;
   end;

   if (FindData.dwFileAttributes and FILE_ATTRIBUTE_TEMPORARY)<>0 then begin
    EntryType:=EntryType or P9_QTTMP;
   end;

   FileName:=ComposePath(aFile.fPath,RawByteString(FindData.cFileName));
   Handle:=CreateFileA(PAnsiChar(RawByteString(FileName)),
                       GENERIC_READ,
                       FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE,
                       nil,
                       OPEN_EXISTING,
                       FILE_FLAG_BACKUP_SEMANTICS,
                       0);

   if Handle=INVALID_HANDLE_VALUE then begin

    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);

   end else begin

    try
     if GetFileInformationByHandle(Handle,FileInfo) then begin
      PathU64:=(TPasRISCVUInt64(FileInfo.nFileIndexHigh) shl 32) or FileInfo.nFileIndexLow;
     end else begin
      result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
     end;
    finally
     CloseHandle(Handle);
    end;

   end;

   PPasRISCVUInt8Array(aBuffer)^[BytesWritten]:=EntryType; inc(BytesWritten);
   PPasRISCVUInt32(@PPasRISCVUInt8Array(aBuffer)^[BytesWritten])^:=0; inc(BytesWritten,SizeOf(TPasRISCVUInt32));
   PPasRISCVUInt64(@PPasRISCVUInt8Array(aBuffer)^[BytesWritten])^:=PathU64; inc(BytesWritten,SizeOf(TPasRISCVUInt64));
   PPasRISCVUInt64(@PPasRISCVUInt8Array(aBuffer)^[BytesWritten])^:=EntryOffset; inc(BytesWritten,SizeOf(TPasRISCVUInt64));
   PPasRISCVUInt8Array(aBuffer)^[BytesWritten]:=EntryType; inc(BytesWritten);
   PPasRISCVUInt16(@PPasRISCVUInt8Array(aBuffer)^[BytesWritten])^:=NameLen; inc(BytesWritten,SizeOf(TPasRISCVUInt16));
   FileName:=UTF8String(FindData.cFileName);
   Move(FileName[1],PPasRISCVUInt8Array(aBuffer)^[BytesWritten],NameLen); inc(BytesWritten,NameLen);

  until (result=0) and not Windows.FindNextFileA(FindHandle,FindData);

  if result=0 then begin
   result:=BytesWritten;
  end;

 finally
  Windows.FindClose(FindHandle);
 end;

end;

{$if not declared(SetFilePointerEx)}
function SetFilePointerEx(hFile:HANDLE;liDistanceToMove:TPasMPUInt64;lpNewFilePointer:PPasMPUInt64;dwMoveMethod:DWORD):BOOL; {$ifdef cpu386}stdcall;{$endif} external 'kernel32.dll' name 'SetFilePointerEx';
{$ifend}

function TPasRISCV9PFileSystemWindows.Read(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
var BytesRead:DWORD;
    Overlapped:TOverlapped;
    Success:BOOL;
//  FilePointer:LARGE_INTEGER;
begin

 // Validate that the file is opened and not a directory
 if (not aFile.fIsOpened) or aFile.fIsDirectory then begin
  result:=-P9_EPROTO;
  exit;
 end;

 if aFile.fIsOverlapped then begin

  // Initialize the OVERLAPPED structure for asynchronous I/O
  ZeroMemory(@Overlapped,SizeOf(TOverlapped));
  Overlapped.Offset:=DWORD(aOffset and $ffffffff);
  Overlapped.OffsetHigh:=DWORD((aOffset shr 32) and $ffffffff);

  // Perform asynchronous write
  Success:=ReadFile(aFile.fFileHandle,aBuffer^,DWORD(aSize),BytesRead,@Overlapped);

  if Success then begin

   // If the operation completed synchronously, return the number of bytes read
   result:=BytesRead;

  end else begin

   // Check if the operation is pending
   if GetLastError=ERROR_IO_PENDING then begin

    // Wait for the operation to complete
    if GetOverlappedResult(aFile.fFileHandle,Overlapped,BytesRead,true) then begin
     result:=BytesRead;
    end else begin
     result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
    end;

   end else begin

    // If the operation failed, return the error code
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
   end;

  end;

 end else begin

  // Perform synchronous write without OVERLAPPED

  // Set the file pointer to aOffset
//FilePointer.QuadPart:=aOffset;
  if SetFilePointerEx(aFile.fFileHandle,aOffset,nil,FILE_BEGIN) then begin

   // Perform synchronous read
   if ReadFile(aFile.fFileHandle,aBuffer^,DWORD(aSize),BytesRead,nil) then begin
    result:=BytesRead;
   end else begin
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
   end;

  end else begin
   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
  end;

 end;

end;

function TPasRISCV9PFileSystemWindows.Write(const aFile:TPasRISCV9PFileSystem.TFSFile;const aOffset:TPasRISCVUInt64;const aBuffer:Pointer;const aSize:TPasRISCVInt64):TPasRISCVInt64;
var BytesWritten:DWORD;
    Overlapped:TOverlapped;
    Success:BOOL;
//  FilePointer:LARGE_INTEGER;
begin

 // Validate that the file is opened and not a directory
 if (not aFile.fIsOpened) or aFile.fIsDirectory then begin
  result:=-P9_EPROTO;
  exit;
 end;

 if aFile.fIsOverlapped then begin

  // Initialize the OVERLAPPED structure for asynchronous I/O
  ZeroMemory(@Overlapped,SizeOf(TOverlapped));
  Overlapped.Offset:=DWORD(aOffset and $ffffffff);
  Overlapped.OffsetHigh:=DWORD((aOffset shr 32) and $ffffffff);

  // Perform asynchronous write
  Success:=WriteFile(aFile.fFileHandle,aBuffer^,DWORD(aSize),BytesWritten,@Overlapped);

  if Success then begin

   // If the operation completed synchronously, return the number of bytes written
   result:=BytesWritten;

  end else begin

   // Check if the operation is pending
   if GetLastError=ERROR_IO_PENDING then begin

    // Wait for the operation to complete
    if GetOverlappedResult(aFile.fFileHandle,Overlapped,BytesWritten,true) then begin
     result:=BytesWritten;
    end else begin
     result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
    end;

   end else begin

    // If the operation failed, return the error code
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
   end;

  end;

 end else begin

  // Perform synchronous write without OVERLAPPED

  // Set the file pointer to aOffset
//FilePointer.QuadPart:=aOffset;
  if SetFilePointerEx(aFile.fFileHandle,aOffset,nil,FILE_BEGIN) then begin

   // Perform synchronous write
   if WriteFile(aFile.fFileHandle,aBuffer^,DWORD(aSize),BytesWritten,nil) then begin
    result:=BytesWritten;
   end else begin
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
   end;

  end else begin
   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
  end;

 end;

end;

procedure TPasRISCV9PFileSystemWindows.Close(const aFile:TPasRISCV9PFileSystem.TFSFile);
begin
 if aFile.fIsOpened then begin
  if not aFile.fIsDirectory and (aFile.fFileHandle<>INVALID_HANDLE_VALUE) then begin
   CloseHandle(aFile.fFileHandle);
   aFile.fFileHandle:=INVALID_HANDLE_VALUE;
  end else if aFile.fIsDirectory and (aFile.fDirectoryHandle<>INVALID_HANDLE_VALUE) then begin
   CloseHandle(aFile.fDirectoryHandle);
   aFile.fDirectoryHandle:=INVALID_HANDLE_VALUE;
  end;
  aFile.fIsOpened:=false;
  aFile.fIsDirectory:=false;
 end;
end;

function TPasRISCV9PFileSystemWindows.Stat(const aFile:TPasRISCV9PFileSystem.TFSFile;out aStat:TPasRISCV9PFileSystem.TFSStat):TPasRISCVInt32;
var Handle:THandle;
    FileInfo:BY_HANDLE_FILE_INFORMATION;
    Success:BOOL;
    TargetName:String;
begin

 Handle:=CreateFileA(PAnsiChar(RawByteString(aFile.fPath)),
                     GENERIC_READ,
                     FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE,
                     nil,
                     OPEN_EXISTING,
                     FILE_FLAG_BACKUP_SEMANTICS,
                     0);

 if Handle=INVALID_HANDLE_VALUE then begin
  result:=-P9_ENOENT;
  exit;
 end;

 try
  Success:=GetFileInformationByHandle(Handle,FileInfo);
  if Success then begin
   StatToQID(@aStat.qid,FileInfo);
   aStat.Mode:=Win32FileAttributesToP9Mode(FileInfo.dwFileAttributes);
{  if FileGetSymLinkTarget(aFile.fPath,TargetName) then begin
    aStat.Mode:=aStat.Mode or P9_S_IFLNK;
   end;}
   aStat.UID:=0; // Windows does not use UID/GID in the same way
   aStat.GID:=0;
   aStat.NLink:=FileInfo.nNumberOfLinks;
   aStat.RDev:=0; // Not applicable
   aStat.Size:=(TPasRISCVUInt64(FileInfo.nFileSizeHigh) shl 32) or FileInfo.nFileSizeLow;
   aStat.BlkSize:=4096; // Default block size
   aStat.Blocks:=(aStat.Size+(aStat.BlkSize-1)) div aStat.BlkSize;
   aStat.ATimeSec:=FileTimeToUnixTime(FileInfo.ftLastAccessTime);
   aStat.ATimeNSec:=0;
   aStat.MTimeSec:=FileTimeToUnixTime(FileInfo.ftLastWriteTime);
   aStat.MTimeNSec:=0;
   aStat.CTimeSec:=FileTimeToUnixTime(FileInfo.ftCreationTime);
   aStat.CTimeNSec:=0;
   result:=0;
  end else begin
   result:=-P9_ENOENT;
  end;
 finally
  CloseHandle(Handle);
 end;

end;

function TPasRISCV9PFileSystemWindows.SetAttr(const aFile:TPasRISCV9PFileSystem.TFSFile;const aMask,aMode,aUID,aGID:TPasRISCVUInt32;const aSize,aATimeSec,aATimeNSec,aMTimeSec,aMTimeNSec,aCTimeSec,aCTimeNSec:TPasRISCVUInt64):TPasRISCVInt32;
var Attributes:DWORD;
    Success:BOOL;
    Handle:THandle;
    NewFileTime:FILETIME;
    SystemTime:TSystemTime;
//  NewSize:LARGE_INTEGER;
    ftCreation,ftLastAccess,ftLastWrite:FILETIME;
begin

 // Handle mode changes
 if (aMask and P9_SETATTR_MODE)<>0 then begin
  Attributes:=0;
  if ((aMode and P9_QTDIR)<>0) and ((aMode and P9_QTFILE)=0) then begin
   Attributes:=FILE_ATTRIBUTE_DIRECTORY;
  end else begin
   Attributes:=FILE_ATTRIBUTE_NORMAL; // Default
  end;
  if (aMode and P9_QTSYMLINK)<>0 then begin
   Attributes:=Attributes or FILE_ATTRIBUTE_REPARSE_POINT;
  end;
  Success:=SetFileAttributesA(PAnsiChar(RawByteString(aFile.fPath)),Attributes);
  if not Success then begin
   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
   exit;
  end;
 end;

 // Handle size changes
 if (aMask and P9_SETATTR_SIZE)<>0 then begin
  Handle:=CreateFileA(PAnsiChar(RawByteString(aFile.fPath)),
                      GENERIC_WRITE,
                      0,
                      nil,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      0);
  if Handle=INVALID_HANDLE_VALUE then begin
   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
   exit;
  end;
  try
// NewSize.QuadPart:=aSize;
   if not SetFilePointerEx(Handle,aSize,nil,FILE_BEGIN) then begin
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
    exit;
   end;
   Success:=SetEndOfFile(Handle);
   if not Success then begin
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
    exit;
   end;
  finally
   CloseHandle(Handle);
  end;
 end;

 // Handle timestamps
 if (aMask and (P9_SETATTR_ATIME or P9_SETATTR_MTIME))<>0 then begin
  Handle:=CreateFileA(PAnsiChar(RawByteString(aFile.fPath)),
                      GENERIC_WRITE,
                      0,
                      nil,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      0);
  if Handle=INVALID_HANDLE_VALUE then begin
   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
   exit;
  end;
  try

   // Retrieve existing creation time
   Success:=GetFileTime(Handle,@ftCreation,@ftLastAccess,@ftLastWrite);
   if not Success then begin
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
    exit;
   end;

   // Update access time if needed
   if (aMask and P9_SETATTR_ATIME)<>0 then begin
    ftLastAccess:=UnixTimeToFileTime(aATimeSec);
   end;

   // Update modification time if needed
   if (aMask and P9_SETATTR_MTIME)<>0 then begin
    ftLastWrite:=UnixTimeToFileTime(aMTimeSec);
   end;

   // Update creation time if needed
   if (aMask and P9_SETATTR_CTIME)<>0 then begin
    ftCreation:=UnixTimeToFileTime(aCTimeSec);
   end;

   // Set the new times
   Success:=SetFileTime(Handle,@ftCreation,@ftLastAccess,@ftLastWrite);
   if not Success then begin
    result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
    exit;
   end;

  finally
   CloseHandle(Handle);
  end;
 end;

 // Note: UID and GID are not directly applicable in Windows; typically, you would handle security descriptors instead.

 result:=0;

end;

{$if not declared(CreateHardLinkA)}
function CreateHardLinkA(lpFileName,lpExistingFileName:LPCSTR;lpSecurityAttributes:LPSECURITY_ATTRIBUTES):BOOL; {$ifdef cpu386}stdcall;{$endif} external 'kernel32.dll' name 'CreateHardLinkA';
{$ifend}

function TPasRISCV9PFileSystemWindows.Link(const aDestFile,aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32;
var NewPath:RawByteString;
    Success:BOOL;
begin
 NewPath:=ComposePath(aDestFile.fPath,aName);
 Success:=CreateHardLinkA(PAnsiChar(NewPath),PAnsiChar(aFile.fPath),nil);
 if Success then begin
  result:=0;
 end else begin
  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
 end;
end;

{$if not declared(CreateSymbolicLinkA)}
function CreateSymbolicLinkA(lpSymlinkFileName,lpTargetFileName:LPCSTR;dwFlags:DWORD):BOOL; {$ifdef cpu386}stdcall;{$endif} external 'kernel32.dll' name 'CreateSymbolicLinkA';
{$ifend}

function TPasRISCV9PFileSystemWindows.Symlink(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName,aTarget:TPasRISCVRawByteString;const aGID:TPasRISCVUInt32):TPasRISCVInt32;
const SYMBOLIC_LINK_FLAG_DIRECTORY=$1;
var NewPath:TPasRISCVRawByteString;
    Success:BOOL;
    Handle:THandle;
    FileInfo:BY_HANDLE_FILE_INFORMATION;
    IsDirectory:BOOL;
    TargetHandle:THandle;
    TargetFileInfo:BY_HANDLE_FILE_INFORMATION;
begin

 NewPath:=ComposePath(aFile.fPath,aName);

 // Determine if the target is a directory to set appropriate flags
 IsDirectory:=false;
 TargetHandle:=CreateFileA(PAnsiChar(RawByteString(aTarget)),
                           0,
                           FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE,
                           nil,
                           OPEN_EXISTING,
                           FILE_FLAG_BACKUP_SEMANTICS,
                           0);

 if TargetHandle<>INVALID_HANDLE_VALUE then begin
  if GetFileInformationByHandle(TargetHandle,TargetFileInfo) then begin
   IsDirectory:=(TargetFileInfo.dwFileAttributes and FILE_ATTRIBUTE_DIRECTORY)<>0;
  end;
  CloseHandle(TargetHandle);
 end;

 Success:=CreateSymbolicLinkA(PAnsiChar(RawByteString(NewPath)),
                              PAnsiChar(RawByteString(aTarget)),
                              IfThen(IsDirectory,SYMBOLIC_LINK_FLAG_DIRECTORY,0));

 if not Success then begin
  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
  exit;
 end;

 // Retrieve file information to populate QID
 Handle:=CreateFileA(PAnsiChar(RawByteString(NewPath)),
                     GENERIC_READ,
                     FILE_SHARE_READ or FILE_SHARE_WRITE or FILE_SHARE_DELETE,
                     nil,
                     OPEN_EXISTING,
                     FILE_FLAG_BACKUP_SEMANTICS,
                     0);

 if Handle=INVALID_HANDLE_VALUE then begin
  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
  exit;
 end;

 try
  if GetFileInformationByHandle(Handle,FileInfo) then begin
   StatToQID(aQID,FileInfo);
   result:=0;
  end else begin
   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
  end;
 finally
  CloseHandle(Handle);
 end;

end;

function TPasRISCV9PFileSystemWindows.MkNod(const aQID:TPasRISCV9PFileSystem.PFSQID;const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aMode,aMajor,aMinor,aGID:TPasRISCVUInt32):TPasRISCVInt32;
begin
 // Windows does not support device nodes like POSIX. Return not supported. Simple as that.
 result:=-P9_ENOTSUP;
end;

function TPasRISCV9PFileSystemWindows.ReadLink(const aBuffer:Pointer;const aSize:TPasRISCVInt64;const aFile:TPasRISCV9PFileSystem.TFSFile):TPasRISCVInt64;
var TargetName:{$ifdef fpc}UnicodeString{$else}String{$endif};
    UTF8Target:TPasRISCVUTF8String;
begin
 if FileGetSymLinkTarget(aFile.fPath,TargetName) then begin
  UTF8Target:=TargetName;
  if length(UTF8Target)<aSize then begin
   if length(UTF8Target)>0 then begin
    Move(UTF8Target[1],aBuffer^,length(UTF8Target));
   end;
   PPasRISCVInt8Array(aBuffer)[length(UTF8Target)]:=0;
   result:=length(UTF8Target);
  end else begin
   result:=-P9_EINVAL;
  end;
 end else begin
  if FileExists(aFile.fPath) then begin
   result:=-P9_EIO;
  end else begin
   result:=-P9_EEXIST;
  end;
 end;
end;

function TPasRISCV9PFileSystemWindows.RenameAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString;const aNewFile:TPasRISCV9PFileSystem.TFSFile;const aNewName:TPasRISCVRawByteString):TPasRISCVInt32;
var OldPath,NewPath:TPasRISCVRawByteString;
    Success:BOOL;
begin
 OldPath:=ComposePath(aFile.fPath,aName);
 NewPath:=ComposePath(aNewFile.fPath,aNewName);
 Success:=MoveFileExA(PAnsiChar(RawByteString(OldPath)),PAnsiChar(RawByteString(NewPath)),MOVEFILE_REPLACE_EXISTING);
 if Success then begin
  result:=0;
 end else begin
  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
 end;
end;

function TPasRISCV9PFileSystemWindows.UnlinkAt(const aFile:TPasRISCV9PFileSystem.TFSFile;const aName:TPasRISCVRawByteString):TPasRISCVInt32;
var Path:TPasRISCVRawByteString;
    Success:BOOL;
begin
 Path:=ComposePath(aFile.fPath,aName);
 if (GetFileAttributesA(PAnsiChar(RawByteString(Path))) and FILE_ATTRIBUTE_DIRECTORY)<>0 then begin
  Success:=RemoveDirectoryA(PAnsiChar(RawByteString(Path)));
 end else begin
  Success:=DeleteFileA(PAnsiChar(RawByteString(Path)));
 end;
 if Success then begin
  result:=0;
 end else begin
  result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
 end;
end;

function TPasRISCV9PFileSystemWindows.Lock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32;
var LockType,LockMode:DWORD;
    Success:BOOL;
    Overlapped:TOverlapped;
    FilerPointer:LARGE_INTEGER;
begin

 result:=-P9_ENOTSUP;
 exit;

 // Validate that the file is opened and not a directory
 if not aFile.fIsOpened or aFile.fIsDirectory then begin
  result:=-P9_EPROTO;
  exit;
 end;

 // Initialize the OVERLAPPED structure for asynchronous I/O
 ZeroMemory(@Overlapped,SizeOf(TOverlapped));
 Overlapped.Offset:=DWORD(aLock.Start and $ffffffff);
 Overlapped.OffsetHigh:=DWORD((aLock.Start shr 32) and $ffffffff);

 if aLock.Type_=P9_LOCK_TYPE_UNLCK then begin

  // Perform unlock
  Success:=UnlockFileEx(aFile.fFileHandle,
                        0,
                        DWORD(aLock.Length and $ffffffff),
                        DWORD(aLock.Length shr 32),
                        Overlapped);
  if Success then begin
   result:=0;
  end else begin
   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
  end;

 end else begin

  // Determine lock type
  case aLock.Type_ of
   P9_LOCK_TYPE_RDLCK:begin
    LockType:=LOCKFILE_EXCLUSIVE_LOCK;
    LockMode:=LOCKFILE_FAIL_IMMEDIATELY;
   end;
   P9_LOCK_TYPE_WRLCK:begin
    LockType:=LOCKFILE_EXCLUSIVE_LOCK;
    LockMode:=0;
   end;
   else begin
    result:=-P9_EINVAL;
    exit;
   end;
  end;

  // Perform lock
  Success:=LockFileEx(aFile.fFileHandle,
                      LockType,
                      0,
                      DWORD(aLock.Length and $ffffffff),
                      DWORD(aLock.Length shr 32),
                      Overlapped);
  if Success then begin
   result:=0;
  end else begin
   result:=-Win32ErrorCodeToP9ErrorCode(GetLastError);
  end;

 end;

end;

function TPasRISCV9PFileSystemWindows.GetLock(const aFile:TPasRISCV9PFileSystem.TFSFile;const aLock:TPasRISCV9PFileSystem.PFSLock):TPasRISCVInt32;
var LockType,LockMode:DWORD;
    Success:BOOL;
    Overlapped:TOverlapped;
    FilerPointer:LARGE_INTEGER;
begin

 result:=-P9_ENOTSUP;
 exit;

end;

{$ifend}

{ TPasRISCVEthernetDevice }

constructor TPasRISCVEthernetDevice.Create;
begin

 inherited Create;

 fMACAddress[0]:=$02;
 fMACAddress[1]:=$00;
 fMACAddress[2]:=$00;
 fMACAddress[3]:=$00;
 fMACAddress[4]:=$00;
 fMACAddress[5]:=$01;

 fOnCanWritePacket:=nil;

 fOnWritePacket:=nil;

 fOnSetCarrier:=nil;

end;

destructor TPasRISCVEthernetDevice.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCVEthernetDevice.GenerateMACAddress;
var RandomGenerator:TRNLRandomGenerator;
begin
 RandomGenerator:=TRNLRandomGenerator.Create;
 try
  RandomGenerator.GetRandomBytes(fMACAddress,SizeOf(TMACAddress));
  fMACAddress[0]:=(fMACAddress[0] and $fe) or $02;
 finally
  FreeAndNil(RandomGenerator);
 end;
end;

procedure TPasRISCVEthernetDevice.Shutdown;
begin
end;

procedure TPasRISCVEthernetDevice.WritePacket(const aBuffer:Pointer;const aBufferSize:TPasRISCVSizeInt);
begin
end;

{$if defined(fpc) and defined(unix)}

{ TPasRISCVEthernetDeviceTUN }

constructor TPasRISCVEthernetDeviceTUN.TNetworkThread.Create(const aEthernetDevice:TPasRISCVEthernetDeviceTUN);
begin
 fEthernetDevice:=aEthernetDevice;
 fEvent:=TPasMPEvent.Create(nil,true,false,'');
 inherited Create(false);
end;

destructor TPasRISCVEthernetDeviceTUN.TNetworkThread.Destroy;
begin
 Shutdown;
 FreeAndNil(fEvent);
 inherited Destroy;
end;

procedure TPasRISCVEthernetDeviceTUN.TNetworkThread.Shutdown;
begin
 if not Finished then begin
  Terminate;
  fEvent.SetEvent;
  WaitFor;
 end;
end;

procedure TPasRISCVEthernetDeviceTUN.TNetworkThread.Execute;
begin
 NameThreadForDebugging('TPasRISCVEthernetDeviceTUN.TNetworkThread');
 fEthernetDevice.ThreadProc;
end;

constructor TPasRISCVEthernetDeviceTUN.Create;
begin
 inherited Create;
 fTunFD:=-1;
 fSelectedFilled:=false;
 fThread:=nil;
 fpFD_ZERO(fRFDS);
 fpFD_ZERO(fWFDS);
 fpFD_ZERO(fEFDS);
end;

destructor TPasRISCVEthernetDeviceTUN.Destroy;
begin
 Shutdown;
 FreeAndNil(fThread);
 inherited Destroy;
end;

procedure TPasRISCVEthernetDeviceTUN.Shutdown;
begin
 if assigned(fThread) then begin
  try
   fThread.Shutdown;
  finally
   FreeAndNil(fThread);
  end;
 end;
 if fTunFD>=0 then begin
  fpClose(fTunFD);
  fTunFD:=-1;
 end;
end;

function TPasRISCVEthernetDeviceTUN.Open(const aInterfaceName:TPasRISCVRawByteString):Boolean;
var ifr:Tifreq;
    r:TPasRISCVInt32;
    Len:TPasRISCVSizeInt;
begin

 Shutdown;

 fTunFD:=fpOpen('/dev/net/tun',O_RDWR);
 if fTunFD<0 then begin
  result:=false;
  exit;
 end;

 FillChar(ifr,SizeOf(Tifreq),#0);

 ifr.ifr_ifru.ifru_flags:=IFF_TAP or IFF_NO_PI;

 Len:=Length(aInterfaceName);
 if Len>SizeOf(ifr.ifr_ifrn.ifr_name)-1 then begin
  Len:=SizeOf(ifr.ifr_ifrn.ifr_name)-1;
 end;
 FillChar(ifr.ifr_ifrn.ifr_name[0],SizeOf(ifr.ifr_ifrn.ifr_name),#0);
 if Len>0 then begin
  Move(aInterfaceName[1],ifr.ifr_ifrn.ifr_name[0],Len);
 end;

 r:=fpIOCtl(fTunFD,TUNSETIFF,@ifr);
 if r<>0 then begin
  fpClose(fTunFD);
  fTunFD:=-1;
  result:=false;
  exit;
 end;

 fpfcntl(fTunFD,F_SETFL,O_NONBLOCK);

 fThread:=TNetworkThread.Create(self);

 result:=true;

end;

procedure TPasRISCVEthernetDeviceTUN.WritePacket(const aBuffer:Pointer;const aBufferSize:TPasRISCVSizeInt);
begin
 if fTunFD>=0 then begin
  fpWrite(fTunFD,aBuffer,aBufferSize);
 end;
end;

procedure TPasRISCVEthernetDeviceTUN.ThreadProc;
const Delay:TTimeVal=(tv_sec:0;tv_usec:10000); // 10ms as balance between waiting and termination when shutting down
var Len:TPasRISCVInt32;
begin
 while not fThread.Terminated do begin
  if assigned(fOnCanWritePacket) and fOnCanWritePacket then begin
   fpFD_ZERO(fRFDS);
   fpFD_ZERO(fWFDS);
   fpFD_ZERO(fEFDS);
   fpFD_SET(fTunFD,fRFDS);
   if fpSelect(fTunFD+1,@fRFDS,@fWFDS,@fEFDS,@Delay)>0 then begin
    if fThread.Terminated then begin
     break;
    end else if fpFD_ISSET(fTunFD,fRFDS)<>0 then begin
     Len:=fpRead(fTunFD,@fBuffer,Length(fBuffer));
     if (Len>0) and assigned(fOnWritePacket) then begin
      fOnWritePacket(@fBuffer,Len);
     end;
    end;
   end;
  end;
 end;
end;
{$ifend}

{ TPasRISCV.TPCG32 }

procedure TPasRISCV.TPCG32.Init(const aSeed:TPasRISCVUInt64);
begin
 if aSeed=0 then begin
  fState:=DefaultState;
  fIncrement:=DefaultStream;
 end else begin
  fState:=DefaultState xor (aSeed*362436069);
  if fState=0 then begin
   fState:=DefaultState;
  end;
  fIncrement:=DefaultStream xor (aSeed*1566083941);
  inc(fIncrement,1-(fIncrement and 1));
 end;
end;

function TPasRISCV.TPCG32.Get32:TPasRISCVUInt32;
var OldState:TPasRISCVUInt64;
{$ifndef fpc}
    XorShifted,Rotation:TPasRISCVUInt32;
{$endif}
begin
 OldState:=fState;
 fState:=(OldState*TPCG32.Mult)+fIncrement;
{$ifdef fpc}
 result:=RORDWord(((OldState shr 18) xor OldState) shr 27,OldState shr 59);
{$else}
 XorShifted:=((OldState shr 18) xor OldState) shr 27;
 Rotation:=OldState shr 59;
 result:=(XorShifted shr Rotation) or (XorShifted shl ((-Rotation) and 31));
{$endif}
end;

function TPasRISCV.TPCG32.GetUnbiasedBounded(const aRange:TPasRISCVUInt32):TPasRISCVUInt32;
var x,l,t:TPasRISCVUInt32;
    m:TPasRISCVUInt64;
begin
 if aRange<=1 then begin
  // For ranges of 0 or 1, just output always zero, but do a dummy Get32 call with discarding its result
  Get32;
  result:=0;
 end else {$if (defined(fpc) and declared(BSRDWord)) or declared(CLZDWord)}if (aRange and (aRange-1))<>0 then{$ifend}begin
  // For non-power-of-two ranges: Debiased Integer Multiplication — Lemire's Method
  x:=Get32;
  m:=TPasRISCVUInt64(x);
  m:=m*TPasRISCVUInt64(aRange);
  l:=TPasRISCVUInt32(m and $ffffffff);
  if l<aRange then begin
   t:=-aRange;
   if t>=aRange then begin
    dec(t,aRange);
    if t>=aRange then begin
     t:=t mod aRange;
    end;
   end;
   while l<t do begin
    x:=Get32;
    m:=TPasRISCVUInt64(x);
    m:=m*TPasRISCVUInt64(aRange);
    l:=TPasRISCVUInt32(m and $ffffffff);
   end;
  end;
  result:=m shr 32;
{$if (defined(fpc) and declared(BSRDWord)) or declared(CLZDWord)}
 end else begin
  // For power-of-two ranges: Bitmask with Rejection (Unbiased) — Apple's Method
  m:=TPasRISCVUInt32($ffffffff);
  t:=aRange-1;
{$if defined(fpc) and declared(BSRDWord)}
  m:=m shr (31-BSRDWord(t or 1));
{$else}
  m:=m shr CLZDWord(t or 1);
{$ifend}
  repeat
   result:=Get32 and m;
  until result<=t;
{$ifend}
 end;
end;

{ TPasRISCV.TInstructionSetArchitecture }

constructor TPasRISCV.TInstructionSetArchitecture.Create(const aMachine:TPasRISCV);
begin
 inherited Create;
 fMachine:=aMachine;
 fInstructions32:=nil;
 fInstructions16:=nil;
 fCountInstructions32:=0;
 fCountInstructions16:=0;
 BuildInstructionTables;
 BuildIndexes;
end;

destructor TPasRISCV.TInstructionSetArchitecture.Destroy;
begin
 fInstructions32:=nil;
 fInstructions16:=nil;
 inherited Destroy;
end;

procedure TPasRISCV.TInstructionSetArchitecture.AddInstruction32(const aMnemonic:TPasRISCVUTF8String;
                                                     const aFormat:TInstructionFormat;
                                                     const aMask,aValue:TPasRISCVUInt32);
var InstructionIndex:TPasRISCVSizeInt;
    Instruction:PInstruction;
begin
 InstructionIndex:=fCountInstructions32;
 inc(fCountInstructions32);
 if length(fInstructions32)<fCountInstructions32 then begin
  SetLength(fInstructions32,fCountInstructions32*2);
 end;
 Instruction:=@fInstructions32[InstructionIndex];
 Instruction^.Mask:=aMask;
 Instruction^.Value:=aValue;
 Instruction^.Mnemonic:=aMnemonic;
 Instruction^.Format:=aFormat;
end;

procedure TPasRISCV.TInstructionSetArchitecture.AddInstruction16(const aMnemonic:TPasRISCVUTF8String;
                                                     const aFormat:TCompressedFormat;
                                                     const aDataRegisterKind:TRegisterKind;
                                                     const aMask,aValue:TPasRISCVUInt32);
var InstructionIndex:TPasRISCVSizeInt;
    Instruction:PCompressedInstruction;
begin
 InstructionIndex:=fCountInstructions16;
 inc(fCountInstructions16);
 if length(fInstructions16)<fCountInstructions16 then begin
  SetLength(fInstructions16,fCountInstructions16*2);
 end;
 Instruction:=@fInstructions16[InstructionIndex];
 Instruction^.Mask:=aMask;
 Instruction^.Value:=aValue;
 Instruction^.Mnemonic:=aMnemonic;
 Instruction^.Format:=aFormat;
 Instruction^.DataRegisterKind:=aDataRegisterKind;
end;

procedure TPasRISCV.TInstructionSetArchitecture.BuildInstructionTables;
const OpcodeLoad=$03;
      OpcodeLoadFP=$07;
      OpcodeMiscMem=$0f;
      OpcodeOpImm=$13;
      OpcodeAuipc=$17;
      OpcodeOpImm32=$1b;
      OpcodeStore=$23;
      OpcodeStoreFP=$27;
      OpcodeAmo=$2f;
      OpcodeOp=$33;
      OpcodeLui=$37;
      OpcodeOp32=$3b;
      OpcodeMadd=$43;
      OpcodeMsub=$47;
      OpcodeNmadd=$4b;
      OpcodeNmsub=$4f;
      OpcodeOpFP=$53;
      OpcodeBranch=$63;
      OpcodeJalr=$67;
      OpcodeJal=$6f;
      OpcodeSystem=$73;
      MaskOpcode=$0000007f;
      MaskOpcodeFunct3=$0000707f;
      MaskOpcodeFunct7=$fe00007f;
      MaskOpcodeFunct7Funct3=$fe00707f;
      MaskOpcodeFunct6Funct3=$fc00707f;
      MaskOpcodeFunct7Funct3Shamt=$fff0707f;
      MaskOpcodeFunct7Rs2=$fff0007f;
      MaskOpcodeFunct7Rs2Funct3=$fff0707f;
      MaskAmo=$f800707f;
      MaskFma=$0600007f;
      MaskCbo=$fff0707f;
      MaskCompressedBase=$e003;
      MaskCompressedFunct2=$0c00;
      MaskCompressedBit12=$1000;
      MaskCompressedBits6_5=$0060;
      MaskCompressedBits4_2=$001c;
      MaskCompressedRs2=$007c;
      MaskCompressedRd=$0f80;
function ValueR(const aOpcode,aFunct3,aFunct7:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=(aOpcode and $7f) or ((aFunct3 and 7) shl 12) or ((aFunct7 and $7f) shl 25);
end;
function ValueI(const aOpcode,aFunct3:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=(aOpcode and $7f) or ((aFunct3 and 7) shl 12);
end;
function ValueIShift6(const aOpcode,aFunct3,aFunct6:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=(aOpcode and $7f) or ((aFunct3 and 7) shl 12) or ((aFunct6 and $3f) shl 26);
end;
function ValueIShift7(const aOpcode,aFunct3,aFunct7:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=(aOpcode and $7f) or ((aFunct3 and 7) shl 12) or ((aFunct7 and $7f) shl 25);
end;
function ValueIShiftFixed6(const aOpcode,aFunct3,aFunct6,aShamt:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=(aOpcode and $7f) or ((aFunct3 and 7) shl 12) or ((aFunct6 and $3f) shl 26) or ((aShamt and $3f) shl 20);
end;
function ValueIShiftFixed5(const aOpcode,aFunct3,aFunct7,aShamt:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=(aOpcode and $7f) or ((aFunct3 and 7) shl 12) or ((aFunct7 and $7f) shl 25) or ((aShamt and $1f) shl 20);
end;
function ValueFma(const aOpcode,aFmt:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=(aOpcode and $7f) or ((aFmt and 3) shl 25);
end;
function ValueAmo(const aOpcode,aFunct3,aFunct5:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=(aOpcode and $7f) or ((aFunct3 and 7) shl 12) or ((aFunct5 and $1f) shl 27);
end;
function ValueOpFpRs2(const aOpcode,aFunct7,aRs2:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=(aOpcode and $7f) or ((aFunct7 and $7f) shl 25) or ((aRs2 and $1f) shl 20);
end;
function ValueOpFpFunct3(const aOpcode,aFunct7,aFunct3:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=(aOpcode and $7f) or ((aFunct3 and 7) shl 12) or ((aFunct7 and $7f) shl 25);
end;
function ValueOpFpFunct3Rs2(const aOpcode,aFunct7,aFunct3,aRs2:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=(aOpcode and $7f) or ((aFunct3 and 7) shl 12) or ((aFunct7 and $7f) shl 25) or ((aRs2 and $1f) shl 20);
end;
function ValueCompressedBase(const aFunct3,aQuadrant:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=((aFunct3 and 7) shl 13) or (aQuadrant and 3);
end;
var Mask:TPasRISCVUInt32;
    Value:TPasRISCVUInt32;
    Index:TPasRISCVInt32;
begin
 fCountInstructions32:=0;
 fCountInstructions16:=0;
 SetLength(fInstructions32,0);
 SetLength(fInstructions16,0);

 //////////////////////////////////////////////////////////////////////////////
 // Integer Base                                                             //
 //////////////////////////////////////////////////////////////////////////////
 AddInstruction32('lui',TInstructionFormat.U,MaskOpcode,OpcodeLui);
 AddInstruction32('auipc',TInstructionFormat.U,MaskOpcode,OpcodeAuipc);
 AddInstruction32('jal',TInstructionFormat.J,MaskOpcode,OpcodeJal);
 AddInstruction32('jalr',TInstructionFormat.Jalr,MaskOpcodeFunct3,ValueI(OpcodeJalr,0));

 AddInstruction32('beq',TInstructionFormat.Branch,MaskOpcodeFunct3,ValueI(OpcodeBranch,0));
 AddInstruction32('bne',TInstructionFormat.Branch,MaskOpcodeFunct3,ValueI(OpcodeBranch,1));
 AddInstruction32('blt',TInstructionFormat.Branch,MaskOpcodeFunct3,ValueI(OpcodeBranch,4));
 AddInstruction32('bge',TInstructionFormat.Branch,MaskOpcodeFunct3,ValueI(OpcodeBranch,5));
 AddInstruction32('bltu',TInstructionFormat.Branch,MaskOpcodeFunct3,ValueI(OpcodeBranch,6));
 AddInstruction32('bgeu',TInstructionFormat.Branch,MaskOpcodeFunct3,ValueI(OpcodeBranch,7));

 AddInstruction32('lb',TInstructionFormat.Load,MaskOpcodeFunct3,ValueI(OpcodeLoad,0));
 AddInstruction32('lh',TInstructionFormat.Load,MaskOpcodeFunct3,ValueI(OpcodeLoad,1));
 AddInstruction32('lw',TInstructionFormat.Load,MaskOpcodeFunct3,ValueI(OpcodeLoad,2));
 AddInstruction32('ld',TInstructionFormat.Load,MaskOpcodeFunct3,ValueI(OpcodeLoad,3));
 AddInstruction32('lbu',TInstructionFormat.Load,MaskOpcodeFunct3,ValueI(OpcodeLoad,4));
 AddInstruction32('lhu',TInstructionFormat.Load,MaskOpcodeFunct3,ValueI(OpcodeLoad,5));
 AddInstruction32('lwu',TInstructionFormat.Load,MaskOpcodeFunct3,ValueI(OpcodeLoad,6));

 AddInstruction32('sb',TInstructionFormat.Store,MaskOpcodeFunct3,ValueI(OpcodeStore,0));
 AddInstruction32('sh',TInstructionFormat.Store,MaskOpcodeFunct3,ValueI(OpcodeStore,1));
 AddInstruction32('sw',TInstructionFormat.Store,MaskOpcodeFunct3,ValueI(OpcodeStore,2));
 AddInstruction32('sd',TInstructionFormat.Store,MaskOpcodeFunct3,ValueI(OpcodeStore,3));

 AddInstruction32('addi',TInstructionFormat.I,MaskOpcodeFunct3,ValueI(OpcodeOpImm,0));
 AddInstruction32('slti',TInstructionFormat.I,MaskOpcodeFunct3,ValueI(OpcodeOpImm,2));
 AddInstruction32('sltiu',TInstructionFormat.I,MaskOpcodeFunct3,ValueI(OpcodeOpImm,3));
 AddInstruction32('xori',TInstructionFormat.I,MaskOpcodeFunct3,ValueI(OpcodeOpImm,4));
 AddInstruction32('ori',TInstructionFormat.I,MaskOpcodeFunct3,ValueI(OpcodeOpImm,6));
 AddInstruction32('andi',TInstructionFormat.I,MaskOpcodeFunct3,ValueI(OpcodeOpImm,7));

 // Zicbop: Prefetch hints (encoded as ORI with rd=x0)
 AddInstruction32('prefetch.i',TInstructionFormat.Prefetch,TPasRISCVUInt32($01f07fff),TPasRISCVUInt32($00006013));
 AddInstruction32('prefetch.r',TInstructionFormat.Prefetch,TPasRISCVUInt32($01f07fff),TPasRISCVUInt32($00106013));
 AddInstruction32('prefetch.w',TInstructionFormat.Prefetch,TPasRISCVUInt32($01f07fff),TPasRISCVUInt32($00306013));

 AddInstruction32('slli',TInstructionFormat.IShift,MaskOpcodeFunct6Funct3,ValueIShift6(OpcodeOpImm,1,$00));
 AddInstruction32('bseti',TInstructionFormat.IShift,MaskOpcodeFunct6Funct3,ValueIShift6(OpcodeOpImm,1,$14));
 AddInstruction32('bclri',TInstructionFormat.IShift,MaskOpcodeFunct6Funct3,ValueIShift6(OpcodeOpImm,1,$24));
 AddInstruction32('binvi',TInstructionFormat.IShift,MaskOpcodeFunct6Funct3,ValueIShift6(OpcodeOpImm,1,$34));
 AddInstruction32('clz',TInstructionFormat.RUnary,MaskOpcodeFunct7Funct3Shamt,ValueIShiftFixed6(OpcodeOpImm,1,$30,$00));
 AddInstruction32('ctz',TInstructionFormat.RUnary,MaskOpcodeFunct7Funct3Shamt,ValueIShiftFixed6(OpcodeOpImm,1,$30,$01));
 AddInstruction32('cpop',TInstructionFormat.RUnary,MaskOpcodeFunct7Funct3Shamt,ValueIShiftFixed6(OpcodeOpImm,1,$30,$02));
 AddInstruction32('sext.b',TInstructionFormat.RUnary,MaskOpcodeFunct7Funct3Shamt,ValueIShiftFixed6(OpcodeOpImm,1,$30,$04));
 AddInstruction32('sext.h',TInstructionFormat.RUnary,MaskOpcodeFunct7Funct3Shamt,ValueIShiftFixed6(OpcodeOpImm,1,$30,$05));

 AddInstruction32('srli',TInstructionFormat.IShift,MaskOpcodeFunct6Funct3,ValueIShift6(OpcodeOpImm,5,$00));
 AddInstruction32('srai',TInstructionFormat.IShift,MaskOpcodeFunct6Funct3,ValueIShift6(OpcodeOpImm,5,$10));
 AddInstruction32('orc.b',TInstructionFormat.RUnary,MaskOpcodeFunct7Funct3Shamt,ValueIShiftFixed6(OpcodeOpImm,5,$14,$07));
 AddInstruction32('bexti',TInstructionFormat.IShift,MaskOpcodeFunct6Funct3,ValueIShift6(OpcodeOpImm,5,$24));
 AddInstruction32('rori',TInstructionFormat.IShift,MaskOpcodeFunct6Funct3,ValueIShift6(OpcodeOpImm,5,$30));
 AddInstruction32('rev8',TInstructionFormat.RUnary,MaskOpcodeFunct7Funct3Shamt,ValueIShiftFixed6(OpcodeOpImm,5,$34,$38));

 AddInstruction32('addiw',TInstructionFormat.I,MaskOpcodeFunct3,ValueI(OpcodeOpImm32,0));
 AddInstruction32('slliw',TInstructionFormat.IShiftW,MaskOpcodeFunct7Funct3,ValueIShift7(OpcodeOpImm32,1,$00));
 AddInstruction32('slli.uw',TInstructionFormat.IShift,MaskOpcodeFunct6Funct3,ValueIShift6(OpcodeOpImm32,1,$02));
 AddInstruction32('clzw',TInstructionFormat.RUnary,MaskOpcodeFunct7Funct3Shamt,ValueIShiftFixed5(OpcodeOpImm32,1,$30,$00));
 AddInstruction32('ctzw',TInstructionFormat.RUnary,MaskOpcodeFunct7Funct3Shamt,ValueIShiftFixed5(OpcodeOpImm32,1,$30,$01));
 AddInstruction32('cpopw',TInstructionFormat.RUnary,MaskOpcodeFunct7Funct3Shamt,ValueIShiftFixed5(OpcodeOpImm32,1,$30,$02));
 AddInstruction32('srliw',TInstructionFormat.IShiftW,MaskOpcodeFunct7Funct3,ValueIShift7(OpcodeOpImm32,5,$00));
 AddInstruction32('sraiw',TInstructionFormat.IShiftW,MaskOpcodeFunct7Funct3,ValueIShift7(OpcodeOpImm32,5,$20));
 AddInstruction32('roriw',TInstructionFormat.IShiftW,MaskOpcodeFunct7Funct3,ValueIShift7(OpcodeOpImm32,5,$30));

 AddInstruction32('add',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,0,$00));

 // Zihintntl: Non-temporal locality hints (encoded as ADD x0, x0, xN)
 AddInstruction32('ntl.p1',TInstructionFormat.None,TPasRISCVUInt32($ffffffff),TPasRISCVUInt32($00200033));
 AddInstruction32('ntl.pall',TInstructionFormat.None,TPasRISCVUInt32($ffffffff),TPasRISCVUInt32($00300033));
 AddInstruction32('ntl.s1',TInstructionFormat.None,TPasRISCVUInt32($ffffffff),TPasRISCVUInt32($00400033));
 AddInstruction32('ntl.all',TInstructionFormat.None,TPasRISCVUInt32($ffffffff),TPasRISCVUInt32($00500033));

 AddInstruction32('mul',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,0,$01));
 AddInstruction32('sub',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,0,$20));

 AddInstruction32('sll',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,1,$00));
 AddInstruction32('mulh',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,1,$01));
 AddInstruction32('clmul',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,1,$05));
 AddInstruction32('bset',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,1,$14));
 AddInstruction32('bclr',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,1,$24));
 AddInstruction32('rol',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,1,$30));
 AddInstruction32('binv',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,1,$34));

 AddInstruction32('slt',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,2,$00));
 AddInstruction32('mulhsu',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,2,$01));
 AddInstruction32('clmulr',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,2,$05));
 AddInstruction32('sh1add',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,2,$10));

 AddInstruction32('sltu',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,3,$00));
 AddInstruction32('mulhu',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,3,$01));
 AddInstruction32('clmulh',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,3,$05));

 AddInstruction32('xor',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,4,$00));
 AddInstruction32('div',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,4,$01));
 AddInstruction32('min',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,4,$05));
 AddInstruction32('sh2add',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,4,$10));
 AddInstruction32('xnor',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,4,$20));

 AddInstruction32('srl',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,5,$00));
 AddInstruction32('divu',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,5,$01));
 AddInstruction32('minu',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,5,$05));
 AddInstruction32('czero.eqz',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,5,$07));
 AddInstruction32('sra',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,5,$20));
 AddInstruction32('bext',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,5,$24));
 AddInstruction32('ror',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,5,$30));

 AddInstruction32('or',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,6,$00));
 AddInstruction32('rem',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,6,$01));
 AddInstruction32('max',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,6,$05));
 AddInstruction32('sh3add',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,6,$10));
 AddInstruction32('orn',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,6,$20));

 AddInstruction32('and',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,7,$00));
 AddInstruction32('remu',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,7,$01));
 AddInstruction32('maxu',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,7,$05));
 AddInstruction32('czero.nez',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,7,$07));
 AddInstruction32('andn',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp,7,$20));

 AddInstruction32('addw',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp32,0,$00));
 AddInstruction32('mulw',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp32,0,$01));
 AddInstruction32('add.uw',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp32,0,$04));
 AddInstruction32('subw',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp32,0,$20));

 AddInstruction32('sllw',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp32,1,$00));
 AddInstruction32('rolw',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp32,1,$30));

 AddInstruction32('sh1add.uw',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp32,2,$10));

 AddInstruction32('divw',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp32,4,$01));
 AddInstruction32('zext.h',TInstructionFormat.RUnary,MaskOpcodeFunct7Rs2Funct3,ValueOpFpFunct3Rs2(OpcodeOp32,$04,4,0));
 AddInstruction32('sh2add.uw',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp32,4,$10));

 AddInstruction32('srlw',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp32,5,$00));
 AddInstruction32('divuw',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp32,5,$01));
 AddInstruction32('sraw',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp32,5,$20));
 AddInstruction32('rorw',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp32,5,$30));

 AddInstruction32('remw',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp32,6,$01));
 AddInstruction32('sh3add.uw',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp32,6,$10));

 AddInstruction32('remuw',TInstructionFormat.R,MaskOpcodeFunct7Funct3,ValueR(OpcodeOp32,7,$01));

 //////////////////////////////////////////////////////////////////////////////
 // Misc. Mem                                                                //
 //////////////////////////////////////////////////////////////////////////////
 AddInstruction32('pause',TInstructionFormat.None,TPasRISCVUInt32($ffffffff),TPasRISCVUInt32($0100000f));
 AddInstruction32('fence',TInstructionFormat.Fence,MaskOpcodeFunct3,ValueI(OpcodeMiscMem,0));
 AddInstruction32('fence.i',TInstructionFormat.None,MaskOpcodeFunct3,ValueI(OpcodeMiscMem,1));
 AddInstruction32('cbo.inval',TInstructionFormat.Cbo,MaskCbo,(TPasRISCVUInt32($00) shl 20) or ValueI(OpcodeMiscMem,2));
 AddInstruction32('cbo.clean',TInstructionFormat.Cbo,MaskCbo,(TPasRISCVUInt32($01) shl 20) or ValueI(OpcodeMiscMem,2));
 AddInstruction32('cbo.flush',TInstructionFormat.Cbo,MaskCbo,(TPasRISCVUInt32($02) shl 20) or ValueI(OpcodeMiscMem,2));
 AddInstruction32('cbo.zero',TInstructionFormat.Cbo,MaskCbo,(TPasRISCVUInt32($04) shl 20) or ValueI(OpcodeMiscMem,2));

 //////////////////////////////////////////////////////////////////////////////
 // System                                                                   //
 //////////////////////////////////////////////////////////////////////////////
 AddInstruction32('ecall',TInstructionFormat.None,TPasRISCVUInt32($ffffffff),TPasRISCVUInt32($00000073));
 AddInstruction32('ebreak',TInstructionFormat.None,TPasRISCVUInt32($ffffffff),TPasRISCVUInt32($00100073));
 AddInstruction32('uret',TInstructionFormat.None,TPasRISCVUInt32($ffffffff),TPasRISCVUInt32($00200073));
 AddInstruction32('sret',TInstructionFormat.None,TPasRISCVUInt32($ffffffff),TPasRISCVUInt32($10200073));
 AddInstruction32('mret',TInstructionFormat.None,TPasRISCVUInt32($ffffffff),TPasRISCVUInt32($30200073));
 AddInstruction32('wfi',TInstructionFormat.None,TPasRISCVUInt32($ffffffff),TPasRISCVUInt32($10500073));
 AddInstruction32('wrs.nto',TInstructionFormat.None,TPasRISCVUInt32($ffffffff),TPasRISCVUInt32($00d00073));
 AddInstruction32('wrs.sto',TInstructionFormat.None,TPasRISCVUInt32($ffffffff),TPasRISCVUInt32($01d00073));
 AddInstruction32('sfence.vma',TInstructionFormat.SFence,MaskOpcodeFunct7Funct3,ValueR(OpcodeSystem,0,$09));
 AddInstruction32('sfence.w.inval',TInstructionFormat.None,TPasRISCVUInt32($ffffffff),TPasRISCVUInt32($18000073));
 AddInstruction32('sfence.inval.ir',TInstructionFormat.None,TPasRISCVUInt32($ffffffff),TPasRISCVUInt32($18100073));
 AddInstruction32('sinval.vma',TInstructionFormat.SFence,MaskOpcodeFunct7Funct3,ValueR(OpcodeSystem,0,$0c));
 AddInstruction32('hfence.vvma',TInstructionFormat.SFence,MaskOpcodeFunct7Funct3,ValueR(OpcodeSystem,0,$11));
 AddInstruction32('hfence.gvma',TInstructionFormat.SFence,MaskOpcodeFunct7Funct3,ValueR(OpcodeSystem,0,$51));
 AddInstruction32('hinval.vvma',TInstructionFormat.SFence,MaskOpcodeFunct7Funct3,ValueR(OpcodeSystem,0,$16));
 AddInstruction32('hinval.gvma',TInstructionFormat.SFence,MaskOpcodeFunct7Funct3,ValueR(OpcodeSystem,0,$66));
 // H-extension load/store instructions
 AddInstruction32('hlv.b',TInstructionFormat.HLV,MaskOpcodeFunct7Rs2Funct3,ValueR(OpcodeSystem,4,$30) or (0 shl 20));
 AddInstruction32('hlv.bu',TInstructionFormat.HLV,MaskOpcodeFunct7Rs2Funct3,ValueR(OpcodeSystem,4,$30) or (1 shl 20));
 AddInstruction32('hlv.h',TInstructionFormat.HLV,MaskOpcodeFunct7Rs2Funct3,ValueR(OpcodeSystem,4,$32) or (0 shl 20));
 AddInstruction32('hlv.hu',TInstructionFormat.HLV,MaskOpcodeFunct7Rs2Funct3,ValueR(OpcodeSystem,4,$32) or (1 shl 20));
 AddInstruction32('hlvx.hu',TInstructionFormat.HLV,MaskOpcodeFunct7Rs2Funct3,ValueR(OpcodeSystem,4,$32) or (3 shl 20));
 AddInstruction32('hlv.w',TInstructionFormat.HLV,MaskOpcodeFunct7Rs2Funct3,ValueR(OpcodeSystem,4,$34) or (0 shl 20));
 AddInstruction32('hlv.wu',TInstructionFormat.HLV,MaskOpcodeFunct7Rs2Funct3,ValueR(OpcodeSystem,4,$34) or (1 shl 20));
 AddInstruction32('hlvx.wu',TInstructionFormat.HLV,MaskOpcodeFunct7Rs2Funct3,ValueR(OpcodeSystem,4,$34) or (3 shl 20));
 AddInstruction32('hlv.d',TInstructionFormat.HLV,MaskOpcodeFunct7Rs2Funct3,ValueR(OpcodeSystem,4,$36) or (0 shl 20));
 AddInstruction32('hsv.b',TInstructionFormat.HSV,MaskOpcodeFunct7Funct3,ValueR(OpcodeSystem,4,$31));
 AddInstruction32('hsv.h',TInstructionFormat.HSV,MaskOpcodeFunct7Funct3,ValueR(OpcodeSystem,4,$33));
 AddInstruction32('hsv.w',TInstructionFormat.HSV,MaskOpcodeFunct7Funct3,ValueR(OpcodeSystem,4,$35));
 AddInstruction32('hsv.d',TInstructionFormat.HSV,MaskOpcodeFunct7Funct3,ValueR(OpcodeSystem,4,$37));
 AddInstruction32('csrrw',TInstructionFormat.CSR,MaskOpcodeFunct3,ValueI(OpcodeSystem,1));
 AddInstruction32('csrrs',TInstructionFormat.CSR,MaskOpcodeFunct3,ValueI(OpcodeSystem,2));
 AddInstruction32('csrrc',TInstructionFormat.CSR,MaskOpcodeFunct3,ValueI(OpcodeSystem,3));
 AddInstruction32('csrrwi',TInstructionFormat.CSRImm,MaskOpcodeFunct3,ValueI(OpcodeSystem,5));
 AddInstruction32('csrrsi',TInstructionFormat.CSRImm,MaskOpcodeFunct3,ValueI(OpcodeSystem,6));
 AddInstruction32('csrrci',TInstructionFormat.CSRImm,MaskOpcodeFunct3,ValueI(OpcodeSystem,7));

 //////////////////////////////////////////////////////////////////////////////
 // Zimop                                                                    //
 //////////////////////////////////////////////////////////////////////////////
 for Index:=0 to 31 do begin
  AddInstruction32('mop.r.'+IntToStr(Index),TInstructionFormat.RUnary,
                   TPasRISCVUInt32($fff0707f),
                   TPasRISCVUInt32($81c04073) or
                   TPasRISCVUInt32((Index and 3) shl 20) or
                   TPasRISCVUInt32(((Index shr 2) and 3) shl 26) or
                   TPasRISCVUInt32(((Index shr 4) and 1) shl 30));
 end;
 for Index:=0 to 7 do begin
  AddInstruction32('mop.rr.'+IntToStr(Index),TInstructionFormat.R,
                   TPasRISCVUInt32($fe00707f),
                   TPasRISCVUInt32($82004073) or
                   TPasRISCVUInt32((Index and 3) shl 26) or
                   TPasRISCVUInt32(((Index shr 2) and 1) shl 30));
 end;

 //////////////////////////////////////////////////////////////////////////////
 // AMO                                                                      //
 //////////////////////////////////////////////////////////////////////////////
 AddInstruction32('lr.w',TInstructionFormat.LR,MaskAmo,ValueAmo(OpcodeAmo,2,$02));
 AddInstruction32('sc.w',TInstructionFormat.SC,MaskAmo,ValueAmo(OpcodeAmo,2,$03));
 AddInstruction32('amoswap.w',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,2,$01));
 AddInstruction32('amoadd.w',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,2,$00));
 AddInstruction32('amoxor.w',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,2,$04));
 AddInstruction32('amoand.w',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,2,$0c));
 AddInstruction32('amoor.w',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,2,$08));
 AddInstruction32('amomin.w',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,2,$10));
 AddInstruction32('amomax.w',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,2,$14));
 AddInstruction32('amominu.w',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,2,$18));
 AddInstruction32('amomaxu.w',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,2,$1c));
 AddInstruction32('amocas.w',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,2,$05));

 // Zabha: Byte and Halfword AMO
 AddInstruction32('amoswap.b',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,0,$01));
 AddInstruction32('amoadd.b',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,0,$00));
 AddInstruction32('amoxor.b',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,0,$04));
 AddInstruction32('amoand.b',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,0,$0c));
 AddInstruction32('amoor.b',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,0,$08));
 AddInstruction32('amomin.b',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,0,$10));
 AddInstruction32('amomax.b',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,0,$14));
 AddInstruction32('amominu.b',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,0,$18));
 AddInstruction32('amomaxu.b',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,0,$1c));
 AddInstruction32('amocas.b',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,0,$05));
 AddInstruction32('amoswap.h',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,1,$01));
 AddInstruction32('amoadd.h',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,1,$00));
 AddInstruction32('amoxor.h',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,1,$04));
 AddInstruction32('amoand.h',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,1,$0c));
 AddInstruction32('amoor.h',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,1,$08));
 AddInstruction32('amomin.h',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,1,$10));
 AddInstruction32('amomax.h',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,1,$14));
 AddInstruction32('amominu.h',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,1,$18));
 AddInstruction32('amomaxu.h',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,1,$1c));
 AddInstruction32('amocas.h',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,1,$05));

 AddInstruction32('lr.d',TInstructionFormat.LR,MaskAmo,ValueAmo(OpcodeAmo,3,$02));
 AddInstruction32('sc.d',TInstructionFormat.SC,MaskAmo,ValueAmo(OpcodeAmo,3,$03));
 AddInstruction32('amoswap.d',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,3,$01));
 AddInstruction32('amoadd.d',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,3,$00));
 AddInstruction32('amoxor.d',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,3,$04));
 AddInstruction32('amoand.d',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,3,$0c));
 AddInstruction32('amoor.d',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,3,$08));
 AddInstruction32('amomin.d',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,3,$10));
 AddInstruction32('amomax.d',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,3,$14));
 AddInstruction32('amominu.d',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,3,$18));
 AddInstruction32('amomaxu.d',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,3,$1c));
 AddInstruction32('amocas.d',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,3,$05));

 AddInstruction32('amocas.q',TInstructionFormat.AMO,MaskAmo,ValueAmo(OpcodeAmo,4,$05));

 //////////////////////////////////////////////////////////////////////////////
 // Floating-Point Load/Store                                                //
 //////////////////////////////////////////////////////////////////////////////
 AddInstruction32('flw',TInstructionFormat.FLoad,MaskOpcodeFunct3,ValueI(OpcodeLoadFP,2));
 AddInstruction32('fld',TInstructionFormat.FLoad,MaskOpcodeFunct3,ValueI(OpcodeLoadFP,3));
 AddInstruction32('flh',TInstructionFormat.FLoad,MaskOpcodeFunct3,ValueI(OpcodeLoadFP,1));
 AddInstruction32('fsw',TInstructionFormat.FStore,MaskOpcodeFunct3,ValueI(OpcodeStoreFP,2));
 AddInstruction32('fsd',TInstructionFormat.FStore,MaskOpcodeFunct3,ValueI(OpcodeStoreFP,3));
 AddInstruction32('fsh',TInstructionFormat.FStore,MaskOpcodeFunct3,ValueI(OpcodeStoreFP,1));

 //////////////////////////////////////////////////////////////////////////////
 // Floating-Point FMA                                                       //
 //////////////////////////////////////////////////////////////////////////////
 AddInstruction32('fmadd.s',TInstructionFormat.FMA,MaskFma,ValueFma(OpcodeMadd,0));
 AddInstruction32('fmadd.d',TInstructionFormat.FMA,MaskFma,ValueFma(OpcodeMadd,1));
 AddInstruction32('fmadd.h',TInstructionFormat.FMA,MaskFma,ValueFma(OpcodeMadd,2));
 AddInstruction32('fmsub.s',TInstructionFormat.FMA,MaskFma,ValueFma(OpcodeMsub,0));
 AddInstruction32('fmsub.d',TInstructionFormat.FMA,MaskFma,ValueFma(OpcodeMsub,1));
 AddInstruction32('fmsub.h',TInstructionFormat.FMA,MaskFma,ValueFma(OpcodeMsub,2));
 AddInstruction32('fnmadd.s',TInstructionFormat.FMA,MaskFma,ValueFma(OpcodeNmadd,0));
 AddInstruction32('fnmadd.d',TInstructionFormat.FMA,MaskFma,ValueFma(OpcodeNmadd,1));
 AddInstruction32('fnmadd.h',TInstructionFormat.FMA,MaskFma,ValueFma(OpcodeNmadd,2));
 AddInstruction32('fnmsub.s',TInstructionFormat.FMA,MaskFma,ValueFma(OpcodeNmsub,0));
 AddInstruction32('fnmsub.d',TInstructionFormat.FMA,MaskFma,ValueFma(OpcodeNmsub,1));
 AddInstruction32('fnmsub.h',TInstructionFormat.FMA,MaskFma,ValueFma(OpcodeNmsub,2));

 //////////////////////////////////////////////////////////////////////////////
 // Floating-Point OP                                                        //
 //////////////////////////////////////////////////////////////////////////////
 AddInstruction32('fadd.s',TInstructionFormat.FPBinaryRM,MaskOpcodeFunct7,ValueIShift7(OpcodeOpFP,0,$00));
 AddInstruction32('fadd.d',TInstructionFormat.FPBinaryRM,MaskOpcodeFunct7,ValueIShift7(OpcodeOpFP,0,$01));
 AddInstruction32('fadd.h',TInstructionFormat.FPBinaryRM,MaskOpcodeFunct7,ValueIShift7(OpcodeOpFP,0,$02));
 AddInstruction32('fsub.s',TInstructionFormat.FPBinaryRM,MaskOpcodeFunct7,ValueIShift7(OpcodeOpFP,0,$04));
 AddInstruction32('fsub.d',TInstructionFormat.FPBinaryRM,MaskOpcodeFunct7,ValueIShift7(OpcodeOpFP,0,$05));
 AddInstruction32('fsub.h',TInstructionFormat.FPBinaryRM,MaskOpcodeFunct7,ValueIShift7(OpcodeOpFP,0,$06));
 AddInstruction32('fmul.s',TInstructionFormat.FPBinaryRM,MaskOpcodeFunct7,ValueIShift7(OpcodeOpFP,0,$08));
 AddInstruction32('fmul.d',TInstructionFormat.FPBinaryRM,MaskOpcodeFunct7,ValueIShift7(OpcodeOpFP,0,$09));
 AddInstruction32('fmul.h',TInstructionFormat.FPBinaryRM,MaskOpcodeFunct7,ValueIShift7(OpcodeOpFP,0,$0a));
 AddInstruction32('fdiv.s',TInstructionFormat.FPBinaryRM,MaskOpcodeFunct7,ValueIShift7(OpcodeOpFP,0,$0c));
 AddInstruction32('fdiv.d',TInstructionFormat.FPBinaryRM,MaskOpcodeFunct7,ValueIShift7(OpcodeOpFP,0,$0d));
 AddInstruction32('fdiv.h',TInstructionFormat.FPBinaryRM,MaskOpcodeFunct7,ValueIShift7(OpcodeOpFP,0,$0e));

 AddInstruction32('fsgnj.s',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$10,0));
 AddInstruction32('fsgnjn.s',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$10,1));
 AddInstruction32('fsgnjx.s',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$10,2));
 AddInstruction32('fsgnj.d',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$11,0));
 AddInstruction32('fsgnjn.d',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$11,1));
 AddInstruction32('fsgnjx.d',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$11,2));
 AddInstruction32('fsgnj.h',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$12,0));
 AddInstruction32('fsgnjn.h',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$12,1));
 AddInstruction32('fsgnjx.h',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$12,2));

 AddInstruction32('fmin.s',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$14,0));
 AddInstruction32('fmax.s',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$14,1));
 AddInstruction32('fminm.s',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$14,2));
 AddInstruction32('fmaxm.s',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$14,3));
 AddInstruction32('fmin.d',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$15,0));
 AddInstruction32('fmax.d',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$15,1));
 AddInstruction32('fminm.d',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$15,2));
 AddInstruction32('fmaxm.d',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$15,3));
 AddInstruction32('fmin.h',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$16,0));
 AddInstruction32('fmax.h',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$16,1));
 AddInstruction32('fminm.h',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$16,2));
 AddInstruction32('fmaxm.h',TInstructionFormat.FPBinary,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$16,3));

 AddInstruction32('fcvt.s.d',TInstructionFormat.FPCvtFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$20,1));
 AddInstruction32('fcvt.s.h',TInstructionFormat.FPCvtFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$20,2));
 AddInstruction32('fcvt.s.bf16',TInstructionFormat.FPCvtFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$20,6));
 AddInstruction32('fround.s',TInstructionFormat.FPUnaryRM,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$20,4));
 AddInstruction32('froundnx.s',TInstructionFormat.FPUnaryRM,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$20,5));
 AddInstruction32('fcvt.d.s',TInstructionFormat.FPCvtFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$21,0));
 AddInstruction32('fcvt.d.h',TInstructionFormat.FPCvtFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$21,2));
 AddInstruction32('fround.d',TInstructionFormat.FPUnaryRM,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$21,4));
 AddInstruction32('froundnx.d',TInstructionFormat.FPUnaryRM,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$21,5));
 AddInstruction32('fcvt.h.s',TInstructionFormat.FPCvtFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$22,0));
 AddInstruction32('fcvt.h.d',TInstructionFormat.FPCvtFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$22,1));
 AddInstruction32('fcvt.bf16.s',TInstructionFormat.FPCvtFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$22,8));
 AddInstruction32('fround.h',TInstructionFormat.FPUnaryRM,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$22,4));
 AddInstruction32('froundnx.h',TInstructionFormat.FPUnaryRM,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$22,5));
 AddInstruction32('fsqrt.s',TInstructionFormat.FPUnaryRM,MaskOpcodeFunct7,ValueIShift7(OpcodeOpFP,0,$2c));
 AddInstruction32('fsqrt.d',TInstructionFormat.FPUnaryRM,MaskOpcodeFunct7,ValueIShift7(OpcodeOpFP,0,$2d));
 AddInstruction32('fsqrt.h',TInstructionFormat.FPUnaryRM,MaskOpcodeFunct7,ValueIShift7(OpcodeOpFP,0,$2e));

 AddInstruction32('fle.s',TInstructionFormat.FPCompare,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$50,0));
 AddInstruction32('flt.s',TInstructionFormat.FPCompare,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$50,1));
 AddInstruction32('feq.s',TInstructionFormat.FPCompare,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$50,2));
 AddInstruction32('fleq.s',TInstructionFormat.FPCompare,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$50,4));
 AddInstruction32('fltq.s',TInstructionFormat.FPCompare,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$50,5));
 AddInstruction32('fle.d',TInstructionFormat.FPCompare,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$51,0));
 AddInstruction32('flt.d',TInstructionFormat.FPCompare,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$51,1));
 AddInstruction32('feq.d',TInstructionFormat.FPCompare,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$51,2));
 AddInstruction32('fleq.d',TInstructionFormat.FPCompare,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$51,4));
 AddInstruction32('fltq.d',TInstructionFormat.FPCompare,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$51,5));
 AddInstruction32('fle.h',TInstructionFormat.FPCompare,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$52,0));
 AddInstruction32('flt.h',TInstructionFormat.FPCompare,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$52,1));
 AddInstruction32('feq.h',TInstructionFormat.FPCompare,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$52,2));
 AddInstruction32('fleq.h',TInstructionFormat.FPCompare,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$52,4));
 AddInstruction32('fltq.h',TInstructionFormat.FPCompare,MaskOpcodeFunct7Funct3,ValueOpFpFunct3(OpcodeOpFP,$52,5));

 AddInstruction32('fcvt.w.s',TInstructionFormat.FPCvtIntFromFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$60,0));
 AddInstruction32('fcvt.wu.s',TInstructionFormat.FPCvtIntFromFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$60,1));
 AddInstruction32('fcvt.l.s',TInstructionFormat.FPCvtIntFromFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$60,2));
 AddInstruction32('fcvt.lu.s',TInstructionFormat.FPCvtIntFromFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$60,3));

 AddInstruction32('fcvt.w.d',TInstructionFormat.FPCvtIntFromFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$61,0));
 AddInstruction32('fcvt.wu.d',TInstructionFormat.FPCvtIntFromFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$61,1));
 AddInstruction32('fcvt.l.d',TInstructionFormat.FPCvtIntFromFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$61,2));
 AddInstruction32('fcvt.lu.d',TInstructionFormat.FPCvtIntFromFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$61,3));
 AddInstruction32('fcvtmod.w.d',TInstructionFormat.FPCvtIntFromFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$61,8));
 AddInstruction32('fcvt.w.h',TInstructionFormat.FPCvtIntFromFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$62,0));
 AddInstruction32('fcvt.wu.h',TInstructionFormat.FPCvtIntFromFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$62,1));
 AddInstruction32('fcvt.l.h',TInstructionFormat.FPCvtIntFromFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$62,2));
 AddInstruction32('fcvt.lu.h',TInstructionFormat.FPCvtIntFromFP,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$62,3));

 AddInstruction32('fcvt.s.w',TInstructionFormat.FPCvtFPFromInt,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$68,0));
 AddInstruction32('fcvt.s.wu',TInstructionFormat.FPCvtFPFromInt,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$68,1));
 AddInstruction32('fcvt.s.l',TInstructionFormat.FPCvtFPFromInt,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$68,2));
 AddInstruction32('fcvt.s.lu',TInstructionFormat.FPCvtFPFromInt,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$68,3));

 AddInstruction32('fcvt.d.w',TInstructionFormat.FPCvtFPFromInt,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$69,0));
 AddInstruction32('fcvt.d.wu',TInstructionFormat.FPCvtFPFromInt,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$69,1));
 AddInstruction32('fcvt.d.l',TInstructionFormat.FPCvtFPFromInt,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$69,2));
 AddInstruction32('fcvt.d.lu',TInstructionFormat.FPCvtFPFromInt,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$69,3));
 AddInstruction32('fcvt.h.w',TInstructionFormat.FPCvtFPFromInt,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$6a,0));
 AddInstruction32('fcvt.h.wu',TInstructionFormat.FPCvtFPFromInt,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$6a,1));
 AddInstruction32('fcvt.h.l',TInstructionFormat.FPCvtFPFromInt,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$6a,2));
 AddInstruction32('fcvt.h.lu',TInstructionFormat.FPCvtFPFromInt,MaskOpcodeFunct7Rs2,ValueOpFpRs2(OpcodeOpFP,$6a,3));

 AddInstruction32('fmv.x.w',TInstructionFormat.FPMoveToInt,MaskOpcodeFunct7Rs2Funct3,ValueOpFpFunct3Rs2(OpcodeOpFP,$70,0,0));
 AddInstruction32('fclass.s',TInstructionFormat.FPClass,MaskOpcodeFunct7Rs2Funct3,ValueOpFpFunct3Rs2(OpcodeOpFP,$70,1,0));
 AddInstruction32('fmv.x.d',TInstructionFormat.FPMoveToInt,MaskOpcodeFunct7Rs2Funct3,ValueOpFpFunct3Rs2(OpcodeOpFP,$71,0,0));
 AddInstruction32('fclass.d',TInstructionFormat.FPClass,MaskOpcodeFunct7Rs2Funct3,ValueOpFpFunct3Rs2(OpcodeOpFP,$71,1,0));
 AddInstruction32('fmv.x.h',TInstructionFormat.FPMoveToInt,MaskOpcodeFunct7Rs2Funct3,ValueOpFpFunct3Rs2(OpcodeOpFP,$72,0,0));
 AddInstruction32('fclass.h',TInstructionFormat.FPClass,MaskOpcodeFunct7Rs2Funct3,ValueOpFpFunct3Rs2(OpcodeOpFP,$72,1,0));

 AddInstruction32('fmv.w.x',TInstructionFormat.FPMoveFromInt,MaskOpcodeFunct7Rs2Funct3,ValueOpFpFunct3Rs2(OpcodeOpFP,$78,0,0));
 AddInstruction32('fli.s',TInstructionFormat.FPLoadImm,MaskOpcodeFunct7Rs2Funct3,ValueOpFpFunct3Rs2(OpcodeOpFP,$78,0,1));
 AddInstruction32('fmv.d.x',TInstructionFormat.FPMoveFromInt,MaskOpcodeFunct7Rs2Funct3,ValueOpFpFunct3Rs2(OpcodeOpFP,$79,0,0));
 AddInstruction32('fli.d',TInstructionFormat.FPLoadImm,MaskOpcodeFunct7Rs2Funct3,ValueOpFpFunct3Rs2(OpcodeOpFP,$79,0,1));
 AddInstruction32('fmv.h.x',TInstructionFormat.FPMoveFromInt,MaskOpcodeFunct7Rs2Funct3,ValueOpFpFunct3Rs2(OpcodeOpFP,$7a,0,0));
 AddInstruction32('fli.h',TInstructionFormat.FPLoadImm,MaskOpcodeFunct7Rs2Funct3,ValueOpFpFunct3Rs2(OpcodeOpFP,$7a,0,1));

 //////////////////////////////////////////////////////////////////////////////
 // Compressed                                                               //
 //////////////////////////////////////////////////////////////////////////////
 AddInstruction16('c.addi4spn',TCompressedFormat.CIW,TRegisterKind.Integer,MaskCompressedBase,ValueCompressedBase(0,0));
 AddInstruction16('c.fld',TCompressedFormat.CLD,TRegisterKind.Float,MaskCompressedBase,ValueCompressedBase(1,0));
 AddInstruction16('c.lw',TCompressedFormat.CLW,TRegisterKind.Integer,MaskCompressedBase,ValueCompressedBase(2,0));
 AddInstruction16('c.ld',TCompressedFormat.CLD,TRegisterKind.Integer,MaskCompressedBase,ValueCompressedBase(3,0));

 Mask:=MaskCompressedBase or $1c00;
 Value:=ValueCompressedBase(4,0);
 AddInstruction16('c.lbu',TCompressedFormat.ZcbLbu,TRegisterKind.Integer,Mask,Value);
 AddInstruction16('c.lh',TCompressedFormat.ZcbLh,TRegisterKind.Integer,Mask or $0040,Value or (TPasRISCVUInt32(1) shl 10) or $0040);
 AddInstruction16('c.lhu',TCompressedFormat.ZcbLhu,TRegisterKind.Integer,Mask or $0040,Value or (TPasRISCVUInt32(1) shl 10));
 AddInstruction16('c.sbu',TCompressedFormat.ZcbSbu,TRegisterKind.Integer,Mask,Value or (TPasRISCVUInt32(2) shl 10));
 AddInstruction16('c.sh',TCompressedFormat.ZcbSh,TRegisterKind.Integer,Mask or $0040,Value or (TPasRISCVUInt32(3) shl 10));

 AddInstruction16('c.fsd',TCompressedFormat.CSD,TRegisterKind.Float,MaskCompressedBase,ValueCompressedBase(5,0));
 AddInstruction16('c.sw',TCompressedFormat.CSW,TRegisterKind.Integer,MaskCompressedBase,ValueCompressedBase(6,0));
 AddInstruction16('c.sd',TCompressedFormat.CSD,TRegisterKind.Integer,MaskCompressedBase,ValueCompressedBase(7,0));

 AddInstruction16('c.nop',TCompressedFormat.None,TRegisterKind.Integer,TPasRISCVUInt32($ffff),TPasRISCVUInt32($0001));
 AddInstruction16('c.addi',TCompressedFormat.CI,TRegisterKind.Integer,MaskCompressedBase,ValueCompressedBase(0,1));
 AddInstruction16('c.addiw',TCompressedFormat.CI,TRegisterKind.Integer,MaskCompressedBase,ValueCompressedBase(1,1));
 AddInstruction16('c.li',TCompressedFormat.CI,TRegisterKind.Integer,MaskCompressedBase,ValueCompressedBase(2,1));
 AddInstruction16('c.addi16sp',TCompressedFormat.CIAddi16sp,TRegisterKind.Integer,MaskCompressedBase or MaskCompressedRd,ValueCompressedBase(3,1) or (TPasRISCVUInt32(2) shl 7));
 AddInstruction16('c.lui',TCompressedFormat.CILui,TRegisterKind.Integer,MaskCompressedBase,ValueCompressedBase(3,1));

 // Zcmop
 for Index:=0 to 7 do begin
  AddInstruction16('c.mop.'+IntToStr((Index shl 1) or 1),TCompressedFormat.None,TRegisterKind.Integer,
                   TPasRISCVUInt32($ffff),
                   TPasRISCVUInt32($6081) or TPasRISCVUInt32(Index shl 8));
 end;

 Mask:=MaskCompressedBase or MaskCompressedFunct2;
 Value:=ValueCompressedBase(4,1);
 AddInstruction16('c.srli',TCompressedFormat.CIShiftPrime,TRegisterKind.Integer,Mask,Value);
 AddInstruction16('c.srai',TCompressedFormat.CIShiftPrime,TRegisterKind.Integer,Mask,Value or (TPasRISCVUInt32(1) shl 10));
 AddInstruction16('c.andi',TCompressedFormat.CIPrime,TRegisterKind.Integer,Mask,Value or (TPasRISCVUInt32(2) shl 10));

 Mask:=MaskCompressedBase or MaskCompressedFunct2 or MaskCompressedBit12 or MaskCompressedBits6_5;
 Value:=ValueCompressedBase(4,1) or (TPasRISCVUInt32(3) shl 10);
 AddInstruction16('c.sub',TCompressedFormat.CA,TRegisterKind.Integer,Mask,Value);
 AddInstruction16('c.xor',TCompressedFormat.CA,TRegisterKind.Integer,Mask,Value or (TPasRISCVUInt32(1) shl 5));
 AddInstruction16('c.or',TCompressedFormat.CA,TRegisterKind.Integer,Mask,Value or (TPasRISCVUInt32(2) shl 5));
 AddInstruction16('c.and',TCompressedFormat.CA,TRegisterKind.Integer,Mask,Value or (TPasRISCVUInt32(3) shl 5));

 Value:=Value or MaskCompressedBit12;
 AddInstruction16('c.subw',TCompressedFormat.CA,TRegisterKind.Integer,Mask,Value);
 AddInstruction16('c.addw',TCompressedFormat.CA,TRegisterKind.Integer,Mask,Value or (TPasRISCVUInt32(1) shl 5));
 AddInstruction16('c.mul',TCompressedFormat.CA,TRegisterKind.Integer,Mask,Value or (TPasRISCVUInt32(2) shl 5));

 Mask:=MaskCompressedBase or MaskCompressedFunct2 or MaskCompressedBit12 or MaskCompressedBits6_5 or MaskCompressedBits4_2;
 Value:=ValueCompressedBase(4,1) or (TPasRISCVUInt32(3) shl 10) or MaskCompressedBit12 or (TPasRISCVUInt32(3) shl 5);
 AddInstruction16('c.zext.b',TCompressedFormat.RDPrime,TRegisterKind.Integer,Mask,Value or (TPasRISCVUInt32(0) shl 2));
 AddInstruction16('c.sext.b',TCompressedFormat.RDPrime,TRegisterKind.Integer,Mask,Value or (TPasRISCVUInt32(1) shl 2));
 AddInstruction16('c.zext.h',TCompressedFormat.RDPrime,TRegisterKind.Integer,Mask,Value or (TPasRISCVUInt32(2) shl 2));
 AddInstruction16('c.sext.w',TCompressedFormat.RDPrime,TRegisterKind.Integer,Mask,Value or (TPasRISCVUInt32(3) shl 2));
 AddInstruction16('c.zext.w',TCompressedFormat.RDPrime,TRegisterKind.Integer,Mask,Value or (TPasRISCVUInt32(4) shl 2));
 AddInstruction16('c.not',TCompressedFormat.RDPrime,TRegisterKind.Integer,Mask,Value or (TPasRISCVUInt32(5) shl 2));

 AddInstruction16('c.j',TCompressedFormat.CJ,TRegisterKind.Integer,MaskCompressedBase,ValueCompressedBase(5,1));
 AddInstruction16('c.beqz',TCompressedFormat.CB,TRegisterKind.Integer,MaskCompressedBase,ValueCompressedBase(6,1));
 AddInstruction16('c.bnez',TCompressedFormat.CB,TRegisterKind.Integer,MaskCompressedBase,ValueCompressedBase(7,1));

 AddInstruction16('c.slli',TCompressedFormat.CIShift,TRegisterKind.Integer,MaskCompressedBase,ValueCompressedBase(0,2));
 AddInstruction16('c.fldsp',TCompressedFormat.CLDSP,TRegisterKind.Float,MaskCompressedBase,ValueCompressedBase(1,2));
 AddInstruction16('c.lwsp',TCompressedFormat.CLWSP,TRegisterKind.Integer,MaskCompressedBase,ValueCompressedBase(2,2));
 AddInstruction16('c.ldsp',TCompressedFormat.CLDSP,TRegisterKind.Integer,MaskCompressedBase,ValueCompressedBase(3,2));

 AddInstruction16('c.ebreak',TCompressedFormat.None,TRegisterKind.Integer,TPasRISCVUInt32($ffff),TPasRISCVUInt32($9002));
 Mask:=MaskCompressedBase or MaskCompressedBit12 or MaskCompressedRs2;
 Value:=ValueCompressedBase(4,2);
 AddInstruction16('c.jr',TCompressedFormat.CJR,TRegisterKind.Integer,Mask,Value);
 AddInstruction16('c.mv',TCompressedFormat.CR,TRegisterKind.Integer,MaskCompressedBase or MaskCompressedBit12,ValueCompressedBase(4,2));
 AddInstruction16('c.jalr',TCompressedFormat.CJR,TRegisterKind.Integer,Mask,Value or MaskCompressedBit12);
 AddInstruction16('c.add',TCompressedFormat.CR,TRegisterKind.Integer,MaskCompressedBase or MaskCompressedBit12,ValueCompressedBase(4,2) or MaskCompressedBit12);

 // Zihintntl: Compressed NTL hints (encoded as C.ADD x0, xN)
 AddInstruction16('c.ntl.p1',TCompressedFormat.None,TRegisterKind.Integer,TPasRISCVUInt32($ffff),TPasRISCVUInt32($900a));
 AddInstruction16('c.ntl.pall',TCompressedFormat.None,TRegisterKind.Integer,TPasRISCVUInt32($ffff),TPasRISCVUInt32($900e));
 AddInstruction16('c.ntl.s1',TCompressedFormat.None,TRegisterKind.Integer,TPasRISCVUInt32($ffff),TPasRISCVUInt32($9012));
 AddInstruction16('c.ntl.all',TCompressedFormat.None,TRegisterKind.Integer,TPasRISCVUInt32($ffff),TPasRISCVUInt32($9016));

 AddInstruction16('c.fsdsp',TCompressedFormat.CSDSP,TRegisterKind.Float,MaskCompressedBase,ValueCompressedBase(5,2));
 AddInstruction16('c.swsp',TCompressedFormat.CSWSP,TRegisterKind.Integer,MaskCompressedBase,ValueCompressedBase(6,2));
 AddInstruction16('c.sdsp',TCompressedFormat.CSDSP,TRegisterKind.Integer,MaskCompressedBase,ValueCompressedBase(7,2));

 SetLength(fInstructions32,fCountInstructions32);
 SetLength(fInstructions16,fCountInstructions16);
end;

procedure TPasRISCV.TInstructionSetArchitecture.BuildIndexes;
var InstructionIndex:TPasRISCVSizeInt;
    Opcode:TPasRISCVUInt32;
    Quadrant:TPasRISCVUInt32;
    Funct3:TPasRISCVUInt32;
    IndexCount:TPasRISCVSizeInt;
begin
 for Opcode:=Low(fOpcodeIndex32) to High(fOpcodeIndex32) do begin
  SetLength(fOpcodeIndex32[Opcode],0);
 end;
 for Quadrant:=Low(fCompressedIndex16) to High(fCompressedIndex16) do begin
  for Funct3:=Low(fCompressedIndex16[Quadrant]) to High(fCompressedIndex16[Quadrant]) do begin
   SetLength(fCompressedIndex16[Quadrant][Funct3],0);
  end;
 end;
 for InstructionIndex:=0 to length(fInstructions32)-1 do begin
  Opcode:=fInstructions32[InstructionIndex].Value and $7f;
  IndexCount:=length(fOpcodeIndex32[Opcode]);
  SetLength(fOpcodeIndex32[Opcode],IndexCount+1);
  fOpcodeIndex32[Opcode][IndexCount]:=InstructionIndex;
 end;
 for InstructionIndex:=0 to length(fInstructions16)-1 do begin
  Quadrant:=fInstructions16[InstructionIndex].Value and 3;
  Funct3:=(fInstructions16[InstructionIndex].Value shr 13) and 7;
  IndexCount:=length(fCompressedIndex16[Quadrant][Funct3]);
  SetLength(fCompressedIndex16[Quadrant][Funct3],IndexCount+1);
  fCompressedIndex16[Quadrant][Funct3][IndexCount]:=InstructionIndex;
 end;
end;

function TPasRISCV.TInstructionSetArchitecture.FindInstruction32(const aInstruction:TPasRISCVUInt32;out aInstructionDefinition:TInstruction):Boolean;
var Opcode:TPasRISCVUInt32;
    Index:TPasRISCVSizeInt;
    InstructionIndex:TPasRISCVSizeInt;
    InstructionIndices:TInstructionIndexList;
begin
 Opcode:=aInstruction and $7f;
 InstructionIndices:=fOpcodeIndex32[Opcode];
 for Index:=0 to length(InstructionIndices)-1 do begin
  InstructionIndex:=InstructionIndices[Index];
  if (aInstruction and fInstructions32[InstructionIndex].Mask)=fInstructions32[InstructionIndex].Value then begin
   aInstructionDefinition:=fInstructions32[InstructionIndex];
   result:=true;
   exit;
  end;
 end;
 result:=false;
end;

function TPasRISCV.TInstructionSetArchitecture.FindInstruction16(const aInstruction:TPasRISCVUInt32;out aInstructionDefinition:TCompressedInstruction):Boolean;
var Quadrant:TPasRISCVUInt32;
    Funct3:TPasRISCVUInt32;
    Index:TPasRISCVSizeInt;
    InstructionIndex:TPasRISCVSizeInt;
    InstructionIndices:TInstructionIndexList;
begin
 Quadrant:=aInstruction and 3;
 Funct3:=(aInstruction shr 13) and 7;
 InstructionIndices:=fCompressedIndex16[Quadrant][Funct3];
 for Index:=0 to length(InstructionIndices)-1 do begin
  InstructionIndex:=InstructionIndices[Index];
  if (aInstruction and fInstructions16[InstructionIndex].Mask)=fInstructions16[InstructionIndex].Value then begin
   aInstructionDefinition:=fInstructions16[InstructionIndex];
   result:=true;
   exit;
  end;
 end;
 result:=false;
end;

{ TPasRISCV.TFDT.TFDTProperty }

constructor TPasRISCV.TFDT.TFDTProperty.Create;
begin
 inherited Create;
 fName:='';
 fData:=nil;
 fLen:=0;
end;

destructor TPasRISCV.TFDT.TFDTProperty.Destroy;
begin
 fName:='';
 fData:=nil;
 inherited Destroy;
end;

{ TPasRISCV.TFDT.TFDTNode }

constructor TPasRISCV.TFDT.TFDTNode.Create(const aFDT:TFDT;const aName:TPasRISCVRawByteString);
begin
 inherited Create;
 fFDT:=aFDT;
 fName:=aName;
 fParent:=nil;
 fProperties:=nil;
 fCountProperties:=0;
 fNodes:=nil;
 fCountNodes:=0;
 fPHandle:=0;
end;

constructor TPasRISCV.TFDT.TFDTNode.Create(const aFDT:TFDT;const aName:TPasRISCVRawByteString;const aAddress:TPasRISCVUInt64);
begin
 inherited Create;
 fFDT:=aFDT;
 fName:=aName+'@'+FDTHex64(aAddress);
 fParent:=nil;
 fProperties:=nil;
 fCountProperties:=0;
 fNodes:=nil;
 fCountNodes:=0;
 fPHandle:=0;
end;

destructor TPasRISCV.TFDT.TFDTNode.Destroy;
var Index:TPasRISCVSizeInt;
begin

 fName:='';

 for Index:=0 to fCountProperties-1 do begin
  FreeAndNil(fProperties[Index]);
 end;
 fProperties:=nil;

 for Index:=0 to fCountNodes-1 do begin
  FreeAndNil(fNodes[Index]);
 end;
 fNodes:=nil;

 inherited Destroy;

end;

procedure TPasRISCV.TFDT.TFDTNode.AddChild(const aNode:TFDTNode);
var Index:TPasRISCVSizeInt;
begin
 Index:=fCountNodes;
 inc(fCountNodes);
 if length(fNodes)<fCountNodes then begin
  SetLength(fNodes,fCountNodes+((fCountNodes+1) shr 1));
 end;
 fNodes[Index]:=aNode;
end;

function TPasRISCV.TFDT.TFDTNode.FindNode(const aName:TPasRISCVRawByteString):TFDTNode;
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to fCountNodes-1 do begin
  if fNodes[Index].fName=aName then begin
   result:=fNodes[Index];
   exit;
  end;
 end;
 result:=nil;
end;

function TPasRISCV.TFDT.TFDTNode.FindNode(const aName:TPasRISCVRawByteString;const aAddress:TPasRISCVUInt64):TFDTNode;
var Index:TPasRISCVSizeInt;
    CompareName:TPasRISCVRawByteString;
begin
 CompareName:=aName+'@'+FDTHex64(aAddress);
 for Index:=0 to fCountNodes-1 do begin
  if fNodes[Index].fName=CompareName then begin
   result:=fNodes[Index];
   exit;
  end;
 end;
 result:=nil;
end;

function TPasRISCV.TFDT.TFDTNode.FindNodeAny(const aName:TPasRISCVRawByteString):TFDTNode;
var Index:TPasRISCVSizeInt;
    CompareName:TPasRISCVRawByteString;
begin
 CompareName:=aName+'@';
 for Index:=0 to fCountNodes-1 do begin
  if pos(CompareName,fNodes[Index].fName)=1 then begin
   result:=fNodes[Index];
   exit;
  end;
 end;
 result:=nil;
end;

function TPasRISCV.TFDT.TFDTNode.GetNewPHandle:TPasRISCVUInt32;
begin
 inc(fFDT.fPHandleCounter);
 result:=fFDT.fPHandleCounter;
end;

function TPasRISCV.TFDT.TFDTNode.GetPHandle:TPasRISCVUInt32;
begin
 if length(fName)>0 then begin
  if TPasRISCV.TFDT.IsIllegalPHandle(fPHandle) then begin
   fPHandle:=GetNewPHandle;
   AddPropertyU32('phandle',fPHandle);
  end;
  result:=fPHandle;
 end else begin
  result:=0;
 end;
end;

function TPasRISCV.TFDT.TFDTNode.AddProperty(const aName:TPasRISCVRawByteString;const aData;const aSize:TPasRISCVUInt32):TPasRISCV.TFDT.TFDTProperty;
var Index:TPasRISCVSizeInt;
begin
 Index:=fCountProperties;
 inc(fCountProperties);
 if length(fProperties)<fCountProperties then begin
  SetLength(fProperties,fCountProperties+((fCountProperties+1) shr 1));
 end;
 fProperties[Index]:=TPasRISCV.TFDT.TFDTProperty.Create;
 result:=fProperties[Index];
 result.fName:=aName;
 result.fData:=nil;
 if aSize>0 then begin
  SetLength(result.fData,aSize);
  Move(aData,result.fData[0],aSize);
  result.fLen:=aSize;
 end else begin
  result.fLen:=0;
 end;
end;

function TPasRISCV.TFDT.TFDTNode.AddPropertyU32(const aName:TPasRISCVRawByteString;const aValue:TPasRISCVUInt32):TFDTProperty;
var Data:TPasRISCVUInt32;
begin
{$ifdef LITTLE_ENDIAN}
 Data:=(aValue shr 24) or ((aValue shr 8) and $ff00) or ((aValue shl 8) and $ff0000) or (aValue shl 24);
{$else}
 Data:=aValue;
{$endif}
 result:=AddProperty(aName,Data,SizeOf(TPasRISCVUInt32));
end;

function TPasRISCV.TFDT.TFDTNode.AddPropertyU64(const aName:TPasRISCVRawByteString;const aValue:TPasRISCVUInt64):TFDTProperty;
var Data:TPasRISCVUInt64;
begin
{$ifdef LITTLE_ENDIAN}
 Data:=(aValue shr 56) or ((aValue shr 40) and $ff00) or ((aValue shr 24) and $ff0000) or ((aValue shr 8) and $ff000000) or ((aValue shl 8) and $ff00000000) or ((aValue shl 24) and $ff0000000000) or ((aValue shl 40) and $ff000000000000) or (aValue shl 56);
{$else}
 Data:=aValue;
{$endif}
 result:=AddProperty(aName,Data,SizeOf(TPasRISCVUInt64));
end;

function TPasRISCV.TFDT.TFDTNode.AddPropertyCells(const aName:TPasRISCVRawByteString;const aCells:PPasRISCVUInt32;const aCountCells:TPasRISCVSizeInt):TFDTProperty;
var Index:TPasRISCVSizeInt;
    Data:TPasRISCVUInt32DynamicArray;
    Value:TPasRISCVUInt32;
    Cell:PPasRISCVUInt32;
begin
 Data:=nil;
 try
  SetLength(Data,aCountCells);
  Cell:=aCells;
  for Index:=0 to aCountCells-1 do begin
   Value:=Cell^;
   inc(Cell);
{$ifdef LITTLE_ENDIAN}
   Data[Index]:=(Value shr 24) or ((Value shr 8) and $ff00) or ((Value shl 8) and $ff0000) or (Value shl 24);
{$else}
   Data[Index]:=Value;
{$endif}
  end;
  result:=AddProperty(aName,Data[0],aCountCells*SizeOf(TPasRISCVUInt32));
 finally
  Data:=nil;
 end;
end;

function TPasRISCV.TFDT.TFDTNode.AddPropertyString(const aName,aValue:TPasRISCVRawByteString):TFDTProperty;
var Value:TPasRISCVRawByteString;
begin
 Value:=aValue+#0; // Null terminated
 result:=AddProperty(aName,Value[1],length(Value));
end;

function TPasRISCV.TFDT.TFDTNode.AddPropertyReg(const aName:TPasRISCVRawByteString;const aBegin,aSize:TPasRISCVUInt64):TFDTProperty;
var Data:array[0..1] of TPasRISCVUInt64;
begin
{$ifdef LITTLE_ENDIAN}
 Data[0]:=(aBegin shr 56) or ((aBegin shr 40) and $ff00) or ((aBegin shr 24) and $ff0000) or ((aBegin shr 8) and $ff000000) or ((aBegin shl 8) and $ff00000000) or ((aBegin shl 24) and $ff0000000000) or ((aBegin shl 40) and $ff000000000000) or (aBegin shl 56);
 Data[1]:=(aSize shr 56) or ((aSize shr 40) and $ff00) or ((aSize shr 24) and $ff0000) or ((aSize shr 8) and $ff000000) or ((aSize shl 8) and $ff00000000) or ((aSize shl 24) and $ff0000000000) or ((aSize shl 40) and $ff000000000000) or (aSize shl 56);
{$else}
 Data[0]:=aBegin;
 Data[1]:=aSize;
{$endif}
 result:=AddProperty(aName,Data[0],SizeOf(Data));
end;

function TPasRISCV.TFDT.TFDTNode.DeleteProperty(const aName:TPasRISCVRawByteString):Boolean;
var Index:TPasRISCVSizeInt;
    Property_:TPasRISCV.TFDT.TFDTProperty;
begin
 for Index:=0 to fCountProperties-1 do begin
  if fProperties[Index].fName=aName then begin
   Property_:=fProperties[Index];
   try
    fProperties[Index]:=nil;
    if Index<fCountProperties-1 then begin
     Move(fProperties[Index+1],fProperties[Index],(fCountProperties-Index-1)*SizeOf(TFDTProperty));
    end;
    dec(fCountProperties);
   finally
    FreeAndNil(Property_);
   end;
   result:=true;
   exit;
  end;
 end;
 result:=false;
end;

function TPasRISCV.TFDT.TFDTNode.FindProperty(const aName:TPasRISCVRawByteString):TFDTProperty;
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to fCountProperties-1 do begin
  if fProperties[Index].fName=aName then begin
   result:=fProperties[Index];
   exit;
  end;
 end;
 result:=nil;
end;

procedure TPasRISCV.TFDT.TFDTNode.GetTreeSize(var aSize:TFDTSizeDescriptor);
var NameLen:TPasRISCVSizeInt;
    Index:TPasRISCVSizeInt;
    Property_:TPasRISCV.TFDT.TFDTProperty;
    Node:TPasRISCV.TFDT.TFDTNode;
begin

 NameLen:=RoundUpTo32(length(fName)+1,SizeOf(TPasRISCVUInt32));
 inc(aSize.StructSize,SizeOf(TPasRISCVUInt32)+NameLen);

 for Index:=0 to fCountProperties-1 do begin
  Property_:=fProperties[Index];
  inc(aSize.StructSize,SizeOf(TPasRISCVUInt32)*3);
  inc(aSize.StructSize,RoundUpTo32(Property_.fLen,SizeOf(TPasRISCVUInt32)));
  inc(aSize.StringsSize,RoundUpTo32(length(Property_.fName)+1,SizeOf(TPasRISCVUInt32)));
 end;

 for Index:=0 to fCountNodes-1 do begin
  Node:=fNodes[Index];
  Node.GetTreeSize(aSize);
 end;

 inc(aSize.StructSize,SizeOf(TPasRISCVUInt32));

end;

procedure TPasRISCV.TFDT.TFDTNode.SerializeToStream(const aFDT:TFDT);
 procedure WriteBigEndian32(const aValue:TPasRISCVUInt32);
 var Value:TPasRISCVUInt32;
 begin
 {$ifdef LITTLE_ENDIAN}
  Value:=(aValue shr 24) or ((aValue shr 8) and $ff00) or ((aValue shl 8) and $ff0000) or (aValue shl 24);
 {$else}
  Value:=aValue;
 {$endif}
  aFDT.fMemoryStream.Seek(aFDT.fStructOffset,soBeginning);
  aFDT.fMemoryStream.WriteBuffer(Value,SizeOf(TPasRISCVUInt32));
  inc(aFDT.fStructOffset,SizeOf(TPasRISCVUInt32));
 end;
 procedure WriteString(const aValue:TPasRISCVRawByteString);
 var Value:TPasRISCVRawByteString;
 begin
  Value:=aValue+#0;
  aFDT.fMemoryStream.Seek(aFDT.fStructOffset,soBeginning);
  aFDT.fMemoryStream.WriteBuffer(Value[1],length(Value));
  aFDT.fStructOffset:=RoundUpTo32(aFDT.fStructOffset+length(Value),SizeOf(TPasRISCVUInt32));
 end;
 procedure WriteData(const aValue;const aSize:TPasRISCVUInt32);
 begin
  aFDT.fMemoryStream.Seek(aFDT.fStructOffset,soBeginning);
  aFDT.fMemoryStream.WriteBuffer(aValue,aSize);
  aFDT.fStructOffset:=RoundUpTo32(aFDT.fStructOffset+aSize,SizeOf(TPasRISCVUInt32));
 end;
 procedure WriteName(const aValue:TPasRISCVRawByteString);
 var Value:TPasRISCVRawByteString;
 begin
  Value:=aValue+#0;
  aFDT.fMemoryStream.Seek(aFDT.fStringsOffset,soBeginning);
  aFDT.fMemoryStream.WriteBuffer(Value[1],length(Value));
  aFDT.fStringsOffset:=RoundUpTo32(aFDT.fStringsOffset+length(Value),SizeOf(TPasRISCVUInt32));
 end;
var NameLen:TPasRISCVSizeInt;
    Index:TPasRISCVSizeInt;
    Property_:TPasRISCV.TFDT.TFDTProperty;
    Node:TPasRISCV.TFDT.TFDTNode;
begin

 WriteBigEndian32(FDT_BEGIN_NODE);
 WriteString(fName);

 for Index:=0 to fCountProperties-1 do begin
  Property_:=fProperties[Index];
  WriteBigEndian32(FDT_PROP);
  WriteBigEndian32(Property_.fLen);
  WriteBigEndian32(aFDT.fStringsOffset-aFDT.fStringsBegin);
  WriteData(Property_.fData[0],Property_.fLen);
  WriteName(Property_.fName);
 end;

 for Index:=0 to fCountNodes-1 do begin
  Node:=fNodes[Index];
  Node.SerializeToStream(aFDT);
 end;

 WriteBigEndian32(FDT_END_NODE);

end;

procedure TPasRISCV.TFDT.WriteBigEndian32(const aValue:TPasRISCVUInt32);
var Value:TPasRISCVUInt32;
begin
{$ifdef LITTLE_ENDIAN}
 Value:=(aValue shr 24) or ((aValue shr 8) and $ff00) or ((aValue shl 8) and $ff0000) or (aValue shl 24);
{$else}
 Value:=aValue;
{$endif}
 fMemoryStream.WriteBuffer(Value,SizeOf(TPasRISCVUInt32));
end;

procedure TPasRISCV.TFDT.SerializeToStream(const aStream:TStream);
var SizeDescriptor:TFDTSizeDescriptor;
begin

 SizeDescriptor:=GetTreeSize;
 inc(SizeDescriptor.StructSize,SizeOf(TPasRISCVUInt32)); // FDT_END

 fMemoryStream:=TMemoryStream.Create;
 try

  fBufferSize:=FDT_HDR_SIZE+FDT_RSV_SIZE+SizeDescriptor.StructSize;
  fReservedOffset:=FDT_HDR_SIZE;
  fStructOffset:=FDT_HDR_SIZE+FDT_RSV_SIZE;
  fStringsBegin:=fBufferSize;
  fStringsOffset:=fStringsBegin;
  inc(fBufferSize,SizeDescriptor.StringsSize);

  fMemoryStream.SetSize(fBufferSize);

  FillChar(fMemoryStream.Memory^,fBufferSize,#0);

  WriteBigEndian32(FDT_MAGIC);
  WriteBigEndian32(fBufferSize);
  WriteBigEndian32(fStructOffset);
  WriteBigEndian32(fStringsOffset);
  WriteBigEndian32(fReservedOffset);
  WriteBigEndian32(FDT_VERSION);
  WriteBigEndian32(FDT_COMP_VERSION);
  WriteBigEndian32(0); // boot_cpuid
  WriteBigEndian32(SizeDescriptor.StringsSize);
  WriteBigEndian32(SizeDescriptor.StructSize);

  fRoot.SerializeToStream(self);

  aStream.Seek(fStructOffset,soBeginning);
  WriteBigEndian32(FDT_END);
  inc(fStructOffset,SizeOf(TPasRISCVUInt32));

  aStream.Seek(0,soBeginning);
  fMemoryStream.Seek(0,soBeginning);
  aStream.CopyFrom(fMemoryStream,fMemoryStream.Size);

 finally
  FreeAndNil(fMemoryStream);
 end;

end;

{ TPasRISCV.TTimer }

procedure TPasRISCV.TTimer.Rebase(const aTime:TPasRISCVUInt64);
begin
 TPasMPInterlocked.Write(fBeginTime,GetCurrentFrequencyTime(TPasMPInterlocked.Read(fFrequency))-aTime);
end;

procedure TPasRISCV.TTimer.Initialize(const aFrequency:TPasRISCVUInt64);
begin
 fFrequency:=aFrequency;
 Rebase(0);
end;

function TPasRISCV.TTimer.Get:TPasRISCVUInt64;
begin
 result:=GetCurrentFrequencyTime(fFrequency)-TPasMPInterlocked.Read(fBeginTime);
end;

{ TPasRISCV.TTimeCmp }

procedure TPasRISCV.TTimeCmp.Initialize(const aTimer:TPasRISCV.PTimer);
begin
 fTimer:=aTimer;
 fTimeCmp:=TPasRISCVUInt64($ffffffffffffffff);
end;

function TPasRISCV.TTimeCmp.GetTimeCmp:TPasMPUInt64;
begin
 result:=TPasMPInterlocked.Read(fTimeCmp);
end;

procedure TPasRISCV.TTimeCmp.SetTimeCmp(aTimeCmp:TPasMPUInt64);
begin
 TPasMPInterlocked.Write(fTimeCmp,aTimeCmp);
end;

function TPasRISCV.TTimeCmp.Pending:Boolean;
begin
 result:=fTimer^.Get>=TPasMPInterlocked.Read(fTimeCmp);
end;

function TPasRISCV.TTimeCmp.Delay:TPasMPUInt64;
var Timer,TimeCmp:TPasMPUInt64;
begin
 Timer:=fTimer^.Get;
 TimeCmp:=TPasMPInterlocked.Read(fTimeCmp);
 if Timer<TimeCmp then begin
  result:=TimeCmp-Timer;
 end else begin
  result:=0;
 end;
end;

function TPasRISCV.TTimeCmp.DelayNS:TPasMPUInt64;
var Timer,TimeCmp:TPasMPUInt64;
begin
 Timer:=fTimer^.Get;
 TimeCmp:=TPasMPInterlocked.Read(fTimeCmp);
 if Timer<TimeCmp then begin
  result:=TimeCmp-Timer;
  if result>TPasMPUInt64($400000000) then begin
   result:=TPasMPUInt64($400000000);
  end;
  result:=(result*TPasMPUInt64(1000000000)) div fTimer.fFrequency;
 end else begin
  result:=0;
 end;
end;

{ TPasRISCV.TThreadTimer }

constructor TPasRISCV.TThreadTimer.Create(const aOnTimer:TThreadTimerEvent);
begin
 fInterval:=CLOCK_FREQUENCY;
 fEvent:=TPasMPEvent.Create(nil,false,false,'');
 fOnTimer:=aOnTimer;
 inherited Create(false);
end;

destructor TPasRISCV.TThreadTimer.Destroy;
begin
 Shutdown;
 FreeAndNil(fEvent);
 inherited Destroy;
end;

procedure TPasRISCV.TThreadTimer.Shutdown;
begin
 if not Finished then begin
  Terminate;
  fEvent.SetEvent;
  WaitFor;
 end;
end;

procedure TPasRISCV.TThreadTimer.Execute;
begin
 NameThreadForDebugging('TPasRISCV.TThreadTimer');
 while not Terminated do begin
  case fEvent.WaitFor of
   wrSignaled:begin
    if Terminated then begin
     break;
    end else begin
     if fInterval>0 then begin
      WaitTime(fInterval);
     end;
     if assigned(fOnTimer) and (fInterval>0) then begin
      fOnTimer;
     end;
    end;
   end;
   else begin
   end;
  end;
 end;
end;

procedure TPasRISCV.TThreadTimer.SetInterval(const aInterval:TPasRISCVUInt64);
begin
 fInterval:=aInterval;
 fEvent.SetEvent;
end;

{ TPasRISCV.TFDT }

constructor TPasRISCV.TFDT.Create;
begin
 inherited Create;
 fPHandleCounter:=0;
 fRoot:=TPasRISCV.TFDT.TFDTNode.Create(self,'');
end;

destructor TPasRISCV.TFDT.Destroy;
begin
 FreeAndNil(fRoot);
 inherited Destroy;
end;

class function TPasRISCV.TFDT.NameWithAddr(const aName:TPasRISCVRawByteString;const aAddress:TPasRISCVUInt64):TPasRISCVRawByteString;
begin
 result:=aName+'@'+FDTHex64(aAddress);
end;

class function TPasRISCV.TFDT.IsIllegalPHandle(const aPHandle:TPasRISCVUInt32):Boolean;
begin
 result:=aPHandle=0;
end;

function TPasRISCV.TFDT.GetTreeSize:TFDTSizeDescriptor;
begin
 result.StructSize:=0;
 result.StringsSize:=0;
 fRoot.GetTreeSize(result);
end;

{ TPasRISCV.TSoundIO }

constructor TPasRISCV.TSoundIO.Create(const aMachine:TPasRISCV);
begin
 inherited Create;
 fMachine:=aMachine;
 fSampleRate:=48000;
 fOnOutputFillBuffer:=nil;
 fOnInputFillBuffer:=nil;
end;

destructor TPasRISCV.TSoundIO.Destroy;
begin
 fOnOutputFillBuffer:=nil;
 fOnInputFillBuffer:=nil;
 inherited Destroy;
end;

procedure TPasRISCV.TSoundIO.OutputFillBuffer(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
begin
 if assigned(fOnOutputFillBuffer) then begin
  fOnOutputFillBuffer(aBuffer,aCount);
 end else begin
  FillChar(aBuffer^,aCount*2*SizeOf(TPasRISCVFloat),#0);
 end;
end;

procedure TPasRISCV.TSoundIO.InputFillBuffer(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
begin
 if assigned(fOnInputFillBuffer) then begin
  fOnInputFillBuffer(aBuffer,aCount);
 end else begin
  FillChar(aBuffer^,aCount*2*SizeOf(TPasRISCVFloat),#0);
 end;
end;

procedure TPasRISCV.TSoundIO.OutputAudioFillBufferCallback(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
begin
 OutputFillBuffer(aBuffer,aCount);
end;

procedure TPasRISCV.TSoundIO.InputAudioFillBufferCallback(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
begin
 InputFillBuffer(aBuffer,aCount);
end;

{ TPasRISCV.TBusDevice }

constructor TPasRISCV.TBusDevice.Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64);
begin
 inherited Create;
 fMachine:=aMachine;
 fBase:=aBase;
 fSize:=aSize;
 fPHandle:=fMachine.AllocatePHandle;
 fUnalignedAccessSupport:=true;
 fMinOpSize:=1;
 fMaxOpSize:=8;
 fSubBusDevices:=nil;
 fCountSubBusDevices:=0;
end;

destructor TPasRISCV.TBusDevice.Destroy;
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to fCountSubBusDevices-1 do begin
  FreeAndNil(fSubBusDevices[Index]);
 end;
 fSubBusDevices:=nil;
 fCountSubBusDevices:=0;
 inherited Destroy;
end;

procedure TPasRISCV.TBusDevice.AddSubBusDevice(const aSubBusDevice:TBusDevice);
var Index:TPasRISCVSizeInt;
begin
 Index:=fCountSubBusDevices;
 inc(fCountSubBusDevices);
 if length(fSubBusDevices)<fCountSubBusDevices then begin
  SetLength(fSubBusDevices,fCountSubBusDevices+((fCountSubBusDevices+1) shr 1)); // Grow by 1.5
 end;
 fSubBusDevices[Index]:=aSubBusDevice;
end;

procedure TPasRISCV.TBusDevice.RemoveSubBusDevice(const aSubBusDevice:TBusDevice);
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to fCountSubBusDevices-1 do begin
  if fSubBusDevices[Index]=aSubBusDevice then begin
   if (Index+1)<fCountSubBusDevices then begin
    fSubBusDevices[Index]:=fSubBusDevices[fCountSubBusDevices-1];
   end;
   fSubBusDevices[fCountSubBusDevices-1]:=nil;
   dec(fCountSubBusDevices);
   exit;
  end;
 end;
end;

function TPasRISCV.TBusDevice.FindSubBusDevice(const aAddress:TPasRISCVUInt64):TPasRISCV.TBusDevice;
var Index:TPasRISCVSizeInt;
    SubBusDevice:TBusDevice;
begin
 for Index:=0 to fCountSubBusDevices-1 do begin
  SubBusDevice:=fSubBusDevices[Index];
  if (SubBusDevice.fBase<=aAddress) and ((aAddress-SubBusDevice.fBase)<SubBusDevice.fSize) then begin
   result:=SubBusDevice;
   exit;
  end;
 end;
 result:=self;
end;

procedure TPasRISCV.TBusDevice.SetBase(const aValue:TPasRISCVUInt64);
begin
 fBase:=aValue;
end;

procedure TPasRISCV.TBusDevice.SetSize(const aValue:TPasRISCVUInt64);
begin
 fSize:=aValue;
end;

procedure TPasRISCV.TBusDevice.SetEnd(const aValue:TPasRISCVUInt64);
begin
 fSize:=(aValue-fBase)+1;
end;

procedure TPasRISCV.TBusDevice.Reset;
begin
end;

function TPasRISCV.TBusDevice.GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
var Index:TPasRISCVSizeInt;
    SubBusDevice:TBusDevice;
begin
 for Index:=0 to fCountSubBusDevices-1 do begin
  SubBusDevice:=fSubBusDevices[Index];
  if (SubBusDevice.fBase<=aAddress) and ((aAddress-SubBusDevice.fBase)<SubBusDevice.fSize) then begin
   result:=SubBusDevice.GetDeviceDirectMemoryAccessPointer(aAddress,aSize,aWrite,aBounce);
   if assigned(result) then begin
    exit;
   end;
  end;
 end;
 result:=nil;
end;

function TPasRISCV.TBusDevice.GetGlobalDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
begin
 result:=fMachine.fBus.GetDirectMemoryAccessPointer(aAddress,aSize,aWrite,aBounce);
end;

function TPasRISCV.TBusDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Index:TPasRISCVSizeInt;
    SubBusDevice:TBusDevice;
begin
 for Index:=0 to fCountSubBusDevices-1 do begin
  SubBusDevice:=fSubBusDevices[Index];
  if (SubBusDevice.fBase<=aAddress) and ((aAddress-SubBusDevice.fBase)<SubBusDevice.fSize) then begin
   result:=SubBusDevice.Load(aAddress,aSize);
   exit;
  end;
 end;
 result:=0;
end;

procedure TPasRISCV.TBusDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Index:TPasRISCVSizeInt;
    SubBusDevice:TBusDevice;
begin
 for Index:=0 to fCountSubBusDevices-1 do begin
  SubBusDevice:=fSubBusDevices[Index];
  if (SubBusDevice.fBase<=aAddress) and ((aAddress-SubBusDevice.fBase)<SubBusDevice.fSize) then begin
   SubBusDevice.Store(aAddress,aValue,aSize);
   exit;
  end;
 end;
end;

procedure TPasRISCV.TBusDevice.Step;
begin
end;

{ TPasRISCV.TInterrupts }

constructor TPasRISCV.TInterrupts.Create(const aMachine:TPasRISCV);
begin
 inherited Create;
 fMachine:=aMachine;
 FillChar(fIRQAllocationBitmap,SizeOf(fIRQAllocationBitmap),#0);
end;

destructor TPasRISCV.TInterrupts.Destroy;
begin
 inherited Destroy;
end;

function TPasRISCV.TInterrupts.AllocateIRQ:TPasRISCVUInt32;
var Index:TPasRISCVUInt32;
    Mask,IRQMask:TPasRISCVUInt32;
begin
 for Index:=0 to length(fIRQAllocationBitmap)-1 do begin
  Mask:=TPasMPInterlocked.Read(fIRQAllocationBitmap[Index]);
  while Mask<>TPasRISCVUInt32($ffffffff) do begin
   result:=(Index shl 5) or TPasMPMath.BitScanForward32(not Mask);
   IRQMask:=TPasRISCVUInt32(TPasRISCVUInt32(1) shl result);
   if (TPasMPInterlocked.ExchangeBitwiseOr(fIRQAllocationBitmap[Index],IRQMask) and IRQMask)=0 then begin
    exit;
   end else begin
    Mask:=TPasMPInterlocked.Read(fIRQAllocationBitmap[Index]);
   end;
  end;
 end;
 result:=NoIRQ;
end;

function TPasRISCV.TInterrupts.AcquireIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
var Index:TPasRISCVUInt32;
    Mask:TPasRISCVUInt32;
begin
 Index:=aIRQ shr 5;
 Mask:=TPasRISCVUInt32(TPasRISCVUInt32(1) shl (aIRQ and $1f));
 if Index<length(fIRQAllocationBitmap) then begin
  result:=(TPasMPInterlocked.ExchangeBitwiseOr(fIRQAllocationBitmap[Index],Mask) and Mask)=0;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TInterrupts.ReleaseIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
var Index:TPasRISCVUInt32;
    Mask:TPasRISCVUInt32;
begin
 Index:=aIRQ shr 5;
 Mask:=TPasRISCVUInt32(TPasRISCVUInt32(1) shl (aIRQ and $1f));
 if Index<length(fIRQAllocationBitmap) then begin
  result:=(TPasMPInterlocked.ExchangeBitwiseAnd(fIRQAllocationBitmap[Index],not Mask) and Mask)<>0;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TInterrupts.SendIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
begin
 result:=fMachine.fINTCDevice.SendIRQ(aIRQ);
end;

function TPasRISCV.TInterrupts.RaiseIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
begin
 result:=fMachine.fINTCDevice.RaiseIRQ(aIRQ);
end;

function TPasRISCV.TInterrupts.LowerIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
begin
 result:=fMachine.fINTCDevice.LowerIRQ(aIRQ);
end;

{ TPasRISCV.TACLINTDevice.TCLINTMTimerSubDevice }

// For own MMIO sub-region with other minimum and maximum operation sizes, so it calls just the parent class methods for Load and Store.
// So no big magic here, just a simple wrapper class for the CLINT MTIME registers with different minimum and maximum operation sizes for
// aligned accesses.

constructor TPasRISCV.TACLINTDevice.TCLINTMTimerSubDevice.Create(const aACLINTDevice:TACLINTDevice);
begin
 inherited Create(aACLINTDevice.fMachine,aACLINTDevice.fBase+MTimeCmpAddress,MTimeCmpAddressSize);
 fACLINTDevice:=aACLINTDevice;
 fUnalignedAccessSupport:=false;
 fMinOpSize:=8; // <= these are the only differences to the parent class
 fMaxOpSize:=8;
end;

destructor TPasRISCV.TACLINTDevice.TCLINTMTimerSubDevice.Destroy;
begin
 inherited Destroy;
end;

function TPasRISCV.TACLINTDevice.TCLINTMTimerSubDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 result:=fACLINTDevice.Load(aAddress,aSize);
end;

procedure TPasRISCV.TACLINTDevice.TCLINTMTimerSubDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
begin
 fACLINTDevice.Store(aAddress,aValue,aSize);
end;

{ TPasRISCV.TACLINTDevice }

constructor TPasRISCV.TACLINTDevice.Create(const aMachine:TPasRISCV);
begin

 inherited Create(aMachine,aMachine.fConfiguration.fCLINTBase,aMachine.fConfiguration.fCLINTSize);

 fStartTime:=GetCurrentTime;

 fUnalignedAccessSupport:=false;
 fMinOpSize:=4;
 fMaxOpSize:=4;

 fCLINTMTimerSubDevice:=TCLINTMTimerSubDevice.Create(self);
 AddSubBusDevice(fCLINTMTimerSubDevice);

end;

destructor TPasRISCV.TACLINTDevice.Destroy;
begin
 inherited Destroy; // where each sub-device is also destroyed
end;

procedure TPasRISCV.TACLINTDevice.Reset;
begin
 inherited Reset;
 fStartTime:=GetCurrentTime;
end;

function TPasRISCV.TACLINTDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var CountHARTs,Address,HARTID:TPasRISCVUInt64;
begin
 CountHARTs:=length(fMachine.fHARTs);
 Address:=aAddress-fBase;
 if (Address>=MSIPAddress) and (Address<(MSIPAddress+(CountHARTs shl 2))) then begin
  HARTID:=(Address-MSIPAddress) shr 2;
  result:=(fMachine.fHARTs[HARTID].InterruptsRaised shr TPasRISCVUInt32(THART.TInterruptValue.MachineSoftware)) and 1;
 end else if (Address>=MTimeCmpAddress) and (Address<(MTimeCmpAddress+(CountHARTs shl 3))) then begin
  HARTID:=(Address-MTimeCmpAddress) shr 3;
  result:=fMachine.fHARTs[HARTID].fMTIMECMP;
 end else if (Address>=MTimeAddress) and (Address<(MTimeAddress+8)) then begin
  result:=GetTime;
 end else if (Address>=SSIPAddress) and (Address<(SSIPAddress+(CountHARTs shl 2))) then begin
  HARTID:=(Address-SSIPAddress) shr 2;
  result:=(fMachine.fHARTs[HARTID].InterruptsRaised shr TPasRISCVUInt32(THART.TInterruptValue.SupervisorSoftware)) and 1;
 end else begin
  result:=0;
 end;
end;

procedure TPasRISCV.TACLINTDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var CountHARTs,Address,HARTID,Time:TPasRISCVUInt64;
begin
 CountHARTs:=length(fMachine.fHARTs);
 Address:=aAddress-fBase;
 if (Address>=MSIPAddress) and (Address<(MSIPAddress+(CountHARTs shl 2))) then begin
  HARTID:=(Address-MSIPAddress) shr 2;
  if (aValue and 1)<>0 then begin
   fMachine.fHARTs[HARTID].RaiseInterrupt(THART.TInterruptValue.MachineSoftware);
  end else begin
   fMachine.fHARTs[HARTID].ClearInterrupt(THART.TInterruptValue.MachineSoftware);
  end;
 end else if (Address>=MTimeCmpAddress) and (Address<(MTimeCmpAddress+(CountHARTs shl 3))) then begin
  HARTID:=(Address-MTimeCmpAddress) shr 3;
  fMachine.fHARTs[HARTID].fMTIMECMP:=aValue;
  if GetTime>=aValue then begin
   fMachine.fHARTs[HARTID].RaiseInterrupt(THART.TInterruptValue.MachineTimer);
  end else begin
   fMachine.fHARTs[HARTID].ClearInterrupt(THART.TInterruptValue.MachineTimer);
  end;
 end else if (Address>=MTimeAddress) and (Address<(MTimeAddress+8)) then begin
  fStartTime:=GetTime-aValue;
  Time:=GetTime;
  for HARTID:=1 to CountHARTs do begin
   if Time>=fMachine.fHARTs[HARTID-1].fMTIMECMP then begin
    fMachine.fHARTs[HARTID-1].RaiseInterrupt(THART.TInterruptValue.MachineTimer);
   end else begin
    fMachine.fHARTs[HARTID-1].ClearInterrupt(THART.TInterruptValue.MachineTimer);
   end;
  end;
 end else if (Address>=SSIPAddress) and (Address<(SSIPAddress+(CountHARTs shl 2))) then begin
  HARTID:=(Address-SSIPAddress) shr 2;
  if (aValue and 1)<>0 then begin
   fMachine.fHARTs[HARTID].RaiseInterrupt(THART.TInterruptValue.SupervisorSoftware);
  end else begin
   fMachine.fHARTs[HARTID].ClearInterrupt(THART.TInterruptValue.SupervisorSoftware);
  end;
 end;
end;

function TPasRISCV.TACLINTDevice.GetTime:TPasRISCVUInt64;
begin
 result:=TPasRISCVUInt64(GetCurrentTime-fStartTime);
end;

function TPasRISCV.TACLINTDevice.GetCachedTime(var aTime:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 if aTime=TPasRISCVUInt64($ffffffffffffffff) then begin
  aTime:=GetTime;
 end;
 result:=aTime;
end;

{ TPasRISCV.TIMSICDevice }

constructor TPasRISCV.TIMSICDevice.Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64;const aAIARegFileMode:TPasRISCV.TAIARegFileMode);
begin
 inherited Create(aMachine,aBase,aSize);
 fAIARegFileMode:=aAIARegFileMode;
 fUnalignedAccessSupport:=false;
 fMinOpSize:=4;
 fMaxOpSize:=4;
end;

destructor TPasRISCV.TIMSICDevice.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV.TIMSICDevice.Reset;
begin
 inherited Reset;
end;

function TPasRISCV.TIMSICDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 result:=0;
end;

procedure TPasRISCV.TIMSICDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
const IMSIC_REG_SETEIPNUM_LE=$00;
      IMSIC_REG_SETEIPNUM_BE=$04;
var Address,HARTID:TPasRISCVUInt64;
    HART:TPasRISCV.THART;
begin
 Address:=aAddress-fBase;
 if (Address>=0) and (Address<Size) then begin
  HARTID:=Address shr 12;
  if HARTID<length(fMachine.fHARTs) then begin
   HART:=fMachine.fHARTs[HARTID];
   case Address and $ffc of
    IMSIC_REG_SETEIPNUM_LE:begin
     HART.SendAIAIRQ(fAIARegFileMode,TPasRISCVUInt32(aValue));
    end;
    IMSIC_REG_SETEIPNUM_BE:begin
     HART.SendAIAIRQ(fAIARegFileMode,ByteSwap32(TPasRISCVUInt32(aValue)));
    end;
    else begin
    end;
   end;
  end;
 end;
end;

{ TPasRISCV.TAPLICDevice.TDomainDevice }

constructor TPasRISCV.TAPLICDevice.TDomainDevice.Create(const aAPLICDevice:TAPLICDevice;const aBase,aSize:TPasRISCVUInt64;const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aRootDomain:Boolean);
begin
 inherited Create(aAPLICDevice.fMachine,aBase,aSize);
 fAPLICDevice:=aAPLICDevice;
 fAIARegFileMode:=aAIARegFileMode;
 fRootDomain:=aRootDomain;
 if fAIARegFileMode=TPasRISCV.TAIARegFileMode.Machine then begin
  fDelegationInvert:=$ffffffff;
 end else begin
  fDelegationInvert:=0;
 end;
 fUnalignedAccessSupport:=false;
 fMinOpSize:=4;
 fMaxOpSize:=4;
end;

destructor TPasRISCV.TAPLICDevice.TDomainDevice.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.Reset;
begin
 inherited Reset;
end;

function TPasRISCV.TAPLICDevice.TDomainDevice.ValidBits(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
begin
 if aReg<APLIC_SRC_REGS then begin
  TPasMPMemoryBarrier.ReadDependency;
  result:=fAPLICDevice.fDelegated[aReg] xor fDelegationInvert;
 end else begin
  result:=0;
 end;
end;

function TPasRISCV.TAPLICDevice.TDomainDevice.ValidSrc(const aSrc:TPasRISCVUInt64):Boolean;
var Mask:TPasRISCVUInt32;
begin
 Mask:=TPasRISCVUInt32(1) shl (aSrc and 31);
 result:=(ValidBits(aSrc shr 5) and Mask)<>0;
end;

function TPasRISCV.TAPLICDevice.TDomainDevice.UngatedSrc(const aSrc:TPasRISCVUInt64):Boolean;
begin
 if ValidSrc(aSrc) then begin
  result:=fAPLICDevice.RectifiedSrc(aSrc) or fAPLICDevice.DetachedSrc(aSrc);
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TAPLICDevice.TDomainDevice.ReadIP(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
begin
 if aReg<APLIC_SRC_REGS then begin
  TPasMPMemoryBarrier.ReadDependency;
  result:=fAPLICDevice.fPending[aReg] and ValidBits(aReg);
 end else begin
  result:=0;
 end;
end;

function TPasRISCV.TAPLICDevice.TDomainDevice.ReadIN(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
begin
 result:=fAPLICDevice.RectifiedBits(aReg) and ValidBits(aReg);
end;

function TPasRISCV.TAPLICDevice.TDomainDevice.ReadIE(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
begin
 if aReg<APLIC_SRC_REGS then begin
  TPasMPMemoryBarrier.ReadDependency;
  result:=fAPLICDevice.fEnabled[aReg] and ValidBits(aReg);
 end else begin
  result:=0;
 end;
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.SetIPNum(const aSrc:TPasRISCVUInt64);
begin
 if UngatedSrc(aSrc) then begin
  fAPLICDevice.NotifyInterrupt(aSrc);
 end;
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.SetIP(const aReg:TPasRISCVUInt64;const aBits:TPasRISCVUInt32);
var SetValue:TPasRISCVUInt32;
    Index:TPasRISCVInt32;
begin
 if aReg<APLIC_SRC_REGS then begin
  SetValue:=aBits and ValidBits(aReg);
  if SetValue<>0 then begin
   for Index:=0 to 31 do begin
    if (SetValue and (TPasRISCVUInt32(1) shl Index))<>0 then begin
     SetIPNum((aReg shl 5) or TPasRISCVUInt64(Index));
    end;
   end;
  end;
 end;
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.ClearIP(const aReg:TPasRISCVUInt64;const aBits:TPasRISCVUInt32);
var ClearValue:TPasRISCVUInt32;
begin
 if aReg<APLIC_SRC_REGS then begin
  ClearValue:=aBits and ValidBits(aReg);
  if ClearValue<>0 then begin
   TPasMPInterlocked.ExchangeBitwiseAnd(fAPLICDevice.fPending[aReg],not ClearValue);
   TPasMPMemoryBarrier.Write;
  end;
 end;
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.ClearIPNum(const aSrc:TPasRISCVUInt64);
var Reg:TPasRISCVUInt64;
    Mask:TPasRISCVUInt32;
begin
 Reg:=aSrc shr 5;
 Mask:=TPasRISCVUInt32(1) shl (aSrc and 31);
 ClearIP(Reg,Mask);
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.SetIE(const aReg:TPasRISCVUInt64;const aBits:TPasRISCVUInt32);
var SetValue,Deliver:TPasRISCVUInt32;
    Index:TPasRISCVInt32;
begin
 if aReg<APLIC_SRC_REGS then begin
  SetValue:=aBits and ValidBits(aReg);
  SetValue:=SetValue and not TPasMPInterlocked.ExchangeBitwiseOr(fAPLICDevice.fEnabled[aReg],SetValue);
  if SetValue<>0 then begin
   Deliver:=TPasMPInterlocked.ExchangeBitwiseAnd(fAPLICDevice.fPending[aReg],not SetValue);
   TPasMPMemoryBarrier.Write;
   if Deliver<>0 then begin
    for Index:=0 to 31 do begin
     if (Deliver and (TPasRISCVUInt32(1) shl Index))<>0 then begin
      fAPLICDevice.NotifyInterrupt((aReg shl 5) or TPasRISCVUInt64(Index));
     end;
    end;
   end;
  end;
 end;
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.SetIENum(const aSrc:TPasRISCVUInt64);
var Reg:TPasRISCVUInt64;
    Mask:TPasRISCVUInt32;
begin
 Reg:=aSrc shr 5;
 Mask:=TPasRISCVUInt32(1) shl (aSrc and 31);
 SetIE(Reg,Mask);
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.ClearIE(const aReg:TPasRISCVUInt64;const aBits:TPasRISCVUInt32);
var ClearValue:TPasRISCVUInt32;
begin
 if aReg<APLIC_SRC_REGS then begin
  ClearValue:=aBits and ValidBits(aReg);
  if ClearValue<>0 then begin
   TPasMPInterlocked.ExchangeBitwiseAnd(fAPLICDevice.fEnabled[aReg],not ClearValue);
   TPasMPMemoryBarrier.Write;
  end;
 end;
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.ClearIENum(const aSrc:TPasRISCVUInt64);
var Reg:TPasRISCVUInt64;
    Mask:TPasRISCVUInt32;
begin
 Reg:=aSrc shr 5;
 Mask:=TPasRISCVUInt32(1) shl (aSrc and 31);
 ClearIE(Reg,Mask);
end;

function TPasRISCV.TAPLICDevice.TDomainDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address,Reg:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 if (Address>=0) and (Address<Size) then begin
  case Address of
   APLIC_REG_DOMAINCFG:begin
    result:=fAPLICDevice.fDomainCfg[fAIARegFileMode] or APLIC_DOMAINCFG;
   end;
   APLIC_REG_MMSIADDRCFGH,APLIC_REG_SMSIADDRCFGH:begin
    result:=APLIC_MSIADDRCFGH_L;
   end;
   APLIC_REG_SETIP_0..APLIC_REG_SETIP_31:begin
    result:=ReadIP((Address-APLIC_REG_SETIP_0) shr 2);
   end;
   APLIC_REG_IN_CLRIP_0..APLIC_REG_IN_CLRIP_31:begin
    result:=ReadIN((Address-APLIC_REG_IN_CLRIP_0) shr 2);
   end;
   APLIC_REG_SOURCECFG_1..APLIC_REG_SOURCECFG_1023:begin
    Reg:=((Address-APLIC_REG_SOURCECFG_1) shr 2)+1;
    if ValidSrc(Reg) then begin
     TPasMPMemoryBarrier.ReadDependency;
     result:=fAPLICDevice.fSource[Reg];
    end else begin
     if fRootDomain then begin
      result:=APLIC_SOURCECFG_DETACHED;
     end else begin
      result:=0;
     end;
    end;
   end;
   APLIC_REG_TARGET_1..APLIC_REG_TARGET_1023:begin
    Reg:=((Address-APLIC_REG_TARGET_1) shr 2)+1;
    if ValidSrc(Reg) then begin
     TPasMPMemoryBarrier.ReadDependency;
     result:=fAPLICDevice.fTarget[Reg];
    end else begin
     result:=0;
    end;
   end;
   else begin
    result:=0;
   end;
  end;
 end else begin
  result:=0;
 end;
end;

procedure TPasRISCV.TAPLICDevice.TDomainDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address,Reg:TPasRISCVUInt64;
    Mask,Cfg:TPasRISCVUInt32;
begin
 Address:=aAddress-fBase;
 if (Address>=0) and (Address<Size) then begin
  case Address of
   APLIC_REG_DOMAINCFG:begin
    TPasMPMemoryBarrier.ReadWrite;
    fAPLICDevice.fDomainCfg[fAIARegFileMode]:=TPasRISCVUInt32(aValue) and APLIC_DOMAINCFG_IE;
    TPasMPMemoryBarrier.Write;
   end;
   APLIC_REG_SETIPNUM,APLIC_REG_SETIPNUM_LE:begin
    SetIPNum(TPasRISCVUInt64(TPasRISCVUInt32(aValue)));
   end;
   APLIC_REG_SETIPNUM_BE:begin
    SetIPNum(TPasRISCVUInt64(ByteSwap32(TPasRISCVUInt32(aValue))));
   end;
   APLIC_REG_SETIENUM:begin
    SetIENum(TPasRISCVUInt64(TPasRISCVUInt32(aValue)));
   end;
   APLIC_REG_CLRIENUM:begin
    ClearIENum(TPasRISCVUInt64(TPasRISCVUInt32(aValue)));
   end;
   APLIC_REG_GENMSI:begin
    fAPLICDevice.GenerateMSI(fAIARegFileMode,TPasRISCVUInt32(aValue));
   end;
   APLIC_REG_SETIP_0..APLIC_REG_SETIP_31:begin
    SetIP((Address-APLIC_REG_SETIP_0) shr 2,TPasRISCVUInt32(aValue));
   end;
   APLIC_REG_IN_CLRIP_0..APLIC_REG_IN_CLRIP_31:begin
    ClearIP((Address-APLIC_REG_IN_CLRIP_0) shr 2,TPasRISCVUInt32(aValue));
   end;
   APLIC_REG_SETIE_0..APLIC_REG_SETIE_31:begin
    SetIE((Address-APLIC_REG_SETIE_0) shr 2,TPasRISCVUInt32(aValue));
   end;
   APLIC_REG_CLRIE_0..APLIC_REG_CLRIE_31:begin
    ClearIE((Address-APLIC_REG_CLRIE_0) shr 2,TPasRISCVUInt32(aValue));
   end;
   APLIC_REG_SOURCECFG_1..APLIC_REG_SOURCECFG_1023:begin
    Reg:=((Address-APLIC_REG_SOURCECFG_1) shr 2)+1;
    if fRootDomain then begin
     Mask:=TPasRISCVUInt32(1) shl (Reg and 31);
     if (aValue and APLIC_SOURCECFG_DELEGATE)<>0 then begin
      TPasMPInterlocked.ExchangeBitwiseOr(fAPLICDevice.fDelegated[Reg shr 5],Mask);
     end else begin
      TPasMPInterlocked.ExchangeBitwiseAnd(fAPLICDevice.fDelegated[Reg shr 5],not Mask);
     end;
    end;
    if ValidSrc(Reg) then begin
     Cfg:=aValue and APLIC_SOURCECFG_MASK;
     Mask:=TPasRISCVUInt32(1) shl (Reg and 31);
     TPasMPMemoryBarrier.ReadWrite;
//   writeln(Reg,' ',Cfg,' ',aValue);
     fAPLICDevice.fSource[Reg]:=Cfg;
     TPasMPMemoryBarrier.Write;
     case Cfg of
      APLIC_SOURCECFG_LVL_LOW,APLIC_SOURCECFG_EDGE_FALL:begin
       TPasMPInterlocked.ExchangeBitwiseOr(fAPLICDevice.fInvert[Reg shr 5],Mask);
      end;
      else begin
       TPasMPInterlocked.ExchangeBitwiseAnd(fAPLICDevice.fInvert[Reg shr 5],not Mask);
      end;
     end;
    end;
   end;
   APLIC_REG_TARGET_1..APLIC_REG_TARGET_1023:begin
    Reg:=((Address-APLIC_REG_TARGET_1) shr 2)+1;
    if ValidSrc(Reg) then begin
     TPasMPMemoryBarrier.ReadWrite;
     fAPLICDevice.fTarget[Reg]:=TPasRISCVUInt32(aValue);
     TPasMPMemoryBarrier.Write;
    end;
   end;
   else begin
   end;
  end;
 end;
end;

{ TPasRISCV.TAPLICDevice }

constructor TPasRISCV.TAPLICDevice.Create(const aMachine:TPasRISCV);
var StartAddress,EndAddress,
    MachineBase,MachineSize,
    SupervisorBase,SupervisorSize:TPasRISCVUInt64;
begin
 MachineBase:=aMachine.fConfiguration.fAPLICMachineBase;
 MachineSize:=aMachine.fConfiguration.fAPLICMachineSize;
 SupervisorBase:=aMachine.fConfiguration.fAPLICSupervisorBase;
 SupervisorSize:=aMachine.fConfiguration.fAPLICSupervisorSize;
 if MachineBase<SupervisorBase then begin
  StartAddress:=MachineBase;
  EndAddress:=SupervisorBase+SupervisorSize;
 end else begin
  StartAddress:=SupervisorBase;
  EndAddress:=MachineBase+MachineSize;
 end;
 inherited Create(aMachine,StartAddress,EndAddress-StartAddress);
 fUnalignedAccessSupport:=false;
 fMinOpSize:=4;
 fMaxOpSize:=4;
 fDomainDevices[TPasRISCV.TAIARegFileMode.Machine]:=TDomainDevice.Create(self,MachineBase,MachineSize,TPasRISCV.TAIARegFileMode.Machine,true);
 fDomainDevices[TPasRISCV.TAIARegFileMode.Supervisor]:=TDomainDevice.Create(self,SupervisorBase,SupervisorSize,TPasRISCV.TAIARegFileMode.Supervisor,false);
 AddSubBusDevice(fDomainDevices[TPasRISCV.TAIARegFileMode.Machine]);
 AddSubBusDevice(fDomainDevices[TPasRISCV.TAIARegFileMode.Supervisor]);
 Reset;
end;

destructor TPasRISCV.TAPLICDevice.Destroy;
begin
 inherited Destroy; // where each sub-device is also destroyed
end;

procedure TPasRISCV.TAPLICDevice.Reset;
var Mode:TPasRISCV.TAIARegFileMode;
begin
 inherited Reset;
 FillChar(fDomainCfg,SizeOf(TDomainCfg),#0);
 FillChar(fDelegated,SizeOf(TDeviceRegisters),#$ff); // All sources delegated in root domain
 FillChar(fRaised,SizeOf(TDeviceRegisters),#0);
 FillChar(fInvert,SizeOf(TDeviceRegisters),#0);
 FillChar(fPending,SizeOf(TDeviceRegisters),#0);
 FillChar(fEnabled,SizeOf(TDeviceRegisters),#0);
 FillChar(fSource,SizeOf(TSources),#0);
 FillChar(fTarget,SizeOf(TSources),#0);
 for Mode:=Low(TPasRISCV.TAIARegFileMode) to High(TPasRISCV.TAIARegFileMode) do begin
  if assigned(fDomainDevices[Mode]) then begin
   fDomainDevices[Mode].Reset;
  end;
 end;
end;

procedure TPasRISCV.TAPLICDevice.GenerateMSI(const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aTarget:TPasRISCVUInt32);
var HARTID:TPasRISCVUInt32;
begin
 HARTID:=aTarget shr 18;
 if HARTID<length(fMachine.fHARTs) then begin
  fMachine.fHARTs[HARTID].SendAIAIRQ(aAIARegFileMode,aTarget and $3ff);
 end;
end;

function TPasRISCV.TAPLICDevice.RectifiedBits(const aReg:TPasRISCVUInt64):TPasRISCVUInt32;
var Raised,Invert:TPasRISCVUInt32;
begin
 if aReg<APLIC_SRC_REGS then begin
  TPasMPMemoryBarrier.ReadDependency;
  Raised:=fRaised[aReg];
  TPasMPMemoryBarrier.ReadDependency;
  Invert:=fInvert[aReg];
  result:=Raised xor Invert;
 end else begin
  result:=0;
 end;
end;

function TPasRISCV.TAPLICDevice.RectifiedSrc(const aSrc:TPasRISCVUInt64):Boolean;
var Mask:TPasRISCVUInt32;
begin
 Mask:=TPasRISCVUInt32(1) shl (aSrc and 31);
 result:=(RectifiedBits(aSrc shr 5) and Mask)<>0;
end;

function TPasRISCV.TAPLICDevice.DetachedSrc(const aSrc:TPasRISCVUInt64):Boolean;
begin
 if aSrc<APLIC_SRC_LIMIT then begin
  TPasMPMemoryBarrier.ReadDependency;
  result:=fSource[aSrc]<=APLIC_SOURCECFG_DETACHED;
 end else begin
  result:=true;
 end;
end;

procedure TPasRISCV.TAPLICDevice.NotifyInterrupt(const aSrc:TPasRISCVUInt64);
var Reg:TPasRISCVUInt64;
    Mask,Enabled,DomainCfg,Target:TPasRISCVUInt32;
    SMode:Boolean;
    AIARegFileMode:TPasRISCV.TAIARegFileMode;
begin
 if aSrc<APLIC_SRC_LIMIT then begin
  Reg:=aSrc shr 5;
  Mask:=TPasRISCVUInt32(1) shl (aSrc and 31);
  TPasMPMemoryBarrier.ReadDependency;
  SMode:=(fDelegated[Reg] and Mask)<>0;
  if SMode then begin
   AIARegFileMode:=TPasRISCV.TAIARegFileMode.Supervisor;
  end else begin
   AIARegFileMode:=TPasRISCV.TAIARegFileMode.Machine;
  end;
  TPasMPMemoryBarrier.ReadDependency;
  Enabled:=fEnabled[Reg] and Mask;
  TPasMPMemoryBarrier.ReadDependency;
  DomainCfg:=fDomainCfg[AIARegFileMode] or APLIC_DOMAINCFG; // Domain config
  if ((Enabled and Mask)<>0) and ((DomainCfg and APLIC_DOMAINCFG_IE)<>0) then begin
   TPasMPMemoryBarrier.ReadDependency;
   Target:=fTarget[aSrc];
   GenerateMSI(AIARegFileMode,Target);
  end else begin
   TPasMPInterlocked.ExchangeBitwiseOr(fPending[Reg],Mask);
  end;
 end;
end;

procedure TPasRISCV.TAPLICDevice.EdgeInterrupt(const aSrc:TPasRISCVUInt64);
begin
 if not DetachedSrc(aSrc) then begin
  NotifyInterrupt(aSrc);
 end;
end;

procedure TPasRISCV.TAPLICDevice.UpdateInterrupt(const aSrc:TPasRISCVUInt64);
begin
 if RectifiedSrc(aSrc) then begin
  EdgeInterrupt(aSrc);
 end;
end;

function TPasRISCV.TAPLICDevice.SendIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
begin
 if (aIRQ>0) and (aIRQ<APLIC_SRC_LIMIT) then begin
  EdgeInterrupt(aIRQ);
 end;
 result:=false;
end;

function TPasRISCV.TAPLICDevice.RaiseIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
var Mask:TPasRISCVUInt32;
begin
 if (aIRQ>0) and (aIRQ<APLIC_SRC_LIMIT) then begin
  Mask:=TPasRISCVUInt32(1) shl (aIRQ and 31);
  if ((not TPasMPInterlocked.ExchangeBitwiseOr(fRaised[aIRQ shr 5],Mask)) and Mask)<>0 then begin
   UpdateInterrupt(aIRQ);
  end;
  result:=true;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TAPLICDevice.LowerIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
var Mask:TPasRISCVUInt32;
begin
 if (aIRQ>0) and (aIRQ<APLIC_SRC_LIMIT) then begin
  Mask:=TPasRISCVUInt32(1) shl (aIRQ and 31);
  if ((TPasMPInterlocked.ExchangeBitwiseAnd(fRaised[aIRQ shr 5],not Mask)) and not Mask)<>0 then begin
   UpdateInterrupt(aIRQ);
  end;
  result:=true;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TAPLICDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 result:=inherited Load(aAddress,aSize);
end;

procedure TPasRISCV.TAPLICDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
begin
 inherited Store(aAddress,aValue,aSize);
end;

{ TPasRISCV.TPLICDevice }

constructor TPasRISCV.TPLICDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fPLICBase,aMachine.fConfiguration.fPLICSize);
 fUnalignedAccessSupport:=false;
 fMinOpSize:=4;
 fMaxOpSize:=4;
 fAllocationIRQCounter:=0;
 fCountContexts:=fMachine.fCountHARTs shl 1;
 Reset;
end;

destructor TPasRISCV.TPLICDevice.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV.TPLICDevice.Reset;
begin
 FillChar(fPriority,SizeOf(fPriority),#0);
 FillChar(fPending,SizeOf(fPending),#0);
 FillChar(fRaised,SizeOf(fRaised),#0);
 FillChar(fEnable,SizeOf(fEnable),#0);
 FillChar(fThreshold,SizeOf(fThreshold),#0);
end;

function TPasRISCV.TPLICDevice.IsIRQPending(const aIRQ:TPasRISCVUInt32):Boolean;
begin
 result:=(TPasMPInterlocked.Read(fPending[aIRQ shr 5]) and (TPasRISCVUInt32(1) shl (aIRQ and 31)))<>0;
end;

function TPasRISCV.TPLICDevice.IsIRQEnabled(const aContext,aIRQ:TPasRISCVUInt32):Boolean;
begin
 result:=(TPasMPInterlocked.Read(fEnable[aContext][aIRQ shr 5]) and (TPasRISCVUInt32(1) shl (aIRQ and 31)))<>0;
end;

function TPasRISCV.TPLICDevice.NotifyContextIRQ(const aContext,aIRQ:TPasRISCVUInt32):Boolean;
var HARTID:TPasRISCVUInt32;
begin
 if IsIRQEnabled(aContext,aIRQ) and
    (TPasMPInterlocked.Read(fPriority[aIRQ])>TPasMPInterlocked.Read(fThreshold[aContext])) then begin
  HARTID:=aContext shr 1;
  if HARTID<length(fMachine.fHARTs) then begin
   if (aContext and 1)<>0 then begin
    fMachine.fHARTs[HARTID].RaiseInterrupt(TPasRISCV.THART.TInterruptValue.SupervisorExternal);
   end else begin
    fMachine.fHARTs[HARTID].RaiseInterrupt(TPasRISCV.THART.TInterruptValue.MachineExternal);
   end;
  end;
  result:=true;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TPLICDevice.NotifyIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
var Context:TPasRISCVUInt32;
begin
 for Context:=0 to fCountContexts-1 do begin
  if NotifyContextIRQ(Context,aIRQ) then begin
   result:=true;
   exit;
  end;
 end;
 result:=false;
end;

procedure TPasRISCV.TPLICDevice.UpdateIRQ(const aIRQ:TPasRISCVUInt32);
begin
 if IsIRQPending(aIRQ) then begin
  NotifyIRQ(aIRQ);
 end;
end;

procedure TPasRISCV.TPLICDevice.UpdateContextIRQRegister(const aContext,aRegister:TPasRISCVUInt32);
var IRQs,Index:TPasRISCVUInt32;
begin
 IRQs:=TPasMPInterlocked.Read(fPending[aRegister]) and TPasMPInterlocked.Read(fEnable[aContext][aRegister]);
 if IRQs<>0 then begin
  for Index:=0 to 31 do begin
   UpdateIRQ((aRegister shl 5) or Index);
  end;
 end;
end;

function TPasRISCV.TPLICDevice.UpdateContext(const aContext:TPasRISCVUInt32;const aClaim:Boolean):TPasRISCVUInt32;
var Threshold,NotifyingIRQs,HighestPriorityIRQ,Priority,MaxPriority,IRQs,Index,IRQ,HARTID:TPasRISCVUInt32;
begin
 HARTID:=aContext shr 1;
 if HARTID<length(fMachine.fHARTs) then begin
  if (aContext and 1)<>0 then begin
   fMachine.fHARTs[HARTID].ClearInterrupt(TPasRISCV.THART.TInterruptValue.SupervisorExternal);
  end else begin
   fMachine.fHARTs[HARTID].ClearInterrupt(TPasRISCV.THART.TInterruptValue.MachineExternal);
  end;
 end;
 Threshold:=TPasMPInterlocked.Read(fThreshold[aContext]);
 NotifyingIRQs:=0;
 HighestPriorityIRQ:=0;
 MaxPriority:=0;
 for Index:=0 to PLIC_SRC_REG_COUNT-1 do begin
  IRQs:=TPasMPInterlocked.Read(fPending[Index]) and TPasMPInterlocked.Read(fEnable[aContext][Index]);
  while IRQs<>0 do begin
   IRQ:=(Index shl 5) or TPasMPMath.BitScanForward32(IRQs); // Find first set bit
   Priority:=TPasMPInterlocked.Read(fPriority[IRQ]);
   if Threshold<Priority then begin
    inc(NotifyingIRQs);
   end;
   if MaxPriority<Priority then begin
    MaxPriority:=Priority;
    HighestPriorityIRQ:=IRQ;
   end;
   IRQs:=IRQs and (IRQs-1); // Mask out first set bit
  end;
 end;
 if aClaim and (Threshold<MaxPriority) then begin
  dec(NotifyingIRQs);
 end;
 if NotifyingIRQs<>0 then begin
  if HARTID<length(fMachine.fHARTs) then begin
   if (aContext and 1)<>0 then begin
    fMachine.fHARTs[HARTID].RaiseInterrupt(TPasRISCV.THART.TInterruptValue.SupervisorExternal);
   end else begin
    fMachine.fHARTs[HARTID].RaiseInterrupt(TPasRISCV.THART.TInterruptValue.MachineExternal);
   end;
  end;
 end;
 result:=HighestPriorityIRQ;
end;

procedure TPasRISCV.TPLICDevice.FullUpdate;
var Context:TPasRISCVUInt32;
begin
 for Context:=0 to fCountContexts-1 do begin
  UpdateContext(Context,false);
 end;
end;

procedure TPasRISCV.TPLICDevice.SetIRQPriority(const aIRQ,aPriority:TPasRISCVUInt32);
var OldPriority:TPasRISCVUInt32;
begin
 OldPriority:=TPasMPInterlocked.Exchange(fPriority[aIRQ],aPriority);
 if aPriority<OldPriority then begin
  if IsIRQPending(aIRQ) then begin
   // Pending IRQ priority was lowered - do a full PLIC state update
   FullUpdate;
  end;
 end else if aPriority>OldPriority then begin
  // IRQ priority was raised - do a partial check
  UpdateIRQ(aIRQ);
 end;
end;

procedure TPasRISCV.TPLICDevice.SetEnableBits(const aContext,aRegister,aEnable:TPasRISCVUInt32);
var OldEnable,IRQsDisabled:TPasRISCVUInt32;
begin
 OldEnable:=TPasMPInterlocked.Exchange(fEnable[aContext][aRegister],aEnable);
 IRQsDisabled:=OldEnable and not aEnable;
 if IRQsDisabled<>0 then begin
  if (IRQsDisabled and TPasMPInterlocked.Read(fPending[aRegister]))<>0 then begin
   // Some pending IRQs were disabled - do a full PLIC state update
   FullUpdate;
  end;
 end else if (aEnable and not OldEnable)<>0 then begin
  // Some IRQs were enabled - do a partial check
  UpdateContextIRQRegister(aContext,aRegister);
 end;
end;

procedure TPasRISCV.TPLICDevice.SetContextThreshold(const aContext,aThreshold:TPasRISCVUInt32);
var OldThreshold:TPasRISCVUInt32;
begin
 OldThreshold:=TPasMPInterlocked.Exchange(fThreshold[aContext],aThreshold);
 if OldThreshold<>aThreshold then begin
  // Context threshold changed - do a context update
  UpdateContext(aContext,false);
 end;
end;

function TPasRISCV.TPLICDevice.ClaimIRQ(const aContext:TPasRISCVUInt32):TPasRISCVUInt32;
var IRQ,Mask:TPasRISCVUInt32;
begin
 repeat
  IRQ:=UpdateContext(aContext,true);
  if IRQ<>0 then begin
   Mask:=TPasRISCVUInt32(1) shl (IRQ and 31);
   if (TPasMPInterlocked.ExchangeBitwiseAnd(fPending[IRQ shr 5],not Mask) and Mask)=0 then begin
    // Someone stole our IRQ in the meantime, retry
    continue;
   end;
  end;
  break;
 until false;
 result:=IRQ;
end;

procedure TPasRISCV.TPLICDevice.CompleteIRQ(const aContext,aIRQ:TPasRISCVUInt32);
var Raised:TPasRISCVUInt32;
begin
 Raised:=TPasMPInterlocked.Read(fRaised[aIRQ shr 5]) and (TPasRISCVUInt32(1) shl (aIRQ and 31));
 if Raised<>0 then begin
  TPasMPInterlocked.BitwiseOr(fPending[aIRQ shr 5],Raised);
  NotifyContextIRQ(aContext,aIRQ);
 end;
end;

function TPasRISCV.TPLICDevice.AllocateIRQ:TPasRISCVUInt32;
begin
 result:=TPasMPInterlocked.Increment(fAllocationIRQCounter);
 if result>=PLIC_SOURCE_MAX then begin
  raise EPasRISCV.Create('Out of IRQs');
 end;
end;

function TPasRISCV.TPLICDevice.SendIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
var Mask:TPasRISCVUInt32;
begin
 if (aIRQ>0) and (aIRQ<PLIC_SOURCE_MAX) then begin
  Mask:=TPasRISCVUInt32(1) shl (aIRQ and 31);
  if (TPasMPInterlocked.ExchangeBitwiseOr(fPending[aIRQ shr 5],Mask) and Mask)=0 then begin
   NotifyIRQ(aIRQ);
  end;
  result:=true;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TPLICDevice.RaiseIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
var Mask:TPasRISCVUInt32;
begin
 if (aIRQ>0) and (aIRQ<PLIC_SOURCE_MAX) then begin
  Mask:=TPasRISCVUInt32(1) shl (aIRQ and 31);
  if (TPasMPInterlocked.ExchangeBitwiseOr(fRaised[aIRQ shr 5],Mask) and Mask)=0 then begin
   SendIRQ(aIRQ);
  end;
  result:=true;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TPLICDevice.LowerIRQ(const aIRQ:TPasRISCVUInt32):Boolean;
begin
 if (aIRQ>0) and (aIRQ<PLIC_SOURCE_MAX) then begin
  TPasMPInterlocked.BitwiseAnd(fRaised[aIRQ shr 5],not (TPasRISCVUInt32(1) shl (aIRQ and 31)));
  result:=true;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TPLICDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address,{Offset,}Context,IRQ,Register:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 if (Address>=SourcePriorityAddress) and (Address<=SourcePriorityEndAddress) then begin
  IRQ:=Address shr 2;
  if (IRQ>0) and (IRQ<PLIC_SOURCE_MAX) then begin
   result:=TPasMPInterlocked.Read(fPriority[IRQ]);
  end else begin
   result:=0;
  end;
 end else if (Address>=PendingAddress) and (Address<=PendingEndAddress) then begin
  Register:=(Address-PendingAddress) shr 2;
  if Register<PLIC_SRC_REG_COUNT then begin
   result:=TPasMPInterlocked.Read(fPending[Register]);
  end else begin
   result:=0;
  end;
 end else if (Address>=EnableAddress) and (Address<=EnableEndAddress) then begin
  dec(Address,EnableAddress);
  Register:=(Address shr 2) and 31;
  Context:=Address shr 7;
  if (Register<PLIC_SRC_REG_COUNT) and (Context<fCountContexts) then begin
   result:=TPasMPInterlocked.Read(fEnable[Context][Register]);
  end else begin
   result:=0;
  end;
 end else if (Address>=ThresholdClaimAddress) and (Address<=ThresholdClaimEndAddress) then begin
  dec(Address,ThresholdClaimAddress);
  Register:=(Address shr 2) and 1023;
  Context:=Address shr 12;
  if Context<fCountContexts then begin
   case Register of
    CTXFLAG_THRESHOLD:begin
     result:=TPasMPInterlocked.Read(fThreshold[Context]);
    end;
    CTXFLAG_COMPLETE:begin
     result:=ClaimIRQ(Context);
    end;
    else begin
     result:=0;
    end;
   end;
  end else begin
   result:=0;
  end;
 end else begin
  result:=0;
 end;
{Offset:=Address and 7;
 result:=(result shr (Offset shl 3)) and TPasRISCVUInt64(TPasRISCVUInt64(TPasRISCVUInt64(1) shl (aSize shl 3))-1);//}
end;

procedure TPasRISCV.TPLICDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address,Context,IRQ,Register:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 if (Address>=SourcePriorityAddress) and (Address<=SourcePriorityEndAddress) then begin
  IRQ:=Address shr 2;
  if (IRQ>0) and (IRQ<PLIC_SOURCE_MAX) then begin
   SetIRQPriority(IRQ,aValue);
  end;
 end else if (Address>=PendingAddress) and (Address<=PendingEndAddress) then begin
{ Register:=(Address-PendingAddress) shr 2;
  if Register<PLIC_SRC_REG_COUNT then begin
   TPasMPInterlocked.Write(fPending[Register],aValue);
  end;//}
  // R/O, do nothing. Pending bits are cleared by reading CLAIMCOMPLETE register
 end else if (Address>=EnableAddress) and (Address<=EnableEndAddress) then begin
  dec(Address,EnableAddress);
  Register:=(Address shr 2) and 31;
  Context:=Address shr 7;
  if (Register<PLIC_SRC_REG_COUNT) and (Context<fCountContexts) then begin
   SetEnableBits(Context,Register,aValue);
  end;
 end else if (Address>=ThresholdClaimAddress) and (Address<=ThresholdClaimEndAddress) then begin
  dec(Address,ThresholdClaimAddress);
  Register:=(Address shr 2) and 1023;
  Context:=Address shr 12;
  if Context<fCountContexts then begin
   case Register of
    CTXFLAG_THRESHOLD:begin
     SetContextThreshold(Context,aValue);
    end;
    CTXFLAG_COMPLETE:begin
     CompleteIRQ(Context,aValue);
    end;
    else begin
    end;
   end;
  end;
 end;
end;

{ TPasRISCV.TSYSCONDevice }

constructor TPasRISCV.TSYSCONDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fSYSCONBase,aMachine.fConfiguration.fSYSCONSize);
end;

destructor TPasRISCV.TSYSCONDevice.Destroy;
begin
 inherited Destroy;
end;

function TPasRISCV.TSYSCONDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 if aAddress=fBase then begin
  result:=TPasRISCVUInt64($ffffffffffffffff);
 end else begin
  result:=0;
 end;
end;

procedure TPasRISCV.TSYSCONDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
begin
 if aAddress=fBase then begin
  case aValue of
   PowerOffValue:begin
    fMachine.PowerOff;
   end;
   RebootValue:begin
    fMachine.Reboot;
   end;
  end;
 end;
end;

{ TPasRISCV.TPCIMemoryDevice }

constructor TPasRISCV.TPCIMemoryDevice.Create(const aMachine:TPasRISCV;const aPCIDevice:TPCIDevice;const aPCIFunc:TPCIFunc;const aBase,aSize:TPasRISCVUInt64;const aOnLoad:TOnLoad;const aOnStore:TOnStore);
begin
 fPCIBusDevice:=aPCIDevice.fBus;
 fPCIDevice:=aPCIDevice;
 fPCIFunc:=aPCIFunc;
 fOnLoad:=aOnLoad;
 fOnStore:=aOnStore;
 inherited Create(aMachine,aBase,aSize,nil,assigned(fOnLoad) or assigned(fOnStore));
end;

destructor TPasRISCV.TPCIMemoryDevice.Destroy;
begin
 inherited Destroy;
end;

function TPasRISCV.TPCIMemoryDevice.GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
begin
 if assigned(fOnGetDeviceDirectMemoryAccessPointer) then begin
  result:=fOnGetDeviceDirectMemoryAccessPointer(self,aAddress,aSize,aWrite,aBounce);
  if assigned(result) then begin
   exit;
  end;
 end;
 if assigned(fOnLoad) or assigned(fOnStore) then begin
  result:=aBounce;
 end else begin
  result:=inherited GetDeviceDirectMemoryAccessPointer(aAddress,aSize,aWrite,aBounce);
 end;
end;

function TPasRISCV.TPCIMemoryDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 if assigned(fOnLoad) then begin
  result:=fOnLoad(self,aAddress,aSize);
 end else begin
  result:=inherited Load(aAddress,aSize);
 end;
end;

procedure TPasRISCV.TPCIMemoryDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
begin
 if assigned(fOnStore) then begin
  fOnStore(self,aAddress,aValue,aSize);
 end else begin
  inherited Store(aAddress,aValue,aSize);
 end;
end;

{ TPasRISCV.TPCIFunc }

constructor TPasRISCV.TPCIFunc.Create(const aBus:TPasRISCV.TPCIBusDevice;const aDevice:TPasRISCV.TPCIDevice;const aFuncDesc:TPasRISCV.TPCIFuncDescriptor);
var BARIndex:TPasRISCVUInt32;
    BARRegion:TPCIBARRegion;
    PCIMemoryDevice:TPCIMemoryDevice;
begin
 inherited Create;
 fBus:=aBus;
 fDevice:=aDevice;
 fStatus:=0;
 fCommand:=TPCI.PCI_CMD_DEFAULT;
 fIRQLine:=0;
 fVendorID:=aFuncDesc.fVendorID;
 fDeviceID:=aFuncDesc.fDeviceID;
 fSubsystemVendorID:=aFuncDesc.fSubsystemVendorID;
 fSubsystemDeviceID:=aFuncDesc.fSubsystemDeviceID;
 fClassCode:=aFuncDesc.fClassCode;
 fProgIF:=aFuncDesc.fProgIF;
 fRevisionID:=aFuncDesc.fRevisionID;
 fIRQPin:=aFuncDesc.fIRQPin;
 fBridgeIO:=0;
 fBridgeMem:=0;
 if fIRQPin<>0 then begin
//writeln('IRQs: ',TPCI.PCI_IRQs[0],' ',TPCI.PCI_IRQs[1],' ',TPCI.PCI_IRQs[2],' ',TPCI.PCI_IRQs[3],' PCIFuncIRQPinID: ',TPCIBusDevice.PCIFuncIRQPinID(self));
  fIRQLine:=fBus.fIRQs[TPCIBusDevice.PCIFuncIRQPinID(self)];
 end else begin
  fIRQLine:=0;
 end;
 fExpansionROM:=nil;
//writeln('PCI Func: ',LowerCase(IntToHex(fVendorID,4)),' ',LowerCase(IntToHex(fDeviceID,4)),' ',LowerCase(IntToHex(fClassCode,6)),' ',LowerCase(IntToHex(fProgIF,2)),' ',LowerCase(IntToHex(fRevisionID,2)),' ',LowerCase(IntToHex(fIRQPin,2)),' ',LowerCase(IntToHex(fIRQLine,2)));
 for BARIndex:=0 to TPCI.PCI_FUNC_BARS-1 do begin
  fBARMemoryDevices[BARIndex]:=nil;
  fBARIsIO[BARIndex]:=false;
 end;
 for BARIndex:=0 to TPCI.PCI_FUNC_BARS-1 do begin
  BARRegion:=aFuncDesc.fBARRegions[BARIndex];
  if BARRegion.fSize<>0 then begin
   fBARIsIO[BARIndex]:=BARRegion.fIsIO;
{$ifdef NewPCI}
   if BARRegion.fIsIO then begin
    BARRegion.fAddress:=GetIOBARAddress(BARRegion.fSize);
   end else begin
    BARRegion.fAddress:=GetBARAddress(BARRegion.fSize);
   end;
   PCIMemoryDevice:=TPCIMemoryDevice.Create(fBus.fMachine,aDevice,self,BARRegion.fAddress,BARRegion.fSize,BARRegion.fOnLoad,BARRegion.fOnStore);
   fBARMemoryDevices[BARIndex]:=PCIMemoryDevice;
   if BARRegion.fIsIO then begin
    // I/O BAR: register as sub-device of TPCIIODevice so FindBusDevice finds it
    if assigned(fBus.fMachine.fPCIIODevice) then begin
     fBus.fMachine.fPCIIODevice.AddSubBusDevice(PCIMemoryDevice);
    end;
   end else begin
    fBus.fMachine.fBus.AddBusDevice(PCIMemoryDevice);
   end;
{$else}
   BARRegion.fSize:=(BARRegion.fSize+15) and TPasRISCVUInt64($fffffffffffffff0);
   if BARRegion.fSize<>0 then begin
    BARRegion.fAddress:=fBus.fMemAddr+((BARRegion.fSize-fBus.fMemAddr) mod BARRegion.fSize);
    dec(fBus.fMemSize,(BARRegion.fAddress+BARRegion.fSize)-fBus.fMemAddr);
    fBus.fMemAddr:=BARRegion.fAddress+BARRegion.fSize;
    PCIMemoryDevice:=TPCIMemoryDevice.Create(fBus.fMachine,aDevice,self,BARRegion.fAddress,BARRegion.fSize,BARRegion.fOnLoad,BARRegion.fOnStore);
    fBARMemoryDevices[BARIndex]:=PCIMemoryDevice;
    fBus.fMachine.fBus.AddBusDevice(PCIMemoryDevice);
   end;
{$endif}
  end;
 end;
end;

destructor TPasRISCV.TPCIFunc.Destroy;
var BarIndex:TPasRISCVUInt32;
    PCIMemoryDevice:TPCIMemoryDevice;
begin
 for BarIndex:=0 to TPCI.PCI_FUNC_BARS-1 do begin
  PCIMemoryDevice:=fBARMemoryDevices[BarIndex];
  if assigned(PCIMemoryDevice) and assigned(fBus) and assigned(fBus.fMachine) then begin
   if fBARIsIO[BarIndex] then begin
    // I/O BAR: remove from TPCIIODevice sub-bus devices
    if assigned(fBus.fMachine.fPCIIODevice) then begin
     fBus.fMachine.fPCIIODevice.RemoveSubBusDevice(PCIMemoryDevice);
    end;
   end else begin
    // MMIO BAR: remove from main bus
    if assigned(fBus.fMachine.fBus) then begin
     fBus.fMachine.fBus.RemoveBusDevice(PCIMemoryDevice);
    end;
   end;
  end;
  FreeAndNil(fBARMemoryDevices[BarIndex]);
 end;
 FreeAndNil(fExpansionROM);
 inherited Destroy;
end;

function TPasRISCV.TPCIFunc.IsUpperHalf(const aBarID:TPasRISCVSizeUInt):Boolean;
begin
 result:=(aBarID<>0) and (not assigned(fBARMemoryDevices[aBarID])) and assigned(fBARMemoryDevices[aBarID-1]);
end;

function TPasRISCV.TPCIFunc.Is64Bit(const aBarID:TPasRISCVSizeUInt):Boolean;
begin
 result:=((aBarID+1)<TPCI.PCI_FUNC_BARS) and assigned(fBARMemoryDevices[aBarID]) and not assigned(fBARMemoryDevices[aBarID+1]);
end;

function TPasRISCV.TPCIFunc.GetEffectiveBar(const aBarID:TPasRISCVSizeUInt):TPCIMemoryDevice;
begin
 if IsUpperHalf(aBarID) then begin
  result:=fBARMemoryDevices[aBarID-1];
 end else begin
  result:=fBARMemoryDevices[aBarID];
 end;
end;

function TPasRISCV.TPCIFunc.GetBARAddress(const aBARSize:TPasRISCVUInt64):TPasRISCVUInt64;
var AlignSize,TemporaryAddress:TPasRISCVUInt64;
begin
 AlignSize:=RoundUpToPowerOfTwo64(Max(aBARSize,$1000));
 result:=fBus.fMemAddr;
 repeat
  TemporaryAddress:=fBus.fMachine.fBus.GetAutoMemoryAddress(result,AlignSize);
  if result=TemporaryAddress then begin
   break;
  end else begin
   result:=TemporaryAddress+((AlignSize-TemporaryAddress) and (AlignSize-1));
  end;
 until false;
end;

function TPasRISCV.TPCIFunc.GetIOBARAddress(const aBARSize:TPasRISCVUInt64):TPasRISCVUInt64;
var AlignSize:TPasRISCVUInt64;
begin
 // Align to power of 2, minimum 4 bytes for I/O BARs
 AlignSize:=RoundUpToPowerOfTwo64(Max(aBARSize,4));
 // Align fIOAddr up to AlignSize boundary
 result:=fBus.fIOAddr+((AlignSize-(fBus.fIOAddr and (AlignSize-1))) and (AlignSize-1));
 // Advance I/O address pointer
 fBus.fIOAddr:=result+AlignSize;
 dec(fBus.fIOSize,fBus.fIOAddr-result);
end;

procedure TPasRISCV.TPCIFunc.SendIRQ(const aMSIID:TPasRISCVUInt32;const aRaiseIRQ:Boolean);
var IRQ:TPasRISCVUInt32;
begin
 if (fIRQPin<>0) and ((TPasMPInterlocked.Read(fCommand) and TPCI.PCI_CMD_INTX_DISABLE)=0) then begin
  TPasMPInterlocked.BitwiseOr(fStatus,TPCI.PCI_STATUS_INTX);
  IRQ:=fBus.fIRQs[TPasRISCV.TPCIBusDevice.PCIFuncIRQPinID(self)];
  if aRaiseIRQ then begin
   fBus.fMachine.fInterrupts.RaiseIRQ(IRQ);
  end else begin
   fBus.fMachine.fInterrupts.SendIRQ(IRQ);
  end;
 end;
end;

procedure TPasRISCV.TPCIFunc.RaiseIRQ(const aMSIID:TPasRISCVUInt32);
begin
 SendIRQ(aMSIID,true);
end;

procedure TPasRISCV.TPCIFunc.LowerIRQ;
var IRQ:TPasRISCVUInt32;
begin
 TPasMPInterlocked.BitwiseAnd(fStatus,TPasRISCVUInt32(not TPCI.PCI_STATUS_INTX));
 IRQ:=fBus.fIRQs[TPasRISCV.TPCIBusDevice.PCIFuncIRQPinID(self)];
 fBus.fMachine.fInterrupts.LowerIRQ(IRQ);
end;

procedure TPasRISCV.TPCIFunc.LowerIRQ(const aMSIID:TPasRISCVUInt32);
begin
 LowerIRQ;
end;

{ TPasRISCV.TPCIIODevice }

constructor TPasRISCV.TPCIIODevice.Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64);
begin
 inherited Create(aMachine,aBase,aSize);
 fRanges:=nil;
 fCountRanges:=0;
 fUnalignedAccessSupport:=true;
 fMinOpSize:=1;
 fMaxOpSize:=4;
end;

destructor TPasRISCV.TPCIIODevice.Destroy;
begin
 fRanges:=nil;
 fCountRanges:=0;
 inherited Destroy;
end;

function TPasRISCV.TPCIIODevice.FindRange(const aPort:TPasRISCVUInt16):PIORange;
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to fCountRanges-1 do begin
  result:=@fRanges[Index];
  if (aPort>=result^.fPort) and (aPort<(result^.fPort+result^.fSize)) then begin
   exit;
  end;
 end;
 result:=nil;
end;

procedure TPasRISCV.TPCIIODevice.RegisterIORange(const aPort,aSize:TPasRISCVUInt16;const aOnLoad:TOnIOLoad;const aOnStore:TOnIOStore);
var Index:TPasRISCVSizeInt;
    Range:PIORange;
begin
 Index:=fCountRanges;
 inc(fCountRanges);
 if length(fRanges)<fCountRanges then begin
  SetLength(fRanges,fCountRanges+((fCountRanges+1) shr 1));
 end;
 Range:=@fRanges[Index];
 Range^.fPort:=aPort;
 Range^.fSize:=aSize;
 Range^.fOnLoad:=aOnLoad;
 Range^.fOnStore:=aOnStore;
end;

procedure TPasRISCV.TPCIIODevice.UnregisterIORange(const aPort:TPasRISCVUInt16);
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to fCountRanges-1 do begin
  if fRanges[Index].fPort=aPort then begin
   if (Index+1)<fCountRanges then begin
    fRanges[Index]:=fRanges[fCountRanges-1];
   end;
   dec(fCountRanges);
   exit;
  end;
 end;
end;

function TPasRISCV.TPCIIODevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Port:TPasRISCVUInt16;
    Range:PIORange;
begin
 Port:=TPasRISCVUInt16(aAddress-fBase);
 Range:=FindRange(Port);
 if assigned(Range) and assigned(Range^.fOnLoad) then begin
  result:=Range^.fOnLoad(Port,aSize);
 end else begin
  // Unassigned I/O port reads return all-ones (like QEMU/x86 behavior)
  case aSize of
   1:begin
    result:=TPasRISCVUInt64($ff);
   end;
   2:begin
    result:=TPasRISCVUInt64($ffff);
   end; 
   4:begin
    result:=TPasRISCVUInt64($ffffffff);
   end;
   else begin
    result:=TPasRISCVUInt64($ffffffffffffffff);
   end;
  end;
 end;
end;

procedure TPasRISCV.TPCIIODevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Port:TPasRISCVUInt16;
    Range:PIORange;
begin
 Port:=TPasRISCVUInt16(aAddress-fBase);
 Range:=FindRange(Port);
 if assigned(Range) and assigned(Range^.fOnStore) then begin
  Range^.fOnStore(Port,aValue,aSize);
 end;
 // Unassigned I/O port writes are silently ignored
end;

{ TPasRISCV.TPCIBusDevice }

constructor TPasRISCV.TPCIBusDevice.Create(const aMachine:TPasRISCV);
var IRQPinIndex:TPasRISCVSizeInt;
begin
 inherited Create(aMachine,TPasRISCV.TPCI.PCI_BASE_DEFAULT_MMIO,256 shl BusShift);
 fIOAddr:=TPasRISCV.TPCI.PCI_IO_DEFAULT_ADDR;
 fIOSize:=TPasRISCV.TPCI.PCI_IO_DEFAULT_SIZE;
 fMemAddr:=TPasRISCV.TPCI.PCI_MEM32_DEFAULT_MMIO;
 fMemSize:=TPasRISCV.TPCI.PCI_MEM32_DEFAULT_SIZE;
 fBusID:=0;
 for IRQPinIndex:=0 to TPCI.PCI_BUS_IRQS-1 do begin
  fIRQs[IRQPinIndex]:=TPCI.PCI_IRQs[IRQPinIndex];
 end;
 Reset;
 FillChar(fDevices,SizeOf(fDevices),#0);
 fCountDevices:=0;
 fHostBridgeDevice:=TPCIHostBridgeDevice.Create(self);
 AddBusDevice(fHostBridgeDevice);
 fUnalignedAccessSupport:=false;
 fMinOpSize:=4;
 fMaxOpSize:=4;
end;

destructor TPasRISCV.TPCIBusDevice.Destroy;
begin
 RemoveBusDevice(fHostBridgeDevice);
 FreeAndNil(fHostBridgeDevice);
 inherited Destroy;
end;

procedure TPasRISCV.TPCIBusDevice.Reset;
begin
end;

function TPasRISCV.TPCIBusDevice.GetFunc(const aBus,aDev,aFunc:TPasRISCVUInt32):TPasRISCV.TPCIFunc;
var Device:TPCIDevice;
begin
 if aDev<TPCI.PCI_BUS_DEVS then begin
  Device:=fDevices[aDev];
  if assigned(Device) then begin
   result:=Device.fFuncs[aFunc];
  end else begin
   result:=nil;
  end;
 end else begin
  result:=nil;
 end;
end;

class function TPasRISCV.TPCIBusDevice.GetIRQID(const aDeviceID,aIRQPin:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 result:=(aDeviceID+aIRQPin+3) and 3;
end;

class function TPasRISCV.TPCIBusDevice.PCIFuncIRQPinID(const aFunc:TPasRISCV.TPCIFunc):TPasRISCVUInt32;
begin
 // Use the bus slot number (TPCIDevice.fDeviceID) for IRQ swizzling, not the PCI Device ID
 result:=GetIRQID(aFunc.fDevice.fDeviceID,aFunc.fIRQPin);
end;

procedure TPasRISCV.TPCIBusDevice.AddBusDevice(const aDevice:TPasRISCV.TPCIDevice);
var DeviceID,FuncIndex:TPasRISCVUInt32;
    Func:TPCIFunc;
begin
 DeviceID:=0;
 while (DeviceID<TPCI.PCI_BUS_DEVS) and assigned(fDevices[DeviceID]) do begin
  inc(DeviceID);
 end;
 if DeviceID<TPCI.PCI_BUS_DEVS then begin
  fDevices[DeviceID]:=aDevice;
  aDevice.fDeviceID:=DeviceID; // Store the bus slot number for IRQ routing
  // Re-compute IRQ lines for all functions now that the slot is known
  for FuncIndex:=0 to TPCI.PCI_DEV_FUNCS-1 do begin
   Func:=aDevice.fFuncs[FuncIndex];
   if assigned(Func) then begin
    if Func.fIRQPin<>0 then begin
     Func.fIRQLine:=fIRQs[PCIFuncIRQPinID(Func)];
    end;
   end;
  end;
  inc(fCountDevices);
 end else begin
  raise EPasRISCV.Create('Too much devices on a single PCI bus');
 end;
end;

procedure TPasRISCV.TPCIBusDevice.RemoveBusDevice(const aDevice:TPasRISCV.TPCIDevice);
var Index:TPasRISCVSizeInt;
begin
 if assigned(aDevice) then begin
  for Index:=0 to TPCI.PCI_BUS_DEVS-1 do begin
   if fDevices[Index]=aDevice then begin
    fDevices[Index]:=nil;
    dec(fCountDevices);
    exit;
   end;
  end;
  raise EPasRISCV.Create('Device not found on PCI bus');
 end;
end;

function TPasRISCV.TPCIBusDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Index:TPasRISCVSizeInt;
    Address,BusAddress,BarID,SecondaryBus,CapabilityID:TPasRISCVUInt64;
    BusID,DevID,FuncID,Register:TPasRISCVUInt8;
    Func:TPasRISCV.TPCIFunc;
    BusDevice:TPasRISCV.TBusDevice;
    Device:TPCIDevice;
begin

 Address:=aAddress-fBase;

 BusID:=Address shr BusShift;
 DevID:=(Address shr (BusShift-5)) and 31;
 FuncID:=(Address shr (BusShift-8)) and 7;
 BusAddress:=Address shr (BusShift-8);
 Register:=Address and (((TPasRISCVUInt64(1) shl (BusShift-8))-1) and TPasRISCVUInt64($fffffffffffffffc));

 Func:=GetFunc(BusID,DevID,FuncID);
 if assigned(Func) then begin

  result:=0;

  case Register of
   TPCI.PCI_REG_DEV_VEN_ID:begin
    result:=Func.fVendorID or (TPasRISCVUInt32(Func.fDeviceID) shl 16);
   end;
   TPCI.PCI_REG_STATUS_CMD:begin
    result:=(TPasMPInterlocked.Read(Func.fStatus) shl 16) or TPasMPInterlocked.Read(Func.fCommand);
{$ifdef NewPCI}
    if BusAddress<>0 then begin
     result:=result or (TPasRISCVUInt32(TPCI.PCI_STATUS_CAP) shl 16);
    end;
{$endif}
   end;
   TPCI.PCI_REG_CLASS_REV:begin
    result:=(Func.fClassCode shl 16) or (TPasRISCVUInt32(Func.fProgIF) shl 8) or Func.fRevisionID;
   end;
   TPCI.PCI_REG_BIST_HDR_LATENCY_CACHE:begin
    result:=16;
{$ifdef NewPCI}
    if DevID<TPCI.PCI_BUS_DEVS then begin
     Device:=fDevices[DevID];
     if assigned(Device) then begin
      for Index:=0 to TPCI.PCI_DEV_FUNCS-1 do begin
       if assigned(Device.fFuncs[Index]) and (Index<>FuncID) then begin
        result:=result or (TPasRISCVUInt32(TPCI.PCI_HEADER_MULTIFUNC) shl 16);
        break;
       end;
      end;
     end;
    end;
    if Func.fClassCode=$0604 then begin
     result:=result or (TPasRISCVUInt32(TPCI.PCI_HEADER_PCI_PCI) shl 16);
    end;
{$endif}
   end;
   TPCI.PCI_REG_IRQ_PIN_LINE:begin
    result:=(TPasMPInterlocked.Read(Func.fIRQLine) or (TPasRISCVUInt32(Func.fIRQPin) shl 8));
   end;
   TPCI.PCI_REG_BAR0..TPCI.PCI_REG_BAR5:begin
{$ifdef NewPCI}
    BarID:=(Register-TPCI.PCI_REG_BAR0) shr 2;
    if (Func.fClassCode<>$0604) or (BarID<2) then begin
     BusDevice:=Func.GetEffectiveBar(BarID);
     if assigned(BusDevice) then begin
      if Func.IsUpperHalf(BarID) then begin
       result:=BusDevice.fBase shr 32;
      end else begin
       result:=TPasRISCVUInt32(BusDevice.fBase);
       if Func.fBARIsIO[BarID] then begin
        // I/O BAR: report port number (offset from I/O base), not physical address
        result:=TPasRISCVUInt32(BusDevice.fBase-TPCI.PCI_IO_DEFAULT_ADDR);
        result:=result or TPCI.PCI_BAR_IO_SPACE;
       end else begin
        if Func.Is64Bit(BarID) then begin
         result:=result or TPCI.PCI_BAR_64_BIT;
        end;
        if BusDevice.fSize>=$10000000 then begin
         result:=result or TPCI.PCI_BAR_PREFETCH;
        end;
       end;
      end;
     end else begin
      result:=0;
     end;
    end else begin
     SecondaryBus:=(BusAddress shr 3) or (BusAddress and 7);
     case BarID of
      $02:begin
       result:=(SecondaryBus shl 16) or (SecondaryBus shl 8);
      end;
      $03:begin
       result:=TPasMPInterlocked.Read(Func.fBridgeIO);
      end;
      $04:begin
       result:=TPasMPInterlocked.Read(Func.fBridgeMem);
      end;
      else begin
       result:=0;
      end;
     end;
    end;
{$else}
    BusDevice:=Func.fBARMemoryDevices[(Register-TPCI.PCI_REG_BAR0) shr 2];
    if assigned(BusDevice) then begin
     result:=BusDevice.fBase;
    end else begin
     result:=0;
    end;
{$endif}
   end;
   TPCI.PCI_REG_SSID_SVID:begin
    if (Func.fSubsystemVendorID<>0) or (Func.fSubsystemDeviceID<>0) then begin
     result:=Func.fSubsystemVendorID or (TPasRISCVUInt32(Func.fSubsystemDeviceID) shl 16);
    end else begin
     result:=$eba110dc;
    end;
   end;
{$ifdef NewPCI}
   TPCI.PCI_REG_EXPANSION_ROM:begin
    if assigned(Func.fExpansionROM) then begin
     result:=Func.fExpansionROM.fBase or TPCI.PCI_EXPANSION_ROM_ENABLED;
    end else begin
     result:=0;
    end;
   end;
   TPCI.PCI_REG_CAP_PTR:begin
    if BusAddress<>0 then begin
     result:=TPCI.PCI_CAP_LIST_OFF;
    end else begin
     result:=0;
    end;
   end;
   else begin
    if BusAddress<>0 then begin
     CapabilityID:=(Register-TPCI.PCI_CAP_LIST_OFF) shr 2;
     if CapabilityID<Length(TPCI.PCIExpressCapabilities) then begin
      result:=TPCI.PCIExpressCapabilities[CapabilityID];
     end else begin
      result:=0;
     end;
     if CapabilityID=0 then begin
      if Func.fClassCode=$0604 then begin
       result:=result or (TPCI.PCIE_CAP_ROOT_PORT shl 20);
      end else if (BusAddress shr 8)=0 then begin
       result:=result or (TPCI.PCIE_CAP_INTEGRATED_ENDPOINT shl 20);
      end;
     end;
    end;
   end;
{$else}
   TPCI.PCI_REG_EXPANSION_ROM,
   TPCI.PCI_REG_CAP_PTR:begin
    result:=0;
   end;
{$endif}
  end;

//writeln('PCI Read: ',LowerCase(IntToHex(Address,8)),' ',LowerCase(IntToHex(BusID,2)),':',LowerCase(IntToHex(DevID,2)),'.',LowerCase(IntToHex(FuncID,1)),' ',LowerCase(IntToHex(Register,2)),' = ',LowerCase(IntToHex(result,8)));

 end else begin

  result:=$ffffffff;

 end;

end;

procedure TPasRISCV.TPCIBusDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address,BusAddress,BarID,BarAddress,BarSize,ROMAddress,ROMSize:TPasRISCVUInt64;
    Old,IRQ:TPasRISCVUInt32;
    BusID,DevID,FuncID,Register:TPasRISCVUInt8;
    Func:TPasRISCV.TPCIFunc;
    BusDevice:TPasRISCV.TBusDevice;
begin

 Address:=aAddress-fBase;

 BusID:=Address shr BusShift;
 DevID:=(Address shr (BusShift-5)) and 31;
 FuncID:=(Address shr (BusShift-8)) and 7;
 BusAddress:=Address shr (BusShift-8);
 Register:=Address and (((TPasRISCVUInt64(1) shl (BusShift-8))-1) and TPasRISCVUInt64($fffffffffffffffc));

//writeln('PCI Write: ',LowerCase(IntToHex(Address,8)),' ',LowerCase(IntToHex(BusID,2)),':',LowerCase(IntToHex(DevID,2)),'.',LowerCase(IntToHex(FuncID,1)),' ',LowerCase(IntToHex(Register,2)),' = ',LowerCase(IntToHex(aValue,8)));

 Func:=GetFunc(BusID,DevID,FuncID);
 if assigned(Func) then begin
  case Register of
   TPCI.PCI_REG_STATUS_CMD:begin
{$ifdef NewPCI}
    Old:=TPasMPInterlocked.Exchange(Func.fCommand,aValue and TPCI.PCI_CMD_MASK);
    if ((Old and TPCI.PCI_CMD_INTX_DISABLE)=0) and ((aValue and TPCI.PCI_CMD_INTX_DISABLE)<>0) then begin
     Func.LowerIRQ;
    end;
{$else}
    TPasMPInterlocked.Write(Func.fCommand,aValue and $ffff);
{$endif}
   end;
   TPCI.PCI_REG_BAR0..TPCI.PCI_REG_BAR5:begin
{$ifdef NewPCI}
    BarID:=(Register-TPCI.PCI_REG_BAR0) shr 2;
    if (Func.fClassCode<>$0604) or (BarID<2) then begin
     BusDevice:=Func.GetEffectiveBar(BarID);
     if assigned(BusDevice) then begin
      BarAddress:=BusDevice.fBase;
      BarSize:=RoundUpToPowerOfTwo64(BusDevice.fSize);
      if Func.IsUpperHalf(BarID) then begin
       BarAddress:=(BarAddress and TPasRISCVUInt64($00000000ffffffff)) or (TPasRISCVUInt64(aValue) shl 32);
      end else begin
       if Func.fBARIsIO[BarID] then begin
        // I/O BAR: kernel writes port number, convert to physical address
        BarAddress:=TPCI.PCI_IO_DEFAULT_ADDR or (TPasRISCVUInt64(aValue) and TPasRISCVUInt64($00000000fffffffc));
       end else begin
        BarAddress:=(BarAddress and TPasRISCVUInt64($ffffffff00000000)) or (TPasRISCVUInt64(aValue) and TPasRISCVUInt64($00000000fffff000));
       end;
      end;
      BarAddress:=BarAddress and TPasRISCVUInt64(not TPasRISCVUInt64(BarSize-1));
      TPasMPInterlocked.Write(BusDevice.fBase,BarAddress);
      TPasMPMemoryBarrier.ReadWrite;
     end;
    end else begin
     case BarID of
      $3:begin
       TPasMPInterlocked.Write(Func.fBridgeIO,TPasRISCVUInt32(aValue));
      end;
      $4:begin
       TPasMPInterlocked.Write(Func.fBridgeMem,TPasRISCVUInt32(aValue));
      end;
     end;
    end;
{$else}
    BusDevice:=Func.fBARMemoryDevices[(Register-TPCI.PCI_REG_BAR0) shr 2];
    if assigned(BusDevice) then begin
     Address:=aValue and not TPasRISCVUInt64(15);
     if TPasRISCVUInt32(TPasRISCVUInt32($ffffffff)-Address)<TPasRISCVUInt32(BusDevice.fSize) then begin
      Address:=TPasRISCVUInt32(-BusDevice.fSize);
     end;
     Address:=Address and not TPasRISCVUInt64(15);
     TPasMPInterlocked.Write(BusDevice.fBase,Address);
    end;
{$endif}
   end;
   TPCI.PCI_REG_IRQ_PIN_LINE:begin
    TPasMPInterlocked.Write(Func.fIRQLine,aValue and $ff);
   end;
   TPCI.PCI_REG_EXPANSION_ROM:begin
{$ifdef NewPCI}
    if assigned(Func.fExpansionROM) then begin
     ROMAddress:=aValue and TPasRISCVUInt64($fffffffffffff000);
     ROMSize:=RoundUpToPowerOfTwo64(Func.fExpansionROM.fSize);
     ROMAddress:=ROMAddress and TPasRISCVUInt64(not TPasRISCVUInt64(ROMSize-1));
     TPasMPInterlocked.Write(Func.fExpansionROM.fBase,ROMAddress);
     TPasMPMemoryBarrier.ReadWrite;
    end;
{$endif}
   end;
  end;
 end;

end;

{ TPasRISCV.TPCIDevice }

constructor TPasRISCV.TPCIDevice.Create(const aBus:TPasRISCV.TPCIBusDevice);
begin
 inherited Create;
 fMachine:=aBus.fMachine;
 fBus:=aBus;
end;

destructor TPasRISCV.TPCIDevice.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV.TPCIDevice.Reset;
begin
end;

procedure TPasRISCV.TPCIDevice.SendIRQ(const aFuncID,aMSIID:TPasRISCVUInt32);
var Func:TPasRISCV.TPCIFunc;
begin
 Func:=fFuncs[aFuncID];
 if assigned(Func) then begin
  Func.SendIRQ(aMSIID,false);
 end;
end;

procedure TPasRISCV.TPCIDevice.RaiseIRQ(const aFuncID,aMSIID:TPasRISCVUInt32);
var Func:TPasRISCV.TPCIFunc;
begin
 Func:=fFuncs[aFuncID];
 if assigned(Func) then begin
  Func.SendIRQ(aMSIID,true);
 end;
end;

procedure TPasRISCV.TPCIDevice.LowerIRQ(const aFuncID:TPasRISCVUInt32);
var Func:TPasRISCV.TPCIFunc;
begin
 Func:=fFuncs[aFuncID];
 if assigned(Func) then begin
  Func.LowerIRQ;
 end;
end;

function TPasRISCV.TPCIDevice.GetGlobalDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
begin
 result:=fBus.fMachine.fBus.GetDirectMemoryAccessPointer(aAddress,aSize,aWrite,aBounce);
end;

{ TPasRISCV.TPCIHostBridgeDevice }

constructor TPasRISCV.TPCIHostBridgeDevice.Create(const aBus:TPasRISCV.TPCIBusDevice);
var FuncDesc:TPasRISCV.TPCIFuncDescriptor;
begin
 inherited Create(aBus);
 FillChar(FuncDesc,SizeOf(TPCIFuncDescriptor),#0);
 FuncDesc.fVendorID:=$f15e;
 FuncDesc.fDeviceID:=$0000;
 FuncDesc.fClassCode:=$0600;
 fFuncs[0]:=TPasRISCV.TPCIFunc.Create(aBus,self,FuncDesc);
end;

destructor TPasRISCV.TPCIHostBridgeDevice.Destroy;
begin
 FreeAndNil(fFuncs[0]);
 inherited Destroy;
end;

{ TPasRISCV.TJobWorkerThread }

constructor TPasRISCV.TJobWorkerThread.Create(const aJobManager:TPasRISCV.TJobManager);
begin
 fJobManager:=aJobManager;
 inherited Create(false);
end;

destructor TPasRISCV.TJobWorkerThread.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV.TJobWorkerThread.Execute;
var Item:TJobQueueItem;
begin

 NameThreadForDebugging('TPasRISCV.TJobWorkerThread');

 while not Terminated do begin

  // Wait until there is something to do
  fJobManager.WaitForWakeUp;

  // Check if the thread is terminated
  if Terminated then begin

   break;

  end else begin

   // Loop until the queue is empty or the thread is terminated
   while not Terminated do begin

    // Dequeue the next item
    if fJobManager.fQueue.TryDequeue(Item) then begin

     case Item.fJobType of

      TPasRISCV.TJobQueueItem.TJobType.VirtIODeviceQueue:begin
       TPasRISCV.TVirtIODevice(Item.fObject).ProcessQueue(Item.fVirtIODeviceQueue,Item.fVirtIODeviceAvailableIndex);
      end;

      TPasRISCV.TJobQueueItem.TJobType.NVMeDeviceQueue:begin
       TPasRISCV.TNVMeDevice(Item.fObject).ProcessQueue(Item.fNVMeDeviceQueue,Item.fNVMeDeviceQueueValue,true);
      end;

      TPasRISCV.TJobQueueItem.TJobType.NVMeDeviceCommand:begin
       TPasRISCV.TNVMeDevice(Item.fObject).ProcessCommand(Item.fNVMeDeviceCommand);
      end;

      else begin
      end;

     end;

    end else begin

     // Queue is empty, wait for the next event
     break;

    end;

   end;

  end;

 end;

end;

{ TPasRISCV.TJobManager }

constructor TPasRISCV.TJobManager.Create(const aCountWorkerThreads:TPasRISCVSizeInt);
var Index:TPasRISCVSizeInt;
    JobWorkerThread:TPasRISCV.TJobWorkerThread;
begin

 fQueue:=TJobQueue.Create;

 fCountWorkerThreads:=aCountWorkerThreads;

 SetLength(fWorkerThreads,fCountWorkerThreads);

 fSleepingOnIdle:=true;

 fSleepingJobWorkerThreads:=0;

 fWakeUpCounter:=0;

 fWakeUpConditionVariableLock:=TPasMPConditionVariableLock.Create;

 fWakeUpConditionVariable:=TPasMPConditionVariable.Create;

 for Index:=0 to fCountWorkerThreads-1 do begin
  JobWorkerThread:=TPasRISCV.TJobWorkerThread.Create(self);
  fWorkerThreads[Index]:=JobWorkerThread;
 end;

 fSequence:=0;

end;

destructor TPasRISCV.TJobManager.Destroy;
var Item:TJobQueueItem;
    Index:TPasRISCVSizeInt;
begin

 Shutdown;

 while fQueue.TryDequeue(Item) do begin
  case Item.fJobType of
   TPasRISCV.TJobQueueItem.TJobType.VirtIODeviceQueue:begin
   end;
   TPasRISCV.TJobQueueItem.TJobType.NVMeDeviceCommand:begin
   end;
   else begin
   end;
  end;
 end;

 FreeAndNil(fQueue);

 for Index:=0 to fCountWorkerThreads-1 do begin
  FreeAndNil(fWorkerThreads[Index]);
 end;

 FreeAndNil(fWakeUpConditionVariable);
 FreeAndNil(fWakeUpConditionVariableLock);

 inherited Destroy;

end;

procedure TPasRISCV.TJobManager.Shutdown;
var Index:TPasRISCVSizeInt;
    JobWorkerThread:TPasRISCV.TJobWorkerThread;
begin
 for Index:=0 to fCountWorkerThreads-1 do begin
  JobWorkerThread:=fWorkerThreads[Index];
  if assigned(JobWorkerThread) then begin
   JobWorkerThread.Terminate;
  end;
 end;
 WakeUpAllWorkerThreads;
 for Index:=0 to fCountWorkerThreads-1 do begin
  JobWorkerThread:=fWorkerThreads[Index];
  if assigned(JobWorkerThread) then begin
   JobWorkerThread.WaitFor;
  end;
 end;
end;

procedure TPasRISCV.TJobManager.WaitForWakeUp;
var SavedWakeUpCounter:TPasMPInt32;
begin
 if fSleepingOnIdle then begin
  fWakeUpConditionVariableLock.Acquire;
  try
   TPasMPInterlocked.Increment(fSleepingJobWorkerThreads);
   TPasMPMemoryBarrier.Read;
   SavedWakeUpCounter:=fWakeUpCounter;
   TPasMPMemoryBarrier.ReadDependency;
   repeat
    fWakeUpConditionVariable.Wait(fWakeUpConditionVariableLock);
   until SavedWakeUpCounter<>fWakeUpCounter;
   TPasMPInterlocked.Decrement(fSleepingJobWorkerThreads);
  finally
   fWakeUpConditionVariableLock.Release;
  end;
 end else begin
  TPasMP.Yield;
 end;
end;

procedure TPasRISCV.TJobManager.WakeUpAllWorkerThreads;
begin
 if fSleepingJobWorkerThreads>0 then begin
  fWakeUpConditionVariableLock.Acquire;
  try
   inc(fWakeUpCounter);
   TPasMPMemoryBarrier.Write;
   fWakeUpConditionVariable.Broadcast;
  finally
   fWakeUpConditionVariableLock.Release;
  end;
 end;
end;

function TPasRISCV.TJobManager.EnqueueVirtIODeviceQueue(const aVirtIODevice:TVirtIODevice;const aVirtIODeviceQueue:TPasRISCVUInt32;const aVirtIODeviceAvailableIndex:TPasRISCVInt32):Boolean;
var Item:TJobQueueItem;
begin

 Item.fJobType:=TPasRISCV.TJobQueueItem.TJobType.VirtIODeviceQueue;
 Item.fObject:=aVirtIODevice;
 Item.fVirtIODeviceQueue:=aVirtIODeviceQueue;
 Item.fVirtIODeviceAvailableIndex:=aVirtIODeviceAvailableIndex;

 fQueue.Enqueue(Item);

 WakeUpAllWorkerThreads;

 result:=true;

end;

function TPasRISCV.TJobManager.EnqueueNVMeDeviceQueue(const aNVMeDevice:TNVMeDevice;const aNVMeDeviceQueue,aNVMeDeviceQueueValue:TPasRISCVUInt32):Boolean;
var Item:TJobQueueItem;
begin

 Item.fJobType:=TPasRISCV.TJobQueueItem.TJobType.NVMeDeviceQueue;
 Item.fObject:=aNVMeDevice;
 Item.fNVMeDeviceQueue:=aNVMeDeviceQueue;
 Item.fNVMeDeviceQueueValue:=aNVMeDeviceQueueValue;

 fQueue.Enqueue(Item);

 WakeUpAllWorkerThreads;

 result:=true;

end;

function TPasRISCV.TJobManager.EnqueueNVMeDeviceCommand(const aNVMeDevice:TNVMeDevice;const aNVMeDeviceCommand:TNVMeDeviceCommand):Boolean;
var Item:TJobQueueItem;
begin

 Item.fJobType:=TPasRISCV.TJobQueueItem.TJobType.NVMeDeviceCommand;
 Item.fObject:=aNVMeDevice;
 Item.fNVMeDeviceCommand:=aNVMeDeviceCommand;

 fQueue.Enqueue(Item);

 WakeUpAllWorkerThreads;

 result:=true;

end;

function TPasRISCV.TJobManager.EnqueueNVMeDeviceCommands(const aNVMeDevice:TNVMeDevice;const aNVMeDeviceCommands:TNVMeDeviceCommandDynamicArray;const aCount:TPasRISCVSizeInt):Boolean;
var Item:TJobQueueItem;
    Index:TPasRISCVSizeInt;
begin

 if aCount>0 then begin

  Item.fJobType:=TPasRISCV.TJobQueueItem.TJobType.NVMeDeviceCommand;
  Item.fObject:=aNVMeDevice;

  for Index:=0 to aCount-1 do begin

   Item.fNVMeDeviceCommand:=aNVMeDeviceCommands[Index];

   fQueue.Enqueue(Item);

  end;

  WakeUpAllWorkerThreads;

 end;

 result:=true;

end;

{ TPasRISCV.TNVMeDevice.TNVMeQueue }

class function TPasRISCV.TNVMeDevice.TNVMeQueue.Dequeue(var aQueue:TNVMeQueue;out aEntry:TPasRISCVUInt32):Boolean;
var Size,Head,Tail,Next:TPasRISCVUInt32;
begin
 Size:=TPasMPInterlocked.Read(aQueue.Size);
 Tail:=TPasMPInterlocked.Read(aQueue.Tail);
 repeat
  TPasMPMemoryBarrier.ReadDependency;
  Head:=TPasMPInterlocked.Read(aQueue.Head);
  if (Head=Tail) or (Tail>Size) then begin
   aEntry:=0;
   result:=false;
   exit;
  end;
  if Head<Size then begin
   Next:=Head+1;
  end else begin
   Next:=0;
  end;
 until TPasMPInterlocked.CompareExchange(aQueue.Head,Next,Head)=Head;
 aEntry:=Head;
 result:=true;
end;

class function TPasRISCV.TNVMeDevice.TNVMeQueue.Enqueue(var aQueue:TNVMeQueue):TPasRISCVUInt32;
var Size,Tail,Next:TPasRISCVUInt32;
begin
 Size:=TPasMPInterlocked.Read(aQueue.Size);
 repeat
  TPasMPMemoryBarrier.ReadDependency;
  Tail:=TPasMPInterlocked.Read(aQueue.Tail);
  if Tail<Size then begin
   Next:=Tail+1;
  end else begin
   Next:=0;
  end;
 until TPasMPInterlocked.CompareExchange(aQueue.Tail,Next,Tail)=Tail;
 result:=Tail;
end;

function TPasRISCV.TNVMeDevice.TNVMeQueue.GetAddress:TPasRISCVUInt64;
begin
 TPasMPMemoryBarrier.ReadDependency;
 result:=TPasMPInterlocked.Read(AddressLow);
 TPasMPMemoryBarrier.ReadDependency;
 result:=result or (TPasRISCVUInt64(TPasMPInterlocked.Read(AddressHigh)) shl 32);
end;

function TPasRISCV.TNVMeDevice.TNVMeQueue.GetSize:TPasRISCVUInt32;
begin
 TPasMPMemoryBarrier.ReadDependency;
 result:=TPasMPInterlocked.Read(Size);
end;

procedure TPasRISCV.TNVMeDevice.TNVMeQueue.RaiseIRQ(const aNVMEDevice:TNVMEDevice);
var IRQRegister,IRQVector,IRQMask:TPasRISCVUInt32;
begin
 IRQRegister:=TPasMPInterlocked.Read(Data.IRQ);
 if (IRQRegister and CQ_FLAGS_IEN)<>0 then begin
  IRQVector:=(IRQRegister shr 16) and $1f;
  IRQMask:=TPasRISCVUInt32(1) shl (IRQVector and $1f);
  if (TPasMPInterlocked.Read(aNVMEDevice.fIRQMask) and IRQMask)=0 then begin
   aNVMEDevice.fFuncs[0].RaiseIRQ(IRQVector);
  end;
 end;
end;

procedure TPasRISCV.TNVMeDevice.TNVMeQueue.LowerIRQ(const aNVMEDevice:TNVMEDevice);
var IRQVector:TPasRISCVUInt32;
begin
 IRQVector:=(TPasMPInterlocked.Read(Data.IRQ) shr 16) and $1f;
 aNVMEDevice.fFuncs[0].LowerIRQ(IRQVector);
end;

procedure TPasRISCV.TNVMeDevice.TNVMeQueue.Reset;
begin
 TPasMPInterlocked.Write(Head,0);
 TPasMPInterlocked.Write(Tail,0);
 TPasMPInterlocked.Write(Phase,0); // gets 1 initial, because Tail is initally also 0 (0=overflow flip indicator)
end;

procedure TPasRISCV.TNVMeDevice.TNVMeQueue.Setup(const aNVMEDevice:TNVMEDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt32;const aData:TPasRISCVUInt32);
begin
 TPasMPInterlocked.Write(AddressLow,TPasRISCVUInt32(aAddress and not NVME_PAGE_MASK));
 TPasMPInterlocked.Write(AddressHigh,TPasRISCVUInt32(aAddress shr 32));
 TPasMPInterlocked.Write(Size,aSize);
 TPasMPInterlocked.Write(Data.CompletionQueueID,aData);
 Reset;
end;

{ TPasRISCV.TNVMeDevice }

constructor TPasRISCV.TNVMeDevice.Create(const aBus:TPasRISCV.TPCIBusDevice);
var FuncDesc:TPasRISCV.TPCIFuncDescriptor;
    BARRegion:TPasRISCV.PPCIBARRegion;
    PCG32:TPCG32;
    Index:TPasRISCVSizeInt;
begin
 inherited Create(aBus);

 FillChar(FuncDesc,SizeOf(TPCIFuncDescriptor),#0);
 FuncDesc.fVendorID:=SSD_VendorID;
 FuncDesc.fDeviceID:=SSD_DeviceID;
 FuncDesc.fClassCode:=$0108; // Mass Storage Controller, Non-Volatile Memory Controller
 FuncDesc.fProgIF:=$02; // NVMHCI
 FuncDesc.fRevisionID:=0;
 FuncDesc.fIRQPin:=TPCI.PCI_IRQ_PIN_INTA;

 BARRegion:=@FuncDesc.fBARRegions[0];
{$ifdef NewPCI}
 BARRegion^.fAddress:=0;
{$else}
 BARRegion^.fAddress:=TPCI.PCI_BAR_ADDR_64;
{$endif}
 BARRegion^.fSize:=$4000;
 BARRegion^.fIsIO:=false;
 BARRegion^.fOnLoad:=OnLoad;
 BARRegion^.fOnStore:=OnStore;

 fFuncs[0]:=TPasRISCV.TPCIFunc.Create(aBus,self,FuncDesc);

{$ifdef NVMELevelTriggeredPCIEInterrupts}
 // Enable IEN on Admin Completion Queue
 fCompletionQueues[QUEUE_ADMIN].Data.IRQ:=CQ_FLAGS_IEN;
{$endif}

 // Random serial number
 PCG32.Init(GetCurrentTime xor TPasRISCVPtrUInt(self));
 for Index:=0 to 11 do begin
  fSerial[Index]:=TPasRISCV.SerialChars[PCG32.GetUnbiasedBounded(36) mod 36];
 end;

 fStreamLock:=TPasMPSlimReaderWriterLock.Create;

 fStream:=TMemoryStream.Create;

end;

destructor TPasRISCV.TNVMeDevice.Destroy;
begin
 FreeAndNil(fStream);
 FreeAndNil(fStreamLock);
 FreeAndNil(fFuncs[0]);
 inherited Destroy;
end;

function TPasRISCV.TNVMeDevice.GetSubmissionQueue(const aQueueID:TPasRISCVUInt32):PNVMeQueue;
begin
 if aQueueID<=NVME_IO_QUEUES then begin
  result:=@fSubmissionQueues[aQueueID];
 end else begin
  result:=nil;
 end;
end;

function TPasRISCV.TNVMeDevice.GetCompletionQueue(const aQueueID:TPasRISCVUInt32):PNVMeQueue;
begin
 if aQueueID<=NVME_IO_QUEUES then begin
  result:=@fCompletionQueues[aQueueID];
 end else begin
  result:=nil;
 end;
end;

procedure TPasRISCV.TNVMeDevice.ResetDevice;
var Index:TPasRISCVSizeInt;
begin
 while TPasMPInterlocked.Read(fThreads)<>0 do begin
  sleep(1);
 end;
 // Reset Admin Queues (keep address, size, data)
 fSubmissionQueues[QUEUE_ADMIN].Reset;
 fCompletionQueues[QUEUE_ADMIN].LowerIRQ(self);
 fCompletionQueues[QUEUE_ADMIN].Reset;
 // Reset IO Queues
 for Index:=QUEUE_IO to NVME_IO_QUEUES do begin
  fSubmissionQueues[Index].Setup(self,0,0,0);
  fCompletionQueues[Index].LowerIRQ(self);
  fCompletionQueues[Index].Setup(self,0,0,0);
 end;
end;

procedure TPasRISCV.TNVMeDevice.CompleteCommand(const aCommand:PNVMeCommand;const aStatus:TPasRISCVUInt32;const aCommandSpecific:TPasRISCVUInt32=0);
var Queue:PNVMeQueue;
    QueueTail,CmdID{$ifndef NVMELevelTriggeredPCIEInterrupts},IRQVector,IRQMask{$endif}:TPasRISCVUInt32;
    Address:TPasRISCVUInt64;
    Ptr:PPasRISCVUInt8;
begin

 Queue:=GetCompletionQueue(aCommand^.CompletionQueueID);
 if not assigned(Queue) then begin
  exit;
 end;

 QueueTail:=TNVMeQueue.Enqueue(Queue^);

 if QueueTail=0 then begin
  Queue^.Phase:=Queue^.Phase xor 1;
 end;

 Address:=Queue^.GetAddress+(TPasRISCVUInt64(QueueTail) shl CQE_SIZE_SHIFT);

 Ptr:=GetGlobalDirectMemoryAccessPointer(Address,CQE_SIZE,true,nil);
 if assigned(Ptr) then begin
  // Read CmdID from the SQE
  CmdID:=PPasRISCVUInt16(@PPasRISCVUInt8Array(aCommand^.Ptr)[SQE_CID])^;
  PPasRISCVUInt32(@PPasRISCVUInt8Array(Ptr)[CQE_CS])^:=aCommandSpecific;
  PPasRISCVUInt32(@PPasRISCVUInt8Array(Ptr)[CQE_RSVD])^:=0;
  PPasRISCVUInt32(@PPasRISCVUInt8Array(Ptr)[CQE_SQHD_SQID])^:=aCommand^.SqHeadID;
  TPasMPMemoryBarrier.Write;
  PPasRISCVUInt32(@PPasRISCVUInt8Array(Ptr)[CQE_CID_PB_SF])^:=CmdID or (aStatus shl CQE_SF_SHIFT) or ((Queue^.Phase and 1) shl 16);
  TPasMPMemoryBarrier.Write;
{$ifdef NVMELevelTriggeredPCIEInterrupts}
  Queue^.RaiseIRQ(self);
{$else}
  IRQVector:=Queue^.Data.IRQ shr 16;
  IRQMask:=TPasRISCVUInt32(1) shl (IRQVector and $1f);
  if (fIRQMask and IRQMask)=0 then begin
   SendIRQ(0,IRQMask);
  end;
{$endif}
 end;

end;

procedure TPasRISCV.TNVMeDevice.PreparePRP(const aCommand:PNVMeCommand;const aSize:TPasRISCVUInt64);
begin
 aCommand^.PRP.PRP1:=PPasRISCVUInt64(@PPasRISCVUInt8Array(aCommand^.Ptr)[SQE_PRP1])^;
 aCommand^.PRP.PRP2:=PPasRISCVUInt64(@PPasRISCVUInt8Array(aCommand^.Ptr)[SQE_PRP2])^;
 aCommand^.PRP.Size:=aSize;
 aCommand^.PRP.Current:=0;
end;

function TPasRISCV.TNVMeDevice.PRPAvail(const aCommand:PNVMeCommand):TPasRISCVUInt64;
begin
 result:=aCommand^.PRP.Size-aCommand^.PRP.Current;
end;

function TPasRISCV.TNVMeDevice.ParsePRPRegion(const aCommand:PNVMeCommand):TPasRISCVUInt64;
var PRP:PNVMePRPCtx;
    Len:TPasRISCVUInt64;
    PRP2Addr:TPasRISCVUInt64;
    DMA:Pointer;
    Page:TPasRISCVUInt64;
    Avail:TPasRISCVUInt64;
begin

 PRP:=@aCommand^.PRP;
 Len:=NVME_PAGE_SIZE;

 if PRP^.Current=0 then begin
  // Consume the first page from PRP1, may be misaligned
  Len:=NVME_PAGE_SIZE-(PRP^.PRP1 and NVME_PAGE_MASK);
  if Len>=PRP^.Size then begin
   // Single-page region
   result:=PRP^.Size;
   exit;
  end else if PRP^.Size<=(Len+NVME_PAGE_SIZE) then begin
   // PRP2 encodes second page address
   Page:=PRP^.PRP2 and (not NVME_PAGE_MASK);
   if Page=(PRP^.PRP1+Len) then begin
    // Contiguous two-page region
    result:=PRP^.Size;
   end else begin
    // Scattered two-page region
    PRP^.PRP1:=Page;
    result:=Len;
   end;
   exit;
  end;
 end;

 // Process PRP list entries until we reach end of transfer
 PRP2Addr:=PRP^.PRP2 and (not TPasRISCVUInt64(7));
 DMA:=nil;

 while PRPAvail(aCommand)>Len do begin

  if not assigned(DMA) then begin
   // Obtain DMA mapping of the PRP list
   DMA:=GetGlobalDirectMemoryAccessPointer(PRP2Addr and (not NVME_PAGE_MASK),NVME_PAGE_SIZE,true,nil);
   if not assigned(DMA) then begin
    // PRP list DMA error
    break;
   end;
  end;

  if (((PRP2Addr+8) and NVME_PAGE_MASK)=0) and (PRPAvail(aCommand)>(Len+NVME_PAGE_SIZE)) then begin
   // Last entry in PRP list page => pointer to next PRP list page
   PRP2Addr:=PPasRISCVUInt64(TPasRISCVPtrUInt(TPasRISCVPtrUInt(DMA)+NVME_PAGE_SIZE-8))^ and (not NVME_PAGE_MASK);
   DMA:=nil;
  end else begin
   // Regular PRP list entry
   Page:=PPasRISCVUInt64(TPasRISCVPtrUInt(TPasRISCVPtrUInt(DMA)+(PRP2Addr and NVME_PAGE_MASK)))^;
   // Advance pointers
   inc(PRP2Addr,8);
   if Page<>(PRP^.PRP1+Len) then begin
    // Scattered region - save state and break
    PRP^.PRP1:=Page;
    PRP^.PRP2:=PRP2Addr;
    break;
   end;
   inc(Len,NVME_PAGE_SIZE);
  end;

 end;

 Avail:=PRPAvail(aCommand);
 if Len<Avail then begin
  result:=Len;
 end else begin
  result:=Avail;
 end;

end;

function TPasRISCV.TNVMeDevice.GetPRPRegion(const aCommand:PNVMeCommand;out aSize:TPasRISCVUInt64):Pointer;
var Address:TPasRISCVUInt64;
    Size:TPasRISCVUInt64;
begin
 Address:=aCommand^.PRP.PRP1;
 Size:=ParsePRPRegion(aCommand);
 if Size<>0 then begin
  result:=GetGlobalDirectMemoryAccessPointer(Address,Size,true,nil);
  inc(aCommand^.PRP.Current,Size);
  if assigned(result) then begin
   aSize:=Size;
   exit;
  end;
 end;
 aSize:=0;
 result:=nil;
end;

procedure TPasRISCV.TNVMeDevice.CopyToPRP(const aCommand:PNVMeCommand;const aData:Pointer;const aSize:TPasRISCVUInt64);
var Src:PPasRISCVUInt8;
    Dest:Pointer;
    RegSize,Remaining,ToCopy:TPasRISCVUInt64;
begin
 Src:=aData;
 Remaining:=aSize;
 while true do begin
  RegSize:=0;
  Dest:=GetPRPRegion(aCommand,RegSize);
  if not assigned(Dest) then begin
   break;
  end;
  ToCopy:=RegSize;
  if ToCopy>Remaining then begin
   ToCopy:=Remaining;
  end;
  if ToCopy>0 then begin
   Move(Src^,Dest^,ToCopy);
   Dest:=Pointer(TPasRISCVPtrUInt(Dest)+ToCopy);
   dec(RegSize,ToCopy);
   inc(Src,ToCopy);
   dec(Remaining,ToCopy);
  end;
  if RegSize>0 then begin
   FillChar(Dest^,RegSize,#0);
  end;
 end;
end;

procedure TPasRISCV.TNVMeDevice.Identify(const aCommand:PNVMeCommand);
const ID:RawByteString='nqn.2024-12.pasriscv:nvme:';
      NVMeStr:RawByteString='NVMe Storage';
      R947Str:RawByteString='R947';
var Ptr:PPasRISCVUInt8;
    LBASize:TPasRISCVUInt64;
    OK:Boolean;
    s:TPasRISCVRawByteString;
begin
 GetMem(Ptr,NVME_PAGE_SIZE);
 try
  FillChar(Ptr^,NVME_PAGE_SIZE,#0);
//writeln('Admin command identify: ',LowerCase(IntToHex(PPasRISCVUInt8Array(aCommand^.Ptr)^[SQE_CDW10])));
  PreparePRP(aCommand,NVME_PAGE_SIZE);
  case PPasRISCVUInt8Array(aCommand^.Ptr)^[SQE_CDW10] of
   IDENT_NS:begin
    LBASize:=fStream.Size shr NVME_LBAS;
    PPasRISCVUInt64(@PPasRISCVUInt8Array(Ptr)^[0])^:=LBASize;
    PPasRISCVUInt64(@PPasRISCVUInt8Array(Ptr)^[8])^:=LBASize;
    PPasRISCVUInt64(@PPasRISCVUInt8Array(Ptr)^[16])^:=LBASize;
    // Namespace features
    PPasRISCVUInt8Array(Ptr)^[33]:=$09; // Deallocated blocks read as zero; Supports Deallocate bit in Write Zeroes
    PPasRISCVUInt8Array(Ptr)^[130]:=NVME_LBAS; // LBA Format: 512b logical blocks
    OK:=true;
   end;
   IDENT_CTRL:begin
    PPasRISCVUInt16(@PPasRISCVUInt8Array(Ptr)^[0])^:=SSD_VendorID; // PCI Vendor ID
    PPasRISCVUInt16(@PPasRISCVUInt8Array(Ptr)^[2])^:=SSD_VendorID; // PCI Vendor ID
    Move(fSerial,PPasRISCVUInt8Array(Ptr)^[4],SizeOf(fSerial)); // Serial Number
    Move(NVMeStr[1],PPasRISCVUInt8Array(Ptr)^[24],Length(NVMeStr)); // Model Number
    Move(R947Str[1],PPasRISCVUInt8Array(Ptr)^[64],Length(R947Str)); // Firmware Revision
    PPasRISCVUInt32(@PPasRISCVUInt8Array(Ptr)^[80])^:=NVME_VERSION; // Version
    // Controller features
    PPasRISCVUInt8Array(Ptr)^[72]:=$02; // Recommended Arbitration Burst
    PPasRISCVUInt8Array(Ptr)^[111]:=$1; // Controller Type: I/O Controller
    PPasRISCVUInt8Array(Ptr)^[512]:=$66; // Submission Queue Max/Cur Entry Size
    PPasRISCVUInt8Array(Ptr)^[513]:=$44; // Completion Queue Max/Cur Entry Size
    PPasRISCVUInt8Array(Ptr)^[516]:=$1; // Number of Namespaces
    PPasRISCVUInt8Array(Ptr)^[520]:=$4; // Supports Dataset Management (TRIM)
    PPasRISCVUInt8Array(Ptr)^[526]:=$07; // Atomic Write Unit Normal: 4kb
    PPasRISCVUInt8Array(Ptr)^[528]:=$07; // Atomic Write Unit Power Fail: 4kb
    // NVMe Qualified Name including serial to distinguish targets
    s:=ID;
    SetLength(s,length(s)+SizeOf(fSerial));
    Move(fSerial[0],s[length(s)-SizeOf(fSerial)],SizeOf(fSerial));
    Move(s[1],PPasRISCVUInt8Array(Ptr)[768],length(s));
    OK:=true;
   end;
   IDENT_NSLS:begin
    PPasRISCVUInt32(@PPasRISCVUInt8Array(Ptr)^[0])^:=$1;
    OK:=true;
   end;
   IDENT_NIDS:begin
    PPasRISCVUInt8Array(Ptr)^[0]:=$3;
    PPasRISCVUInt8Array(Ptr)^[1]:=$10;
    OK:=true;
   end;
   else begin
    OK:=false;
   end;
  end;
  if OK then begin
   CopyToPRP(aCommand,Ptr,NVME_PAGE_SIZE);
   CompleteCommand(aCommand,SC_SUCCESS);
  end else begin
   CompleteCommand(aCommand,SC_BAD_FIELD);
  end;
 finally
  FreeMem(Ptr);
 end;
end;

procedure TPasRISCV.TNVMeDevice.GetLogPage(const aCommand:PNVMeCommand);
var Ptr:PPasRISCVUInt8;
    LogID:TPasRISCVUInt8;
    OK:Boolean;
begin
 GetMem(Ptr,NVME_PAGE_SIZE);
 try
  FillChar(Ptr^,NVME_PAGE_SIZE,#0);
  LogID:=PPasRISCVUInt8Array(aCommand^.Ptr)^[SQE_CDW10];
  case LogID of
   LOG_ERROR,LOG_FIRMWARE_SLOT:begin
    OK:=true;
   end;
   LOG_SMART:begin
    PPasRISCVUInt16(@PPasRISCVUInt8Array(Ptr)^[1])^:=315; // Temperature (In Kelvins)
    PPasRISCVUInt8Array(Ptr)^[3]:=94;  // Available Spare Percent
    PPasRISCVUInt8Array(Ptr)^[4]:=10;  // Available Spare Threshold
    OK:=true;
   end;
   else begin
    OK:=false;
   end;
  end;
  if OK then begin
   PreparePRP(aCommand,PPasRISCVUInt32(@PPasRISCVUInt8Array(aCommand^.Ptr)^[SQE_CDW10])^ shr 16);
   CopyToPRP(aCommand,Ptr,NVME_PAGE_SIZE);
   CompleteCommand(aCommand,SC_SUCCESS);
  end else begin
   CompleteCommand(aCommand,SC_BAD_FIELD);
  end;
 finally
  FreeMem(Ptr);
 end;
end;

procedure TPasRISCV.TNVMeDevice.CreateIOSubmissionQueue(const aCommand:PNVMeCommand);
var Address:TPasRISCVUInt64;
    SubmissionQueueID,SubmissionQueueSize,CompletionQueueFlag,CompletionQueueID:TPasRISCVUInt32;
    SubmissionQueue:PNVMeQueue;
    CompletionQueue:PNVMeQueue;
begin
 Address:=PPasRISCVUInt64(@PPasRISCVUInt8Array(aCommand^.Ptr)[SQE_PRP1])^;
 SubmissionQueueID:=PPasRISCVUInt16(@PPasRISCVUInt8Array(aCommand^.Ptr)[SQE_CDW10])^;
 SubmissionQueueSize:=PPasRISCVUInt16(@PPasRISCVUInt8Array(aCommand^.Ptr)[SQE_CDW10+2])^;
 CompletionQueueFlag:=PPasRISCVUInt16(@PPasRISCVUInt8Array(aCommand^.Ptr)[SQE_CDW11])^;
 CompletionQueueID:=PPasRISCVUInt16(@PPasRISCVUInt8Array(aCommand^.Ptr)[SQE_CDW11+2])^;
 SubmissionQueue:=GetSubmissionQueue(SubmissionQueueID);
 CompletionQueue:=GetCompletionQueue(CompletionQueueID);
{$ifdef NVMELevelTriggeredPCIEInterrupts}
 if (CompletionQueueFlag and CQ_FLAGS_PC)=0 then begin
  // Non-contiguous queue
  CompleteCommand(aCommand,SC_BAD_FIELD);
 end else{$endif}if SubmissionQueueSize=0 then begin
  CompleteCommand(aCommand,SC_BAD_QUEUE_SIZE);
 end else if (SubmissionQueueID=0) or (not assigned(SubmissionQueue)) or (SubmissionQueue^.GetSize<>0) then begin
  // Submission queue ID invalid or already in use
  CompleteCommand(aCommand,SC_BAD_QUEUE_ID);
 end else if (not assigned(CompletionQueue)) or (CompletionQueue^.GetSize=0) then begin
  // Completion queue invalid or not yet created
  CompleteCommand(aCommand,SC_BAD_CQ);
 end else begin
  SubmissionQueue^.Setup(self,Address,SubmissionQueueSize,CompletionQueueID);
  CompleteCommand(aCommand,SC_SUCCESS);
 end;
end;

procedure TPasRISCV.TNVMeDevice.CreateIOCompletionQueue(const aCommand:PNVMeCommand);
var Address:TPasRISCVUInt64;
    CompletionQueueID,CompletionQueueSize,CompletionQueueFlag:TPasRISCVUInt32;
    Queue:PNVMeQueue;
begin
 Address:=PPasRISCVUInt64(@PPasRISCVUInt8Array(aCommand^.Ptr)[SQE_PRP1])^;
 CompletionQueueID:=PPasRISCVUInt16(@PPasRISCVUInt8Array(aCommand^.Ptr)[SQE_CDW10])^;
 CompletionQueueSize:=PPasRISCVUInt16(@PPasRISCVUInt8Array(aCommand^.Ptr)[SQE_CDW10+2])^;
 CompletionQueueFlag:=PPasRISCVUInt32(@PPasRISCVUInt8Array(aCommand^.Ptr)[SQE_CDW11])^;
 Queue:=GetCompletionQueue(CompletionQueueID);
{$ifdef NVMELevelTriggeredPCIEInterrupts}
 if (CompletionQueueFlag and CQ_FLAGS_PC)=0 then begin
  // Non-contiguous queue
  CompleteCommand(aCommand,SC_BAD_FIELD);
 end else{$endif}if CompletionQueueSize=0 then begin
  CompleteCommand(aCommand,SC_BAD_QUEUE_SIZE);
 end else if (CompletionQueueID=0) or (not assigned(Queue)) or (Queue^.GetSize<>0) then begin
  // Completion queue ID invalid or already in use
  CompleteCommand(aCommand,SC_BAD_QUEUE_ID);
 end else begin
  Queue^.LowerIRQ(self);
  Queue^.Setup(self,Address,CompletionQueueSize,CompletionQueueFlag);
  CompleteCommand(aCommand,SC_SUCCESS);
 end;
end;

procedure TPasRISCV.TNVMeDevice.DeleteIOQueue(const aCommand:PNVMeCommand;const aIsCompletionQueue:Boolean);
var QueueID:TPasRISCVUInt32;
    Queue:PNVMeQueue;
begin
 QueueID:=PPasRISCVUInt16(@PPasRISCVUInt8Array(aCommand^.Ptr)[SQE_CDW10])^;
 if aIsCompletionQueue then begin
  Queue:=GetCompletionQueue(QueueID);
 end else begin
  Queue:=GetSubmissionQueue(QueueID);
 end;
 if (QueueID=0) or (not assigned(Queue)) then begin
  CompleteCommand(aCommand,SC_BAD_QUEUE_ID);
 end else begin
  if aIsCompletionQueue then begin
   Queue^.LowerIRQ(self);
  end;
  Queue^.Setup(self,0,0,0);
  CompleteCommand(aCommand,SC_SUCCESS);
 end;
end;

procedure TPasRISCV.TNVMeDevice.HandleFeature(const aCommand:PNVMeCommand;const aSet:Boolean);
var FeatureID:TPasRISCVUInt8;
    FeatureVal:TPasRISCVUInt32;
begin
 FeatureID:=PPasRISCVUInt8Array(aCommand^.Ptr)^[SQE_CDW10];
 FeatureVal:=0;
 case FeatureID of
  FEAT_ARBITRATION:begin
   FeatureVal:=$07;
  end;
  FEAT_NUM_QUEUES:begin
   FeatureVal:=TPasRISCVUInt32(NVME_IO_QUEUES-1) or TPasRISCVUInt32(TPasRISCVUInt32(NVME_IO_QUEUES-1) shl 16);
  end;
  FEAT_TEMP_THRESH:begin
   if aSet then begin
    TPasMPInterlocked.Write(fTempThresh,PPasRISCVUInt32(@PPasRISCVUInt8Array(aCommand^.Ptr)^[SQE_CDW11])^);
   end else begin
    FeatureVal:=TPasMPInterlocked.Read(fTempThresh);
   end;
  end;
  FEAT_POWER_MGMT,
  FEAT_ERROR_RECOVER,
  FEAT_VOLATILE_WC,
  FEAT_IRQ_COALESCE,
  FEAT_IRQ_VECTOR,
  FEAT_WR_ATOMIC,
  FEAT_ASYNC_EVENT:begin
   // Stubs
  end;
  else begin
   CompleteCommand(aCommand,SC_BAD_FIELD);
   exit;
  end;
 end;
 if aSet then begin
  CompleteCommand(aCommand,SC_SUCCESS);
 end else begin
  CompleteCommand(aCommand,SC_SUCCESS,FeatureVal);
 end;
end;

procedure TPasRISCV.TNVMeDevice.AdminCommand(const aCommand:PNVMeCommand);
begin
//writeln('Admin command opcode: ',LowerCase(IntToHex(PPasRISCVUInt8Array(aCommand^.Ptr)^[0],8)));
 case PPasRISCVUInt8Array(aCommand^.Ptr)^[0] of
  ADMIN_CREATE_IO_SQ:begin
   CreateIOSubmissionQueue(aCommand);
  end;
  ADMIN_CREATE_IO_CQ:begin
   CreateIOCompletionQueue(aCommand);
  end;
  ADMIN_DELETE_IO_SQ:begin
   DeleteIOQueue(aCommand,false);
  end;
  ADMIN_DELETE_IO_CQ:begin
   DeleteIOQueue(aCommand,true);
  end;
  ADMIN_GET_LOG_PAGE:begin
   GetLogPage(aCommand);
  end;
  ADMIN_IDENTIFY:begin
   Identify(aCommand);
  end;
  ADMIN_ABORT:begin
   CompleteCommand(aCommand,SC_SUCCESS,1);
  end;
  ADMIN_SET_FEATURES,ADMIN_GET_FEATURES:begin
   HandleFeature(aCommand,PPasRISCVUInt8Array(aCommand^.Ptr)^[0]=ADMIN_SET_FEATURES);
  end;
{$ifdef NVMeAdminSelfTest}
  ADMIN_SELF_TEST:begin
   CompleteCommand(aCommand,SC_SUCCESS);
  end;
{$endif}
  ADMIN_ASYNC_EVENT_REQ:begin
   // Nothing ever happens
  end;
  else begin
   CompleteCommand(aCommand,SC_BAD_OPCODE);
  end;
 end;
end;

procedure TPasRISCV.TNVMeDevice.IOCommand(const aCommand:PNVMeCommand);
var Opcode:TPasRISCVUInt8;
    Pos:TPasRISCVUInt64;
    Buffer:Pointer;
    Size,ToDo,Temporary:TPasRISCVUInt64;
    NLB:TPasRISCVUInt16;
begin
 Opcode:=PPasRISCVUInt8Array(aCommand^.Ptr)^[0];
 Pos:=PPasRISCVUInt64(@PPasRISCVUInt8Array(aCommand^.Ptr)^[SQE_CDW10])^ shl NVME_LBA_SHIFT;
 case Opcode of
  NVM_READ,NVM_WRITE:begin
   NLB:=PPasRISCVUInt16(@PPasRISCVUInt8Array(aCommand^.Ptr)^[SQE_CDW12])^;
   PreparePRP(aCommand,(TPasRISCVUInt64(NLB)+1) shl NVME_LBA_SHIFT);
   while PRPAvail(aCommand)>0 do begin
    Size:=0;
    Buffer:=GetPRPRegion(aCommand,Size);
    if assigned(Buffer) then begin
     fStreamLock.Acquire;
     try
      fStream.Seek(Pos,soBeginning);
      if Opcode=NVM_WRITE then begin
       Temporary:=fStream.Write(Buffer^,Size);
      end else begin
       Temporary:=fStream.Read(Buffer^,Size);
      end;
     finally
      fStreamLock.Release;
     end;
     if Temporary<>Size then begin
      CompleteCommand(aCommand,SC_DATA_ERR);
      exit;
     end;
     inc(Pos,Size);
    end else begin
     exit;
    end;
   end;
   CompleteCommand(aCommand,SC_SUCCESS);
  end;
  NVM_FLUSH:begin
   fStreamLock.Acquire;
   try
    if FlushStream(fStream) then begin
     CompleteCommand(aCommand,SC_SUCCESS);
    end else begin
     CompleteCommand(aCommand,SC_DATA_ERR);
    end;
   finally
    fStreamLock.Release;
   end;
  end;
  NVM_DTSM:begin
   if (PPasRISCVUInt8Array(aCommand^.Ptr)^[SQE_CDW11] and 4)<>0 then begin
    PreparePRP(aCommand,((TPasRISCVUInt64(PPasRISCVUInt8Array(aCommand^.Ptr)^[SQE_CDW10]))+1) shl 4);
    while PRPAvail(aCommand)>0 do begin
     Size:=0;
     Buffer:=GetPRPRegion(aCommand,Size);
     if assigned(Buffer) then begin
      Temporary:=0;
      while (Temporary+16)<=Size do begin
       Pos:=TPasRISCVUInt64(PPasRISCVUInt32(@PPasRISCVUInt8Array(Buffer)^[Temporary+4])^) shl NVME_LBA_SHIFT;
       ToDo:=PPasRISCVUInt64(@PPasRISCVUInt8Array(Buffer)^[Temporary+8])^ shl NVME_LBA_SHIFT;
       if ToDo>0 then begin
        fStreamLock.Acquire;
        try
         fStream.Seek(Pos,soBeginning);
         while ToDo>0 do begin
          if ToDo<SizeOf(TZeroBuffer) then begin
           Size:=ToDo;
          end else begin
           Size:=SizeOf(TZeroBuffer);
          end;
          fStream.Write(ZeroBuffer[0],Size);
          dec(ToDo,Size);
         end;
        finally
         fStreamLock.Release;
        end;
       end;
       inc(Temporary,16);
      end;
     end else begin
      exit;
     end;
    end;
   end;
   CompleteCommand(aCommand,SC_SUCCESS);
  end;
  else begin
   CompleteCommand(aCommand,SC_BAD_OPCODE);
  end;
 end;
end;

procedure TPasRISCV.TNVMeDevice.ProcessCommand(const aCommand:TNVMeDeviceCommand);
var SubmissionQueue:PNVMeQueue;
    SubmissionQueueAddress:TPasRISCVUInt64;
    Ptr:Pointer;
    Command:TNVMeCommand;
begin

 SubmissionQueue:=GetSubmissionQueue(aCommand.SubmissionQueueID);
 if not assigned(SubmissionQueue) then begin
  TPasMPInterlocked.Decrement(fThreads);
  exit;
 end;

 SubmissionQueueAddress:=SubmissionQueue^.GetAddress;

 Ptr:=GetGlobalDirectMemoryAccessPointer(SubmissionQueueAddress+(TPasRISCVUInt64(aCommand.SubmissionQueueHead) shl SQE_SIZE_SHIFT),SQE_SIZE,false,nil);
 if assigned(Ptr) then begin

  FillChar(Command,SizeOf(TNVMeCommand),#0);
  Command.Ptr:=Ptr;
  Command.SqHeadID:=aCommand.SubmissionQueueHead or (TPasRISCVUInt32(aCommand.SubmissionQueueID) shl 16);
  Command.CompletionQueueID:=SubmissionQueue^.Data.CompletionQueueID;

  case aCommand.SubmissionQueueID of
   QUEUE_ADMIN:begin
    AdminCommand(@Command);
   end;
   else begin
    IOCommand(@Command);
   end;
  end;

 end;

 TPasMPInterlocked.Decrement(fThreads);

end;

procedure TPasRISCV.TNVMeDevice.ProcessQueue(const aSubmissionQueueID:TPasRISCVUInt32;const aValue:TPasRISCVUInt16;const aLocking:Boolean);
var Queue:PNVMeQueue;
    QueueHead:TPasRISCVUInt32;
    Command:TNVMeDeviceCommand;
begin

 Queue:=GetSubmissionQueue(aSubmissionQueueID);
 if not assigned(Queue) then begin
  exit;
 end;

 while TNVMeQueue.Dequeue(Queue^,QueueHead) do begin
  Command.SubmissionQueueID:=aSubmissionQueueID;
  Command.SubmissionQueueHead:=QueueHead;
  TPasMPInterlocked.Increment(fThreads);
  if aSubmissionQueueID<>0 then begin
   if not fBus.fMachine.fJobManager.EnqueueNVMeDeviceCommand(self,Command) then begin
    ProcessCommand(Command);
   end;
  end else begin
   ProcessCommand(Command);
  end;
 end;

end;

procedure TPasRISCV.TNVMeDevice.Doorbell(const aQueueID:TPasRISCVUInt32;const aValue:TPasRISCVUInt16);
var Queue:PNVMeQueue;
    QueueSize,SubmissionQueueID:TPasRISCVUInt32;
begin

 SubmissionQueueID:=aQueueID shr 1;

 if (aQueueID and 1)<>0 then begin
  // Completion Queue doorbell
  if SubmissionQueueID<=NVME_IO_QUEUES then begin
   Queue:=GetCompletionQueue(SubmissionQueueID);
   if assigned(Queue) then begin
    TPasMPMemoryBarrier.ReadDependency;
    QueueSize:=Queue^.Size;
    if aValue<=QueueSize then begin
     TPasMPMemoryBarrier.ReadWrite;
     Queue^.Head:=aValue;
{$ifdef NVMELevelTriggeredPCIEInterrupts}
     TPasMPMemoryBarrier.ReadDependency;
     if Queue^.Tail=aValue then begin
      Queue^.LowerIRQ(self);
     end;
{$endif}
    end;
   end;
  end;
 end else begin
  // Submission Queue doorbell
  if SubmissionQueueID<=NVME_IO_QUEUES then begin
   Queue:=GetSubmissionQueue(SubmissionQueueID);
   if assigned(Queue) then begin
    TPasMPMemoryBarrier.ReadDependency;
    QueueSize:=Queue^.Size;
    if aValue<=QueueSize then begin
     TPasMPMemoryBarrier.ReadWrite;
     Queue^.Tail:=aValue;
     TPasMPMemoryBarrier.ReadDependency;
//   ProcessQueue(SubmissionQueueID,aValue,false);
     if not fBus.fMachine.fJobManager.EnqueueNVMeDeviceQueue(self,SubmissionQueueID,aValue) then begin
      ProcessQueue(SubmissionQueueID,aValue,false);
     end;
    end;
   end;
  end;
 end;

end;

procedure TPasRISCV.TNVMeDevice.CheckMaskedIRQs(const aMask:TPasRISCVUInt32);
var Index:TPasRISCVSizeInt;
    Queue:PNVMeQueue;
begin
 for Index:=QUEUE_ADMIN to NVME_IO_QUEUES do begin
  Queue:=@fCompletionQueues[Index];
  if (aMask and (TPasRISCVUInt32(1) shl ((TPasMPInterlocked.Read(Queue^.Data.IRQ) shr 16) and $1f)))<>0 then begin
   TPasMPMemoryBarrier.ReadDependency;
   if Queue^.Head<>TPasMPInterlocked.Read(Queue^.Tail) then begin
    Queue^.RaiseIRQ(self);
   end else begin
    Queue^.LowerIRQ(self);
   end;
  end;
 end;
end;

function TPasRISCV.TNVMeDevice.OnLoad(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address,Conf:TPasRISCVUInt64;
begin
 Address:=aAddress-aPCIMemoryDevice.fBase;
 if aSize=4 then begin
  case Address of
   NVME_REG_CAP1:begin
    result:=NVME_CAP1_MQES or NVME_CAP1_CQR or NVME_CAP1_TO;
   end;
   NVME_REG_CAP2:begin
    result:=NVME_CAP2_CSS;
   end;
   NVME_REG_VS:begin
    result:=NVME_VERSION;
   end;
   NVME_REG_INTMS,NVME_REG_INTMC:begin
    TPasMPMemoryBarrier.ReadDependency;
    result:=fIRQMask;
   end;
   NVME_REG_CC:begin
    TPasMPMemoryBarrier.ReadDependency;
    Conf:=fConf;
    result:=(Conf and NVME_CC_EN) or NVME_CC_IOQES;
   end;
   NVME_REG_CSTS:begin
    TPasMPMemoryBarrier.ReadDependency;
    Conf:=fConf;
    result:=Conf and NVME_CSTS_RDY;
    if (Conf and NVME_CC_SHN)<>0 then begin
     result:=result or NVME_CSTS_SHST;
    end;
   end;
   NVME_REG_AQA:begin
    TPasMPMemoryBarrier.ReadDependency;
    result:=fSubmissionQueues[QUEUE_ADMIN].Size;
    TPasMPMemoryBarrier.ReadDependency;
    result:=result or (fCompletionQueues[QUEUE_ADMIN].Size shl 16);
   end;
   NVME_REG_ASQ1:begin
    TPasMPMemoryBarrier.ReadDependency;
    result:=fSubmissionQueues[QUEUE_ADMIN].AddressLow;
   end;
   NVME_REG_ASQ2:begin
    TPasMPMemoryBarrier.ReadDependency;
    result:=fSubmissionQueues[QUEUE_ADMIN].AddressHigh;
   end;
   NVME_REG_ACQ1:begin
    TPasMPMemoryBarrier.ReadDependency;
    result:=fCompletionQueues[QUEUE_ADMIN].AddressLow;
   end;
   NVME_REG_ACQ2:begin
    TPasMPMemoryBarrier.ReadDependency;
    result:=fCompletionQueues[QUEUE_ADMIN].AddressHigh;
   end;
   else begin
    result:=0;
   end;
  end;
//writeln('NVMe Read ',LowerCase(IntToHex(Address,8)),' ',LowerCase(IntToHex(result,8)));
 end else begin
  result:=0;
 end;
end;

procedure TPasRISCV.TNVMeDevice.OnStore(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address,QueueID:TPasRISCVUInt64;
begin
 Address:=aAddress-aPCIMemoryDevice.fBase;
 if aSize=4 then begin
//writeln('NVMe Write ',LowerCase(IntToHex(Address,8)),' ',LowerCase(IntToHex(aValue,8)));
  if Address>=$1000 then begin
   QueueID:=(Address-$1000) shr 2;
   Doorbell(QueueID,aValue);
  end else begin
   case Address of
    NVME_REG_INTMS:begin
     TPasMPInterlocked.BitwiseOr(fIRQMask,TPasRISCVUInt32(aValue));
     CheckMaskedIRQs(TPasRISCVUInt32(aValue));
    end;
    NVME_REG_INTMC:begin
     TPasMPInterlocked.BitwiseAnd(fIRQMask,TPasRISCVUInt32(not TPasRISCVUInt32(aValue)));
     CheckMaskedIRQs(TPasRISCVUInt32(aValue));
    end;
    NVME_REG_CC:begin
     TPasMPInterlocked.Write(fConf,TPasRISCVUInt32(aValue));
     if ((aValue and NVME_CC_SHN)<>0) or ((aValue and NVME_CC_EN)=0) then begin
      ResetDevice;
     end;
    end;
    NVME_REG_AQA:begin
     TPasMPInterlocked.Write(fSubmissionQueues[QUEUE_ADMIN].Size,TPasRISCVUInt32(aValue and $fff));
     TPasMPInterlocked.Write(fCompletionQueues[QUEUE_ADMIN].Size,TPasRISCVUInt32((aValue shr 16) and $fff));
    end;
    NVME_REG_ASQ1:begin
     TPasMPInterlocked.Write(fSubmissionQueues[QUEUE_ADMIN].AddressLow,TPasRISCVUInt32(aValue) and TPasRISCVUInt32($fffff000));
    end;
    NVME_REG_ASQ2:begin
     TPasMPInterlocked.Write(fSubmissionQueues[QUEUE_ADMIN].AddressHigh,TPasRISCVUInt32(aValue));
    end;
    NVME_REG_ACQ1:begin
     TPasMPInterlocked.Write(fCompletionQueues[QUEUE_ADMIN].AddressLow,TPasRISCVUInt32(aValue) and TPasRISCVUInt32($fffff000));
    end;
    NVME_REG_ACQ2:begin
     TPasMPInterlocked.Write(fCompletionQueues[QUEUE_ADMIN].AddressHigh,TPasRISCVUInt32(aValue));
    end;
   end;
  end;
 end;
end;

procedure TPasRISCV.TNVMeDevice.AttachStream(const aStream:TStream);
begin
 FreeAndNil(fStream);
 if assigned(aStream) then begin
  fStream:=aStream;
 end else begin
  fStream:=TMemoryStream.Create;
  TMemoryStream(fStream).SetSize(1 shl 20);
 end;
end;

procedure TPasRISCV.TNVMeDevice.LoadFromStream(const aStream:TStream);
begin
 if fStream is TMemoryStream then begin
  TMemoryStream(fStream).Clear;
 end;
 aStream.Seek(0,soBeginning);
 fStream.CopyFrom(aStream,aStream.Size);
end;

procedure TPasRISCV.TNVMeDevice.LoadFromFile(const aFileName:TPasRISCVUTF8String);
var Stream:TFileStream;
begin
 Stream:=TFileStream.Create(aFileName,fmOpenRead); // or fmShareDenyWrite);
 try
  LoadFromStream(Stream);
 finally
  Stream.Free;
 end;
end;

procedure TPasRISCV.TNVMeDevice.SaveToStream(const aStream:TStream);
begin
 fStream.Seek(0,soBeginning);
 aStream.Seek(0,soBeginning);
 aStream.CopyFrom(fStream,fStream.Size);
end;

procedure TPasRISCV.TNVMeDevice.SaveToFile(const aFileName:TPasRISCVUTF8String);
var Stream:TFileStream;
begin
 Stream:=TFileStream.Create(aFileName,fmCreate); // or fmShareDenyWrite);
 try
  SaveToStream(Stream);
 finally
  Stream.Free;
 end;
end;

{ TPasRISCV.TIVSHMEMDevice }

constructor TPasRISCV.TIVSHMEMDevice.Create(const aBus:TPasRISCV.TPCIBusDevice;const aSharedMemorySize:TPasRISCVUInt64=IVSHMEM_DEFAULT_SHM_SIZE);
var FuncDesc:TPasRISCV.TPCIFuncDescriptor;
    BARRegion:TPasRISCV.PPCIBARRegion;
begin
 inherited Create(aBus);

 fIntMask:=0;
 fIntStatus:=0;
 fIVPosition:=0;
 fSharedMemorySize:=aSharedMemorySize;
 fSharedMemoryPointer:=nil;
 fOnDoorbell:=nil;

 FillChar(FuncDesc,SizeOf(TPCIFuncDescriptor),#0);
 FuncDesc.fVendorID:=IVSHMEM_VENDOR_ID;
 FuncDesc.fDeviceID:=IVSHMEM_DEVICE_ID;
 FuncDesc.fClassCode:=IVSHMEM_CLASS_CODE; // Memory Controller, Other
 FuncDesc.fProgIF:=$00;
 FuncDesc.fRevisionID:=IVSHMEM_REVISION;
 FuncDesc.fIRQPin:=TPCI.PCI_IRQ_PIN_INTA;

 // BAR0: Device registers (Doorbell, Interrupt Mask/Status, etc.)
 BARRegion:=@FuncDesc.fBARRegions[0];
{$ifdef NewPCI}
 BARRegion^.fAddress:=0;
{$else}
 BARRegion^.fAddress:=TPCI.PCI_BAR_ADDR_64;
{$endif}
 BARRegion^.fSize:=IVSHMEM_BAR0_SIZE;
 BARRegion^.fIsIO:=false;
 BARRegion^.fOnLoad:=OnLoad;
 BARRegion^.fOnStore:=OnStore;

 // BAR2: Shared memory region (raw memory, no callbacks)
 BARRegion:=@FuncDesc.fBARRegions[2];
{$ifdef NewPCI}
 BARRegion^.fAddress:=0;
{$else}
 BARRegion^.fAddress:=TPCI.PCI_BAR_ADDR_64;
{$endif}
 BARRegion^.fSize:=fSharedMemorySize;
 BARRegion^.fIsIO:=false;
 BARRegion^.fOnLoad:=nil;
 BARRegion^.fOnStore:=nil;

 fFuncs[0]:=TPasRISCV.TPCIFunc.Create(aBus,self,FuncDesc);

 // Get shared memory pointer from BAR2's TPCIMemoryDevice backing memory
 if assigned(fFuncs[0]) and assigned(fFuncs[0].fBARMemoryDevices[2]) then begin
  fSharedMemoryPointer:=fFuncs[0].fBARMemoryDevices[2].fData;
 end;

end;

destructor TPasRISCV.TIVSHMEMDevice.Destroy;
begin
 fOnDoorbell:=nil;
 fSharedMemoryPointer:=nil;
 FreeAndNil(fFuncs[0]);
 inherited Destroy;
end;

procedure TPasRISCV.TIVSHMEMDevice.Reset;
begin
 inherited Reset;
 fIntMask:=0;
 fIntStatus:=0;
end;

function TPasRISCV.TIVSHMEMDevice.OnLoad(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-aPCIMemoryDevice.fBase;
 if aSize=4 then begin
  case Address of
   IVSHMEM_REG_INTMASK:begin
    result:=TPasMPInterlocked.Read(fIntMask);
   end;
   IVSHMEM_REG_INTSTATUS:begin
    // Read and clear
    result:=TPasMPInterlocked.Exchange(fIntStatus,0);
    if result<>0 then begin
     fFuncs[0].LowerIRQ;
    end;
   end;
   IVSHMEM_REG_IVPOSITION:begin
    result:=fIVPosition;
   end;
   IVSHMEM_REG_DOORBELL:begin
    result:=0; // Write-only register
   end;
   IVSHMEM_REG_SHM_SIZE_LO:begin
    result:=fSharedMemorySize and TPasRISCVUInt64($ffffffff);
   end;
   IVSHMEM_REG_SHM_SIZE_HI:begin
    result:=fSharedMemorySize shr 32;
   end;
   else begin
    result:=0;
   end;
  end;
 end else begin
  result:=0;
 end;
end;

procedure TPasRISCV.TIVSHMEMDevice.OnStore(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-aPCIMemoryDevice.fBase;
 if aSize=4 then begin
  case Address of
   IVSHMEM_REG_INTMASK:begin
    TPasMPInterlocked.Write(fIntMask,TPasRISCVUInt32(aValue));
   end;
   IVSHMEM_REG_INTSTATUS:begin
    // Write to clear specific bits
    TPasMPInterlocked.BitwiseAnd(fIntStatus,TPasRISCVUInt32(not TPasRISCVUInt32(aValue)));
   end;
   IVSHMEM_REG_DOORBELL:begin
    // Guest rings doorbell to host
    if assigned(fOnDoorbell) then begin
     fOnDoorbell(self,TPasRISCVUInt32(aValue));
    end;
   end;
   else begin
    // Ignore writes to read-only or undefined registers
   end;
  end;
 end;
end;

procedure TPasRISCV.TIVSHMEMDevice.RingDoorbell;
begin
 if (TPasMPInterlocked.Read(fIntMask) and 1)<>0 then begin
  TPasMPInterlocked.BitwiseOr(fIntStatus,1);
  fFuncs[0].RaiseIRQ(0);
 end;
end;

{ TPasRISCV.TBochsVBEDevice }

constructor TPasRISCV.TBochsVBEDevice.Create(const aBus:TPasRISCV.TPCIBusDevice;const aFrameBuffer:TFrameBufferDevice);
var FuncDesc:TPasRISCV.TPCIFuncDescriptor;
    BARRegion:TPasRISCV.PPCIBARRegion;
begin
 inherited Create(aBus);

 fFrameBuffer:=aFrameBuffer;
 fFrameBuffer.fAutomaticRefresh:=true;
 fFrameBuffer.fSwapColorChannels:=true;
 fFrameBuffer.fIgnoreDirty:=true;

 fVBEEnable:=0;
 fVBEXRes:=640;
 fVBEYRes:=400;
 fVBEBPP:=32;
 fVBEBank:=0;
 fVBEVirtWidth:=640;
 fVBEVirtHeight:=400;
 fVBEXOffset:=0;
 fVBEYOffset:=0;

 FillChar(FuncDesc,SizeOf(TPCIFuncDescriptor),#0);
 FuncDesc.fVendorID:=BOCHS_VBE_VENDOR_ID;
 FuncDesc.fDeviceID:=BOCHS_VBE_DEVICE_ID;
 FuncDesc.fClassCode:=BOCHS_VBE_CLASS_CODE;
 FuncDesc.fProgIF:=$00;
 FuncDesc.fRevisionID:=BOCHS_VBE_REVISION;
 FuncDesc.fIRQPin:=TPCI.PCI_IRQ_PIN_INTA;

 // BAR0: Linear framebuffer (16MB)
 BARRegion:=@FuncDesc.fBARRegions[0];
{$ifdef NewPCI}
 BARRegion^.fAddress:=0;
{$else}
 BARRegion^.fAddress:=TPCI.PCI_BAR_ADDR_64;
{$endif}
 BARRegion^.fSize:=BOCHS_VBE_BAR0_SIZE;
 BARRegion^.fIsIO:=false;
 BARRegion^.fOnLoad:=OnFBLoad;
 BARRegion^.fOnStore:=OnFBStore;

 // BAR2: VBE DISPI registers (4KB MMIO)
 BARRegion:=@FuncDesc.fBARRegions[2];
{$ifdef NewPCI}
 BARRegion^.fAddress:=0;
{$else}
 BARRegion^.fAddress:=TPCI.PCI_BAR_ADDR_64;
{$endif}
 BARRegion^.fSize:=BOCHS_VBE_BAR2_SIZE;
 BARRegion^.fIsIO:=false;
 BARRegion^.fOnLoad:=OnVBELoad;
 BARRegion^.fOnStore:=OnVBEStore;

 fFuncs[0]:=TPasRISCV.TPCIFunc.Create(aBus,self,FuncDesc);

 if assigned(fFuncs[0].fBARMemoryDevices[0]) then begin
  fFuncs[0].fBARMemoryDevices[0].fOnGetDeviceDirectMemoryAccessPointer:=OnFBGetDeviceDirectMemoryAccessPointer;
 end;

end;

destructor TPasRISCV.TBochsVBEDevice.Destroy;
begin
 fFrameBuffer:=nil;
 FreeAndNil(fFuncs[0]);
 inherited Destroy;
end;

procedure TPasRISCV.TBochsVBEDevice.Reset;
begin
 inherited Reset;
 fVBEEnable:=0;
 fVBEXRes:=640;
 fVBEYRes:=400;
 fVBEBPP:=32;
 fVBEBank:=0;
 fVBEVirtWidth:=640;
 fVBEVirtHeight:=400;
 fVBEXOffset:=0;
 fVBEYOffset:=0;
end;

procedure TPasRISCV.TBochsVBEDevice.ApplyVideoMode;
var NewBPP:TPasRISCVUInt32;
begin
 if (fVBEEnable and VBE_DISPI_ENABLED)<>0 then begin
  if fVBEXRes=0 then begin
   fVBEXRes:=1;
  end;
  if fVBEYRes=0 then begin
   fVBEYRes:=1;
  end;
  if fVBEXRes>VBE_DISPI_MAX_XRES then begin
   fVBEXRes:=VBE_DISPI_MAX_XRES;
  end;
  if fVBEYRes>VBE_DISPI_MAX_YRES then begin
   fVBEYRes:=VBE_DISPI_MAX_YRES;
  end;
  case fVBEBPP of
   8:begin
    NewBPP:=1;
   end;
   15,16:begin
    NewBPP:=2;
   end;
   24:begin
    NewBPP:=3;
   end;
   else begin
    NewBPP:=4; // 32
   end;
  end;
  fVBEVirtWidth:=fVBEXRes;
  fVBEVirtHeight:=fVBEYRes;
  fFrameBuffer.ResizeFrameBuffer(fVBEXRes,fVBEYRes,NewBPP);
  fFrameBuffer.fActive:=true;
  if (fVBEEnable and VBE_DISPI_NOCLEARMEM)=0 then begin
   fFrameBuffer.ClearFrameBuffer;
  end;
  fFrameBuffer.UpdateOutputData;
  if assigned(fMachine.OnNewFrame) then begin
   fMachine.OnNewFrame();
  end;
 end else begin
  fFrameBuffer.fActive:=false;
 end;
end;

function TPasRISCV.TBochsVBEDevice.OnFBLoad(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-aPCIMemoryDevice.fBase;
 if (Address+aSize)<=length(fFrameBuffer.fData) then begin
  case aSize of
   1:begin
    result:=fFrameBuffer.fData[Address];
   end;
   2:begin
    result:=TPasRISCVUInt16(Pointer(@fFrameBuffer.fData[Address])^);
   end;
   4:begin
    result:=TPasRISCVUInt32(Pointer(@fFrameBuffer.fData[Address])^);
   end;
   8:begin
    result:=TPasRISCVUInt64(Pointer(@fFrameBuffer.fData[Address])^);
   end;
   else begin
    result:=0;
   end;
  end;
 end else begin
  result:=0;
 end;
end;

procedure TPasRISCV.TBochsVBEDevice.OnFBStore(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-aPCIMemoryDevice.fBase;
 if (Address+aSize)<=length(fFrameBuffer.fData) then begin
  fFrameBuffer.fDirty:=true;
  case aSize of
   1:begin
    fFrameBuffer.fData[Address]:=TPasRISCVUInt8(aValue);
   end;
   2:begin
    TPasRISCVUInt16(Pointer(@fFrameBuffer.fData[Address])^):=TPasRISCVUInt16(aValue);
   end;
   4:begin
    TPasRISCVUInt32(Pointer(@fFrameBuffer.fData[Address])^):=TPasRISCVUInt32(aValue);
   end;
   8:begin
    TPasRISCVUInt64(Pointer(@fFrameBuffer.fData[Address])^):=TPasRISCVUInt64(aValue);
   end;
  end;
 end;
end;

function TPasRISCV.TBochsVBEDevice.OnFBGetDeviceDirectMemoryAccessPointer(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-aPCIMemoryDevice.fBase;
 if (Address+aSize)<=TPasRISCVUInt64(length(fFrameBuffer.fData)) then begin
  if aWrite then begin
   fFrameBuffer.fDirty:=true;
  end;
  result:=@fFrameBuffer.fData[Address];
 end else begin
  result:=aBounce;
 end;
end;

function TPasRISCV.TBochsVBEDevice.OnVBELoad(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-aPCIMemoryDevice.fBase;
 case Address of
  MMIO_QEXT_BASE..(MMIO_QEXT_BASE+MMIO_QEXT_SIZE)-1:begin
   case Address-MMIO_QEXT_BASE of
    PCI_VGA_QEXT_REG_SIZE:begin
     result:=PCI_VGA_QEXT_SIZE;
    end;
    PCI_VGA_QEXT_REG_BYTEORDER:begin
     result:=PCI_VGA_QEXT_LITTLE_ENDIAN;
    end;
    else begin
     result:=0;
    end;
   end;
  end;
  MMIO_VBE_BASE..(MMIO_VBE_BASE+MMIO_VBE_SIZE)-1:begin
   if (fVBEEnable and VBE_DISPI_GETCAPS)<>0 then begin
    case Address-MMIO_VBE_BASE of
     VBE_DISPI_INDEX_XRES:begin
      result:=VBE_DISPI_MAX_XRES;
     end;
     VBE_DISPI_INDEX_YRES:begin
      result:=VBE_DISPI_MAX_YRES;
     end;
     VBE_DISPI_INDEX_BPP:begin
      result:=VBE_DISPI_MAX_BPP;
     end;
     else begin
      result:=0;
     end;
    end;
   end else begin
    case Address-MMIO_VBE_BASE of
     VBE_DISPI_INDEX_ID:begin
      result:=VBE_DISPI_ID5;
     end;
     VBE_DISPI_INDEX_XRES:begin
      result:=fVBEXRes;
     end;
     VBE_DISPI_INDEX_YRES:begin
      result:=fVBEYRes;
     end;
     VBE_DISPI_INDEX_BPP:begin
      result:=fVBEBPP;
     end;
     VBE_DISPI_INDEX_ENABLE:begin
      result:=fVBEEnable;
     end;
     VBE_DISPI_INDEX_BANK:begin
      result:=fVBEBank;
     end;
     VBE_DISPI_INDEX_VIRT_WIDTH:begin
      result:=fVBEVirtWidth;
     end;
     VBE_DISPI_INDEX_VIRT_HEIGHT:begin
      result:=fVBEVirtHeight;
     end;
     VBE_DISPI_INDEX_X_OFFSET:begin
      result:=fVBEXOffset;
     end;
     VBE_DISPI_INDEX_Y_OFFSET:begin
      result:=fVBEYOffset;
     end;
     VBE_DISPI_INDEX_VIDEO_MEMORY_64K:begin
      result:=BOCHS_VBE_BAR0_SIZE div 65536;
     end;
     else begin
      result:=0;
     end;
    end;
   end;
  end;
  MMIO_VGA_BASE..(MMIO_VGA_BASE+MMIO_VGA_SIZE)-1:begin
   // VGA registers — return safe defaults
   result:=0;
  end;
  MMIO_EDID_BASE..(MMIO_EDID_BASE+MMIO_EDID_SIZE)-1:begin
   // EDID data — not implemented, return zeros
   result:=0;
  end;
  else begin
   result:=0;
  end;
 end;
end;

procedure TPasRISCV.TBochsVBEDevice.OnVBEStore(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
    Value16:TPasRISCVUInt16;
begin
 Address:=aAddress-aPCIMemoryDevice.fBase;
 case Address of
  MMIO_VBE_BASE..(MMIO_VBE_BASE+MMIO_VBE_SIZE)-1:begin
   Value16:=TPasRISCVUInt16(aValue);
   case Address-MMIO_VBE_BASE of
    VBE_DISPI_INDEX_ID:begin
     // Guest can write any ID value; we always report VBE_DISPI_ID5 on read
    end;
    VBE_DISPI_INDEX_XRES:begin
     fVBEXRes:=Value16;
    end;
    VBE_DISPI_INDEX_YRES:begin
     fVBEYRes:=Value16;
    end;
    VBE_DISPI_INDEX_BPP:begin
     if Value16 in [8,15,16,24,32] then begin
      fVBEBPP:=Value16;
     end;
    end;
    VBE_DISPI_INDEX_ENABLE:begin
     fVBEEnable:=Value16;
     ApplyVideoMode;
    end;
    VBE_DISPI_INDEX_BANK:begin
     fVBEBank:=Value16;
    end;
    VBE_DISPI_INDEX_VIRT_WIDTH:begin
     fVBEVirtWidth:=Value16;
    end;
    VBE_DISPI_INDEX_VIRT_HEIGHT:begin
     fVBEVirtHeight:=Value16;
    end;
    VBE_DISPI_INDEX_X_OFFSET:begin
     fVBEXOffset:=Value16;
     fFrameBuffer.fDirty:=true;
    end;
    VBE_DISPI_INDEX_Y_OFFSET:begin
     fVBEYOffset:=Value16;
     fFrameBuffer.fDirty:=true;
    end;
   end;
  end;
  // VGA registers at $400, QEMU ext at $600, EDID at $000 — writes ignored for now
 end;
end;

{ TPasRISCV.TCirrusDevice }

constructor TPasRISCV.TCirrusDevice.Create(const aBus:TPasRISCV.TPCIBusDevice;const aFrameBuffer:TFrameBufferDevice);
var FuncDesc:TPasRISCV.TPCIFuncDescriptor;
    BARRegion:TPasRISCV.PPCIBARRegion;
begin
 inherited Create(aBus);

 fFrameBuffer:=aFrameBuffer;
 fFrameBuffer.fAutomaticRefresh:=true;
 fFrameBuffer.fSwapColorChannels:=true;
 fFrameBuffer.fIgnoreDirty:=true;

 fSEQIndex:=0;
 FillChar(fSEQRegs,SizeOf(fSEQRegs),#0);
 fCRTIndex:=0;
 FillChar(fCRTRegs,SizeOf(fCRTRegs),#0);
 fGFXIndex:=0;
 FillChar(fGFXRegs,SizeOf(fGFXRegs),#0);
 fHDRReadCount:=0;
 fHDR:=0;
 fWidth:=640;
 fHeight:=480;
 fBPP:=32;
 fPitch:=640*4;
 fStartAddress:=0;
 fModeActive:=false;

 FillChar(FuncDesc,SizeOf(TPCIFuncDescriptor),#0);
 FuncDesc.fVendorID:=CIRRUS_VENDOR_ID;
 FuncDesc.fDeviceID:=CIRRUS_DEVICE_ID;
 FuncDesc.fSubsystemVendorID:=CIRRUS_SUBVENDOR_ID;
 FuncDesc.fSubsystemDeviceID:=CIRRUS_SUBDEVICE_ID;
 FuncDesc.fClassCode:=CIRRUS_CLASS_CODE;
 FuncDesc.fProgIF:=$00;
 FuncDesc.fRevisionID:=CIRRUS_REVISION;
 FuncDesc.fIRQPin:=TPCI.PCI_IRQ_PIN_INTA;

 // BAR0: Linear framebuffer (4MB VRAM)
 BARRegion:=@FuncDesc.fBARRegions[0];
{$ifdef NewPCI}
 BARRegion^.fAddress:=0;
{$else}
 BARRegion^.fAddress:=TPCI.PCI_BAR_ADDR_64;
{$endif}
 BARRegion^.fSize:=CIRRUS_VRAM_SIZE;
 BARRegion^.fIsIO:=false;
 BARRegion^.fOnLoad:=OnFBLoad;
 BARRegion^.fOnStore:=OnFBStore;

 // BAR1: MMIO registers (4KB)
 BARRegion:=@FuncDesc.fBARRegions[1];
{$ifdef NewPCI}
 BARRegion^.fAddress:=0;
{$else}
 BARRegion^.fAddress:=TPCI.PCI_BAR_ADDR_64;
{$endif}
 BARRegion^.fSize:=CIRRUS_MMIO_SIZE;
 BARRegion^.fIsIO:=false;
 BARRegion^.fOnLoad:=OnMMIOLoad;
 BARRegion^.fOnStore:=OnMMIOStore;

 fFuncs[0]:=TPasRISCV.TPCIFunc.Create(aBus,self,FuncDesc);

 if assigned(fFuncs[0].fBARMemoryDevices[0]) then begin
  fFuncs[0].fBARMemoryDevices[0].fOnGetDeviceDirectMemoryAccessPointer:=OnFBGetDeviceDirectMemoryAccessPointer;
 end;

 RegisterVGAIO;

end;

destructor TPasRISCV.TCirrusDevice.Destroy;
var PCIIODevice:TPCIIODevice;
begin
 if assigned(fBus) and assigned(fBus.fMachine) then begin
  PCIIODevice:=fBus.fMachine.fPCIIODevice;
  if assigned(PCIIODevice) then begin
   PCIIODevice.UnregisterIORange($3c0);
  end;
 end;
 fFrameBuffer:=nil;
 FreeAndNil(fFuncs[0]);
 inherited Destroy;
end;

procedure TPasRISCV.TCirrusDevice.Reset;
begin
 inherited Reset;
 fSEQIndex:=0;
 FillChar(fSEQRegs,SizeOf(fSEQRegs),#0);
 fCRTIndex:=0;
 FillChar(fCRTRegs,SizeOf(fCRTRegs),#0);
 fGFXIndex:=0;
 FillChar(fGFXRegs,SizeOf(fGFXRegs),#0);
 fHDRReadCount:=0;
 fHDR:=0;
 fWidth:=640;
 fHeight:=480;
 fBPP:=32;
 fPitch:=640*4;
 fStartAddress:=0;
 fModeActive:=false;
end;

procedure TPasRISCV.TCirrusDevice.UpdateDerivedState;
var SR07:TPasRISCVUInt8;
    NewBPP,NewPitch,NewWidth,NewHeight:TPasRISCVUInt32;
    HDispEnd,VDispEnd:TPasRISCVUInt32;
    BytesPerPixel:TPasRISCVUInt32;
begin
 // Determine BPP from SR07 + HDR (same logic as Linux cirrus-qemu driver)
 SR07:=fSEQRegs[$07];
 case SR07 and $1f of // mask relevant bits
  $11:begin
   NewBPP:=8;
  end;
  $17:begin
   NewBPP:=16;
  end;
  $15:begin
   NewBPP:=24;
  end;
  $19:begin
   NewBPP:=32;
  end;
  else begin
   NewBPP:=fBPP; // keep current
  end;
 end;

 // Derive display resolution from CRT registers
 // hdispend = (CRT[1] + 1) * 8
 HDispEnd:=(TPasRISCVUInt32(fCRTRegs[$01])+1)*8;
 // vdispend = CRT[0x12] + overflow bits from CRT[0x07]
 VDispEnd:=TPasRISCVUInt32(fCRTRegs[$12]);
 if (fCRTRegs[$07] and $02)<>0 then begin
  VDispEnd:=VDispEnd or $100;
 end;
 if (fCRTRegs[$07] and $40)<>0 then begin
  VDispEnd:=VDispEnd or $200;
 end;
 inc(VDispEnd); // VDispEnd is 0-based
 NewWidth:=HDispEnd;
 NewHeight:=VDispEnd;

 // Sanity checks
 if NewWidth<1 then begin
  NewWidth:=1;
 end;
 if NewHeight<1 then begin
  NewHeight:=1;
 end;
 if NewWidth>2048 then begin
  NewWidth:=2048;
 end;
 if NewHeight>1024 then begin
  NewHeight:=1024;
 end;

 // Derive pitch from CRT[0x13] + CRT[0x1b]
 NewPitch:=TPasRISCVUInt32(fCRTRegs[$13])*8;
 if (fCRTRegs[$1b] and $10)<>0 then begin
  NewPitch:=NewPitch or $800; // bit 11
 end;

 // Derive start address
 fStartAddress:=TPasRISCVUInt32(fCRTRegs[$0d]) or
                (TPasRISCVUInt32(fCRTRegs[$0c]) shl 8);
 fStartAddress:=fStartAddress shl 2;
 // Extended start address bits from CRT[0x1b] and CRT[0x1d]
 if (fCRTRegs[$1b] and $01)<>0 then begin
  fStartAddress:=fStartAddress or $10000;
 end;
 if (fCRTRegs[$1b] and $04)<>0 then begin
  fStartAddress:=fStartAddress or $20000;
 end;
 if (fCRTRegs[$1b] and $08)<>0 then begin
  fStartAddress:=fStartAddress or $40000;
 end;
 if (fCRTRegs[$1d] and $80)<>0 then begin
  fStartAddress:=fStartAddress or $80000;
 end;

 // Sanity on pitch
 case NewBPP of
  8:BytesPerPixel:=1;
  16:BytesPerPixel:=2;
  24:BytesPerPixel:=3;
  else BytesPerPixel:=4;
 end;
 if NewPitch=0 then begin
  NewPitch:=NewWidth*BytesPerPixel;
 end;

 // Check if mode is valid
 if (NewWidth>=8) and (NewHeight>=8) and
    (NewPitch>0) and (NewPitch<=CIRRUS_MAX_PITCH) and
    (TPasRISCVUInt64(NewPitch)*NewHeight<=CIRRUS_VRAM_SIZE) then begin
  fWidth:=NewWidth;
  fHeight:=NewHeight;
  fBPP:=NewBPP;
  fPitch:=NewPitch;
  fFrameBuffer.ResizeFrameBuffer(fWidth,fHeight,BytesPerPixel);
  fFrameBuffer.fActive:=true;
  fModeActive:=true;
  fFrameBuffer.UpdateOutputData;
  if assigned(fMachine.OnNewFrame) then begin
   fMachine.OnNewFrame();
  end;
 end;
end;

function TPasRISCV.TCirrusDevice.OnFBLoad(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-aPCIMemoryDevice.fBase;
 if (Address+aSize)<=length(fFrameBuffer.fData) then begin
  case aSize of
   1:begin
    result:=fFrameBuffer.fData[Address];
   end;
   2:begin
    result:=TPasRISCVUInt16(Pointer(@fFrameBuffer.fData[Address])^);
   end;
   4:begin
    result:=TPasRISCVUInt32(Pointer(@fFrameBuffer.fData[Address])^);
   end;
   8:begin
    result:=TPasRISCVUInt64(Pointer(@fFrameBuffer.fData[Address])^);
   end;
   else begin
    result:=0;
   end;
  end;
 end else begin
  result:=0;
 end;
end;

procedure TPasRISCV.TCirrusDevice.OnFBStore(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-aPCIMemoryDevice.fBase;
 if (Address+aSize)<=length(fFrameBuffer.fData) then begin
  fFrameBuffer.fDirty:=true;
  case aSize of
   1:begin
    fFrameBuffer.fData[Address]:=TPasRISCVUInt8(aValue);
   end;
   2:begin
    TPasRISCVUInt16(Pointer(@fFrameBuffer.fData[Address])^):=TPasRISCVUInt16(aValue);
   end;
   4:begin
    TPasRISCVUInt32(Pointer(@fFrameBuffer.fData[Address])^):=TPasRISCVUInt32(aValue);
   end;
   8:begin
    TPasRISCVUInt64(Pointer(@fFrameBuffer.fData[Address])^):=TPasRISCVUInt64(aValue);
   end;
  end;
 end;
end;

function TPasRISCV.TCirrusDevice.OnFBGetDeviceDirectMemoryAccessPointer(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-aPCIMemoryDevice.fBase;
 if (Address+aSize)<=TPasRISCVUInt64(length(fFrameBuffer.fData)) then begin
  if aWrite then begin
   fFrameBuffer.fDirty:=true;
  end;
  result:=@fFrameBuffer.fData[Address];
 end else begin
  result:=aBounce;
 end;
end;

function TPasRISCV.TCirrusDevice.OnMMIOLoad(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-aPCIMemoryDevice.fBase;
 case Address of
  SEQ_INDEX:begin
   result:=fSEQIndex;
  end;
  SEQ_DATA:begin
   result:=fSEQRegs[fSEQIndex];
  end;
  CRT_INDEX:begin
   result:=fCRTIndex;
  end;
  CRT_DATA:begin
   result:=fCRTRegs[fCRTIndex];
  end;
  GFX_INDEX:begin
   result:=fGFXIndex;
  end;
  GFX_DATA:begin
   result:=fGFXRegs[fGFXIndex];
  end;
  VGA_DAC_MASK:begin
   // Hidden DAC register: 4 consecutive reads reveal the HDR value
   inc(fHDRReadCount);
   if fHDRReadCount>=4 then begin
    result:=fHDR;
    fHDRReadCount:=0;
   end else begin
    result:=$ff; // normal DAC mask
   end;
  end;
  else begin
   result:=0;
  end;
 end;
end;

procedure TPasRISCV.TCirrusDevice.OnMMIOStore(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
    Value8:TPasRISCVUInt8;
begin
 Address:=aAddress-aPCIMemoryDevice.fBase;
 Value8:=TPasRISCVUInt8(aValue);
 // Reset HDR read count on any non-DAC_MASK access
 if Address<>VGA_DAC_MASK then begin
  fHDRReadCount:=0;
 end;
 case Address of
  SEQ_INDEX:begin
   fSEQIndex:=Value8;
  end;
  SEQ_DATA:begin
   fSEQRegs[fSEQIndex]:=Value8;
   if fSEQIndex=$07 then begin
    // Format register changed — update mode
    UpdateDerivedState;
   end;
  end;
  CRT_INDEX:begin
   fCRTIndex:=Value8;
  end;
  CRT_DATA:begin
   fCRTRegs[fCRTIndex]:=Value8;
   // Update on writes to display-relevant registers
   case fCRTIndex of
    $01,$07,$12,$13,$1b:begin
     UpdateDerivedState;
    end;
    $0c,$0d,$1d:begin
     // Start address — update and signal new frame
     UpdateDerivedState;
     fFrameBuffer.fDirty:=true;
{    fFrameBuffer.UpdateOutputData;
     if assigned(fMachine.OnNewFrame) then begin
      fMachine.OnNewFrame();
     end;}
    end;
   end;
  end;
  GFX_INDEX:begin
   fGFXIndex:=Value8;
  end;
  GFX_DATA:begin
   fGFXRegs[fGFXIndex]:=Value8;
  end;
  VGA_DAC_MASK:begin
   // Hidden DAC register write (after 4 reads)
   fHDR:=Value8;
   fHDRReadCount:=0;
  end;
 end;
end;

procedure TPasRISCV.TCirrusDevice.RegisterVGAIO;
var PCIIODevice:TPCIIODevice;
begin
 PCIIODevice:=fBus.fMachine.fPCIIODevice;
 if assigned(PCIIODevice) then begin
  // VGA I/O range $3C0-$3DF (32 bytes)
  PCIIODevice.RegisterIORange($3c0,$20,OnVGAIOLoad,OnVGAIOStore);
 end;
end;

function TPasRISCV.TCirrusDevice.OnVGAIOLoad(const aPort:TPasRISCVUInt16;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Offset:TPasRISCVUInt16;
begin
 Offset:=aPort-$3c0;
 case Offset of
  SEQ_INDEX:begin
   result:=fSEQIndex;
  end;
  SEQ_DATA:begin
   result:=fSEQRegs[fSEQIndex];
  end;
  CRT_INDEX:begin
   result:=fCRTIndex;
  end;
  CRT_DATA:begin
   result:=fCRTRegs[fCRTIndex];
  end;
  GFX_INDEX:begin
   result:=fGFXIndex;
  end;
  GFX_DATA:begin
   result:=fGFXRegs[fGFXIndex];
  end;
  VGA_DAC_MASK:begin
   inc(fHDRReadCount);
   if fHDRReadCount>=4 then begin
    result:=fHDR;
    fHDRReadCount:=0;
   end else begin
    result:=$ff;
   end;
  end;
  else begin
   result:=$ff;
  end;
 end;
end;

procedure TPasRISCV.TCirrusDevice.OnVGAIOStore(const aPort:TPasRISCVUInt16;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Offset:TPasRISCVUInt16;
    Value8:TPasRISCVUInt8;
begin
 Offset:=aPort-$3c0;
 Value8:=TPasRISCVUInt8(aValue);
 if Offset<>VGA_DAC_MASK then begin
  fHDRReadCount:=0;
 end;
 case Offset of
  SEQ_INDEX:begin
   fSEQIndex:=Value8;
  end;
  SEQ_DATA:begin
   fSEQRegs[fSEQIndex]:=Value8;
   if fSEQIndex=$07 then begin
    UpdateDerivedState;
   end;
  end;
  CRT_INDEX:begin
   fCRTIndex:=Value8;
  end;
  CRT_DATA:begin
   fCRTRegs[fCRTIndex]:=Value8;
   case fCRTIndex of
    $01,$07,$12,$13,$1b:begin
     UpdateDerivedState;
    end;
    $0c,$0d,$1d:begin
     UpdateDerivedState;
     fFrameBuffer.fDirty:=true;
{    fFrameBuffer.UpdateOutputData;
     if assigned(fMachine.OnNewFrame) then begin
      fMachine.OnNewFrame();
     end;}
    end;
   end;
  end;
  GFX_INDEX:begin
   fGFXIndex:=Value8;
  end;
  GFX_DATA:begin
   fGFXRegs[fGFXIndex]:=Value8;
  end;
  VGA_DAC_MASK:begin
   fHDR:=Value8;
   fHDRReadCount:=0;
  end;
 end;
end;

{ TPasRISCV.TFM801Device.TOPL3 }

constructor TPasRISCV.TFM801Device.TOPL3.Create;
begin
 inherited Create;
end;

destructor TPasRISCV.TFM801Device.TOPL3.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV.TFM801Device.TOPL3.DoReset(const aSampleRate:TPasRISCVUInt32);
const ChannelSlotBase:array[0..17] of TPasRISCVUInt8=(0,1,2,6,7,8,12,13,14,18,19,20,24,25,26,30,31,32);
var SlotIndex:TPasRISCVUInt32;
    ChannelIndex:TPasRISCVUInt32;
    BaseSlot:TPasRISCVUInt8;
begin

 FillChar(fChannels,SizeOf(TOPL3Channels),#0);
 FillChar(fSlots,SizeOf(TOPL3Slots),#0);

 fTimer:=0;
 fEnvelopeTimer:=0;
 fEnvelopeTimerRemainder:=0;
 fEnvelopeTimerState:=0;
 fEnvelopeAdd:=0;
 fEnvelopeTimerLow:=0;

 fNewMode:=0;
 fNoteSelect:=0;
 fRhythm:=0;

 fVibratoPosition:=0;
 fVibratoShift:=1;
 fTremolo:=0;
 fTremoloPosition:=0;
 fTremoloShift:=4;

 fNoiseLFSR:=1;
 fZeroMod:=0;

 FillChar(fMixBuffer,SizeOf(TOPL3MixBuffer),#0);

 fRhythmHHBit2:=0;
 fRhythmHHBit3:=0;
 fRhythmHHBit7:=0;
 fRhythmHHBit8:=0;
 fRhythmTCBit3:=0;
 fRhythmTCBit5:=0;

 // Initialize slots
 for SlotIndex:=0 to 35 do begin
  fSlots[SlotIndex].fSlotIndex:=TPasRISCVUInt8(SlotIndex);
  fSlots[SlotIndex].fModSource:=@fZeroMod;
  fSlots[SlotIndex].fEnvelopeRouted:=$1ff;
  fSlots[SlotIndex].fEnvelopeOut:=$1ff;
  fSlots[SlotIndex].fEnvelopeState:=TOPL3EnvelopeState.Release;
  fSlots[SlotIndex].fTremoloSource:=PPasRISCVUInt8(@fZeroMod);
 end;

 // Initialize channels and link slots
 for ChannelIndex:=0 to 17 do begin

  BaseSlot:=ChannelSlotBase[ChannelIndex];
  fChannels[ChannelIndex].fSlots[0]:=@fSlots[BaseSlot];
  fChannels[ChannelIndex].fSlots[1]:=@fSlots[BaseSlot+3];
  fSlots[BaseSlot].fChannelIndex:=TPasRISCVUInt8(ChannelIndex);
  fSlots[BaseSlot+3].fChannelIndex:=TPasRISCVUInt8(ChannelIndex);

  // Set up 4-op channel pairs
  if (ChannelIndex mod 9)<3 then begin
   fChannels[ChannelIndex].fPair:=@fChannels[ChannelIndex+3];
  end else if (ChannelIndex mod 9)<6 then begin
   fChannels[ChannelIndex].fPair:=@fChannels[ChannelIndex-3];
  end else begin
   fChannels[ChannelIndex].fPair:=nil;
  end;

  fChannels[ChannelIndex].fOutputSources[0]:=@fZeroMod;
  fChannels[ChannelIndex].fOutputSources[1]:=@fZeroMod;
  fChannels[ChannelIndex].fOutputSources[2]:=@fZeroMod;
  fChannels[ChannelIndex].fOutputSources[3]:=@fZeroMod;
  fChannels[ChannelIndex].fChannelType:=TOPL3ChannelType.TwoOp;
  fChannels[ChannelIndex].fOutputEnableA:=$ffff;
  fChannels[ChannelIndex].fOutputEnableB:=$ffff;
  fChannels[ChannelIndex].fOutputEnableC:=0;
  fChannels[ChannelIndex].fOutputEnableD:=0;
  fChannels[ChannelIndex].fChannelIndex:=TPasRISCVUInt8(ChannelIndex);

  SetupChannelAlgorithm(@fChannels[ChannelIndex]);

 end;

 // Initialize resampler
 if aSampleRate>0 then begin
  fRateRatio:=TPasRISCVInt32((aSampleRate shl OPL3_RSM_FRAC) div OPL3_NATIVE_RATE);
 end else begin
  fRateRatio:=TPasRISCVInt32((48000 shl OPL3_RSM_FRAC) div OPL3_NATIVE_RATE);
 end;

 fSampleCounter:=0;
 fOldSamples[0]:=0;
 fOldSamples[1]:=0;
 fCurrentSamples[0]:=0;
 fCurrentSamples[1]:=0;

end;

function TPasRISCV.TFM801Device.TOPL3.CalcExp(const aLevel:TPasRISCVUInt32):TPasRISCVInt16;
const ExpROM:array[0..255] of TPasRISCVUInt16=(
       $7fa,$7f5,$7ef,$7ea,$7e4,$7df,$7da,$7d4,$7cf,$7c9,$7c4,$7bf,$7b9,$7b4,$7ae,$7a9,
       $7a4,$79f,$799,$794,$78f,$78a,$784,$77f,$77a,$775,$770,$76a,$765,$760,$75b,$756,
       $751,$74c,$747,$742,$73d,$738,$733,$72e,$729,$724,$71f,$71a,$715,$710,$70b,$706,
       $702,$6fd,$6f8,$6f3,$6ee,$6e9,$6e5,$6e0,$6db,$6d6,$6d2,$6cd,$6c8,$6c4,$6bf,$6ba,
       $6b5,$6b1,$6ac,$6a8,$6a3,$69e,$69a,$695,$691,$68c,$688,$683,$67f,$67a,$676,$671,
       $66d,$668,$664,$65f,$65b,$657,$652,$64e,$649,$645,$641,$63c,$638,$634,$630,$62b,
       $627,$623,$61e,$61a,$616,$612,$60e,$609,$605,$601,$5fd,$5f9,$5f5,$5f0,$5ec,$5e8,
       $5e4,$5e0,$5dc,$5d8,$5d4,$5d0,$5cc,$5c8,$5c4,$5c0,$5bc,$5b8,$5b4,$5b0,$5ac,$5a8,
       $5a4,$5a0,$59c,$599,$595,$591,$58d,$589,$585,$581,$57e,$57a,$576,$572,$56f,$56b,
       $567,$563,$560,$55c,$558,$554,$551,$54d,$549,$546,$542,$53e,$53b,$537,$534,$530,
       $52c,$529,$525,$522,$51e,$51b,$517,$514,$510,$50c,$509,$506,$502,$4ff,$4fb,$4f8,
       $4f4,$4f1,$4ed,$4ea,$4e7,$4e3,$4e0,$4dc,$4d9,$4d6,$4d2,$4cf,$4cc,$4c8,$4c5,$4c2,
       $4be,$4bb,$4b8,$4b5,$4b1,$4ae,$4ab,$4a8,$4a4,$4a1,$49e,$49b,$498,$494,$491,$48e,
       $48b,$488,$485,$482,$47e,$47b,$478,$475,$472,$46f,$46c,$469,$466,$463,$460,$45d,
       $45a,$457,$454,$451,$44e,$44b,$448,$445,$442,$43f,$43c,$439,$436,$433,$430,$42d,
       $42a,$428,$425,$422,$41f,$41c,$419,$416,$414,$411,$40e,$40b,$408,$406,$403,$400);
var Level:TPasRISCVUInt32;
begin
 Level:=aLevel;
 if Level>$1fff then begin
  Level:=$1fff;
 end;
 result:=TPasRISCVInt16((ExpROM[Level and $ff] shl 1) shr (Level shr 8));
end;

function TPasRISCV.TFM801Device.TOPL3.CalcWaveform(const aWaveform:TPasRISCVUInt8;const aPhase:TPasRISCVUInt16;const aEnvelope:TPasRISCVUInt16):TPasRISCVInt16;
const LogSinROM:array[0..255] of TPasRISCVUInt16=(
       $859,$6c3,$607,$58b,$52e,$4e4,$4a6,$471,$443,$41a,$3f5,$3d3,$3b5,$398,$37e,$365,
       $34e,$339,$324,$311,$2ff,$2ed,$2dc,$2cd,$2bd,$2af,$2a0,$293,$286,$279,$26d,$261,
       $256,$24b,$240,$236,$22c,$222,$218,$20f,$206,$1fd,$1f5,$1ec,$1e4,$1dc,$1d4,$1cd,
       $1c5,$1be,$1b7,$1b0,$1a9,$1a2,$19b,$195,$18f,$188,$182,$17c,$177,$171,$16b,$166,
       $160,$15b,$155,$150,$14b,$146,$141,$13c,$137,$133,$12e,$129,$125,$121,$11c,$118,
       $114,$10f,$10b,$107,$103,$0ff,$0fb,$0f8,$0f4,$0f0,$0ec,$0e9,$0e5,$0e2,$0de,$0db,
       $0d7,$0d4,$0d1,$0cd,$0ca,$0c7,$0c4,$0c1,$0be,$0bb,$0b8,$0b5,$0b2,$0af,$0ac,$0a9,
       $0a7,$0a4,$0a1,$09f,$09c,$099,$097,$094,$092,$08f,$08d,$08a,$088,$086,$083,$081,
       $07f,$07d,$07a,$078,$076,$074,$072,$070,$06e,$06c,$06a,$068,$066,$064,$062,$060,
       $05e,$05c,$05b,$059,$057,$055,$053,$052,$050,$04e,$04d,$04b,$04a,$048,$046,$045,
       $043,$042,$040,$03f,$03e,$03c,$03b,$039,$038,$037,$035,$034,$033,$031,$030,$02f,
       $02e,$02d,$02b,$02a,$029,$028,$027,$026,$025,$024,$023,$022,$021,$020,$01f,$01e,
       $01d,$01c,$01b,$01a,$019,$018,$017,$017,$016,$015,$014,$014,$013,$012,$011,$011,
       $010,$00f,$00f,$00e,$00d,$00d,$00c,$00c,$00b,$00a,$00a,$009,$009,$008,$008,$007,
       $007,$007,$006,$006,$005,$005,$005,$004,$004,$004,$003,$003,$003,$002,$002,$002,
       $002,$001,$001,$001,$001,$001,$001,$001,$000,$000,$000,$000,$000,$000,$000,$000);
var Phase:TPasRISCVUInt16;
    LogSinValue:TPasRISCVUInt16;
    Negate:TPasRISCVUInt16;
begin

 Phase:=aPhase and $3ff;

 case aWaveform of

  0:begin // Full sine
   if (Phase and $200)<>0 then begin
    Negate:=$ffff;
   end else begin
    Negate:=0;
   end;
   if (Phase and $100)<>0 then begin
    LogSinValue:=LogSinROM[(Phase and $ff) xor $ff];
   end else begin
    LogSinValue:=LogSinROM[Phase and $ff];
   end;
   result:=CalcExp(TPasRISCVUInt32(LogSinValue)+(TPasRISCVUInt32(aEnvelope) shl 3)) xor TPasRISCVInt16(Negate);
  end;

  1:begin // Half sine (positive half only)
   if (Phase and $200)<>0 then begin
    LogSinValue:=$1000;
   end else if (Phase and $100)<>0 then begin
    LogSinValue:=LogSinROM[(Phase and $ff) xor $ff];
   end else begin
    LogSinValue:=LogSinROM[Phase and $ff];
   end;
   result:=CalcExp(TPasRISCVUInt32(LogSinValue)+(TPasRISCVUInt32(aEnvelope) shl 3));
  end;

  2:begin // Absolute sine (rectified)
   if (Phase and $100)<>0 then begin
    LogSinValue:=LogSinROM[(Phase and $ff) xor $ff];
   end else begin
    LogSinValue:=LogSinROM[Phase and $ff];
   end;
   result:=CalcExp(TPasRISCVUInt32(LogSinValue)+(TPasRISCVUInt32(aEnvelope) shl 3));
  end;

  3:begin // Pseudo-rectified quarter sine
   if (Phase and $100)<>0 then begin
    LogSinValue:=$1000;
   end else begin
    LogSinValue:=LogSinROM[Phase and $ff];
   end;
   result:=CalcExp(TPasRISCVUInt32(LogSinValue)+(TPasRISCVUInt32(aEnvelope) shl 3));
  end;

  4:begin // Double-rate sine
   if (Phase and $300)=$100 then begin
    Negate:=$ffff;
   end else begin
    Negate:=0;
   end;
   if (Phase and $200)<>0 then begin
    LogSinValue:=$1000;
   end else if (Phase and $80)<>0 then begin
    LogSinValue:=LogSinROM[((Phase xor $ff) shl 1) and $ff];
   end else begin
    LogSinValue:=LogSinROM[(Phase shl 1) and $ff];
   end;
   result:=CalcExp(TPasRISCVUInt32(LogSinValue)+(TPasRISCVUInt32(aEnvelope) shl 3)) xor TPasRISCVInt16(Negate);
  end;

  5:begin // Double-rate absolute sine
   if (Phase and $200)<>0 then begin
    LogSinValue:=$1000;
   end else if (Phase and $80)<>0 then begin
    LogSinValue:=LogSinROM[((Phase xor $ff) shl 1) and $ff];
   end else begin
    LogSinValue:=LogSinROM[(Phase shl 1) and $ff];
   end;
   result:=CalcExp(TPasRISCVUInt32(LogSinValue)+(TPasRISCVUInt32(aEnvelope) shl 3));
  end;

  6:begin // Square wave
   if (Phase and $200)<>0 then begin
    Negate:=$ffff;
   end else begin
    Negate:=0;
   end;
   result:=CalcExp(TPasRISCVUInt32(aEnvelope) shl 3) xor TPasRISCVInt16(Negate);
  end;

  7:begin // Derived sawtooth (exponential ramp)
   if (Phase and $200)<>0 then begin
    Negate:=$ffff;
    Phase:=(Phase and $1ff) xor $1ff;
   end else begin
    Negate:=0;
   end;
   LogSinValue:=Phase shl 3;
   result:=CalcExp(TPasRISCVUInt32(LogSinValue)+(TPasRISCVUInt32(aEnvelope) shl 3)) xor TPasRISCVInt16(Negate);
  end;

  else begin
   result:=0;
  end;

 end;

end;

procedure TPasRISCV.TFM801Device.TOPL3.UpdateKSL(const aSlot:POPL3Slot);
const KSLRom:array[0..15] of TPasRISCVUInt8=
       (
        0,32,40,45,48,51,53,55,56,58,59,60,61,62,63,64
       );
var Channel:POPL3Channel;
    KSLValue:TPasRISCVInt16;
begin
 Channel:=@fChannels[aSlot^.fChannelIndex];
 KSLValue:=TPasRISCVInt16(KSLRom[Channel^.fFrequencyNumber shr 6] shl 2)-TPasRISCVInt16(($08-Channel^.fBlock) shl 5);
 if KSLValue<0 then begin
  KSLValue:=0;
 end;
 aSlot^.fEnvelopeKSL:=TPasRISCVUInt8(KSLValue);
end;

procedure TPasRISCV.TFM801Device.TOPL3.ProcessEnvelope(const aSlot:POPL3Slot);
const KSLShift:array[0..3] of TPasRISCVUInt8=(8,1,2,0);
      EGIncStep:array[0..3,0..3] of TPasRISCVUInt8=
       (
        (0,0,0,0),
        (1,0,0,0),
        (1,0,1,0),
        (1,1,1,0)
       );
var Channel:POPL3Channel;
    RegRate,KeyScale,Rate,RateHi,RateLo:TPasRISCVUInt8;
    EGShift,Shift:TPasRISCVUInt8;
    EnvRouted:TPasRISCVUInt16;
    EnvInc:TPasRISCVInt16;
    EnvOff:TPasRISCVUInt8;
    DoReset:Boolean;
    NonZero:Boolean;
begin

 Channel:=@fChannels[aSlot^.fChannelIndex];

 aSlot^.fEnvelopeOut:=aSlot^.fEnvelopeRouted+(TPasRISCVUInt16(aSlot^.fRegTotalLevel) shl 2)+(aSlot^.fEnvelopeKSL shr KSLShift[aSlot^.fRegKSLMode])+aSlot^.fTremoloSource^;

 DoReset:=false;

 RegRate:=0;

 if (aSlot^.fKey<>0) and (aSlot^.fEnvelopeState=TOPL3EnvelopeState.Release) then begin

  DoReset:=true;
  RegRate:=aSlot^.fRegAttackRate;

 end else begin

  case aSlot^.fEnvelopeState of

   TOPL3EnvelopeState.Attack:begin
    RegRate:=aSlot^.fRegAttackRate;
   end;

   TOPL3EnvelopeState.Decay:begin
    RegRate:=aSlot^.fRegDecayRate;
   end;

   TOPL3EnvelopeState.Sustain:begin
    if aSlot^.fRegSustainType=0 then begin
     RegRate:=aSlot^.fRegReleaseRate;
    end;
   end;

   TOPL3EnvelopeState.Release:begin
    RegRate:=aSlot^.fRegReleaseRate;
   end;

  end;

 end;

 aSlot^.fPhaseReset:=ord(DoReset);
 KeyScale:=Channel^.fKeyScaleValue shr ((aSlot^.fRegKSR xor 1) shl 1);
 NonZero:=RegRate<>0;

 Rate:=KeyScale+(RegRate shl 2);
 RateHi:=Rate shr 2;
 RateLo:=Rate and $03;

 if (RateHi and $10)<>0 then begin
  RateHi:=$0f;
 end;

 EGShift:=RateHi+fEnvelopeAdd;
 Shift:=0;

 if NonZero then begin
  if RateHi<12 then begin
   if fEnvelopeTimerState<>0 then begin

    case EGShift of

     12:begin
      Shift:=1;
     end;

     13:begin
      Shift:=(RateLo shr 1) and $01;
     end;

     14:begin
      Shift:=RateLo and $01;
     end;

    end;

   end;

  end else begin

   Shift:=(RateHi and $03)+EGIncStep[RateLo,fEnvelopeTimerLow];
   if (Shift and $04)<>0 then begin
    Shift:=$03;
   end;

   if Shift=0 then begin
    Shift:=fEnvelopeTimerState;
   end;

  end;

 end;

 EnvRouted:=aSlot^.fEnvelopeRouted;
 EnvInc:=0;
 EnvOff:=0;

 // Instant attack
 if DoReset and (RateHi=$0f) then begin
  EnvRouted:=$00;
 end;

 // Envelope off check
 if (aSlot^.fEnvelopeRouted and $1f8)=$1f8 then begin
  EnvOff:=1;
 end;

 if (aSlot^.fEnvelopeState<>TOPL3EnvelopeState.Attack) and (not DoReset) and (EnvOff<>0) then begin
  EnvRouted:=$1ff;
 end;

 case aSlot^.fEnvelopeState of

  TOPL3EnvelopeState.Attack:begin
   if aSlot^.fEnvelopeRouted=0 then begin
    aSlot^.fEnvelopeState:=TOPL3EnvelopeState.Decay;
   end else if (aSlot^.fKey<>0) and (Shift>0) and (RateHi<>$0f) then begin
    EnvInc:=TPasRISCVInt16((not aSlot^.fEnvelopeRouted) shr (4-Shift));
   end;
  end;

  TOPL3EnvelopeState.Decay:begin
   if (aSlot^.fEnvelopeRouted shr 4)=aSlot^.fRegSustainLevel then begin
    aSlot^.fEnvelopeState:=TOPL3EnvelopeState.Sustain;
   end else if (EnvOff=0) and (not DoReset) and (Shift>0) then begin
    EnvInc:=1 shl (Shift-1);
   end;
  end;

  TOPL3EnvelopeState.Sustain,
  TOPL3EnvelopeState.Release:begin
   if (EnvOff=0) and (not DoReset) and (Shift>0) then begin
    EnvInc:=1 shl (Shift-1);
   end;
  end;

 end;

 aSlot^.fEnvelopeRouted:=(EnvRouted+TPasRISCVUInt16(EnvInc)) and $1ff;

 // Key-on triggers attack
 if DoReset then begin
  aSlot^.fEnvelopeState:=TOPL3EnvelopeState.Attack;
 end;

 // Key-off triggers release
 if aSlot^.fKey=0 then begin
  aSlot^.fEnvelopeState:=TOPL3EnvelopeState.Release;
 end;

end;

procedure TPasRISCV.TFM801Device.TOPL3.ProcessPhase(const aSlot:POPL3Slot);
const FreqMultiplier:array[0..15] of TPasRISCVUInt8=
       (
        1,2,4,6,8,10,12,14,16,18,20,20,24,24,30,30
       );
var Channel:POPL3Channel;
    FreqNum:TPasRISCVUInt16;
    BaseFreq:TPasRISCVUInt32;
    Phase:TPasRISCVUInt16;
    VibRange:TPasRISCVInt8;
    VibPos:TPasRISCVUInt8;
    RhythmXOR,NoiseBit:TPasRISCVUInt8;
begin

 Channel:=@fChannels[aSlot^.fChannelIndex];
 FreqNum:=Channel^.fFrequencyNumber;

 // Vibrato modulation
 if aSlot^.fRegVibrato<>0 then begin

  VibRange:=TPasRISCVInt8((FreqNum shr 7) and 7);

  VibPos:=fVibratoPosition;
  if (VibPos and 3)=0 then begin
   VibRange:=0;
  end else if (VibPos and 1)<>0 then begin
   VibRange:=VibRange shr 1;
  end;

  VibRange:=VibRange shr fVibratoShift;
  if (VibPos and 4)<>0 then begin
   VibRange:=-VibRange;
  end;

  FreqNum:=TPasRISCVUInt16(TPasRISCVInt16(FreqNum)+VibRange);

 end;

 BaseFreq:=(TPasRISCVUInt32(FreqNum) shl Channel^.fBlock) shr 1;
 Phase:=TPasRISCVUInt16(aSlot^.fPhaseAccumulator shr 9);

 if aSlot^.fPhaseReset<>0 then begin
  aSlot^.fPhaseAccumulator:=0;
 end;
 aSlot^.fPhaseAccumulator:=aSlot^.fPhaseAccumulator+((BaseFreq*FreqMultiplier[aSlot^.fRegMultiplier]) shr 1);

 // Store phase output
 aSlot^.fPhaseOut:=Phase;

 // Rhythm mode phase bits for hi-hat and cymbal
 if aSlot^.fSlotIndex=13 then begin
  fRhythmHHBit2:=(Phase shr 2) and 1;
  fRhythmHHBit3:=(Phase shr 3) and 1;
  fRhythmHHBit7:=(Phase shr 7) and 1;
  fRhythmHHBit8:=(Phase shr 8) and 1;
 end;

 if (aSlot^.fSlotIndex=17) and ((fRhythm and $20)<>0) then begin
  fRhythmTCBit3:=(Phase shr 3) and 1;
  fRhythmTCBit5:=(Phase shr 5) and 1;
 end;

 // Rhythm mode special phase generation
 if (fRhythm and $20)<>0 then begin

  RhythmXOR:=(fRhythmHHBit2 xor fRhythmHHBit7) or (fRhythmHHBit3 xor fRhythmTCBit5) or (fRhythmTCBit3 xor fRhythmTCBit5);

  case aSlot^.fSlotIndex of

   13:begin // Hi-hat
    aSlot^.fPhaseOut:=RhythmXOR shl 9;
    if (RhythmXOR xor (fNoiseLFSR and 1))<>0 then begin
     aSlot^.fPhaseOut:=aSlot^.fPhaseOut or $d0;
    end else begin
     aSlot^.fPhaseOut:=aSlot^.fPhaseOut or $34;
    end;
   end;

   16:begin // Snare drum
    aSlot^.fPhaseOut:=(fRhythmHHBit8 shl 9) or ((fRhythmHHBit8 xor (fNoiseLFSR and 1)) shl 8);
   end;

   17:begin // Top cymbal
    aSlot^.fPhaseOut:=(RhythmXOR shl 9) or $80;
   end;

  end;

 end;

 // Advance noise LFSR
 NoiseBit:=((fNoiseLFSR shr 14) xor fNoiseLFSR) and $01;
 fNoiseLFSR:=(fNoiseLFSR shr 1) or (TPasRISCVUInt32(NoiseBit) shl 22);

end;

procedure TPasRISCV.TFM801Device.TOPL3.GenerateSlotOutput(const aSlot:POPL3Slot);
begin
 aSlot^.fOut:=CalcWaveform(aSlot^.fRegWaveform,aSlot^.fPhaseOut+TPasRISCVUInt16(aSlot^.fModSource^),aSlot^.fEnvelopeOut);
end;

procedure TPasRISCV.TFM801Device.TOPL3.CalculateSlotFeedback(const aSlot:POPL3Slot);
var Channel:POPL3Channel;
begin
 Channel:=@fChannels[aSlot^.fChannelIndex];
 if Channel^.fFeedback<>0 then begin
  aSlot^.fFeedbackMod:=TPasRISCVInt16((TPasRISCVInt16(aSlot^.fPreviousOut)+aSlot^.fOut) shr ($09-Channel^.fFeedback));
 end else begin
  aSlot^.fFeedbackMod:=0;
 end;
 aSlot^.fPreviousOut:=aSlot^.fOut;
end;

procedure TPasRISCV.TFM801Device.TOPL3.ProcessSlot(const aSlot:POPL3Slot);
begin
 CalculateSlotFeedback(aSlot);
 ProcessEnvelope(aSlot);
 ProcessPhase(aSlot);
 GenerateSlotOutput(aSlot);
end;

procedure TPasRISCV.TFM801Device.TOPL3.SlotKeyOn(const aSlot:POPL3Slot;const aKeyType:TPasRISCVUInt8);
begin
 aSlot^.fKey:=aSlot^.fKey or aKeyType;
end;

procedure TPasRISCV.TFM801Device.TOPL3.SlotKeyOff(const aSlot:POPL3Slot;const aKeyType:TPasRISCVUInt8);
begin
 aSlot^.fKey:=aSlot^.fKey and (not aKeyType);
end;

procedure TPasRISCV.TFM801Device.TOPL3.SetupChannelAlgorithm(const aChannel:POPL3Channel);
begin

 if aChannel^.fChannelType=TOPL3ChannelType.Drum then begin

  if (aChannel^.fChannelIndex=7) or (aChannel^.fChannelIndex=8) then begin

   aChannel^.fSlots[0]^.fModSource:=@fZeroMod;
   aChannel^.fSlots[1]^.fModSource:=@fZeroMod;

  end else begin

   case aChannel^.fAlgorithm and $01 of
    $00:begin
     aChannel^.fSlots[0]^.fModSource:=@aChannel^.fSlots[0]^.fFeedbackMod;
     aChannel^.fSlots[1]^.fModSource:=@aChannel^.fSlots[0]^.fOut;
    end;
    $01:begin
     aChannel^.fSlots[0]^.fModSource:=@aChannel^.fSlots[0]^.fFeedbackMod;
     aChannel^.fSlots[1]^.fModSource:=@fZeroMod;
    end;
   end;

  end;

 end else if (aChannel^.fAlgorithm and $08)=0 then begin // 4-op primary: routing handled by secondary

  if (aChannel^.fAlgorithm and $04)<>0 then begin

   // 4-op mode: this is the secondary channel routing all 4 slots

   if assigned(aChannel^.fPair) then begin

    aChannel^.fPair^.fOutputSources[0]:=@fZeroMod;
    aChannel^.fPair^.fOutputSources[1]:=@fZeroMod;
    aChannel^.fPair^.fOutputSources[2]:=@fZeroMod;
    aChannel^.fPair^.fOutputSources[3]:=@fZeroMod;

    case aChannel^.fAlgorithm and $03 of

     $00:begin // FM-FM chain
      aChannel^.fPair^.fSlots[0]^.fModSource:=@aChannel^.fPair^.fSlots[0]^.fFeedbackMod;
      aChannel^.fPair^.fSlots[1]^.fModSource:=@aChannel^.fPair^.fSlots[0]^.fOut;
      aChannel^.fSlots[0]^.fModSource:=@aChannel^.fPair^.fSlots[1]^.fOut;
      aChannel^.fSlots[1]^.fModSource:=@aChannel^.fSlots[0]^.fOut;
      aChannel^.fOutputSources[0]:=@aChannel^.fSlots[1]^.fOut;
      aChannel^.fOutputSources[1]:=@fZeroMod;
      aChannel^.fOutputSources[2]:=@fZeroMod;
      aChannel^.fOutputSources[3]:=@fZeroMod;
     end;

     $01:begin // FM-FM + direct
      aChannel^.fPair^.fSlots[0]^.fModSource:=@aChannel^.fPair^.fSlots[0]^.fFeedbackMod;
      aChannel^.fPair^.fSlots[1]^.fModSource:=@aChannel^.fPair^.fSlots[0]^.fOut;
      aChannel^.fSlots[0]^.fModSource:=@fZeroMod;
      aChannel^.fSlots[1]^.fModSource:=@aChannel^.fSlots[0]^.fOut;
      aChannel^.fOutputSources[0]:=@aChannel^.fPair^.fSlots[1]^.fOut;
      aChannel^.fOutputSources[1]:=@aChannel^.fSlots[1]^.fOut;
      aChannel^.fOutputSources[2]:=@fZeroMod;
      aChannel^.fOutputSources[3]:=@fZeroMod;
     end;

     $02:begin // Direct + FM chain
      aChannel^.fPair^.fSlots[0]^.fModSource:=@aChannel^.fPair^.fSlots[0]^.fFeedbackMod;
      aChannel^.fPair^.fSlots[1]^.fModSource:=@fZeroMod;
      aChannel^.fSlots[0]^.fModSource:=@aChannel^.fPair^.fSlots[1]^.fOut;
      aChannel^.fSlots[1]^.fModSource:=@aChannel^.fSlots[0]^.fOut;
      aChannel^.fOutputSources[0]:=@aChannel^.fPair^.fSlots[0]^.fOut;
      aChannel^.fOutputSources[1]:=@aChannel^.fSlots[1]^.fOut;
      aChannel^.fOutputSources[2]:=@fZeroMod;
      aChannel^.fOutputSources[3]:=@fZeroMod;
     end;

     $03:begin // All additive outputs
      aChannel^.fPair^.fSlots[0]^.fModSource:=@aChannel^.fPair^.fSlots[0]^.fFeedbackMod;
      aChannel^.fPair^.fSlots[1]^.fModSource:=@fZeroMod;
      aChannel^.fSlots[0]^.fModSource:=@aChannel^.fPair^.fSlots[1]^.fOut;
      aChannel^.fSlots[1]^.fModSource:=@fZeroMod;
      aChannel^.fOutputSources[0]:=@aChannel^.fPair^.fSlots[0]^.fOut;
      aChannel^.fOutputSources[1]:=@aChannel^.fSlots[0]^.fOut;
      aChannel^.fOutputSources[2]:=@aChannel^.fSlots[1]^.fOut;
      aChannel^.fOutputSources[3]:=@fZeroMod;
     end;

    end;

   end;

  end else begin

   // 2-op mode

   case aChannel^.fAlgorithm and $01 of

    $00:begin // FM
     aChannel^.fSlots[0]^.fModSource:=@aChannel^.fSlots[0]^.fFeedbackMod;
     aChannel^.fSlots[1]^.fModSource:=@aChannel^.fSlots[0]^.fOut;
     aChannel^.fOutputSources[0]:=@aChannel^.fSlots[1]^.fOut;
     aChannel^.fOutputSources[1]:=@fZeroMod;
     aChannel^.fOutputSources[2]:=@fZeroMod;
     aChannel^.fOutputSources[3]:=@fZeroMod;
    end;

    $01:begin // Additive
     aChannel^.fSlots[0]^.fModSource:=@aChannel^.fSlots[0]^.fFeedbackMod;
     aChannel^.fSlots[1]^.fModSource:=@fZeroMod;
     aChannel^.fOutputSources[0]:=@aChannel^.fSlots[0]^.fOut;
     aChannel^.fOutputSources[1]:=@aChannel^.fSlots[1]^.fOut;
     aChannel^.fOutputSources[2]:=@fZeroMod;
     aChannel^.fOutputSources[3]:=@fZeroMod;
    end;

   end;

  end;

 end;

end;

procedure TPasRISCV.TFM801Device.TOPL3.UpdateChannelAlgorithm(const aChannel:POPL3Channel);
begin
 aChannel^.fAlgorithm:=aChannel^.fConnection;

 if fNewMode<>0 then begin

  if aChannel^.fChannelType=TOPL3ChannelType.FourOp then begin

   if assigned(aChannel^.fPair) then begin
    aChannel^.fPair^.fAlgorithm:=$04 or (aChannel^.fConnection shl 1) or aChannel^.fPair^.fConnection;
    aChannel^.fAlgorithm:=$08;
    SetupChannelAlgorithm(aChannel^.fPair);
   end;

  end else if aChannel^.fChannelType=TOPL3ChannelType.FourOpSecondary then begin

   if assigned(aChannel^.fPair) then begin
    aChannel^.fAlgorithm:=$04 or (aChannel^.fPair^.fConnection shl 1) or aChannel^.fConnection;
    aChannel^.fPair^.fAlgorithm:=$08;
    SetupChannelAlgorithm(aChannel);
   end;

  end else begin

   SetupChannelAlgorithm(aChannel);

  end;

 end else begin

  SetupChannelAlgorithm(aChannel);

 end;

end;

procedure TPasRISCV.TFM801Device.TOPL3.UpdateRhythmMode(const aData:TPasRISCVUInt8);
var ChannelNum:TPasRISCVUInt8;
begin

 fRhythm:=aData and $3f;

 if (fRhythm and $20)<>0 then begin

  // Rhythm mode enabled: configure channels 6-8 as drums
  fChannels[6].fOutputSources[0]:=@fChannels[6].fSlots[1]^.fOut;
  fChannels[6].fOutputSources[1]:=@fChannels[6].fSlots[1]^.fOut;
  fChannels[6].fOutputSources[2]:=@fZeroMod;
  fChannels[6].fOutputSources[3]:=@fZeroMod;
  fChannels[7].fOutputSources[0]:=@fChannels[7].fSlots[0]^.fOut;
  fChannels[7].fOutputSources[1]:=@fChannels[7].fSlots[0]^.fOut;
  fChannels[7].fOutputSources[2]:=@fChannels[7].fSlots[1]^.fOut;
  fChannels[7].fOutputSources[3]:=@fChannels[7].fSlots[1]^.fOut;
  fChannels[8].fOutputSources[0]:=@fChannels[8].fSlots[0]^.fOut;
  fChannels[8].fOutputSources[1]:=@fChannels[8].fSlots[0]^.fOut;
  fChannels[8].fOutputSources[2]:=@fChannels[8].fSlots[1]^.fOut;
  fChannels[8].fOutputSources[3]:=@fChannels[8].fSlots[1]^.fOut;

  for ChannelNum:=6 to 8 do begin
   fChannels[ChannelNum].fChannelType:=TOPL3ChannelType.Drum;
  end;

  SetupChannelAlgorithm(@fChannels[6]);
  SetupChannelAlgorithm(@fChannels[7]);
  SetupChannelAlgorithm(@fChannels[8]);

  // Key on/off individual drum instruments
  if (fRhythm and $01)<>0 then begin
   SlotKeyOn(fChannels[7].fSlots[0],OPL3_KEY_DRUM);
  end else begin
   SlotKeyOff(fChannels[7].fSlots[0],OPL3_KEY_DRUM);
  end;

  if (fRhythm and $02)<>0 then begin
   SlotKeyOn(fChannels[8].fSlots[1],OPL3_KEY_DRUM);
  end else begin
   SlotKeyOff(fChannels[8].fSlots[1],OPL3_KEY_DRUM);
  end;

  if (fRhythm and $04)<>0 then begin
   SlotKeyOn(fChannels[8].fSlots[0],OPL3_KEY_DRUM);
  end else begin
   SlotKeyOff(fChannels[8].fSlots[0],OPL3_KEY_DRUM);
  end;

  if (fRhythm and $08)<>0 then begin
   SlotKeyOn(fChannels[7].fSlots[1],OPL3_KEY_DRUM);
  end else begin
   SlotKeyOff(fChannels[7].fSlots[1],OPL3_KEY_DRUM);
  end;

  if (fRhythm and $10)<>0 then begin
   SlotKeyOn(fChannels[6].fSlots[0],OPL3_KEY_DRUM);
   SlotKeyOn(fChannels[6].fSlots[1],OPL3_KEY_DRUM);
  end else begin
   SlotKeyOff(fChannels[6].fSlots[0],OPL3_KEY_DRUM);
   SlotKeyOff(fChannels[6].fSlots[1],OPL3_KEY_DRUM);
  end;

 end else begin

  // Rhythm mode disabled: restore normal 2-op channels
  for ChannelNum:=6 to 8 do begin
   fChannels[ChannelNum].fChannelType:=TOPL3ChannelType.TwoOp;
   SetupChannelAlgorithm(@fChannels[ChannelNum]);
   SlotKeyOff(fChannels[ChannelNum].fSlots[0],OPL3_KEY_DRUM);
   SlotKeyOff(fChannels[ChannelNum].fSlots[1],OPL3_KEY_DRUM);
  end;

 end;

end;

procedure TPasRISCV.TFM801Device.TOPL3.ChannelKeyOn(const aChannel:POPL3Channel);
begin
 if fNewMode<>0 then begin
  if aChannel^.fChannelType=TOPL3ChannelType.FourOp then begin
   SlotKeyOn(aChannel^.fSlots[0],OPL3_KEY_NORMAL);
   SlotKeyOn(aChannel^.fSlots[1],OPL3_KEY_NORMAL);
   if assigned(aChannel^.fPair) then begin
    SlotKeyOn(aChannel^.fPair^.fSlots[0],OPL3_KEY_NORMAL);
    SlotKeyOn(aChannel^.fPair^.fSlots[1],OPL3_KEY_NORMAL);
   end;
  end else if (aChannel^.fChannelType=TOPL3ChannelType.TwoOp) or (aChannel^.fChannelType=TOPL3ChannelType.Drum) then begin
   SlotKeyOn(aChannel^.fSlots[0],OPL3_KEY_NORMAL);
   SlotKeyOn(aChannel^.fSlots[1],OPL3_KEY_NORMAL);
  end;
 end else begin
  SlotKeyOn(aChannel^.fSlots[0],OPL3_KEY_NORMAL);
  SlotKeyOn(aChannel^.fSlots[1],OPL3_KEY_NORMAL);
 end;
end;

procedure TPasRISCV.TFM801Device.TOPL3.ChannelKeyOff(const aChannel:POPL3Channel);
begin
 if fNewMode<>0 then begin
  if aChannel^.fChannelType=TOPL3ChannelType.FourOp then begin
   SlotKeyOff(aChannel^.fSlots[0],OPL3_KEY_NORMAL);
   SlotKeyOff(aChannel^.fSlots[1],OPL3_KEY_NORMAL);
   if assigned(aChannel^.fPair) then begin
    SlotKeyOff(aChannel^.fPair^.fSlots[0],OPL3_KEY_NORMAL);
    SlotKeyOff(aChannel^.fPair^.fSlots[1],OPL3_KEY_NORMAL);
   end;
  end else if (aChannel^.fChannelType=TOPL3ChannelType.TwoOp) or (aChannel^.fChannelType=TOPL3ChannelType.Drum) then begin
   SlotKeyOff(aChannel^.fSlots[0],OPL3_KEY_NORMAL);
   SlotKeyOff(aChannel^.fSlots[1],OPL3_KEY_NORMAL);
  end;
 end else begin
  SlotKeyOff(aChannel^.fSlots[0],OPL3_KEY_NORMAL);
  SlotKeyOff(aChannel^.fSlots[1],OPL3_KEY_NORMAL);
 end;
end;

procedure TPasRISCV.TFM801Device.TOPL3.Set4OpMode(const aData:TPasRISCVUInt8);
var Bit,ChannelNum:TPasRISCVUInt8;
begin

 for Bit:=0 to 5 do begin

  ChannelNum:=Bit;

  if Bit>=3 then begin
   inc(ChannelNum,9-3);
  end;

  if ((aData shr Bit) and $01)<>0 then begin
   fChannels[ChannelNum].fChannelType:=TOPL3ChannelType.FourOp;
   fChannels[ChannelNum+3].fChannelType:=TOPL3ChannelType.FourOpSecondary;
   UpdateChannelAlgorithm(@fChannels[ChannelNum]);
  end else begin
   fChannels[ChannelNum].fChannelType:=TOPL3ChannelType.TwoOp;
   fChannels[ChannelNum+3].fChannelType:=TOPL3ChannelType.TwoOp;
   UpdateChannelAlgorithm(@fChannels[ChannelNum]);
   UpdateChannelAlgorithm(@fChannels[ChannelNum+3]);
  end;
 end;

end;

procedure TPasRISCV.TFM801Device.TOPL3.WriteSlotReg20(const aSlot:POPL3Slot;const aData:TPasRISCVUInt8);
begin

 if ((aData shr 7) and $01)<>0 then begin
  aSlot^.fTremoloSource:=@fTremolo;
 end else begin
  aSlot^.fTremoloSource:=PPasRISCVUInt8(@fZeroMod);
 end;

 aSlot^.fRegVibrato:=(aData shr 6) and $01;
 aSlot^.fRegSustainType:=(aData shr 5) and $01;
 aSlot^.fRegKSR:=(aData shr 4) and $01;
 aSlot^.fRegMultiplier:=aData and $0f;

end;

procedure TPasRISCV.TFM801Device.TOPL3.WriteSlotReg40(const aSlot:POPL3Slot;const aData:TPasRISCVUInt8);
begin
 aSlot^.fRegKSLMode:=(aData shr 6) and $03;
 aSlot^.fRegTotalLevel:=aData and $3f;
 UpdateKSL(aSlot);
end;

procedure TPasRISCV.TFM801Device.TOPL3.WriteSlotReg60(const aSlot:POPL3Slot;const aData:TPasRISCVUInt8);
begin
 aSlot^.fRegAttackRate:=(aData shr 4) and $0f;
 aSlot^.fRegDecayRate:=aData and $0f;
end;

procedure TPasRISCV.TFM801Device.TOPL3.WriteSlotReg80(const aSlot:POPL3Slot;const aData:TPasRISCVUInt8);
begin
 aSlot^.fRegSustainLevel:=(aData shr 4) and $0f;
 if aSlot^.fRegSustainLevel=$0f then begin
  aSlot^.fRegSustainLevel:=$1f;
 end;
 aSlot^.fRegReleaseRate:=aData and $0f;
end;

procedure TPasRISCV.TFM801Device.TOPL3.WriteSlotRegE0(const aSlot:POPL3Slot;const aData:TPasRISCVUInt8);
begin
 aSlot^.fRegWaveform:=aData and $07;
 if fNewMode=0 then begin
  aSlot^.fRegWaveform:=aSlot^.fRegWaveform and $03;
 end;
end;

procedure TPasRISCV.TFM801Device.TOPL3.WriteChannelRegA0(const aChannel:POPL3Channel;const aData:TPasRISCVUInt8);
begin

 if (fNewMode=0) or (aChannel^.fChannelType<>TOPL3ChannelType.FourOpSecondary) then begin

  aChannel^.fFrequencyNumber:=(aChannel^.fFrequencyNumber and $300) or aData;
  aChannel^.fKeyScaleValue:=(aChannel^.fBlock shl 1) or ((aChannel^.fFrequencyNumber shr ($09-fNoteSelect)) and $01);

  UpdateKSL(aChannel^.fSlots[0]);
  UpdateKSL(aChannel^.fSlots[1]);

  if (fNewMode<>0) and (aChannel^.fChannelType=TOPL3ChannelType.FourOp) and assigned(aChannel^.fPair) then begin
   aChannel^.fPair^.fFrequencyNumber:=aChannel^.fFrequencyNumber;
   aChannel^.fPair^.fKeyScaleValue:=aChannel^.fKeyScaleValue;
   UpdateKSL(aChannel^.fPair^.fSlots[0]);
   UpdateKSL(aChannel^.fPair^.fSlots[1]);
  end;

 end;

end;

procedure TPasRISCV.TFM801Device.TOPL3.WriteChannelRegB0(const aChannel:POPL3Channel;const aData:TPasRISCVUInt8);
begin

 if (fNewMode=0) or (aChannel^.fChannelType<>TOPL3ChannelType.FourOpSecondary) then begin

  aChannel^.fFrequencyNumber:=(aChannel^.fFrequencyNumber and $ff) or (TPasRISCVUInt16(aData and $03) shl 8);
  aChannel^.fBlock:=(aData shr 2) and $07;
  aChannel^.fKeyScaleValue:=(aChannel^.fBlock shl 1) or ((aChannel^.fFrequencyNumber shr ($09-fNoteSelect)) and $01);

  UpdateKSL(aChannel^.fSlots[0]);
  UpdateKSL(aChannel^.fSlots[1]);

  if (fNewMode<>0) and (aChannel^.fChannelType=TOPL3ChannelType.FourOp) and assigned(aChannel^.fPair) then begin
   aChannel^.fPair^.fFrequencyNumber:=aChannel^.fFrequencyNumber;
   aChannel^.fPair^.fBlock:=aChannel^.fBlock;
   aChannel^.fPair^.fKeyScaleValue:=aChannel^.fKeyScaleValue;
   UpdateKSL(aChannel^.fPair^.fSlots[0]);
   UpdateKSL(aChannel^.fPair^.fSlots[1]);
  end;

 end;

end;

procedure TPasRISCV.TFM801Device.TOPL3.WriteChannelRegC0(const aChannel:POPL3Channel;const aData:TPasRISCVUInt8);
begin

 aChannel^.fFeedback:=(aData and $0e) shr 1;
 aChannel^.fConnection:=aData and $01;

 UpdateChannelAlgorithm(aChannel);

 if fNewMode<>0 then begin
  aChannel^.fOutputEnableA:=TPasRISCVUInt16(((aData shr 4) and $01)*$ffff);
  aChannel^.fOutputEnableB:=TPasRISCVUInt16(((aData shr 5) and $01)*$ffff);
  aChannel^.fOutputEnableC:=TPasRISCVUInt16(((aData shr 6) and $01)*$ffff);
  aChannel^.fOutputEnableD:=TPasRISCVUInt16(((aData shr 7) and $01)*$ffff);
 end else begin
  aChannel^.fOutputEnableA:=$ffff;
  aChannel^.fOutputEnableB:=$ffff;
  aChannel^.fOutputEnableC:=0;
  aChannel^.fOutputEnableD:=0;
 end;

end;

function TPasRISCV.TFM801Device.TOPL3.ClipSample(const aSample:TPasRISCVInt32):TPasRISCVInt16;
begin
 if aSample>32767 then begin
  result:=32767;
 end else if aSample<-32768 then begin
  result:=-32768;
 end else begin
  result:=TPasRISCVInt16(aSample);
 end;
end;

procedure TPasRISCV.TFM801Device.TOPL3.WriteRegister(const aRegister:TPasRISCVUInt16;const aValue:TPasRISCVUInt8);
const AddressToSlot:array[0..31] of TPasRISCVInt8=
       (
        0,1,2,3,4,5,-1,-1,6,7,8,9,10,11,-1,-1,
        12,13,14,15,16,17,-1,-1,-1,-1,-1,-1,-1,-1,-1,-1
       );
var Bank:TPasRISCVUInt8;
    RegM:TPasRISCVUInt8;
    SlotIdx:TPasRISCVInt8;
begin

 Bank:=(aRegister shr 8) and $01;
 RegM:=aRegister and $ff;

 case RegM and $f0 of

  $00:begin

   if Bank<>0 then begin

    case RegM and $0f of

     $04:begin
      Set4OpMode(aValue);
     end;

     $05:begin
      fNewMode:=aValue and $01;
     end;

    end;
   end else begin

    case RegM and $0f of

     $08:begin
      fNoteSelect:=(aValue shr 6) and $01;
     end;

    end;

   end;

  end;

  $20,$30:begin
   if (RegM and $1f)<TPasRISCVUInt8(Length(AddressToSlot)) then begin
    SlotIdx:=AddressToSlot[RegM and $1f];
    if SlotIdx>=0 then begin
     WriteSlotReg20(@fSlots[TPasRISCVUInt32(18)*Bank+TPasRISCVUInt32(SlotIdx)],aValue);
    end;
   end;
  end;

  $40,$50:begin
   if (RegM and $1f)<TPasRISCVUInt8(Length(AddressToSlot)) then begin
    SlotIdx:=AddressToSlot[RegM and $1f];
    if SlotIdx>=0 then begin
     WriteSlotReg40(@fSlots[TPasRISCVUInt32(18)*Bank+TPasRISCVUInt32(SlotIdx)],aValue);
    end;
   end;
  end;

  $60,$70:begin
   if (RegM and $1f)<TPasRISCVUInt8(Length(AddressToSlot)) then begin
    SlotIdx:=AddressToSlot[RegM and $1f];
    if SlotIdx>=0 then begin
     WriteSlotReg60(@fSlots[TPasRISCVUInt32(18)*Bank+TPasRISCVUInt32(SlotIdx)],aValue);
    end;
   end;
  end;

  $80,$90:begin
   if (RegM and $1f)<TPasRISCVUInt8(Length(AddressToSlot)) then begin
    SlotIdx:=AddressToSlot[RegM and $1f];
    if SlotIdx>=0 then begin
     WriteSlotReg80(@fSlots[TPasRISCVUInt32(18)*Bank+TPasRISCVUInt32(SlotIdx)],aValue);
    end;
   end;
  end;

  $e0,$f0:begin
   if (RegM and $1f)<TPasRISCVUInt8(Length(AddressToSlot)) then begin
    SlotIdx:=AddressToSlot[RegM and $1f];
    if SlotIdx>=0 then begin
     WriteSlotRegE0(@fSlots[TPasRISCVUInt32(18)*Bank+TPasRISCVUInt32(SlotIdx)],aValue);
    end;
   end;
  end;

  $a0:begin
   if (RegM and $0f)<9 then begin
    WriteChannelRegA0(@fChannels[TPasRISCVUInt32(9)*Bank+(RegM and $0f)],aValue);
   end;
  end;

  $b0:begin
   if (RegM=$bd) and (Bank=0) then begin
    fTremoloShift:=(((aValue shr 7) xor 1) shl 1)+2;
    fVibratoShift:=((aValue shr 6) and $01) xor 1;
    UpdateRhythmMode(aValue);
   end else if (RegM and $0f)<9 then begin
    WriteChannelRegB0(@fChannels[TPasRISCVUInt32(9)*Bank+(RegM and $0f)],aValue);
    if (aValue and $20)<>0 then begin
     ChannelKeyOn(@fChannels[TPasRISCVUInt32(9)*Bank+(RegM and $0f)]);
    end else begin
     ChannelKeyOff(@fChannels[TPasRISCVUInt32(9)*Bank+(RegM and $0f)]);
    end;
   end;
  end;

  $c0:begin
   if (RegM and $0f)<9 then begin
    WriteChannelRegC0(@fChannels[TPasRISCVUInt32(9)*Bank+(RegM and $0f)],aValue);
   end;
  end;

 end;

end;

procedure TPasRISCV.TFM801Device.TOPL3.GenerateStereo(const aBuffer:PPasRISCVInt16);
var SlotIndex:TPasRISCVUInt32;
    ChannelIndex:TPasRISCVUInt32;
    Channel:POPL3Channel;
    Accumulator:TPasRISCVInt16;
    MixL,MixR:TPasRISCVInt32;
    Shift:TPasRISCVUInt32;
begin

 // Process all 36 operator slots in hardware order
 for SlotIndex:=0 to 35 do begin
  ProcessSlot(@fSlots[SlotIndex]);
 end;

 // Mix all 18 channels to stereo output
 MixL:=0;
 MixR:=0;
 for ChannelIndex:=0 to 17 do begin
  Channel:=@fChannels[ChannelIndex];
  Accumulator:=TPasRISCVInt16(Channel^.fOutputSources[0]^)+TPasRISCVInt16(Channel^.fOutputSources[1]^)+TPasRISCVInt16(Channel^.fOutputSources[2]^)+TPasRISCVInt16(Channel^.fOutputSources[3]^);
  inc(MixL,TPasRISCVInt16(Accumulator and Channel^.fOutputEnableA));
  inc(MixR,TPasRISCVInt16(Accumulator and Channel^.fOutputEnableB));
 end;

 PPasRISCVInt16Array(aBuffer)^[0]:=ClipSample(MixL);
 PPasRISCVInt16Array(aBuffer)^[1]:=ClipSample(MixR);

 // Update tremolo LFO
 if (fTimer and $3f)=$3f then begin
  fTremoloPosition:=(fTremoloPosition+1) mod 210;
 end;
 if fTremoloPosition<105 then begin
  fTremolo:=fTremoloPosition shr fTremoloShift;
 end else begin
  fTremolo:=(210-fTremoloPosition) shr fTremoloShift;
 end;

 // Update vibrato LFO
 if (fTimer and $3ff)=$3ff then begin
  fVibratoPosition:=(fVibratoPosition+1) and 7;
 end;

 // Advance timer
 inc(fTimer);

 // Update envelope generator timer
 if fEnvelopeTimerState<>0 then begin
  Shift:=0;
  while (Shift<13) and (((fEnvelopeTimer shr Shift) and 1)=0) do begin
   inc(Shift);
  end;
  if Shift>12 then begin
   fEnvelopeAdd:=0;
  end else begin
   fEnvelopeAdd:=TPasRISCVUInt8(Shift+1);
  end;
  fEnvelopeTimerLow:=TPasRISCVUInt8(fEnvelopeTimer and $3);
 end;

 if (fEnvelopeTimerRemainder<>0) or (fEnvelopeTimerState<>0) then begin
  if fEnvelopeTimer=TPasRISCVUInt64($fffffffff) then begin
   fEnvelopeTimer:=0;
   fEnvelopeTimerRemainder:=1;
  end else begin
   inc(fEnvelopeTimer);
   fEnvelopeTimerRemainder:=0;
  end;
 end;

 fEnvelopeTimerState:=fEnvelopeTimerState xor 1;

end;

procedure TPasRISCV.TFM801Device.TOPL3.GenerateResampledStereo(const aBuffer:PPasRISCVInt16);
begin

 while fSampleCounter>=fRateRatio do begin
  fOldSamples[0]:=fCurrentSamples[0];
  fOldSamples[1]:=fCurrentSamples[1];
  GenerateStereo(@fCurrentSamples[0]);
  dec(fSampleCounter,fRateRatio);
 end;

 PPasRISCVInt16Array(aBuffer)^[0]:=TPasRISCVInt16((TPasRISCVInt32(fOldSamples[0])*(fRateRatio-fSampleCounter)+TPasRISCVInt32(fCurrentSamples[0])*fSampleCounter) div fRateRatio);
 PPasRISCVInt16Array(aBuffer)^[1]:=TPasRISCVInt16((TPasRISCVInt32(fOldSamples[1])*(fRateRatio-fSampleCounter)+TPasRISCVInt32(fCurrentSamples[1])*fSampleCounter) div fRateRatio);

 inc(fSampleCounter,1 shl OPL3_RSM_FRAC);

end;

procedure TPasRISCV.TFM801Device.TOPL3.GenerateStream(const aBuffer:PPasRISCVInt16;const aCount:TPasRISCVUInt32);
var Index:TPasRISCVUInt32;
    Ptr:PPasRISCVInt16;
begin
 Ptr:=aBuffer;
 for Index:=0 to aCount-1 do begin
  GenerateResampledStereo(Ptr);
  inc(Ptr,2);
 end;
end;

{ TPasRISCV.TFM801Device }

constructor TPasRISCV.TFM801Device.Create(const aBus:TPasRISCV.TPCIBusDevice;const aSoundIO:TSoundIO);
var FuncDesc:TPasRISCV.TPCIFuncDescriptor;
    BARRegion:TPasRISCV.PPCIBARRegion;
begin
 inherited Create(aBus);

 fSoundIO:=aSoundIO;

 FillChar(FuncDesc,SizeOf(TPCIFuncDescriptor),#0);
 FuncDesc.fVendorID:=FM801_VENDOR_ID;
 FuncDesc.fDeviceID:=FM801_DEVICE_ID;
 FuncDesc.fClassCode:=$0401; // Multimedia Controller, Audio Device
 FuncDesc.fProgIF:=$00;
 FuncDesc.fRevisionID:=$b1; // FM801-AU revision (multichannel support flag)
 FuncDesc.fIRQPin:=TPCI.PCI_IRQ_PIN_INTA;

 BARRegion:=@FuncDesc.fBARRegions[0];
{$ifdef NewPCI}
 BARRegion^.fAddress:=0;
{$else}
 BARRegion^.fAddress:=TPCI.PCI_BAR_ADDR_64;
{$endif}
 BARRegion^.fSize:=FM801_BAR_SIZE;
 BARRegion^.fIsIO:=true;
 BARRegion^.fOnLoad:=OnLoad;
 BARRegion^.fOnStore:=OnStore;

 fFuncs[0]:=TPasRISCV.TPCIFunc.Create(aBus,self,FuncDesc);

 Reset;

 // Register our playback and capture callbacks on the shared TSoundIO
 if assigned(fSoundIO) then begin
  fSoundIO.OnOutputFillBuffer:=OutputAudioFillBufferCallback;
  fSoundIO.OnInputFillBuffer:=InputAudioFillBufferCallback;
 end;

end;

destructor TPasRISCV.TFM801Device.Destroy;
begin
 FreeAndNil(fOPL3);
 FreeAndNil(fFuncs[0]);
 inherited Destroy;
end;

procedure TPasRISCV.TFM801Device.Reset;
begin
 inherited Reset;

 // Initialize registers to power-on defaults
 fPCMVol:=$0808;
 fFMVol:=$9f1f;
 fI2SVol:=$8808;
 fRecSrc:=$0000;
 fPlayCtrl:=$0000;
 fPlayCount:=$0000;
 fPlayBuffer1:=$00000000;
 fPlayBuffer2:=$00000000;
 fCaptureCtrl:=$0000;
 fCaptureCount:=$0000;
 fCaptureBuffer1:=$00000000;
 fCaptureBuffer2:=$00000000;
 fCodecCtrl:=$0000;
 fI2SMode:=$0003;
 fVolume:=$0000;
 fAC97Cmd:=$0000;
 fAC97Data:=$0000;
 fGPIOCtrl:=$0000;
 fGenCtrl:=$0000;
 fIRQMask:=$00c3; // mask everything
 fIRQStatus:=$0000;
 fPowerDown:=$0000;

 // OPL3
 FillChar(fOPL3AddressLatch,SizeOf(TOPL3.TOPL3AddressLatch),#0);
 if not assigned(fOPL3) then begin
  fOPL3:=TOPL3.Create;
 end;
 if assigned(fSoundIO) then begin
  fOPL3.DoReset(fSoundIO.fSampleRate);
 end else begin
  fOPL3.DoReset(48000);
 end;

 // AC97 stub - provide a valid codec
 FillChar(fAC97Regs,SizeOf(fAC97Regs),#0);
 fAC97Regs[$00 shr 1]:=$0000; // Reset
 fAC97Regs[$02 shr 1]:=$8000; // Master volume - muted
 fAC97Regs[$04 shr 1]:=$8000; // Aux out volume - muted
 fAC97Regs[$06 shr 1]:=$8000; // Mono volume - muted
 fAC97Regs[$18 shr 1]:=$8808; // PCM out volume
 fAC97Regs[$1c shr 1]:=$8808; // Record gain
 fAC97Regs[$26 shr 1]:=$000f; // Power management - all sections ready
 fAC97Regs[$28 shr 1]:=$0901; // Extended audio ID - VRA, DAC 48kHz
 fAC97Regs[$2a shr 1]:=$0001; // Extended audio status ctrl - VRA enabled
 fAC97Regs[$2c shr 1]:=$bb80; // Front DAC rate - 48000
 fAC97Regs[$7c shr 1]:=$4144; // Vendor ID1 = 'AD' (Analog Devices stub)
 fAC97Regs[$7e shr 1]:=$5348; // Vendor ID2

 // PCM DMA state
 fPlayActive:=false;
 fPlayBufferIndex:=0;
 fPlayBuffer:=0;
 fPlayPosition:=0;
 fPlaySize:=0;
 fPlayScratchBuffer:=nil;
 fPlayResamplerPosition:=0;
 fCaptureActive:=false;
 fCaptureBufferIndex:=0;
 fCaptureBuffer:=0;
 fCapturePosition:=0;
 fCaptureSize:=0;
 fCaptureScratchBuffer:=nil;
 fCaptureResamplerPosition:=0;
end;

function TPasRISCV.TFM801Device.IRQPending:Boolean;
begin
 // IRQ mask register: bit SET = disabled, bit CLEAR = enabled
 // Mask bits are at different positions than status bits:
 //   Mask bit 0 -> Status bit 8 (Playback)
 //   Mask bit 1 -> Status bit 9 (Capture)
 //   Mask bit 6 -> Status bit 14 (Volume)
 //   Mask bit 7 -> Status bit 15 (MPU)
 result:=(((fIRQMask and FM801_IRQ_MASK_PLAYBACK)=0) and ((fIRQStatus and FM801_IRQ_PLAYBACK)<>0)) or
         (((fIRQMask and FM801_IRQ_MASK_CAPTURE)=0) and ((fIRQStatus and FM801_IRQ_CAPTURE)<>0)) or
         (((fIRQMask and FM801_IRQ_MASK_VOLUME)=0) and ((fIRQStatus and FM801_IRQ_VOLUME)<>0)) or
         (((fIRQMask and FM801_IRQ_MASK_MPU)=0) and ((fIRQStatus and FM801_IRQ_MPU)<>0));
end;

function TPasRISCV.TFM801Device.OnLoad(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Offset:TPasRISCVUInt16;
begin
 Offset:=TPasRISCVUInt16(aAddress and $7f);
 result:=0;
 case Offset of
  FM801_PCM_VOL:begin
   result:=fPCMVol;
  end;
  FM801_FM_VOL:begin
   result:=fFMVol;
  end;
  FM801_I2S_VOL:begin
   result:=fI2SVol;
  end;
  FM801_REC_SRC:begin
   result:=fRecSrc;
  end;
  FM801_PLAY_CTRL:begin
   result:=fPlayCtrl;
  end;
  FM801_PLAY_COUNT:begin
   // Hardware counts down from (period_bytes-1) to 0; return remaining bytes in current period
   if fPlayActive and (fPlaySize>0) and (fPlayPosition<fPlaySize) then begin
    result:=TPasRISCVUInt16((fPlaySize-fPlayPosition)-1);
   end else begin
    result:=fPlayCount;
   end;
  end;
  FM801_PLAY_BUF1:begin
   result:=fPlayBuffer1;
  end;
  FM801_PLAY_BUF2:begin
   result:=fPlayBuffer2;
  end;
  FM801_CAPTURE_CTRL:begin
   result:=fCaptureCtrl;
  end;
  FM801_CAPTURE_COUNT:begin
   // Hardware counts down from (period_bytes-1) to 0; return remaining bytes in current period
   if fCaptureActive and (fCaptureSize>0) and (fCapturePosition<fCaptureSize) then begin
    result:=TPasRISCVUInt16((fCaptureSize-fCapturePosition)-1);
   end else begin
    result:=fCaptureCount;
   end;
  end;
  FM801_CAPTURE_BUF1:begin
   result:=fCaptureBuffer1;
  end;
  FM801_CAPTURE_BUF2:begin
   result:=fCaptureBuffer2;
  end;
  FM801_CODEC_CTRL:begin
   result:=fCodecCtrl;
  end;
  FM801_I2S_MODE:begin
   result:=fI2SMode;
  end;
  FM801_VOLUME:begin
   result:=fVolume;
  end;
  FM801_AC97_CMD:begin
   // Return valid + not busy
   result:=fAC97Cmd or FM801_AC97_VALID;
   result:=result and (not FM801_AC97_BUSY);
  end;
  FM801_AC97_DATA:begin
   result:=fAC97Data;
  end;
  FM801_MPU401_DATA:begin
   result:=$fe; // No data available
  end;
  FM801_MPU401_CMD:begin
   result:=$80; // Output ready, input not ready
  end;
  FM801_GPIO_CTRL:begin
   result:=fGPIOCtrl;
  end;
  FM801_GEN_CTRL:begin
   result:=fGenCtrl;
  end;
  FM801_IRQ_MASK:begin
   result:=fIRQMask;
  end;
  FM801_IRQ_STATUS:begin
   result:=fIRQStatus;
  end;
  FM801_OPL3_BANK0:begin
   // OPL3 Status register read (timer flags)
   result:=$00; // No timer emulation, always report ready
  end;
  FM801_OPL3_BANK1:begin
   result:=$00;
  end;
  FM801_POWERDOWN:begin
   result:=fPowerDown;
  end;
 end;
end;

procedure TPasRISCV.TFM801Device.OnStore(const aPCIMemoryDevice:TPasRISCV.TPCIMemoryDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Offset:TPasRISCVUInt16;
    AC97Reg:TPasRISCVUInt8;
begin
 Offset:=TPasRISCVUInt16(aAddress and $7f);
 case Offset of
  FM801_PCM_VOL:begin
   fPCMVol:=TPasRISCVUInt16(aValue);
  end;
  FM801_FM_VOL:begin
   fFMVol:=TPasRISCVUInt16(aValue);
  end;
  FM801_I2S_VOL:begin
   fI2SVol:=TPasRISCVUInt16(aValue);
  end;
  FM801_REC_SRC:begin
   fRecSrc:=TPasRISCVUInt16(aValue);
  end;
  FM801_PLAY_CTRL:begin
   fPlayCtrl:=TPasRISCVUInt16(aValue);
   if (fPlayCtrl and FM801_START)<>0 then begin
    // START takes priority - the Linux driver sets both START and IMMED_STOP
    // simultaneously to mean "stop current playback immediately and restart fresh"
    if (not fPlayActive) or ((fPlayCtrl and FM801_IMMED_STOP)<>0) then begin
     // Starting or restarting playback - set up DMA from buf1
     fPlayBufferIndex:=0;
     fPlayBuffer:=fPlayBuffer1;
     fPlayPosition:=0;
     fPlaySize:=TPasRISCVUInt32(fPlayCount)+1; // count register = period_bytes - 1
     fPlayResamplerPosition:=0;
    end;
    fPlayActive:=true;
    fPlayCtrl:=fPlayCtrl and (not FM801_IMMED_STOP); // clear IMMED_STOP after handling
   end else if (fPlayCtrl and FM801_IMMED_STOP)<>0 then begin
    fPlayActive:=false;
    fPlayCtrl:=fPlayCtrl and (not (FM801_START or FM801_PAUSE or FM801_IMMED_STOP));
   end else begin
    fPlayActive:=false;
   end;
  end;
  FM801_PLAY_COUNT:begin
   fPlayCount:=TPasRISCVUInt16(aValue);
  end;
  FM801_PLAY_BUF1:begin
   fPlayBuffer1:=TPasRISCVUInt32(aValue);
  end;
  FM801_PLAY_BUF2:begin
   fPlayBuffer2:=TPasRISCVUInt32(aValue);
  end;
  FM801_CAPTURE_CTRL:begin
   fCaptureCtrl:=TPasRISCVUInt16(aValue);
   if (fCaptureCtrl and FM801_START)<>0 then begin
    // START takes priority over IMMED_STOP (same as playback)
    if (not fCaptureActive) or ((fCaptureCtrl and FM801_IMMED_STOP)<>0) then begin
     fCaptureBufferIndex:=0;
     fCaptureBuffer:=fCaptureBuffer1;
     fCapturePosition:=0;
     fCaptureSize:=TPasRISCVUInt32(fCaptureCount)+1; // count register = period_bytes - 1
     fCaptureResamplerPosition:=0;
    end;
    fCaptureActive:=true;
    fCaptureCtrl:=fCaptureCtrl and (not FM801_IMMED_STOP);
   end else if (fCaptureCtrl and FM801_IMMED_STOP)<>0 then begin
    fCaptureActive:=false;
    fCaptureCtrl:=fCaptureCtrl and (not (FM801_START or FM801_PAUSE or FM801_IMMED_STOP));
   end else begin
    fCaptureActive:=false;
   end;
  end;
  FM801_CAPTURE_COUNT:begin
   fCaptureCount:=TPasRISCVUInt16(aValue);
  end;
  FM801_CAPTURE_BUF1:begin
   fCaptureBuffer1:=TPasRISCVUInt32(aValue);
  end;
  FM801_CAPTURE_BUF2:begin
   fCaptureBuffer2:=TPasRISCVUInt32(aValue);
  end;
  FM801_CODEC_CTRL:begin
   fCodecCtrl:=TPasRISCVUInt16(aValue);
  end;
  FM801_I2S_MODE:begin
   fI2SMode:=TPasRISCVUInt16(aValue);
  end;
  FM801_AC97_CMD:begin
   fAC97Cmd:=TPasRISCVUInt16(aValue);
   AC97Reg:=TPasRISCVUInt8(fAC97Cmd and $7f);
   if (fAC97Cmd and FM801_AC97_READ)<>0 then begin
    // AC97 Read
    if (AC97Reg shr 1)<=High(fAC97Regs) then begin
     fAC97Data:=fAC97Regs[AC97Reg shr 1];
    end else begin
     fAC97Data:=$0000;
    end;
   end else begin
    // AC97 Write
    if (AC97Reg shr 1)<=High(fAC97Regs) then begin
     fAC97Regs[AC97Reg shr 1]:=TPasRISCVUInt16(fAC97Data);
    end;
   end;
  end;
  FM801_AC97_DATA:begin
   fAC97Data:=TPasRISCVUInt16(aValue);
  end;
  FM801_MPU401_DATA:begin
   // MPU-401 data write (stub)
  end;
  FM801_MPU401_CMD:begin
   // MPU-401 command write (stub)
  end;
  FM801_GPIO_CTRL:begin
   fGPIOCtrl:=TPasRISCVUInt16(aValue);
  end;
  FM801_GEN_CTRL:begin 
   fGenCtrl:=TPasRISCVUInt16(aValue);
  end;
  FM801_IRQ_MASK:begin
   fIRQMask:=TPasRISCVUInt16(aValue);
   // Check if any unmasked IRQ sources are still pending; if not, lower the line
   if not IRQPending then begin
    LowerIRQ(0);
   end;
  end;
  FM801_IRQ_STATUS:begin
   // Writing to IRQ_STATUS acknowledges (clears) bits
   fIRQStatus:=fIRQStatus and (not TPasRISCVUInt16(aValue));
   // Level-triggered PCI IRQ: lower the IRQ line when no unmasked IRQ sources remain pending
   if not IRQPending then begin
    LowerIRQ(0);
   end;
  end;
  FM801_OPL3_BANK0:begin
   // OPL3 address latch bank 0
   fOPL3AddressLatch[0]:=TPasRISCVUInt8(aValue);
  end;
  FM801_OPL3_DATA0:begin
   // OPL3 data write bank 0
   if assigned(fOPL3) then begin
    fOPL3.WriteRegister(TPasRISCVUInt16(fOPL3AddressLatch[0]),TPasRISCVUInt8(aValue));
   end;
  end;
  FM801_OPL3_BANK1:begin
   // OPL3 address latch bank 1
   fOPL3AddressLatch[1]:=TPasRISCVUInt8(aValue);
  end;
  FM801_OPL3_DATA1:begin
   // OPL3 data write bank 1
   if assigned(fOPL3) then begin
    fOPL3.WriteRegister(TPasRISCVUInt16($100) or TPasRISCVUInt16(fOPL3AddressLatch[1]),TPasRISCVUInt8(aValue));
   end;
  end;
  FM801_POWERDOWN:begin
   fPowerDown:=TPasRISCVUInt16(aValue);
  end;
 end;
end;

procedure TPasRISCV.TFM801Device.OutputAudioFillBufferCallback(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
var Remain,ToDo,CopyBytes,SampleFrameSize,Channels:TPasRISCVSizeInt;
    Dest:PPasRISCVUInt8;
    SrcPtr:Pointer;
    Is16Bit,IsStereo:Boolean;
    SrcRate,DstRate:TPasRISCVUInt64;
    RateIndex:TPasRISCVUInt32;
    FloatSample:TPasRISCVFloat;
    SampleIndex:TPasRISCVSizeInt;
    Sample16:TPasRISCVInt16;
    Sample8:TPasRISCVUInt8;
    SrcSamples,DstSamples:TPasRISCVSizeInt;
    p:PPasRISCVUInt8;
    OPL3Buf:array[0..1] of TPasRISCVInt16;
    OPL3Index:TPasRISCVSizeInt;
    OPL3FloatDest:PPasRISCVFloatArray;
begin

 // Output format: aCount stereo float frames = aCount * 2 * SizeOf(Float) bytes
 Remain:=aCount*2*SizeOf(TPasRISCVFloat);
 FillChar(aBuffer^,Remain,#0);

 // Generate OPL3 FM synthesis audio (always active, even without PCM playback)
 if assigned(fOPL3) then begin
  OPL3FloatDest:=PPasRISCVFloatArray(aBuffer);
  for OPL3Index:=0 to aCount-1 do begin
   fOPL3.GenerateResampledStereo(@OPL3Buf[0]);
   OPL3FloatDest^[OPL3Index*2]:=OPL3FloatDest^[OPL3Index*2]+(OPL3Buf[0]/32768.0);
   OPL3FloatDest^[(OPL3Index*2)+1]:=OPL3FloatDest^[(OPL3Index*2)+1]+(OPL3Buf[1]/32768.0);
  end;
 end;

 if (not fPlayActive) or ((fPlayCtrl and FM801_PAUSE)<>0) then begin
  exit;
 end;

 Is16Bit:=(fPlayCtrl and FM801_16BIT)<>0;
 IsStereo:=(fPlayCtrl and FM801_STEREO)<>0;

 if IsStereo then begin
  Channels:=2;
 end else begin
  Channels:=1;
 end;

 if Is16Bit then begin
  SampleFrameSize:=Channels*2; // bytes per frame
 end else begin
  SampleFrameSize:=Channels; // bytes per frame
 end;

 RateIndex:=(fPlayCtrl and FM801_RATE_MASK) shr FM801_RATE_SHIFT;
 if RateIndex>High(FM801_RATES) then begin
  RateIndex:=High(FM801_RATES);
 end;
 SrcRate:=FM801_RATES[RateIndex];
 DstRate:=fSoundIO.fSampleRate;

 Dest:=aBuffer;

 while Remain>0 do begin

  if fPlayPosition>=fPlaySize then begin
   // Current buffer exhausted - fire IRQ and switch to next buffer
   fIRQStatus:=fIRQStatus or FM801_IRQ_PLAYBACK;
   if (fIRQMask and FM801_IRQ_MASK_PLAYBACK)=0 then begin
    RaiseIRQ(0,0);
   end;
   // Ping-pong: switch buffers
   if fPlayBufferIndex=0 then begin
    fPlayBufferIndex:=1;
    fPlayBuffer:=fPlayBuffer2;
   end else begin
    fPlayBufferIndex:=0;
    fPlayBuffer:=fPlayBuffer1;
   end;
   fPlayPosition:=0;
   fPlaySize:=TPasRISCVUInt32(fPlayCount)+1; // count register = period_bytes - 1
   // Check BUF_LAST flags - if set, stop after this buffer
   if fPlayBufferIndex=0 then begin
    if (fPlayCtrl and FM801_BUFFER1_LAST)<>0 then begin
     fPlayActive:=false;
     exit;
    end;
   end else begin
    if (fPlayCtrl and FM801_BUFFER2_LAST)<>0 then begin
     fPlayActive:=false;
     exit;
    end;
   end;
  end;

  // Calculate how many source frames we can read from the current DMA buffer
  ToDo:=fPlaySize-fPlayPosition;
  if ToDo<=0 then begin
   break;
  end;

  // How many source frames available?
  SrcSamples:=ToDo div SampleFrameSize;
  if SrcSamples<=0 then begin
   break;
  end;

  // How many destination frames do we still need?
  DstSamples:=Remain div (2*SizeOf(TPasRISCVFloat));
  if DstSamples<=0 then begin
   break;
  end;

  // Limit source samples to what we need (simple 1:1 for now, ignoring resampling for count limiting)
  if SrcRate=DstRate then begin
   if SrcSamples>DstSamples then begin
    SrcSamples:=DstSamples;
   end;
  end else begin
   // Estimate source samples needed for DstSamples output
   ToDo:=TPasRISCVSizeInt(ConvertScale(DstSamples,DstRate,SrcRate))+1;
   if SrcSamples>ToDo then begin
    SrcSamples:=ToDo;
   end;
  end;

  CopyBytes:=SrcSamples*SampleFrameSize;

  // DMA: read from guest physical memory
  SrcPtr:=GetGlobalDirectMemoryAccessPointer(TPasRISCVUInt64(fPlayBuffer)+fPlayPosition,CopyBytes,false,nil);
  if SrcPtr=nil then begin
   // Can't access guest memory - fill silence and advance
   inc(fPlayPosition,CopyBytes);
   break;
  end;

  // Ensure scratch buffer is large enough (stereo float output)
  if length(fPlayScratchBuffer)<(SrcSamples*2) then begin
   SetLength(fPlayScratchBuffer,SrcSamples*4);
  end;

  // Convert source samples to stereo float
  p:=SrcPtr;
  for SampleIndex:=0 to SrcSamples-1 do begin
   if Is16Bit then begin
    // Left channel
    Sample16:=TPasRISCVInt16(PPasRISCVUInt8Array(p)^[0] or (TPasRISCVUInt16(PPasRISCVUInt8Array(p)^[1]) shl 8));
    inc(p,2);
    FloatSample:=Sample16/32768.0;
    fPlayScratchBuffer[SampleIndex*2]:=FloatSample;
    // Right channel
    if IsStereo then begin
     Sample16:=TPasRISCVInt16(PPasRISCVUInt8Array(p)^[0] or (TPasRISCVUInt16(PPasRISCVUInt8Array(p)^[1]) shl 8));
     inc(p,2);
     FloatSample:=Sample16/32768.0;
     fPlayScratchBuffer[(SampleIndex*2)+1]:=FloatSample;
    end else begin
     fPlayScratchBuffer[(SampleIndex*2)+1]:=fPlayScratchBuffer[SampleIndex*2];
    end;
   end else begin
    // 8-bit unsigned
    Sample8:=p^;
    inc(p);
    FloatSample:=(Sample8-128)/128.0;
    fPlayScratchBuffer[SampleIndex*2]:=FloatSample;
    if IsStereo then begin
     Sample8:=p^;
     inc(p);
     FloatSample:=(Sample8-128)/128.0;
     fPlayScratchBuffer[(SampleIndex*2)+1]:=FloatSample;
    end else begin
     fPlayScratchBuffer[(SampleIndex*2)+1]:=fPlayScratchBuffer[SampleIndex*2];
    end;
   end;
  end;

  inc(fPlayPosition,CopyBytes);

  // Copy to output (no resampling if rates match)
  if SrcRate=DstRate then begin
   CopyBytes:=SrcSamples*2*SizeOf(TPasRISCVFloat);
   if CopyBytes>Remain then begin
    CopyBytes:=Remain;
   end;
   Move(fPlayScratchBuffer[0],Dest^,CopyBytes);
   inc(Dest,CopyBytes);
   dec(Remain,CopyBytes);
  end else begin
   // Simple linear resampling
   DstSamples:=Remain div (2*SizeOf(TPasRISCVFloat));
   ToDo:=TPasRISCVSizeInt(ConvertScale(SrcSamples,SrcRate,DstRate));
   if ToDo>DstSamples then begin
    ToDo:=DstSamples;
   end;
   if ToDo>0 then begin
    ResampleLinear(@fPlayScratchBuffer[0],
                   SrcSamples,
                   PPasRISCVFloatArray(Dest),
                   ToDo,
                   2,
                   nil,
                   fPlayResamplerPosition,
                   ConvertScale(TPasRISCVUInt64($100000000),DstRate,SrcRate));
    CopyBytes:=ToDo*2*SizeOf(TPasRISCVFloat);
    inc(Dest,CopyBytes);
    dec(Remain,CopyBytes);
   end;
  end;

 end;

end;

procedure TPasRISCV.TFM801Device.InputAudioFillBufferCallback(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
var Remain,ToDo,CopyBytes,SampleFrameSize,Channels:TPasRISCVSizeInt;
    Src:PPasRISCVUInt8;
    DstPtr:Pointer;
    Is16Bit,IsStereo:Boolean;
    SrcRate,DstRate:TPasRISCVUInt64;
    RateIndex:TPasRISCVUInt32;
    FloatSample:TPasRISCVFloat;
    SampleIndex:TPasRISCVSizeInt;
    p:PPasRISCVUInt8;
    SrcSamples,DstSamples:TPasRISCVSizeInt;
    Sample16:TPasRISCVInt16;
begin

 // Input: aCount stereo float frames = aCount * 2 * SizeOf(Float) bytes from host
 Remain:=aCount*2*SizeOf(TPasRISCVFloat);

 if (not fCaptureActive) or ((fCaptureCtrl and FM801_PAUSE)<>0) then begin
  exit;
 end;

 Is16Bit:=(fCaptureCtrl and FM801_16BIT)<>0;
 IsStereo:=(fCaptureCtrl and FM801_STEREO)<>0;

 if IsStereo then begin
  Channels:=2;
 end else begin
  Channels:=1;
 end;

 if Is16Bit then begin
  SampleFrameSize:=Channels*2;
 end else begin
  SampleFrameSize:=Channels;
 end;

 RateIndex:=(fCaptureCtrl and FM801_RATE_MASK) shr FM801_RATE_SHIFT;
 if RateIndex>High(FM801_RATES) then begin
  RateIndex:=High(FM801_RATES);
 end;
 DstRate:=FM801_RATES[RateIndex]; // guest rate
 SrcRate:=fSoundIO.fSampleRate;   // host rate

 Src:=aBuffer;

 while Remain>0 do begin

  if fCapturePosition>=fCaptureSize then begin
   // Current buffer full - fire IRQ and switch to next buffer
   fIRQStatus:=fIRQStatus or FM801_IRQ_CAPTURE;
   if (fIRQMask and FM801_IRQ_MASK_CAPTURE)=0 then begin
    RaiseIRQ(0,0);
   end;
   // Ping-pong
   if fCaptureBufferIndex=0 then begin
    fCaptureBufferIndex:=1;
    fCaptureBuffer:=fCaptureBuffer2;
   end else begin
    fCaptureBufferIndex:=0;
    fCaptureBuffer:=fCaptureBuffer1;
   end;
   fCapturePosition:=0;
   fCaptureSize:=TPasRISCVUInt32(fCaptureCount)+1; // count register = period_bytes - 1
   // Check BUFFER_LAST flags
   if fCaptureBufferIndex=0 then begin
    if (fCaptureCtrl and FM801_BUFFER1_LAST)<>0 then begin
     fCaptureActive:=false;
     exit;
    end;
   end else begin
    if (fCaptureCtrl and FM801_BUFFER2_LAST)<>0 then begin
     fCaptureActive:=false;
     exit;
    end;
   end;
  end;

  // How many host float frames are available?
  SrcSamples:=Remain div (2*SizeOf(TPasRISCVFloat));
  if SrcSamples<=0 then begin
   break;
  end;

  // How many guest frames fit in the remaining DMA buffer?
  DstSamples:=(fCaptureSize-fCapturePosition) div SampleFrameSize;
  if DstSamples<=0 then begin
   break;
  end;

  // Determine how many source frames to consume
  if SrcRate=DstRate then begin
   if SrcSamples>DstSamples then begin
    SrcSamples:=DstSamples;
   end;
  end else begin
   // Estimate source frames needed
   ToDo:=TPasRISCVSizeInt(ConvertScale(DstSamples,DstRate,SrcRate))+1;
   if SrcSamples>ToDo then begin
    SrcSamples:=ToDo;
   end;
  end;

  // Copy host float data into scratch buffer
  if length(fCaptureScratchBuffer)<(SrcSamples*2) then begin
   SetLength(fCaptureScratchBuffer,SrcSamples*4);
  end;

  CopyBytes:=SrcSamples*2*SizeOf(TPasRISCVFloat);
  Move(Src^,fCaptureScratchBuffer[0],CopyBytes);
  inc(Src,CopyBytes);
  dec(Remain,CopyBytes);

  // TODO: resample if SrcRate<>DstRate (for now, 1:1 only)
  // After resampling, SrcSamples would change to DstSamples

  // Get DMA pointer to guest memory
  CopyBytes:=SrcSamples*SampleFrameSize;
  ToDo:=fCaptureSize-fCapturePosition;
  if CopyBytes>ToDo then begin
   CopyBytes:=ToDo;
   SrcSamples:=CopyBytes div SampleFrameSize;
  end;

  DstPtr:=GetGlobalDirectMemoryAccessPointer(TPasRISCVUInt64(fCaptureBuffer)+fCapturePosition,CopyBytes,true,nil);
  if DstPtr=nil then begin
   inc(fCapturePosition,CopyBytes);
   break;
  end;

  // Convert stereo float to guest format and write to DMA buffer
  p:=DstPtr;
  for SampleIndex:=0 to SrcSamples-1 do begin
   // Left channel (or mono)
   FloatSample:=fCaptureScratchBuffer[SampleIndex*2];
   if FloatSample>1.0 then begin
    FloatSample:=1.0;
   end else if FloatSample<-1.0 then begin
    FloatSample:=-1.0;
   end;
   if Is16Bit then begin
    Sample16:=TPasRISCVInt16(Trunc(FloatSample*32767.0));
    p^:=TPasRISCVUInt8(Sample16 and $ff);
    inc(p);
    p^:=TPasRISCVUInt8((Sample16 shr 8) and $ff);
    inc(p);
   end else begin
    p^:=TPasRISCVUInt8(Trunc((FloatSample*128.0)+128.0));
    inc(p);
   end;
   // Right channel (if stereo)
   if IsStereo then begin
    FloatSample:=fCaptureScratchBuffer[(SampleIndex*2)+1];
    if FloatSample>1.0 then begin
     FloatSample:=1.0;
    end else if FloatSample<-1.0 then begin
     FloatSample:=-1.0;
    end;
    if Is16Bit then begin
     Sample16:=TPasRISCVInt16(Trunc(FloatSample*32767.0));
     p^:=TPasRISCVUInt8(Sample16 and $ff);
     inc(p);
     p^:=TPasRISCVUInt8((Sample16 shr 8) and $ff);
     inc(p);
    end else begin
     p^:=TPasRISCVUInt8(Trunc((FloatSample*128.0)+128.0));
     inc(p);
    end;
   end;
  end;

  inc(fCapturePosition,SrcSamples*SampleFrameSize);

 end;

end;

{ TPasRISCV.TVirtIODevice }

constructor TPasRISCV.TVirtIODevice.Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64;const aKind:TVirtIODevice.TKind);
var Index:TPasRISCVSizeInt;
    Queue:PQueue;
begin
 inherited Create(aMachine,aBase,aSize);
 fKind:=aKind;
 fUseQueueDescriptorCaching:=false;
 fIRQ:=0;
 fIntStatus:=0;
 fStatus:=0;
 fDriverOK:=false;
 fDeviceFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1 or
                  //TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX or
                  0;
 fDriverFeatures:=0;
 fActiveFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1;
 fDeviceFeaturesSelected:=0;
 fDriverFeaturesSelected:=0;
 fSelectedQueue:=0;
 for Index:=0 to MAXIMUM_COUNT_QUEUES-1 do begin
  Queue:=@fQueues[Index];
  Queue^.Ready:=false;
  Queue^.Lock:=0;
  Queue^.Size:=MAXIMUM_QUEUE_SIZE;
  Queue^.UsedRingEvent:=false;
  Queue^.ShadowAvailableIndex:=0;
  Queue^.ShadowUsedIndex:=0;
  Queue^.DescriptorAddress:=0;
  Queue^.AvailableAddress:=0;
  Queue^.UsedAddress:=0;
  Queue^.ManualRecv:=false;
  Queue^.Asynchronous:=false;
  Queue^.ReadDescriptors:=nil;
  Queue^.WriteDescriptors:=nil;
  Queue^.CountReadDescriptors:=0;
  Queue^.CountWriteDescriptors:=0;
 end;
 fDeviceID:=0;
 fVendorID:=$ffff;
 fConfigSpaceSize:=0;
 FillChar(fConfigSpace,SizeOf(fConfigSpace),#0);
 DeviceReset;
end;

destructor TPasRISCV.TVirtIODevice.Destroy;
var Index:TPasRISCVSizeInt;
    Queue:PQueue;
begin
 for Index:=0 to MAXIMUM_COUNT_QUEUES-1 do begin
  Queue:=@fQueues[Index];
  Queue^.ReadDescriptors:=nil;
  Queue^.WriteDescriptors:=nil;
 end;
 inherited Destroy;
end;

procedure TPasRISCV.TVirtIODevice.DeviceReset;
var Index:TPasRISCVSizeInt;
    Queue:PQueue;
begin
 fDriverOK:=false;
 fStatus:=0;
 fSelectedQueue:=0;
 fActiveFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1;
 fDeviceFeaturesSelected:=0;
 fDriverFeaturesSelected:=0;
 TPasMPInterlocked.Write(fIntStatus,0);
 UpdateIRQ;
 for Index:=0 to MAXIMUM_COUNT_QUEUES-1 do begin
  Queue:=@fQueues[Index];
  Queue^.Ready:=false;
  Queue^.Size:=MAXIMUM_QUEUE_SIZE;
  Queue^.ShadowAvailableIndex:=0;
  Queue^.ShadowUsedIndex:=0;
  Queue^.UsedRingEvent:=false;
  Queue^.DescriptorAddress:=0;
  Queue^.AvailableAddress:=0;
  Queue^.UsedAddress:=0;
 end;
end;

procedure TPasRISCV.TVirtIODevice.DeviceDriverOK;
begin
end;

procedure TPasRISCV.TVirtIODevice.DeviceConfigWrite;
begin
end;

procedure TPasRISCV.TVirtIODevice.DeviceInitialize;
begin
end;

function TPasRISCV.TVirtIODevice.DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean;
begin
 result:=false;
end;

function TPasRISCV.TVirtIODevice.Read8(const aPhysicalAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt8):Boolean;
var p:Pointer;
begin
 p:=GetGlobalDirectMemoryAccessPointer(aPhysicalAddress,SizeOf(TPasRISCVUInt8),false,nil);
 result:=assigned(p);
 if result then begin
  aValue:=PPasRISCVUInt8(p)^;
 end else begin
  aValue:=0;
 end;
end;

function TPasRISCV.TVirtIODevice.Write8(const aPhysicalAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt8):Boolean;
var p:Pointer;
begin
 p:=GetGlobalDirectMemoryAccessPointer(aPhysicalAddress,SizeOf(TPasRISCVUInt8),true,nil);
 result:=assigned(p);
 if result then begin
  PPasRISCVUInt8(p)^:=aValue;
 end;
end;

function TPasRISCV.TVirtIODevice.Read16(const aPhysicalAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt16):Boolean;
var p:Pointer;
begin
 result:=false;
 if (aPhysicalAddress and 1)<>0 then begin
  aValue:=0;
 end else begin
  p:=GetGlobalDirectMemoryAccessPointer(aPhysicalAddress,SizeOf(TPasRISCVUInt16),false,nil);
  if assigned(p) then begin
   aValue:=PPasRISCVUInt16(p)^;
   result:=true;
  end else begin
   aValue:=0;
  end;
 end;
end;

function TPasRISCV.TVirtIODevice.Write16(const aPhysicalAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt16):Boolean;
var p:Pointer;
begin
 result:=false;
 if (aPhysicalAddress and 1)=0 then begin
  p:=GetGlobalDirectMemoryAccessPointer(aPhysicalAddress,SizeOf(TPasRISCVUInt16),true,nil);
  if assigned(p) then begin
   PPasRISCVUInt16(p)^:=aValue;
   result:=true;
  end;
 end;
end;

function TPasRISCV.TVirtIODevice.Read32(const aPhysicalAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt32):Boolean;
var p:Pointer;
begin
 result:=false;
 if (aPhysicalAddress and 3)<>0 then begin
  aValue:=0;
 end else begin
  p:=GetGlobalDirectMemoryAccessPointer(aPhysicalAddress,SizeOf(TPasRISCVUInt32),false,nil);
  if assigned(p) then begin
   aValue:=PPasRISCVUInt32(p)^;
   result:=true;
  end else begin
   aValue:=0;
  end;
 end;
end;

function TPasRISCV.TVirtIODevice.Write32(const aPhysicalAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt32):Boolean;
var p:Pointer;
begin
 result:=false;
 if (aPhysicalAddress and 3)=0 then begin
  p:=GetGlobalDirectMemoryAccessPointer(aPhysicalAddress,SizeOf(TPasRISCVUInt32),true,nil);
  if assigned(p) then begin
   PPasRISCVUInt32(p)^:=aValue;
   result:=true;
  end;
 end;
end;

function TPasRISCV.TVirtIODevice.Read64(const aPhysicalAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt64):Boolean;
var p:Pointer;
begin
 result:=false;
 if (aPhysicalAddress and 7)<>0 then begin
  aValue:=0;
 end else begin
  p:=GetGlobalDirectMemoryAccessPointer(aPhysicalAddress,SizeOf(TPasRISCVUInt64),false,nil);
  if assigned(p) then begin
   aValue:=PPasRISCVUInt64(p)^;
   result:=true;
  end else begin
   aValue:=0;
  end;
 end;
end;

function TPasRISCV.TVirtIODevice.Write64(const aPhysicalAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64):Boolean;
var p:Pointer;
begin
 result:=false;
 if (aPhysicalAddress and 7)=0 then begin
  p:=GetGlobalDirectMemoryAccessPointer(aPhysicalAddress,SizeOf(TPasRISCVUInt64),true,nil);
  if assigned(p) then begin
   PPasRISCVUInt64(p)^:=aValue;
   result:=true;
  end;
 end;
end;

function TPasRISCV.TVirtIODevice.CopyMemoryFromRAM(const aBuf:Pointer;const aPhysicalAddress:TPasRISCVUInt64;const aCount:TPasRISCVUInt64):Boolean;
var p,Buf:PPasRISCVUInt8;
    Len,Count:TPasRISCVUInt64;
    PhysicalAddress:TPasRISCVUInt64;
begin
 Count:=aCount;
 PhysicalAddress:=aPhysicalAddress;
 Buf:=aBuf;
 while Count>0 do begin
  Len:=VIRTIO_PAGE_SIZE-(PhysicalAddress and (VIRTIO_PAGE_SIZE-1));
  if Len>Count then begin
   Len:=Count;
  end;
  p:=GetGlobalDirectMemoryAccessPointer(PhysicalAddress,Len,false,nil);
  if assigned(p) then begin
   Move(p^,Buf^,Len);
   inc(PhysicalAddress,Len);
   inc(Buf,Len);
   dec(Count,Len);
  end else begin
   result:=false;
   exit;
  end;
 end;
 result:=true;
end;

function TPasRISCV.TVirtIODevice.CopyMemoryToRAM(const aPhysicalAddress:TPasRISCVUInt64;const aBuf:Pointer;const aCount:TPasRISCVUInt64):Boolean;
var p,Buf:PPasRISCVUInt8;
    Len,Count:TPasRISCVUInt64;
    PhysicalAddress:TPasRISCVUInt64;
begin
 Count:=aCount;
 PhysicalAddress:=aPhysicalAddress;
 Buf:=aBuf;
 while Count>0 do begin
  Len:=VIRTIO_PAGE_SIZE-(PhysicalAddress and (VIRTIO_PAGE_SIZE-1));
  if Len>Count then begin
   Len:=Count;
  end;
  p:=GetGlobalDirectMemoryAccessPointer(PhysicalAddress,Len,true,nil);
  if assigned(p) then begin
   Move(Buf^,p^,Len);
   inc(PhysicalAddress,Len);
   inc(Buf,Len);
   dec(Count,Len);
  end else begin
   result:=false;
   exit;
  end;
 end;
 result:=true;
end;

function TPasRISCV.TVirtIODevice.GetDescriptor(const aDescriptor:PVirtIODescriptor;const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64):Boolean;
var QueueState:PQueue;
begin
 QueueState:=@fQueues[aQueueIndex];
 result:=CopyMemoryFromRAM(aDescriptor,QueueState^.DescriptorAddress+(aDescriptorIndex*SizeOf(TVirtIODescriptor)),SizeOf(TVirtIODescriptor));
end;

function TPasRISCV.TVirtIODevice.CopyMemoryFromToQueue(const aBuf:Pointer;const aQueueIndex,aDescriptorIndex,aOffset,aCount:TPasRISCVUInt64;const aToQueue:Boolean):Boolean;
var Descriptor:TVirtIODescriptor;
    Len,WriteFlag,Count,Offset,QueueIndex,DescriptorIndex,NextDescriptorIndex:TPasRISCVUInt64;
    Buf:PPasRISCVUInt8;
begin

 Count:=aCount;

 Offset:=aOffset;

 QueueIndex:=aQueueIndex;

 DescriptorIndex:=aDescriptorIndex;

 Buf:=aBuf;

 if Count=0 then begin
  result:=true;
  exit;
 end;

 if not GetDescriptor(@Descriptor,QueueIndex,DescriptorIndex) then begin
  result:=false;
  exit;
 end;

 if aToQueue then begin

  WriteFlag:=VRING_DESC_F_WRITE;

  // Find the first write descriptor
  repeat
   if (Descriptor.Flags and VRING_DESC_F_WRITE)=WriteFlag then begin
    break;
   end;
   if (Descriptor.Flags and VRING_DESC_F_NEXT)=0 then begin
    result:=false;
    exit;
   end;
   DescriptorIndex:=Descriptor.Next;
   if not GetDescriptor(@Descriptor,QueueIndex,DescriptorIndex) then begin
    result:=false;
    exit;
   end;
  until false;
 end else begin
  WriteFlag:=0;
 end;

 // Find the descriptor at offset
 repeat
  if (Descriptor.Flags and VRING_DESC_F_WRITE)<>WriteFlag then begin
   result:=false;
   exit;
  end;
  if Offset>=Descriptor.Len then begin
   if (Descriptor.Flags and VRING_DESC_F_NEXT)=0 then begin
    result:=false;
    exit;
   end;
   DescriptorIndex:=Descriptor.Next;
   dec(Offset,Descriptor.Len);
   if not GetDescriptor(@Descriptor,QueueIndex,DescriptorIndex) then begin
    result:=false;
    exit;
   end;
  end else begin
   break;
  end;
 until false;

 // Copy data
 repeat
  if Offset<Descriptor.Len then begin
   Len:=Descriptor.Len-Offset;
  end else begin
   Len:=0;
  end;
  if Len>Count then begin
   Len:=Count;
  end;
  if aToQueue then begin
   CopyMemoryToRAM(Descriptor.Address+Offset,Buf,Len);
  end else begin
   CopyMemoryFromRAM(Buf,Descriptor.Address+Offset,Len);
  end;
  dec(Count,Len);
  if Count>0 then begin
   inc(Offset,Len);
   inc(Buf,Len);
   if Offset=Descriptor.Len then begin
    if (Descriptor.Flags and VRING_DESC_F_NEXT)=0 then begin
     result:=false;
     exit;
    end;
    NextDescriptorIndex:=Descriptor.Next;
    if not GetDescriptor(@Descriptor,QueueIndex,NextDescriptorIndex) then begin
     result:=false;
     exit;
    end;
    if (Descriptor.Flags and VRING_DESC_F_WRITE)<>WriteFlag then begin
     result:=false;
     exit;
    end;
    Offset:=0;
   end;
  end else begin
   break;
  end;
 until false;

 result:=true;

end;

function TPasRISCV.TVirtIODevice.CopyMemoryFromQueue(const aBuf:Pointer;const aQueueIndex,aDescriptorIndex,aOffset,aCount:TPasRISCVUInt64):Boolean;
begin
 result:=CopyMemoryFromToQueue(aBuf,aQueueIndex,aDescriptorIndex,aOffset,aCount,false);
end;

function TPasRISCV.TVirtIODevice.CopyMemoryToQueue(const aQueueIndex,aDescriptorIndex,aOffset:TPasRISCVUInt64;const aBuf:Pointer;const aCount:TPasRISCVUInt64):Boolean;
begin
 result:=CopyMemoryFromToQueue(aBuf,aQueueIndex,aDescriptorIndex,aOffset,aCount,true);
end;

function TPasRISCV.TVirtIODevice.ConsumeDescriptor(const aQueueIndex,aDescriptorIndex,aDescriptorLength:TPasRISCVUInt64):Boolean;
var Queue:PQueue;
    UsedElementAddress:TPasRISCVUInt64;
    VirtQAvailRingPtr:pointer;
    UsedIndex:TPasRISCVUInt16;
begin

 result:=false;

 Queue:=@fQueues[aQueueIndex];

 UsedElementAddress:=(Queue^.UsedAddress+4)+((Queue^.ShadowUsedIndex and (Queue^.Size-1)) shl 3);

 VirtQAvailRingPtr:=GetGlobalDirectMemoryAccessPointer(UsedElementAddress,SizeOf(TPasRISCVUInt64),true,nil);
 if assigned(VirtQAvailRingPtr) then begin
  TPasMPInterlocked.Write(PPasRISCVUInt64(VirtQAvailRingPtr)^,TPasRISCVUInt64(TPasRISCVUInt64(TPasRISCVUInt32(aDescriptorIndex)) or (TPasRISCVUInt64(TPasRISCVUInt32(aDescriptorLength)) shl 32)));
 end else begin
  if not Write32(UsedElementAddress,aDescriptorIndex) then begin
   exit;
  end;
  if not Write32(UsedElementAddress+4,aDescriptorLength) then begin
   exit;
  end;
 end;

 TPasMPMemoryBarrier.ReadWrite;

 if (fActiveFeatures and TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX)<>0 then begin
  if Read16((Queue^.AvailableAddress+4)+(Queue^.Size shl 1),UsedIndex) then begin
   if Queue^.ShadowUsedIndex=UsedIndex then begin
    TPasMPInterlocked.Write(Queue^.UsedRingEvent,TPasMPBool32(true));
   end;
  end else begin
   exit;
  end;
 end;

 inc(Queue^.ShadowUsedIndex);

 result:=true;

end;

function TPasRISCV.TVirtIODevice.UsedRingSync(const aQueueIndex:TPasRISCVUInt64):Boolean;
var Queue:PQueue;
    VirtQAvailPtr:Pointer;
    NewValue,OldValue:TPasRISCVUInt32;
    Flags:TPasRISCVUInt16;
    UseEventIndex:Boolean;
begin

 result:=false;

 Queue:=@fQueues[aQueueIndex];

 VirtQAvailPtr:=GetGlobalDirectMemoryAccessPointer(Queue^.UsedAddress,SizeOf(TPasRISCVUInt32),true,nil);

 if assigned(VirtQAvailPtr) then begin

  repeat
   OldValue:=PPasRISCVUInt32(VirtQAvailPtr)^;
   NewValue:=(OldValue and $ffff) or (TPasRISCVUInt32(Queue^.ShadowUsedIndex) shl 16);
  until TPasMPInterlocked.CompareExchange(PPasRISCVUInt32(VirtQAvailPtr)^,NewValue,OldValue)=OldValue;

  Flags:=OldValue and $ffff;

 end else begin

  if Read16(Queue^.UsedAddress,Flags) then begin
   Write16(Queue^.UsedAddress+2,Queue^.ShadowUsedIndex);
  end else begin
   exit;
  end;

 end;

 TPasMPMemoryBarrier.ReadWrite;

 UseEventIndex:=(fActiveFeatures and TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX)<>0;
 if (UseEventIndex and TPasMPInterlocked.CompareExchange(Queue^.UsedRingEvent,TPasMPBool32(false),TPasMPBool32(true))) or
    ((not UseEventIndex) and ((Flags and VIRTQ_AVAIL_F_NO_INTERRUPT)=0)) then begin
  NotifyQueueUsed;
 end;

 result:=true;

//Sleep(1);

end;

function TPasRISCV.TVirtIODevice.GetDescriptors(out aReadSize,aWriteSize:TPasRISCVUInt64;const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64):Boolean;
var Queue:PQueue;
    QueueDescriptor:PQueueDescriptor;
    Descriptor:TVirtIODescriptor;
    DescriptorIndex:TPasRISCVUInt64;
begin

 Queue:=@fQueues[aQueueIndex];

 Queue^.CountReadDescriptors:=0;
 Queue^.CountWriteDescriptors:=0;

 aReadSize:=0;
 aWriteSize:=0;

 DescriptorIndex:=aDescriptorIndex;

 GetDescriptor(@Descriptor,aQueueIndex,DescriptorIndex);

 repeat
  if (Descriptor.Flags and VRING_DESC_F_WRITE)<>0 then begin
   break;
  end;
  if length(Queue^.ReadDescriptors)<=Queue^.CountReadDescriptors then begin
   SetLength(Queue^.ReadDescriptors,(Queue^.CountReadDescriptors+1)+((Queue^.CountReadDescriptors+2) shr 1));
  end;
  if fUseQueueDescriptorCaching then begin
   QueueDescriptor:=@Queue^.ReadDescriptors[Queue^.CountReadDescriptors];
   inc(Queue^.CountReadDescriptors);
   QueueDescriptor^.DescriptorIndex:=DescriptorIndex;
   QueueDescriptor^.Offset:=aReadSize;
   QueueDescriptor^.Size:=Descriptor.Len;
  end;
  inc(aReadSize,Descriptor.Len);
  if (Descriptor.Flags and VRING_DESC_F_NEXT)=0 then begin
   result:=true;
   exit;
  end;
  DescriptorIndex:=Descriptor.Next;
  GetDescriptor(@Descriptor,aQueueIndex,DescriptorIndex);
 until false;

 repeat
  if (Descriptor.Flags and VRING_DESC_F_WRITE)=0 then begin
   result:=false;
   exit;
  end;
  if fUseQueueDescriptorCaching then begin
   if length(Queue^.WriteDescriptors)<=Queue^.CountWriteDescriptors then begin
    SetLength(Queue^.WriteDescriptors,(Queue^.CountWriteDescriptors+1)+((Queue^.CountWriteDescriptors+2) shr 1));
   end;
   QueueDescriptor:=@Queue^.WriteDescriptors[Queue^.CountWriteDescriptors];
   inc(Queue^.CountWriteDescriptors);
   QueueDescriptor^.DescriptorIndex:=DescriptorIndex;
   QueueDescriptor^.Offset:=aWriteSize;
   QueueDescriptor^.Size:=Descriptor.Len;
  end;
  inc(aWriteSize,Descriptor.Len);
  if (Descriptor.Flags and VRING_DESC_F_NEXT)=0 then begin
   break;
  end;
  DescriptorIndex:=Descriptor.Next;
  GetDescriptor(@Descriptor,aQueueIndex,DescriptorIndex);
 until false;

 result:=true;

end;

function TPasRISCV.TVirtIODevice.AdvanceShadowAvailableIndex(const aQueueIndex:TPasRISCVUInt64):Boolean;
var Queue:PQueue;
begin
 Queue:=@fQueues[aQueueIndex];
 if (fActiveFeatures and TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX)<>0 then begin
  result:=Write16((Queue^.UsedAddress+4)+(Queue^.Size shl 3),Queue^.ShadowAvailableIndex+1);
 end else begin
  result:=true;
 end;
 if result then begin
  inc(Queue^.ShadowAvailableIndex);
 end;
end;

procedure TPasRISCV.TVirtIODevice.ProcessQueue(const aQueueIndex:TPasRISCVUInt64;const aAvailableIndex:TPasRISCVInt64);
var Queue:PQueue;
    AvailableIndex,DescriptorIndex:TPasRISCVUInt16;
    ReadSize,WriteSize:TPasRISCVUInt64;
    OK:Boolean;
begin
 if fDriverOK then begin
  Queue:=@fQueues[aQueueIndex];
  if not Queue^.ManualRecv then begin
   if TPasMPInterlocked.CompareExchange(Queue^.Lock,-1,0)=0 then begin
    try
     if aAvailableIndex>=0 then begin
      AvailableIndex:=aAvailableIndex;
      OK:=true;
     end else begin
      OK:=Read16(Queue^.AvailableAddress+2,AvailableIndex);
     end;
     if OK then begin
      while Queue^.ShadowAvailableIndex<>AvailableIndex do begin
       if Read16((Queue^.AvailableAddress+4)+((Queue^.ShadowAvailableIndex and (Queue^.Size-1)) shl 1),DescriptorIndex) then begin
        if GetDescriptors(ReadSize,WriteSize,aQueueIndex,DescriptorIndex) then begin
         if DeviceRecv(aQueueIndex,DescriptorIndex,ReadSize,WriteSize) then begin
          if AdvanceShadowAvailableIndex(aQueueIndex) then begin
           if (fStatus and VIRTIO_STATUS_DEVICE_NEEDS_RESET)<>0 then begin
            break;
           end else begin
            continue;
           end;
          end;
         end else begin
          break;
         end;
        end;
       end;
       NotifyDeviceNeedsReset;
       break;
      end;
     end;
    finally
     TPasMPInterlocked.Write(Queue^.Lock,0);
    end;
   end;
  end;
 end;
end;

procedure TPasRISCV.TVirtIODevice.QueueNotify(const aQueueIndex:TPasRISCVUInt64);
var Queue:PQueue;
    AvailableIndex:TPasRISCVUInt16;
begin
 if fDriverOK then begin
  Queue:=@fQueues[aQueueIndex];
  if not Queue^.ManualRecv then begin
   if Read16(Queue^.AvailableAddress+2,AvailableIndex) then begin
    if Queue^.Asynchronous then begin
     if not fMachine.fJobManager.EnqueueVirtIODeviceQueue(self,aQueueIndex,AvailableIndex) then begin
      ProcessQueue(aQueueIndex,AvailableIndex);
     end;
    end else begin
     ProcessQueue(aQueueIndex,AvailableIndex);
    end;
   end;
  end;
 end;
end;

procedure TPasRISCV.TVirtIODevice.UpdateIRQ;
begin
 if TPasMPInterlocked.Read(fIntStatus)<>0 then begin
  fMachine.fInterrupts.RaiseIRQ(fIRQ);
 end else begin
  fMachine.fInterrupts.LowerIRQ(fIRQ);
 end;
end;

procedure TPasRISCV.TVirtIODevice.SetIRQ(const aValue:TPasRISCVUInt32);
begin
 TPasMPInterlocked.BitwiseOr(fIntStatus,TPasMPUInt32(aValue));
 UpdateIRQ;
end;

procedure TPasRISCV.TVirtIODevice.NotifyQueueUsed;
begin
 if fDriverOK then begin
  SetIRQ(VIRTIO_INT_STATUS_USED_BUFFER);
 end;
end;

procedure TPasRISCV.TVirtIODevice.NotifyDeviceNeedsReset;
begin
 TPasMPInterlocked.BitwiseOr(TPasMPUInt32(fStatus),TPasMPUInt32(VIRTIO_STATUS_DEVICE_NEEDS_RESET));
 NotifyConfigChange;
end;

procedure TPasRISCV.TVirtIODevice.NotifyConfigChange;
begin
 if fDriverOK then begin
  SetIRQ(VIRTIO_INT_STATUS_CONFIG_CHANGE);
 end;
end;

function TPasRISCV.TVirtIODevice.ConfigRead(const aOffset:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 case aSize of
  1:begin
   if aOffset<fConfigSpaceSize then begin
    result:=fConfigSpace[aOffset];
   end else begin
    result:=0;
   end;
  end;
  2:begin
   if (aOffset+1)<fConfigSpaceSize then begin
    result:=TPasRISCVUInt16(fConfigSpace[aOffset]) or (TPasRISCVUInt16(fConfigSpace[aOffset+1]) shl 8);
   end else begin
    result:=0;
   end;
  end;
  4:begin
   if (aOffset+3)<fConfigSpaceSize then begin
    result:=TPasRISCVUInt32(fConfigSpace[aOffset]) or (TPasRISCVUInt32(fConfigSpace[aOffset+1]) shl 8) or (TPasRISCVUInt32(fConfigSpace[aOffset+2]) shl 16) or (TPasRISCVUInt32(fConfigSpace[aOffset+3]) shl 24);
   end else begin
    result:=0;
   end;
  end;
  8:begin
   if (aOffset+7)<fConfigSpaceSize then begin
    result:=TPasRISCVUInt64(fConfigSpace[aOffset]) or (TPasRISCVUInt64(fConfigSpace[aOffset+1]) shl 8) or (TPasRISCVUInt64(fConfigSpace[aOffset+2]) shl 16) or (TPasRISCVUInt64(fConfigSpace[aOffset+3]) shl 24) or (TPasRISCVUInt64(fConfigSpace[aOffset+4]) shl 32) or (TPasRISCVUInt64(fConfigSpace[aOffset+5]) shl 40) or (TPasRISCVUInt64(fConfigSpace[aOffset+6]) shl 48) or (TPasRISCVUInt64(fConfigSpace[aOffset+7]) shl 56);
   end else begin
    result:=0;
   end;
  end;
  else begin
   result:=0;
  end;
 end;
end;

procedure TPasRISCV.TVirtIODevice.ConfigWrite(const aOffset:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
begin
 case aSize of
  1:begin
   if aOffset<fConfigSpaceSize then begin
    fConfigSpace[aOffset]:=aValue;
    DeviceConfigWrite;
   end;
  end;
  2:begin
   if (aOffset+1)<fConfigSpaceSize then begin
    fConfigSpace[aOffset]:=aValue and $ff;
    fConfigSpace[aOffset+1]:=(aValue shr 8) and $ff;
    DeviceConfigWrite;
   end;
  end;
  4:begin
   if (aOffset+3)<fConfigSpaceSize then begin
    fConfigSpace[aOffset]:=aValue and $ff;
    fConfigSpace[aOffset+1]:=(aValue shr 8) and $ff;
    fConfigSpace[aOffset+2]:=(aValue shr 16) and $ff;
    fConfigSpace[aOffset+3]:=(aValue shr 24) and $ff;
    DeviceConfigWrite;
   end;
  end;
  8:begin
   if (aOffset+7)<fConfigSpaceSize then begin
    fConfigSpace[aOffset]:=aValue and $ff;
    fConfigSpace[aOffset+1]:=(aValue shr 8) and $ff;
    fConfigSpace[aOffset+2]:=(aValue shr 16) and $ff;
    fConfigSpace[aOffset+3]:=(aValue shr 24) and $ff;
    fConfigSpace[aOffset+4]:=(aValue shr 32) and $ff;
    fConfigSpace[aOffset+5]:=(aValue shr 40) and $ff;
    fConfigSpace[aOffset+6]:=(aValue shr 48) and $ff;
    fConfigSpace[aOffset+7]:=(aValue shr 56) and $ff;
    DeviceConfigWrite;
   end;
  end;
 end;
end;

procedure TPasRISCV.TVirtIODevice.SetStatus(const aStatus:TPasRISCVUInt32);
var NewStatus,OldStatus,EnablingStatus:TPasRISCVUInt32;
begin

 if aStatus=0 then begin

  fDriverOK:=false;
  fStatus:=0;
  fMachine.fInterrupts.LowerIRQ(fIRQ);
  DeviceReset;

 end else begin

  NewStatus:=aStatus;

  OldStatus:=fStatus;

  EnablingStatus:=(OldStatus xor NewStatus) and NewStatus;

  if (NewStatus and VIRTIO_STATUS_DRIVER_OK)=0 then begin
   fDriverOK:=false;
  end;

  if (EnablingStatus and VIRTIO_STATUS_FEATURES_OK)<>0 then begin
   fActiveFeatures:=fDeviceFeatures and fDriverFeatures;
   if (fActiveFeatures and TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1)=0 then begin
    NewStatus:=NewStatus and not VIRTIO_STATUS_FEATURES_OK;
   end;
  end;

  fStatus:=NewStatus and $ff;

  if (OldStatus and VIRTIO_STATUS_DEVICE_NEEDS_RESET)<>0 then begin
   SetIRQ(VIRTIO_INT_STATUS_CONFIG_CHANGE);
  end else begin
   if (EnablingStatus and VIRTIO_STATUS_DRIVER_OK)<>0 then begin
    fDriverOK:=true;
    DeviceDriverOK;
   end;
  end;

 end;

end;

function TPasRISCV.TVirtIODevice.MMIORead(const aOffset:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 if aOffset>=VIRTIO_MMIO_CONFIG then begin
  result:=ConfigRead(aOffset-VIRTIO_MMIO_CONFIG,aSize);
 end else begin
  case aSize of
   4:begin
    case aOffset of
     VIRTIO_MMIO_MAGIC_VALUE:begin
      result:=$74726976;
     end;
     VIRTIO_MMIO_VERSION:begin
      result:=2;
     end;
     VIRTIO_MMIO_DEVICE_ID:begin
      result:=fDeviceID;
     end;
     VIRTIO_MMIO_VENDOR_ID:begin
      result:=fVendorID;
     end;
     VIRTIO_MMIO_DEVICE_FEATURES:begin
      case fDeviceFeaturesSelected of
       0:begin
        result:=fDeviceFeatures and TPasRISCVUInt64($ffffffff);
       end;
       1:begin
        result:=(fDeviceFeatures shr 32) and TPasRISCVUInt64($ffffffff);
       end;
       else begin
        result:=0;
       end;
      end;
     end;
     VIRTIO_MMIO_DEVICE_FEATURES_SEL:begin
      result:=fDeviceFeaturesSelected;
     end;
     VIRTIO_MMIO_DRIVER_FEATURES:begin
      case fDriverFeaturesSelected of
       0:begin
        result:=fDriverFeatures and TPasRISCVUInt64($ffffffff);
       end;
       1:begin
        result:=(fDriverFeatures shr 32) and TPasRISCVUInt64($ffffffff);
       end;
       else begin
        result:=0;
       end;
      end;
     end;
     VIRTIO_MMIO_DRIVER_FEATURES_SEL:begin
      result:=fDriverFeaturesSelected;
     end;
     VIRTIO_MMIO_QUEUE_SEL:begin
      result:=fSelectedQueue;
     end;
     VIRTIO_MMIO_QUEUE_NUM_MAX:begin
      result:=MAXIMUM_QUEUE_SIZE;
     end;
     VIRTIO_MMIO_QUEUE_NUM:begin
      result:=fQueues[fSelectedQueue].Size;
     end;
     VIRTIO_MMIO_QUEUE_DESC_LOW:begin
      result:=fQueues[fSelectedQueue].DescriptorAddress and TPasRISCVUInt64($ffffffff);
     end;
     VIRTIO_MMIO_QUEUE_AVAIL_LOW:begin
      result:=fQueues[fSelectedQueue].AvailableAddress and TPasRISCVUInt64($ffffffff);
     end;
     VIRTIO_MMIO_QUEUE_USED_LOW:begin
      result:=fQueues[fSelectedQueue].UsedAddress and TPasRISCVUInt64($ffffffff);
     end;
     VIRTIO_MMIO_QUEUE_DESC_HIGH:begin
      result:=fQueues[fSelectedQueue].DescriptorAddress shr 32;
     end;
     VIRTIO_MMIO_QUEUE_AVAIL_HIGH:begin
      result:=fQueues[fSelectedQueue].AvailableAddress shr 32;
     end;
     VIRTIO_MMIO_QUEUE_USED_HIGH:begin
      result:=fQueues[fSelectedQueue].UsedAddress shr 32;
     end;
     VIRTIO_MMIO_QUEUE_READY:begin
      result:=ord(fQueues[fSelectedQueue].Ready) and 1;
     end;
     VIRTIO_MMIO_INTERRUPT_STATUS:begin
      result:=TPasMPInterlocked.Read(fIntStatus);
     end;
     VIRTIO_MMIO_STATUS:begin
      result:=fStatus;
     end;
     VIRTIO_MMIO_CONFIG_GENERATION:begin
      result:=0;
     end;
     VIRTIO_MMIO_SHM_LEN_LOW,
     VIRTIO_MMIO_SHM_LEN_HIGH:begin
      // Return ~0 to indicate no shared memory region present
      result:=$ffffffff;
     end;
     VIRTIO_MMIO_SHM_SEL,
     VIRTIO_MMIO_SHM_BASE_LOW,
     VIRTIO_MMIO_SHM_BASE_HIGH:begin
      result:=0;
     end;
     else begin
      result:=0;
     end;
    end;
   end;
   else begin
    result:=0;
   end;
  end;
 end;
//writeln('virtio_mmio_read: ',IntToHex(aOffset),' ',aSize,' ',IntToHex(result));
end;

procedure TPasRISCV.TVirtIODevice.MMIOWrite(const aOffset:TPasRISCVUInt64;const aValue:TPasRISCVUInt32;const aSize:TPasRISCVUInt64);
begin
//writeln('virtio_mmio_write: ',IntToHex(aOffset),' ',aSize,' ',IntToHex(aValue));
 if aOffset>=VIRTIO_MMIO_CONFIG then begin
  ConfigWrite(aOffset-VIRTIO_MMIO_CONFIG,aValue,aSize);
 end else begin
  case aSize of
   4:begin
    case aOffset of
     VIRTIO_MMIO_DEVICE_FEATURES_SEL:begin
      fDeviceFeaturesSelected:=aValue;
     end;
     VIRTIO_MMIO_DRIVER_FEATURES:begin
      case fDriverFeaturesSelected of
       0:begin
        fDriverFeatures:=(fDriverFeatures and TPasRISCVUInt64($ffffffff00000000)) or (TPasRISCVUInt64(TPasRISCVUInt32(aValue)) shl 0);
       end;
       1:begin
        fDriverFeatures:=(fDriverFeatures and TPasRISCVUInt64($00000000ffffffff)) or (TPasRISCVUInt64(TPasRISCVUInt32(aValue)) shl 32);
       end;
       else begin
       end;
      end;
     end;
     VIRTIO_MMIO_DRIVER_FEATURES_SEL:begin
      fDriverFeaturesSelected:=aValue;
     end;
     VIRTIO_MMIO_QUEUE_SEL:begin
      if aValue<MAXIMUM_COUNT_QUEUES then begin
       fSelectedQueue:=aValue;
      end;
     end;
     VIRTIO_MMIO_QUEUE_NUM:begin
      if ((aValue and (aValue-1))=0) and (aValue>0) then begin
       fQueues[fSelectedQueue].Size:=aValue;
      end;
     end;
     VIRTIO_MMIO_QUEUE_DESC_LOW:begin
      fQueues[fSelectedQueue].DescriptorAddress:=(fQueues[fSelectedQueue].DescriptorAddress and TPasRISCVUInt64($ffffffff00000000)) or (aValue and TPasRISCVUInt64($00000000ffffffff));
     end;
     VIRTIO_MMIO_QUEUE_AVAIL_LOW:begin
      fQueues[fSelectedQueue].AvailableAddress:=(fQueues[fSelectedQueue].AvailableAddress and TPasRISCVUInt64($ffffffff00000000)) or (aValue and TPasRISCVUInt64($00000000ffffffff));
     end;
     VIRTIO_MMIO_QUEUE_USED_LOW:begin
      fQueues[fSelectedQueue].UsedAddress:=(fQueues[fSelectedQueue].UsedAddress and TPasRISCVUInt64($ffffffff00000000)) or (aValue and TPasRISCVUInt64($00000000ffffffff));
     end;
     VIRTIO_MMIO_QUEUE_DESC_HIGH:begin
      fQueues[fSelectedQueue].DescriptorAddress:=(fQueues[fSelectedQueue].DescriptorAddress and TPasRISCVUInt64($00000000ffffffff)) or (TPasRISCVUInt64(aValue) shl 32);
     end;
     VIRTIO_MMIO_QUEUE_AVAIL_HIGH:begin
      fQueues[fSelectedQueue].AvailableAddress:=(fQueues[fSelectedQueue].AvailableAddress and TPasRISCVUInt64($00000000ffffffff)) or (TPasRISCVUInt64(aValue) shl 32);
     end;
     VIRTIO_MMIO_QUEUE_USED_HIGH:begin
      fQueues[fSelectedQueue].UsedAddress:=(fQueues[fSelectedQueue].UsedAddress and TPasRISCVUInt64($00000000ffffffff)) or (TPasRISCVUInt64(aValue) shl 32);
     end;
     VIRTIO_MMIO_STATUS:begin
      SetStatus(aValue);
     end;
     VIRTIO_MMIO_QUEUE_READY:begin
      fQueues[fSelectedQueue].Ready:=(aValue and 1)<>0;
      if (aValue and 1)<>0 then begin
       DeviceInitialize;
      end;
     end;
     VIRTIO_MMIO_QUEUE_NOTIFY:begin
      if aValue<MAXIMUM_COUNT_QUEUES then begin
       QueueNotify(aValue);
      end;
     end;
     VIRTIO_MMIO_INTERRUPT_ACK:begin
      TPasMPInterlocked.BitwiseAnd(fIntStatus,not TPasMPUInt32(aValue));
      UpdateIRQ;
     end;
     VIRTIO_MMIO_SHM_SEL:begin
      // no-op: SHM regions not supported
     end;
    end;
   end;
  end;
 end;
end;

function TPasRISCV.TVirtIODevice.PCIRead(const aOffset:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Offset:TPasRISCVUInt64;
begin
 Offset:=aOffset and $fff;
 case aOffset shr 12 of
  VIRTIO_PCI_CFG_OFFSET shr 12:begin
   case aSize of
    1:begin
     case Offset of
      VIRTIO_PCI_DEVICE_STATUS:begin
       result:=fStatus;
      end;
      else begin
       result:=0;
      end;
     end;
    end;
    2:begin
     case Offset of
      VIRTIO_PCI_NUM_QUEUES:begin
       result:=MAXIMUM_QUEUE_SIZE;
      end;
      VIRTIO_PCI_QUEUE_SEL:begin
       result:=fSelectedQueue;
      end;
      VIRTIO_PCI_QUEUE_SIZE:begin
       result:=fQueues[fSelectedQueue].Size;
      end;
      VIRTIO_PCI_QUEUE_ENABLE:begin
       result:=ord(fQueues[fSelectedQueue].Ready) and 1;
      end;
      VIRTIO_PCI_QUEUE_NOTIFY_OFF:begin
       result:=0;
      end;
      else begin
       result:=0;
      end;
     end;
    end;
    4:begin
     case Offset of
      VIRTIO_PCI_DEVICE_FEATURE:begin
       case fDeviceFeaturesSelected of
        0:begin
         result:=fDeviceFeatures and TPasRISCVUInt64($ffffffff);
        end;
        1:begin
         result:=(fDeviceFeatures shr 32) and TPasRISCVUInt64($ffffffff);
        end;
        else begin
         result:=0;
        end;
       end;
      end;
      VIRTIO_PCI_DEVICE_FEATURE_SEL:begin
       result:=fDeviceFeaturesSelected;
      end;
      VIRTIO_PCI_DRIVER_FEATURE:begin
       case fDriverFeaturesSelected of
        0:begin
         result:=fDriverFeatures and TPasRISCVUInt64($ffffffff);
        end;
        1:begin
         result:=(fDriverFeatures shr 32) and TPasRISCVUInt64($ffffffff);
        end;
        else begin
         result:=0;
        end;
       end;
      end;
      VIRTIO_PCI_DRIVER_FEATURE_SEL:begin
       result:=fDriverFeaturesSelected;
      end;
      VIRTIO_PCI_QUEUE_DESC_LOW:begin
       result:=fQueues[fSelectedQueue].DescriptorAddress and $ffffffff;
      end;
      VIRTIO_PCI_QUEUE_AVAIL_LOW:begin
       result:=fQueues[fSelectedQueue].AvailableAddress and $ffffffff;
      end;
      VIRTIO_PCI_QUEUE_USED_LOW:begin
       result:=fQueues[fSelectedQueue].UsedAddress and $ffffffff;
      end;
      VIRTIO_PCI_QUEUE_DESC_HIGH:begin
       result:=fQueues[fSelectedQueue].DescriptorAddress shr 32;
      end;
      VIRTIO_PCI_QUEUE_AVAIL_HIGH:begin
       result:=fQueues[fSelectedQueue].AvailableAddress shr 32;
      end;
      VIRTIO_PCI_QUEUE_USED_HIGH:begin
       result:=fQueues[fSelectedQueue].UsedAddress shr 32;
      end;
      else begin
       result:=0;
      end;
     end;
    end;
    else begin
     result:=0;
    end;
   end;
  end;
  VIRTIO_PCI_ISR_OFFSET shr 12:begin
   case aSize of
    1:begin
     case Offset of
      0:begin
       result:=fIntStatus;
       fIntStatus:=0;
       fMachine.fInterrupts.LowerIRQ(fIRQ);
      end;
      else begin
       result:=0;
      end;
     end;
    end;
    else begin
     result:=0;
    end;
   end;
  end;
  VIRTIO_PCI_CONFIG_OFFSET shr 12:begin
   result:=ConfigRead(Offset,aSize);
  end;
  else begin
   result:=0;
  end;
 end;
end;

procedure TPasRISCV.TVirtIODevice.PCIWrite(const aOffset:TPasRISCVUInt64;const aValue:TPasRISCVUInt32;const aSize:TPasRISCVUInt64);
var Offset:TPasRISCVUInt64;
begin
 Offset:=aOffset and $fff;
 case aOffset shr 12 of
  VIRTIO_PCI_CFG_OFFSET shr 12:begin
   case aSize of
    1:begin
     case Offset of
      VIRTIO_PCI_DEVICE_STATUS:begin
       SetStatus(aValue);
      end;
      else begin
      end;
     end;
    end;
    2:begin
     case Offset of
      VIRTIO_PCI_QUEUE_SEL:begin
       if aValue<MAXIMUM_COUNT_QUEUES then begin
        fSelectedQueue:=aValue;
       end;
      end;
      VIRTIO_PCI_QUEUE_SIZE:begin
       if ((aValue and (aValue-1))=0) and (aValue>0) then begin
        fQueues[fSelectedQueue].Size:=aValue;
       end;
      end;
      VIRTIO_PCI_QUEUE_ENABLE:begin
       fQueues[fSelectedQueue].Ready:=(aValue and 1)<>0;
       if (aValue and 1)<>0 then begin
        DeviceInitialize;
       end;
      end;
      else begin
      end;
     end;
    end;
    4:begin
     case Offset of
      VIRTIO_PCI_DEVICE_FEATURE_SEL:begin
       fDeviceFeaturesSelected:=aValue;
      end;
      VIRTIO_PCI_DRIVER_FEATURE:begin
       case fDriverFeaturesSelected of
        0:begin
         fDriverFeatures:=(fDriverFeatures and TPasRISCVUInt64($ffffffff00000000)) or (TPasRISCVUInt64(TPasRISCVUInt32(aValue)) shl 0);
        end;
        1:begin
         fDriverFeatures:=(fDriverFeatures and TPasRISCVUInt64($00000000ffffffff)) or (TPasRISCVUInt64(TPasRISCVUInt32(aValue)) shl 32);
        end;
        else begin
        end;
       end;
      end;
      VIRTIO_PCI_DRIVER_FEATURE_SEL:begin
       fDriverFeaturesSelected:=aValue;
      end;
      VIRTIO_PCI_QUEUE_DESC_LOW:begin
       fQueues[fSelectedQueue].DescriptorAddress:=(fQueues[fSelectedQueue].DescriptorAddress and $ffffffff00000000) or (aValue and $00000000ffffffff);
      end;
      VIRTIO_PCI_QUEUE_AVAIL_LOW:begin
       fQueues[fSelectedQueue].AvailableAddress:=(fQueues[fSelectedQueue].AvailableAddress and $ffffffff00000000) or (aValue and $00000000ffffffff);
      end;
      VIRTIO_PCI_QUEUE_USED_LOW:begin
       fQueues[fSelectedQueue].UsedAddress:=(fQueues[fSelectedQueue].UsedAddress and $ffffffff00000000) or (aValue and $00000000ffffffff);
      end;
      VIRTIO_PCI_QUEUE_DESC_HIGH:begin
       fQueues[fSelectedQueue].DescriptorAddress:=(fQueues[fSelectedQueue].DescriptorAddress and $00000000ffffffff) or (TPasRISCVUInt64(aValue) shl 32);
      end;
      VIRTIO_PCI_QUEUE_AVAIL_HIGH:begin
       fQueues[fSelectedQueue].AvailableAddress:=(fQueues[fSelectedQueue].AvailableAddress and $00000000ffffffff) or (TPasRISCVUInt64(aValue) shl 32);
      end;
      VIRTIO_PCI_QUEUE_USED_HIGH:begin
       fQueues[fSelectedQueue].UsedAddress:=(fQueues[fSelectedQueue].UsedAddress and $00000000ffffffff) or (TPasRISCVUInt64(aValue) shl 32);
      end;
      else begin
      end;
     end;
    end;
    else begin
    end;
   end;
  end;
  VIRTIO_PCI_CONFIG_OFFSET shr 12:begin
   ConfigWrite(Offset,aValue,aSize);
  end;
  VIRTIO_PCI_NOTIFY_OFFSET shr 12:begin
   if aValue<MAXIMUM_COUNT_QUEUES then begin
    QueueNotify(aValue);
   end;
  end;
  else begin
  end;
 end;
end;

procedure TPasRISCV.TVirtIODevice.Reset;
begin
 inherited Reset;
 DeviceReset;
end;

function TPasRISCV.TVirtIODevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case fKind of
  TPasRISCV.TVirtIODevice.TKind.MMIO:begin
   result:=MMIORead(Address,aSize);
  end;
  TPasRISCV.TVirtIODevice.TKind.PCI:begin
   result:=PCIRead(Address,aSize);
  end;
  else begin
   result:=0;
  end;
 end;
end;

procedure TPasRISCV.TVirtIODevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case fKind of
  TPasRISCV.TVirtIODevice.TKind.MMIO:begin
   MMIOWrite(Address,aValue,aSize);
  end;
  TPasRISCV.TVirtIODevice.TKind.PCI:begin
   PCIWrite(Address,aValue,aSize);
  end;
 end;
end;

{ TPasRISCV.TVirtIOBlockDevice }

constructor TPasRISCV.TVirtIOBlockDevice.Create(const aMachine:TPasRISCV);
var Index:TPasRISCVSizeInt;
begin

 inherited Create(aMachine,aMachine.fConfiguration.fVirtIOBlockBase,aMachine.fConfiguration.fVirtIOBlockSize,TPasRISCV.TVirtIODevice.TKind.MMIO);

 fIRQ:=aMachine.fConfiguration.fVirtIOBlockIRQ;

//fVendorID:=Vendor;

 fDeviceID:=DeviceID;

 for Index:=0 to MAXIMUM_COUNT_QUEUES-1 do begin
  fQueues[Index].Asynchronous:=false;
 end;

 fDeviceFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1 or
//                TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX or
//                TPasRISCV.TVirtIODevice.VIRTIO_F_IN_ORDER or
                  VIRTIO_BLK_F_SIZE_MAX or
                  VIRTIO_BLK_F_SEG_MAX or
                  VIRTIO_BLK_F_BLK_SIZE or
                  VIRTIO_BLK_F_FLUSH;

 if aMachine.fConfiguration.fVirtIOBlockMQ then begin
  fDeviceFeatures:=fDeviceFeatures or VIRTIO_BLK_F_MQ;
 end;

 fStreamLock:=TPasMPSlimReaderWriterLock.Create;

 fStream:=TMemoryStream.Create;

 FillChar(fConfig,Sizeof(TVirtIOBlkConfig),#0);

 if aMachine.fConfiguration.fVirtIOBlockMQ then begin
  fConfig.NumQueues:=MAXIMUM_COUNT_QUEUES;
 end else begin
  fConfig.NumQueues:=1;
 end;

 fConfig.BlkSize:=SECTOR_SIZE;
 fConfig.SizeMax:=SECTOR_SIZE*256;
 fConfig.SegMax:=128;
 fConfig.Writeback:=1;

 fConfig.MaxDiscardSectors:=128;
 fConfig.MaxDiscardSeg:=1;
 fConfig.DiscardSectorAlignment:=fConfig.BlkSize shr 9;

 fConfig.MaxSecureEraseSectors:=128;
 fConfig.MaxSecureEraseSeg:=1;
 fConfig.SecureEraseSectorAlignment:=fConfig.BlkSize shr 9;

 fConfig.MaxWriteZeroesSectors:=128;
 fConfig.MaxWriteZeroesSeg:=1;
 fConfig.WriteZeroesMayUnmap:=0;

 fConfigSpaceSize:=SizeOf(TVirtIOBlkConfig);

 fCountSectors:=(fStream.Size+(SECTOR_SIZE-1)) div SECTOR_SIZE;

 fConfig.Capacity:=fCountSectors;
 Move(fConfig,fConfigSpace[0],SizeOf(TVirtIOBlkConfig));

end;

destructor TPasRISCV.TVirtIOBlockDevice.Destroy;
begin
 FreeAndNil(fStream);
 FreeAndNil(fStreamLock);
 inherited Destroy;
end;

procedure TPasRISCV.TVirtIOBlockDevice.DeviceReset;
begin
 inherited DeviceReset;
 if assigned(fStream) then begin
  fStreamLock.Acquire;
  try
   FlushStream(fStream);
  finally
   fStreamLock.Release;
  end;
 end;
end;

procedure TPasRISCV.TVirtIOBlockDevice.DeviceConfigWrite;
begin
 inherited DeviceConfigWrite;
end;

function TPasRISCV.TVirtIOBlockDevice.ImageRead(const aSectorIndex:TPasRISCVUInt64;const aBuf:Pointer;const aCount:TPasRISCVUInt64):Boolean;
var Offset,Size,Remain:TPasRISCVInt64;
    Buf:PPasRISCVUInt8;
begin
 Offset:=aSectorIndex*SECTOR_SIZE;
 Size:=aCount*SECTOR_SIZE;
 if (Offset+Size)<=(fCountSectors*SECTOR_SIZE) then begin
  Remain:=(fCountSectors*SECTOR_SIZE)-Offset;
  if Remain>Size then begin
   Remain:=Size;
  end;
  Buf:=aBuf;
  if Remain>0 then begin
   fStreamLock.Acquire;
   try
    result:=fStream.Seek(Offset,soBeginning)=Offset;
    if result then begin
     result:=fStream.Read(Buf^,Remain)=Remain;
    end;
   finally
    fStreamLock.Release;
   end;
  end else begin
   result:=true;
  end;
  if result then begin
   inc(Buf,Remain);
   if Remain<Size then begin
    FillChar(Buf^,Size-Remain,#0);
   end;
  end;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TVirtIOBlockDevice.ImageWrite(const aSectorIndex:TPasRISCVUInt64;const aBuf:Pointer;const aCount:TPasRISCVUInt64):Boolean;
var Offset,Size,Remain:TPasRISCVInt64;
    Buf:PPasRISCVUInt8;
begin
 Offset:=aSectorIndex*SECTOR_SIZE;
 Size:=aCount*SECTOR_SIZE;
 if (Offset+Size)<=(fCountSectors*SECTOR_SIZE) then begin
  Remain:=(fCountSectors*SECTOR_SIZE)-Offset;
  if Remain>Size then begin
   Remain:=Size;
  end;
  Buf:=aBuf;
  if Remain>0 then begin
   fStreamLock.Acquire;
   try
    result:=fStream.Seek(Offset,soBeginning)=Offset;
    if result then begin
     result:=fStream.Write(Buf^,Remain)=Remain;
    end;
   finally
    fStreamLock.Release;
   end;
  end else begin
   result:=true;
  end;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TVirtIOBlockDevice.DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean;
var Len,Count,WriteSize,Size,ToDo:TPasRISCVUInt64;
    BlockRequestHeader:TVirtIOBlockDevice.TBlockRequestHeader;
    Value:TPasRISCVUInt8;
    Buf:Pointer;
    VirtIOBlkDiscardWriteZeroes:TVirtIOBlkDiscardWriteZeroes;
begin

 if CopyMemoryFromQueue(@BlockRequestHeader,aQueueIndex,aDescriptorIndex,0,SizeOf(BlockRequestHeader)) then begin

  case BlockRequestHeader.Type_ of

   TVirtIOBlockDevice.VIRTIO_BLK_T_IN:begin

    Count:=(aWriteSize-1) div SECTOR_SIZE;
    WriteSize:=aWriteSize;

    GetMem(Buf,WriteSize);
    try

//   writeln(BlockRequestHeader.SectorIndex);

     if ImageRead(BlockRequestHeader.SectorIndex,Buf,Count) then begin
      PPasRISCVUInt8Array(Buf)^[WriteSize-1]:=VIRTIO_BLK_S_OK;
     end else begin
      PPasRISCVUInt8Array(Buf)^[WriteSize-1]:=VIRTIO_BLK_S_IOERR;
     end;
     if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Buf,WriteSize) and
             ConsumeDescriptor(aQueueIndex,aDescriptorIndex,WriteSize) and
             UsedRingSync(aQueueIndex)) then begin
      NotifyDeviceNeedsReset;
     end;

    finally
     if assigned(Buf) then begin
      try
       FreeMem(Buf);
      finally
       Buf:=nil;
      end;
     end;
    end;

   end;

   TVirtIOBlockDevice.VIRTIO_BLK_T_OUT:begin

    Len:=aReadSize-SizeOf(BlockRequestHeader);
    if Len>0 then begin
     Count:=Len div SECTOR_SIZE;
     WriteSize:=Len;
    end else begin
     Count:=0;
     WriteSize:=0;
    end;

    GetMem(Buf,WriteSize);
    try

     if CopyMemoryFromQueue(Buf,aQueueIndex,aDescriptorIndex,SizeOf(TBlockRequestHeader),WriteSize) then begin
      if ImageWrite(BlockRequestHeader.SectorIndex,Buf,Count) then begin
       Value:=VIRTIO_BLK_S_OK;
      end else begin
       Value:=VIRTIO_BLK_S_IOERR;
      end;
     end else begin
      NotifyDeviceNeedsReset;
      Value:=VIRTIO_BLK_S_IOERR;
     end;
     if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,@Value,SizeOf(TPasRISCVUInt8)) and
             ConsumeDescriptor(aQueueIndex,aDescriptorIndex,1) and
             UsedRingSync(aQueueIndex)) then begin
      NotifyDeviceNeedsReset;
     end;

    finally
     if assigned(Buf) then begin
      try
       FreeMem(Buf);
      finally
       Buf:=nil;
      end;
     end;
    end;

   end;

   TVirtIOBlockDevice.VIRTIO_BLK_T_SCSI:begin
    Value:=VIRTIO_BLK_S_UNSUPP;
    if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,@Value,SizeOf(TPasRISCVUInt8)) and
            ConsumeDescriptor(aQueueIndex,aDescriptorIndex,1) and
            UsedRingSync(aQueueIndex)) then begin
     NotifyDeviceNeedsReset;
    end;
   end;

   TVirtIOBlockDevice.VIRTIO_BLK_T_FLUSH,
   TVirtIOBlockDevice.VIRTIO_BLK_T_FLUSH_OUT:begin
    fStreamLock.Acquire;
    try
     if assigned(fStream) and FlushStream(fStream) then begin
      Value:=VIRTIO_BLK_S_OK;
     end else begin
      Value:=VIRTIO_BLK_S_IOERR;
     end;
    finally
     fStreamLock.Release;
    end;
    if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,@Value,SizeOf(TPasRISCVUInt8)) and
            ConsumeDescriptor(aQueueIndex,aDescriptorIndex,1) and
            UsedRingSync(aQueueIndex)) then begin
     NotifyDeviceNeedsReset;
    end;
   end;

   TVirtIOBlockDevice.VIRTIO_BLK_T_GET_ID:begin
    // Return 20 bytes of zeros (empty serial) + status OK
    WriteSize:=aWriteSize;
    if WriteSize>0 then begin
     GetMem(Buf,WriteSize);
     try
      FillChar(Buf^,WriteSize,0);
      PPasRISCVUInt8Array(Buf)^[WriteSize-1]:=VIRTIO_BLK_S_OK;
      if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Buf,WriteSize) and
              ConsumeDescriptor(aQueueIndex,aDescriptorIndex,WriteSize) and
              UsedRingSync(aQueueIndex)) then begin
       NotifyDeviceNeedsReset;
      end;
     finally
      FreeMem(Buf);
     end;
    end;
   end;

   TVirtIOBlockDevice.VIRTIO_BLK_T_GET_LIFETIME:begin
    Value:=VIRTIO_BLK_S_UNSUPP;
    if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,@Value,SizeOf(TPasRISCVUInt8)) and
            ConsumeDescriptor(aQueueIndex,aDescriptorIndex,1) and
            UsedRingSync(aQueueIndex)) then begin
     NotifyDeviceNeedsReset;
    end;
   end;

   TVirtIOBlockDevice.VIRTIO_BLK_T_DISCARD,
   TVirtIOBlockDevice.VIRTIO_BLK_T_WRITE_ZEROES,
   TVirtIOBlockDevice.VIRTIO_BLK_T_SECURE_ERASE:begin
    if CopyMemoryFromQueue(@VirtIOBlkDiscardWriteZeroes,aQueueIndex,aDescriptorIndex,SizeOf(TBlockRequestHeader),SizeOf(TVirtIOBlkDiscardWriteZeroes)) then begin
     Value:=VIRTIO_BLK_S_OK;
     fStreamLock.Acquire;
     try
      fStream.Seek(VirtIOBlkDiscardWriteZeroes.Sector*512,soBeginning);
      Size:=VirtIOBlkDiscardWriteZeroes.CountSectors*512;
      while Size>0 do begin
       if Size<SizeOf(TZeroBuffer) then begin
        ToDo:=Size;
       end else begin
        ToDo:=SizeOf(TZeroBuffer);
       end;
       if fStream.Write(ZeroBuffer[0],ToDo)<>ToDo then begin
        Value:=VIRTIO_BLK_S_IOERR;
        break;
       end;
       dec(Size,ToDo);
      end;
     finally
      fStreamLock.Release;
     end;
    end else begin
     NotifyDeviceNeedsReset;
     Value:=VIRTIO_BLK_S_IOERR;
    end;
    if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,@Value,SizeOf(TPasRISCVUInt8)) and
            ConsumeDescriptor(aQueueIndex,aDescriptorIndex,1) and
            UsedRingSync(aQueueIndex)) then begin
     NotifyDeviceNeedsReset;
    end;
   end;

   else begin
    // Unknown request type - return UNSUPP
    Value:=VIRTIO_BLK_S_UNSUPP;
    if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,@Value,SizeOf(TPasRISCVUInt8)) and
            ConsumeDescriptor(aQueueIndex,aDescriptorIndex,1) and
            UsedRingSync(aQueueIndex)) then begin
     NotifyDeviceNeedsReset;
    end;
   end;

  end;

 end else begin

  NotifyDeviceNeedsReset;

 end;

 result:=true;

end;

procedure TPasRISCV.TVirtIOBlockDevice.AttachStream(const aStream:TStream);
begin
 FreeAndNil(fStream);
 if assigned(aStream) then begin
  fStream:=aStream;
 end else begin
  fStream:=TMemoryStream.Create;
  TMemoryStream(fStream).SetSize(1 shl 20);
 end;
 fCountSectors:=(fStream.Size+(SECTOR_SIZE-1)) div SECTOR_SIZE;
 fConfig.Capacity:=fCountSectors;
 Move(fConfig,fConfigSpace[0],SizeOf(TVirtIOBlkConfig));
end;

procedure TPasRISCV.TVirtIOBlockDevice.LoadFromStream(const aStream:TStream);
begin
 if fStream is TMemoryStream then begin
  TMemoryStream(fStream).Clear;
 end;
 aStream.Seek(0,soBeginning);
 fStream.CopyFrom(aStream,aStream.Size);
 fCountSectors:=(fStream.Size+(SECTOR_SIZE-1)) div SECTOR_SIZE;
 fConfig.Capacity:=fCountSectors;
 Move(fConfig,fConfigSpace[0],SizeOf(TVirtIOBlkConfig));
end;

procedure TPasRISCV.TVirtIOBlockDevice.LoadFromFile(const aFileName:TPasRISCVUTF8String);
var Stream:TFileStream;
begin
 Stream:=TFileStream.Create(aFileName,fmOpenRead); // or fmShareDenyWrite);
 try
  LoadFromStream(Stream);
 finally
  Stream.Free;
 end;
end;

procedure TPasRISCV.TVirtIOBlockDevice.SaveToStream(const aStream:TStream);
begin
 fStream.Seek(0,soBeginning);
 aStream.Seek(0,soBeginning);
 aStream.CopyFrom(fStream,fStream.Size);
end;

procedure TPasRISCV.TVirtIOBlockDevice.SaveToFile(const aFileName:TPasRISCVUTF8String);
var Stream:TFileStream;
begin
 Stream:=TFileStream.Create(aFileName,fmCreate); // or fmShareDenyWrite);
 try
  SaveToStream(Stream);
 finally
  Stream.Free;
 end;
end;

{ TPasRISCV.TVirtIOInputDevice }

constructor TPasRISCV.TVirtIOInputDevice.Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64;const aKind:TVirtIOInputDevice.TKind);
begin
 inherited Create(aMachine,aBase,aSize,TPasRISCV.TVirtIODevice.TKind.MMIO);
 fKind:=aKind;
 fButtonState:=0;
 fVendorID:=Vendor;
 fDeviceID:=DeviceID;
 fQueues[0].ManualRecv:=true;
 fConfigSpaceSize:=256;
 fDeviceFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1 or
                  //TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX or
                  0;
end;

destructor TPasRISCV.TVirtIOInputDevice.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV.TVirtIOInputDevice.DeviceReset;
begin
 inherited DeviceReset;
 fButtonState:=0;
end;

function TPasRISCV.TVirtIOInputDevice.DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean;
begin
 if aQueueIndex=1 then begin
  ConsumeDescriptor(aQueueIndex,aDescriptorIndex,0);
  UsedRingSync(aQueueIndex);
 end;
 result:=true;
end;

function TPasRISCV.TVirtIOInputDevice.QueueEvent(const aType,aCode:TPasRISCVUInt16;const aValue:TPasRISCVUInt32):Boolean;
var QueueIndex,BufferLength:TPasRISCVUInt64;
    AvailableIndex,DescriptorIndex:TPasRISCVUInt16;
//  Value:TPasRISCVUInt8;
    Queue:PQueue;
    Buffer:array[0..7] of TPasRISCVUInt8;
begin

 result:=false;

 QueueIndex:=0;
 Queue:=@fQueues[QueueIndex];

 DescriptorIndex:=0;

 if fDriverOK and Queue^.Ready then begin

  TPasMPMultipleReaderSingleWriterSpinLock.AcquireWrite(Queue^.Lock);
  try

   Buffer[0]:=TPasRISCVUInt8(aType and $ff);
   Buffer[1]:=TPasRISCVUInt8((aType shr 8) and $ff);

   Buffer[2]:=TPasRISCVUInt8(aCode and $ff);
   Buffer[3]:=TPasRISCVUInt8((aCode shr 8) and $ff);

   Buffer[4]:=TPasRISCVUInt8(aValue and $ff);
   Buffer[5]:=TPasRISCVUInt8((aValue shr 8) and $ff);
   Buffer[6]:=TPasRISCVUInt8((aValue shr 16) and $ff);
   Buffer[7]:=TPasRISCVUInt8((aValue shr 24) and $ff);

   BufferLength:=8;

   if Read16(Queue^.AvailableAddress+2,AvailableIndex) then begin

    if Queue^.ShadowAvailableIndex<>AvailableIndex then begin

     if Read16((Queue^.AvailableAddress+4)+((Queue.ShadowAvailableIndex and (Queue^.Size-1)) shl 1),DescriptorIndex) then begin

      if CopyMemoryToQueue(QueueIndex,DescriptorIndex,0,@Buffer[0],BufferLength) and
         ConsumeDescriptor(QueueIndex,DescriptorIndex,BufferLength) and
         UsedRingSync(QueueIndex) and
         AdvanceShadowAvailableIndex(QueueIndex) then begin
       result:=true;
      end else begin
       NotifyDeviceNeedsReset;
      end;

     end else begin
      NotifyDeviceNeedsReset;
     end;

    end;

   end else begin
    NotifyDeviceNeedsReset;
   end;

  finally
   TPasMPMultipleReaderSingleWriterSpinLock.ReleaseWrite(Queue^.Lock);
  end;

 end;

end;

function TPasRISCV.TVirtIOInputDevice.HandleKeyboard(const aKeyCode:TPasRISCVUInt16;const aDown:Boolean):Boolean;
begin
 result:=QueueEvent(VIRTIO_INPUT_EV_KEY,aKeyCode,ord(aDown) and 1);
 if result then begin
  result:=QueueEvent(VIRTIO_INPUT_EV_SYN,0,0);
 end;
end;

function TPasRISCV.TVirtIOInputDevice.HandleMouse(const aDX,aDY,aDZ:TPasRISCVInt32;const aButtons:TPasRISCVUInt32):Boolean;
var Index:TPasRISCVSizeInt;
    Button,LastButton:Boolean;
begin
 if (fKind=TPasRISCV.TVirtIOInputDevice.TKind.Mouse) or (fKind=TPasRISCV.TVirtIOInputDevice.TKind.Tablet) then begin
  if fKind=TPasRISCV.TVirtIOInputDevice.TKind.Mouse then begin
   result:=QueueEvent(VIRTIO_INPUT_EV_REL,REL_X,aDX);
   if result then begin
    result:=QueueEvent(VIRTIO_INPUT_EV_REL,REL_Y,aDY);
   end;
  end else begin
   result:=QueueEvent(VIRTIO_INPUT_EV_ABS,ABS_X,aDX);
   if result then begin
    result:=QueueEvent(VIRTIO_INPUT_EV_ABS,ABS_Y,aDY);
   end;
  end;
  if result and (aDZ<>0) then begin
   result:=QueueEvent(VIRTIO_INPUT_EV_REL,REL_WHEEL,aDZ);
  end;
  if result and (aButtons<>fButtonState) then begin
   for Index:=0 to 2 do begin
    Button:=(aButtons and (1 shl Index))<>0;
    LastButton:=(fButtonState and (1 shl Index))<>0;
    if Button<>LastButton then begin
     result:=QueueEvent(VIRTIO_INPUT_EV_KEY,ButtonList[Index],ord(Button) and 1);
     if not result then begin
      break;
     end;
    end;
   end;
   fButtonState:=aButtons;
  end;
  if result then begin
   result:=QueueEvent(VIRTIO_INPUT_EV_SYN,0,0);
  end;
 end else begin
  result:=false;
 end;
end;

procedure TPasRISCV.TVirtIOInputDevice.DeviceConfigWrite;
var Name:TPasRISCVRawByteString;
    Index,Len:TPasRISCVSizeInt;
begin
 case fConfigSpace[0] of
  VIRTIO_INPUT_CFG_UNSET:begin
  end;
  VIRTIO_INPUT_CFG_ID_NAME:begin
   case fKind of
    TPasRISCV.TVirtIOInputDevice.TKind.Keyboard:begin
     Name:='virtio_keyboard';
    end;
    TPasRISCV.TVirtIOInputDevice.TKind.Mouse:begin
     Name:='virtio_mouse';
    end;
    TPasRISCV.TVirtIOInputDevice.TKind.Tablet:begin
     Name:='virtio_tablet';
    end;
    else begin
     Name:='';
    end;
   end;
   Len:=length(Name);
   fConfigSpace[2]:=Len;
   for Index:=0 to Len-1 do begin
    fConfigSpace[8+Index]:=TPasRISCVUInt8(Name[Index+1]);
   end;
  end;
  VIRTIO_INPUT_CFG_ID_SERIAL,
  VIRTIO_INPUT_CFG_ID_DEVIDS,
  VIRTIO_INPUT_CFG_PROP_BITS:begin
   fConfigSpace[2]:=0;
  end;
  VIRTIO_INPUT_CFG_EV_BITS:begin
   fConfigSpace[2]:=0;
   case fKind of
    TPasRISCV.TVirtIOInputDevice.TKind.Keyboard:begin
     case fConfigSpace[1] of
      VIRTIO_INPUT_EV_KEY:begin
       fConfigSpace[2]:=128 div 8;
       FillChar(fConfigSpace[8],128 div 8,#$ff);
      end;
      VIRTIO_INPUT_EV_REP:begin
       fConfigSpace[2]:=1;
      end;
      else begin
       fConfigSpace[2]:=0;
      end;
     end;
    end;
    TPasRISCV.TVirtIOInputDevice.TKind.Mouse:begin
     case fConfigSpace[1] of
      VIRTIO_INPUT_EV_KEY:begin
       fConfigSpace[2]:=512 div 8;
       FillChar(fConfigSpace[8],512 div 8,#0);
       for Index:=0 to 2 do begin
        fConfigSpace[8+(ButtonList[Index] shr 3)]:=fConfigSpace[8+(ButtonList[Index] shr 3)] or (1 shl (ButtonList[Index] and 7));
       end;
      end;
      VIRTIO_INPUT_EV_REL:begin
       fConfigSpace[2]:=2;
       fConfigSpace[8]:=0;
       fConfigSpace[9]:=0;
       PPasRISCVUInt32(Pointer(@fConfigSpace[8]))^:=(1 shl REL_X) or (1 shl REL_Y) or (1 shl REL_WHEEL);
      end;
      else begin
       fConfigSpace[2]:=0;
      end;
     end;
    end;
    TPasRISCV.TVirtIOInputDevice.TKind.Tablet:begin
     case fConfigSpace[1] of
      VIRTIO_INPUT_EV_KEY:begin
       fConfigSpace[2]:=512 div 8;
       FillChar(fConfigSpace[8],512 div 8,#0);
       for Index:=0 to 2 do begin
        fConfigSpace[8+(ButtonList[Index] shr 3)]:=fConfigSpace[8+(ButtonList[Index] shr 3)] or (1 shl (ButtonList[Index] and 7));
       end;
      end;
      VIRTIO_INPUT_EV_REL:begin
       fConfigSpace[2]:=2;
       fConfigSpace[8]:=0;
       fConfigSpace[9]:=0;
       PPasRISCVUInt32(Pointer(@fConfigSpace[8]))^:=1 shl REL_WHEEL;
      end;
      VIRTIO_INPUT_EV_ABS:begin
       fConfigSpace[2]:=1;
       PPasRISCVUInt32(Pointer(@fConfigSpace[8]))^:=(1 shl ABS_X) or (1 shl ABS_Y);
      end;
      else begin
       fConfigSpace[2]:=0;
      end;
     end;
    end;
    else begin
     fConfigSpace[2]:=0;
    end;
   end;
  end;
  VIRTIO_INPUT_CFG_ABS_INFO:begin
   if (fKind=TPasRISCV.TVirtIOInputDevice.TKind.Tablet) and (fConfigSpace[1]<=1) then begin
    fConfigSpace[2]:=5*4;
    PPasRISCVUInt32(Pointer(@fConfigSpace[8]))^:=0; // min
    PPasRISCVUInt32(Pointer(@fConfigSpace[12]))^:=VIRTIO_INPUT_ABS_SCALE-1; // max
    PPasRISCVUInt32(Pointer(@fConfigSpace[16]))^:=0; // fuzz
    PPasRISCVUInt32(Pointer(@fConfigSpace[20]))^:=0; // flat
    PPasRISCVUInt32(Pointer(@fConfigSpace[24]))^:=0; // res
   end;
  end;
  else begin
   fConfigSpace[2]:=0;
  end;
 end;
end;

{ TPasRISCV.TVirtIOInputKeyboardDevice }

constructor TPasRISCV.TVirtIOInputKeyboardDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fVirtIOInputKeyboardBase,aMachine.fConfiguration.fVirtIOInputKeyboardSize,TVirtIOInputDevice.TKind.Keyboard);
 fIRQ:=aMachine.fConfiguration.fVirtIOInputKeyboardIRQ;
end;

procedure TPasRISCV.TVirtIOInputKeyboardDevice.DeviceInitialize;
begin
 if assigned(fMachine) and assigned(fMachine.fPS2KeyboardDevice) and fMachine.fPS2KeyboardDevice.fActive then begin
  fMachine.fPS2KeyboardDevice.fActive:=false;
 end;
end;

{ TPasRISCV.TVirtIOInputMouseDevice }

constructor TPasRISCV.TVirtIOInputMouseDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fVirtIOInputMouseBase,aMachine.fConfiguration.fVirtIOInputMouseSize,TVirtIOInputDevice.TKind.Mouse);
 fIRQ:=aMachine.fConfiguration.fVirtIOInputMouseIRQ;
end;

procedure TPasRISCV.TVirtIOInputMouseDevice.DeviceInitialize;
begin
 if assigned(fMachine) and assigned(fMachine.fPS2MouseDevice) and fMachine.fPS2MouseDevice.fActive then begin
  fMachine.fPS2MouseDevice.fActive:=false;
 end;
end;

{ TPasRISCV.TVirtIOInputTabletDevice }

// TODO

{ TPasRISCV.TVirtIOSoundDevice.TPCMBuffer }

constructor TPasRISCV.TVirtIOSoundDevice.TPCMBuffer.Create(const aDevice:TVirtIOSoundDevice);
begin
 inherited Create;
 fDevice:=aDevice;
 fData:=nil;
 fFloatData:=nil;
 fResampledFloatData:=nil;
end;

destructor TPasRISCV.TVirtIOSoundDevice.TPCMBuffer.Destroy;
begin
 fData:=nil;
 fFloatData:=nil;
 fResampledFloatData:=nil;
 inherited Destroy;
end;

procedure TPasRISCV.TVirtIOSoundDevice.TPCMBuffer.Clear;
begin
 fData:=nil;
 fFloatData:=nil;
 fResampledFloatData:=nil;
end;

{ TPasRISCV.TVirtIOSoundDevice.TPCMStream }

procedure TPasRISCV.TVirtIOSoundDevice.TPCMStream.ReturnBuffer(const aPCMBuffer:TPCMBuffer;const aLock:Boolean);
begin
 if assigned(aPCMBuffer) then begin
  if aLock then begin
   fBufferQueueLock.Acquire;
  end;
  try
   fBufferFreeQueue.Enqueue(aPCMBuffer);
  finally
   if aLock then begin
    fBufferQueueLock.Leave;
   end;
  end;
 end;
end;

{ TPasRISCV.TVirtIOSoundDevice }

constructor TPasRISCV.TVirtIOSoundDevice.Create(const aMachine:TPasRISCV;const aSoundIO:TSoundIO);
var Index:TPasRISCVSizeInt;
    Stream:TPCMStream;
    DefaultParams:TVirtIOSoundPCMSetParams;
begin

 inherited Create(aMachine,aMachine.fConfiguration.fVirtIOSoundBase,aMachine.fConfiguration.fVirtIOSoundSize,TVirtIODevice.TKind.MMIO);

 fIRQ:=aMachine.fConfiguration.fVirtIOSoundIRQ;

 fUseQueueDescriptorCaching:=true;

 fDeviceID:=TVirtIOSoundDevice.DeviceID;

 fSoundIO:=aSoundIO;

 fSoundConfig.Jacks:=2;
 fSoundConfig.Streams:=2;
 fSoundConfig.ChannelMaps:=1;
 fSoundConfig.Controls:=0;

 fConfigSpaceSize:=SizeOf(TVirtIOSoundConfig);
 Move(fSoundConfig,fConfigSpace[0],SizeOf(TVirtIOSoundConfig));

 fDeviceFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1 or
                  //TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX or
                  0;

 fQueues[VIRTIO_SND_VQ_CONTROL].ManualRecv:=false;
 fQueues[VIRTIO_SND_VQ_CONTROL].Asynchronous:=false;

 fQueues[VIRTIO_SND_VQ_EVENT].ManualRecv:=false;
 fQueues[VIRTIO_SND_VQ_EVENT].Asynchronous:=false;

 fQueues[VIRTIO_SND_VQ_TX].ManualRecv:=false;
 fQueues[VIRTIO_SND_VQ_TX].Asynchronous:=true;

 fQueues[VIRTIO_SND_VQ_RX].ManualRecv:=false;
 fQueues[VIRTIO_SND_VQ_RX].Asynchronous:=true;

 fCommandQueueLock:=TPasMPCriticalSection.Create;

 fPCMStreams:=nil;

 SetLength(fPCMStreams,fSoundConfig.Streams);

 DefaultParams.Header.Header.Code:=0;
 DefaultParams.Header.StreamID:=0;
 DefaultParams.BufferBytes:=8192;
 DefaultParams.PeriodBytes:=2048;
 DefaultParams.Features:=0;
 DefaultParams.Channels:=2;
 DefaultParams.Format:=VIRTIO_SND_PCM_FMT_S16;
 DefaultParams.Rate:=VIRTIO_SND_PCM_RATE_48000;

 for Index:=0 to fSoundConfig.Streams-1 do begin
  Stream:=TPCMStream.Create;
  try
   Stream.fDevice:=self;
   Stream.fCommand:=TPCMStream.TCommand.None;
   Stream.fActive:=false;
   Stream.fParams:=DefaultParams;
   Stream.fCurrentBuffer:=nil;
   Stream.fLock:=TPasMPCriticalSection.Create;
   Stream.fBufferQueueLock:=TPasMPCriticalSection.Create;
   Stream.fBufferQueue.Initialize;
   Stream.fBufferFreeQueue.Initialize;
   Stream.fPCMRingBuffer:=TPCMRingBuffer.Create(192000);
  finally
   fPCMStreams[Index]:=Stream;
  end;
  SetParams(Index,DefaultParams);
 end;

 fTXScratchBuffer:=nil;
 fRXScratchBuffer:=nil;

 fOutputWAVStreamDump:=nil;
//fOutputWAVStreamDump:=TPasRISCVAudioWAVStreamDump.Create(fSoundIO.fSampleRate,TFileStream.Create('a.wav',fmCreate),true);

 // Register our callbacks on the shared TSoundIO
 if assigned(fSoundIO) then begin
  fSoundIO.OnOutputFillBuffer:=OutputAudioFillBufferCallback;
  fSoundIO.OnInputFillBuffer:=InputAudioFillBufferCallback;
 end;

end;

destructor TPasRISCV.TVirtIOSoundDevice.Destroy;
var Index:TPasRISCVSizeInt;
    Stream:TPCMStream;
begin

 FlushTX;

 FlushRX;

 fTXScratchBuffer:=nil;
 fRXScratchBuffer:=nil;

 for Index:=0 to fSoundConfig.Streams-1 do begin
  Stream:=fPCMStreams[Index];
  try
   FreeAndNil(Stream.fCurrentBuffer);
   FreeBufferQueue(Stream.fBufferQueue);
   Stream.fBufferQueue.Finalize;
   Stream.fBufferFreeQueue.Finalize;
   FreeAndNil(Stream.fBufferQueueLock);
   FreeAndNil(Stream.fLock);
   FreeAndNil(Stream.fPCMRingBuffer);
  finally
   try
    FreeAndNil(Stream);
   finally
    fPCMStreams[Index]:=nil;
   end;
  end;
 end;

 fPCMStreams:=nil;

 FreeAndNil(fCommandQueueLock);

 FreeAndNil(fOutputWAVStreamDump);

 inherited Destroy;
end;

function TPasRISCV.TVirtIOSoundDevice.SetParams(const aStreamID:TPasRISCVUInt32;const aParams:TVirtIOSoundPCMSetParams):TPasRISCVUInt32;
var Params:PVirtIOSoundPCMSetParams;
begin
 if (aParams.Channels<1) or (aParams.Channels>2) then begin
  result:=VIRTIO_SND_S_NOT_SUPP;
 end else if (SupportedFormats and (TPasRISCVUInt64(1) shl aParams.Format))=0 then begin
  result:=VIRTIO_SND_S_NOT_SUPP;
 end else if (SupportedRates and (TPasRISCVUInt64(1) shl aParams.Rate))=0 then begin
  result:=VIRTIO_SND_S_NOT_SUPP;
 end else begin
  Params:=@fPCMStreams[aStreamID].fParams;
  Params^.BufferBytes:=aParams.BufferBytes;
  Params^.PeriodBytes:=aParams.PeriodBytes;
  Params^.Features:=aParams.Features;
  Params^.Channels:=aParams.Channels;
  Params^.Format:=aParams.Format;
  Params^.Rate:=aParams.Rate;
//writeln(aParams.BufferBytes,' ',aParams.PeriodBytes);
  result:=VIRTIO_SND_S_OK;
 end;
end;

procedure TPasRISCV.TVirtIOSoundDevice.DeviceReset;
begin
 inherited DeviceReset;
end;

function TPasRISCV.TVirtIOSoundDevice.DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean;
var Index:TPasRISCVSizeInt;
    SoundHeader:PVirtIOSoundHeader;
    SoundQueryInfo:PVirtIOSoundQueryInfo;
    SoundJackInfo:PVirtIOSoundJackInfo;
    SoundPCMInfo:PVirtIOSoundPCMInfo;
    SoundChMapInfo:PVirtIOSoundChMapInfo;
    SoundPCMSetParams:PVirtIOSoundPCMSetParams;
    SoundPCMHeader:PVirtIOSoundPCMHeader;
    SoundPCMXfer:PVirtIOSoundPCMXfer;
    SoundPCMStatus:TVirtIOSoundPCMStatus;
    Size,Offset:TPasRISCVUInt64;
    Input,Output:PPasRISCVUInt8Array;
    PCMStream:TPCMStream;
    PCMBuffer:TPCMBuffer;
begin

 case aQueueIndex of

  VIRTIO_SND_VQ_CONTROL:begin

   fCommandQueueLock.Acquire;
   try

    if aReadSize>=SizeOf(TVirtIOSoundHeader) then begin

     GetMem(Input,aReadSize);
     try

      if CopyMemoryFromQueue(Input,aQueueIndex,aDescriptorIndex,0,aReadSize) then begin

       SoundHeader:=PVirtIOSoundHeader(@Input[0]);

       case SoundHeader^.Code of

        VIRTIO_SND_R_JACK_INFO:begin
         if aReadSize>=SizeOf(TVirtIOSoundHeader) then begin
          SoundQueryInfo:=PVirtIOSoundQueryInfo(@Input[0]);
          Size:=SizeOf(TVirtIOSoundHeader)+(SizeOf(TVirtIOSoundJackInfo)*SoundQueryInfo^.Count);
          if aWriteSize>=Size then begin
           GetMem(Output,Size);
           try
            Offset:=0;
            PVirtIOSoundHeader(@Output^[Offset])^.Code:=VIRTIO_SND_S_OK;
            inc(Offset,SizeOf(TVirtIOSoundHeader));
            for Index:=0 to SoundQueryInfo^.Count-1 do begin
             SoundJackInfo:=PVirtIOSoundJackInfo(@Output^[Offset]);
             inc(Offset,SizeOf(TVirtIOSoundJackInfo));
             SoundJackInfo^.Header.HDAFunctionGroupNodeID:=0;
             SoundJackInfo^.Features:=0;
             SoundJackInfo^.HDARegDefConfig:=0;
             SoundJackInfo^.HDARegCaps:=0;
             SoundJackInfo^.Connected:=1;
             FillChar(SoundJackInfo^.Padding,SizeOf(SoundJackInfo^.Padding),#0);
            end;
            if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                    ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                    UsedRingSync(aQueueIndex)) then begin
             NotifyDeviceNeedsReset;
            end;
           finally
            FreeMem(Output);
           end;
           result:=true;
          end else begin
           result:=false;
          end;
         end else begin
          result:=false;
         end;
        end;

        VIRTIO_SND_R_JACK_REMAP:begin
         Size:=SizeOf(TVirtIOSoundHeader);
         if Size<aWriteSize then begin
          Size:=aWriteSize;
         end;
         if aWriteSize>=Size then begin
          GetMem(Output,Size);
          try
           FillChar(Output^,Size,#0);
           PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_NOT_SUPP;
           if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                   ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                  UsedRingSync(aQueueIndex)) then begin
            NotifyDeviceNeedsReset;
           end;
          finally
           FreeMem(Output);
          end;
          result:=true;
         end else begin
          result:=false;
         end;
        end;

        VIRTIO_SND_R_PCM_INFO:begin
         if aReadSize>=SizeOf(TVirtIOSoundHeader) then begin
          SoundQueryInfo:=PVirtIOSoundQueryInfo(@Input[0]);
          Size:=SizeOf(TVirtIOSoundHeader)+(SizeOf(TVirtIOSoundPCMInfo)*SoundQueryInfo^.Count);
          if aWriteSize>=Size then begin
           GetMem(Output,Size);
           try
            Offset:=0;
            PVirtIOSoundHeader(@Output^[Offset])^.Code:=VIRTIO_SND_S_OK;
            inc(Offset,SizeOf(TVirtIOSoundHeader));
            for Index:=0 to SoundQueryInfo^.Count-1 do begin
             SoundPCMInfo:=PVirtIOSoundPCMInfo(@Output^[Offset]);
             inc(Offset,SizeOf(TVirtIOSoundPCMInfo));
             SoundPCMInfo^.Header.HDAFunctionGroupNodeID:=0;
             SoundPCMInfo^.Features:=0;
             SoundPCMInfo^.Formats:=SupportedFormats;
             SoundPCMInfo^.Rates:=SupportedRates;
             if Index=0 then begin
              SoundPCMInfo^.Direction:=VIRTIO_SND_D_OUTPUT;
             end else begin
              SoundPCMInfo^.Direction:=VIRTIO_SND_D_INPUT;
             end;
             SoundPCMInfo^.ChannelsMin:=1;
             SoundPCMInfo^.ChannelsMax:=2;
             FillChar(SoundPCMInfo^.Padding,SizeOf(SoundPCMInfo^.Padding),#0);
            end;
            if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                    ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                    UsedRingSync(aQueueIndex)) then begin
             NotifyDeviceNeedsReset;
            end;
           finally
            FreeMem(Output);
           end;
           result:=true;
          end else begin
           result:=false;
          end;
         end else begin
          result:=false;
         end;
        end;

        VIRTIO_SND_R_PCM_SET_PARAMS:begin
         if aReadSize>=SizeOf(TVirtIOSoundPCMSetParams) then begin
          SoundPCMSetParams:=PVirtIOSoundPCMSetParams(@Input[0]);
          Size:=SizeOf(TVirtIOSoundHeader);
          if aWriteSize>=Size then begin
           GetMem(Output,Size);
           try
            if SoundPCMSetParams^.Header.StreamID<fSoundConfig.Streams then begin
             PCMStream:=fPCMStreams[SoundPCMSetParams^.Header.StreamID];
             if PCMStream.fActive then begin
              TPasMPInterlocked.Write(PCMStream.fActive,TPasMPBool32(false));
             end;
             if SoundPCMSetParams^.Header.StreamID=0 then begin
              FlushTX;
             end else begin
              FlushRX;
             end;
             PCMStream.fCommand:=TPCMStream.TCommand.SetParameters;
             PVirtIOSoundHeader(@Output^[0])^.Code:=SetParams(SoundPCMSetParams^.Header.StreamID,SoundPCMSetParams^);
            end else begin
             PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_BAD_MSG;
            end;
            if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                    ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                    UsedRingSync(aQueueIndex)) then begin
             NotifyDeviceNeedsReset;
            end;
           finally
            FreeMem(Output);
           end;
           result:=true;
          end else begin
           result:=false;
          end;
         end else begin
          result:=false;
         end;
        end;

        VIRTIO_SND_R_PCM_PREPARE:begin
         if aReadSize>=SizeOf(TVirtIOSoundPCMHeader) then begin
          SoundPCMHeader:=PVirtIOSoundPCMHeader(@Input[0]);
          Size:=SizeOf(TVirtIOSoundHeader);
          if aWriteSize>=Size then begin
           GetMem(Output,Size);
           try
            if SoundPCMHeader.StreamID<fSoundConfig.Streams then begin
             PCMStream:=fPCMStreams[SoundPCMHeader.StreamID];
             PCMStream.fCommand:=TPCMStream.TCommand.Prepare;
             if PCMStream.fActive then begin
              TPasMPInterlocked.Write(PCMStream.fActive,TPasMPBool32(false));
             end;
             if SoundPCMHeader.StreamID=0 then begin
              FlushTX;
             end else begin
              FlushRX;
             end;
             PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_OK;
            end else begin
             PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_BAD_MSG;
            end;
            if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                    ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                    UsedRingSync(aQueueIndex)) then begin
             NotifyDeviceNeedsReset;
            end;
           finally
            FreeMem(Output);
           end;
           result:=true;
          end else begin
           result:=false;
          end;
         end else begin
          result:=false;
         end;
        end;

        VIRTIO_SND_R_PCM_RELEASE:begin
         if aReadSize>=SizeOf(TVirtIOSoundPCMHeader) then begin
          SoundPCMHeader:=PVirtIOSoundPCMHeader(@Input[0]);
          Size:=SizeOf(TVirtIOSoundHeader);
          if aWriteSize>=Size then begin
           GetMem(Output,Size);
           try
            if SoundPCMHeader.StreamID<fSoundConfig.Streams then begin
             PCMStream:=fPCMStreams[SoundPCMHeader.StreamID];
             PCMStream.fCommand:=TPCMStream.TCommand.Release;
             if PCMStream.fActive then begin
              TPasMPInterlocked.Write(PCMStream.fActive,TPasMPBool32(false));
             end;
             if SoundPCMHeader.StreamID=0 then begin
              FlushTX;
             end else begin
              FlushRX;
             end;
             PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_OK;
            end else begin
             PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_BAD_MSG;
            end;
            if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                    ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                    UsedRingSync(aQueueIndex)) then begin
             NotifyDeviceNeedsReset;
            end;
           finally
            FreeMem(Output);
           end;
           result:=true;
          end else begin
           result:=false;
          end;
         end else begin
          result:=false;
         end;
        end;

        VIRTIO_SND_R_PCM_START:begin
         if aReadSize>=SizeOf(TVirtIOSoundPCMHeader) then begin
          SoundPCMHeader:=PVirtIOSoundPCMHeader(@Input[0]);
          Size:=SizeOf(TVirtIOSoundHeader);
          if aWriteSize>=Size then begin
           GetMem(Output,Size);
           try
            if SoundPCMHeader.StreamID<fSoundConfig.Streams then begin
             PCMStream:=fPCMStreams[SoundPCMHeader.StreamID];
             PCMStream.fCommand:=TPCMStream.TCommand.Start;
             if not PCMStream.fActive then begin
              TPasMPInterlocked.Write(PCMStream.fActive,TPasMPBool32(true));
             end;
             PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_OK;
            end else begin
             PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_BAD_MSG;
            end;
            if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                    ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                    UsedRingSync(aQueueIndex)) then begin
             NotifyDeviceNeedsReset;
            end;
           finally
            FreeMem(Output);
           end;
           result:=true;
          end else begin
           result:=false;
          end;
         end else begin
          result:=false;
         end;
        end;

        VIRTIO_SND_R_PCM_STOP:begin
         if aReadSize>=SizeOf(TVirtIOSoundPCMHeader) then begin
          SoundPCMHeader:=PVirtIOSoundPCMHeader(@Input[0]);
          Size:=SizeOf(TVirtIOSoundHeader);
          if aWriteSize>=Size then begin
           GetMem(Output,Size);
           try
            if SoundPCMHeader.StreamID<fSoundConfig.Streams then begin
             PCMStream:=fPCMStreams[SoundPCMHeader.StreamID];
             PCMStream.fCommand:=TPCMStream.TCommand.Stop;
             if PCMStream.fActive then begin
              TPasMPInterlocked.Write(PCMStream.fActive,TPasMPBool32(false));
             end;
             PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_OK;
            end else begin
             PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_BAD_MSG;
            end;
            if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                    ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                    UsedRingSync(aQueueIndex)) then begin
             NotifyDeviceNeedsReset;
            end;
           finally
            FreeMem(Output);
           end;
           result:=true;
          end else begin
           result:=false;
          end;
         end else begin
          result:=false;
         end;
        end;

        VIRTIO_SND_R_CHMAP_INFO:begin
         if aReadSize>=SizeOf(TVirtIOSoundHeader) then begin
          SoundQueryInfo:=PVirtIOSoundQueryInfo(@Input[0]);
          Size:=SizeOf(TVirtIOSoundHeader)+(SizeOf(TVirtIOSoundChMapInfo)*SoundQueryInfo^.Count);
          if aWriteSize>=Size then begin
           GetMem(Output,Size);
           try
            Offset:=0;
            PVirtIOSoundHeader(@Output^[Offset])^.Code:=VIRTIO_SND_S_OK;
            inc(Offset,SizeOf(TVirtIOSoundHeader));
            for Index:=0 to SoundQueryInfo^.Count-1 do begin
             SoundChMapInfo:=PVirtIOSoundChMapInfo(@Output^[Offset]);
             inc(Offset,SizeOf(TVirtIOSoundChMapInfo));
             SoundChMapInfo^.Header.HDAFunctionGroupNodeID:=0;
             if Index=0 then begin
              SoundChMapInfo^.Direction:=VIRTIO_SND_D_OUTPUT;
             end else begin
              SoundChMapInfo^.Direction:=VIRTIO_SND_D_INPUT;
             end;
             SoundChMapInfo^.Channels:=2;
             FillChar(SoundChMapInfo^.Positions,SizeOf(SoundChMapInfo^.Positions),#0);
             SoundChMapInfo^.Positions[0]:=VIRTIO_SND_CHMAP_FL;
             SoundChMapInfo^.Positions[1]:=VIRTIO_SND_CHMAP_FR;
            end;
            if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                    ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                    UsedRingSync(aQueueIndex)) then begin
             NotifyDeviceNeedsReset;
            end;
           finally
            FreeMem(Output);
           end;
           result:=true;
          end else begin
           result:=false;
          end;
         end else begin
          result:=false;
         end;
        end;

        else begin
         Size:=SizeOf(TVirtIOSoundHeader);
         if Size<aWriteSize then begin
          Size:=aWriteSize;
         end;
         if aWriteSize>=Size then begin
          GetMem(Output,Size);
          try
           FillChar(Output^,Size,#0);
           PVirtIOSoundHeader(@Output^[0])^.Code:=VIRTIO_SND_S_NOT_SUPP;
           if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Output,Size) and
                   ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
                   UsedRingSync(aQueueIndex)) then begin
            NotifyDeviceNeedsReset;
           end;
          finally
           FreeMem(Output);
          end;
          result:=true;
         end else begin
          result:=false;
         end;
        end;

       end;

      end else begin
       NotifyDeviceNeedsReset;
       result:=false;
      end;

     finally
      FreeMem(Input);
     end;

    end else begin
     result:=false;
    end;

   finally
    fCommandQueueLock.Release;
   end;

  end;

  VIRTIO_SND_VQ_EVENT:begin
   if aReadSize>0 then begin
    if ConsumeDescriptor(aQueueIndex,aDescriptorIndex,0) and UsedRingSync(aQueueIndex) then begin
     result:=true;
    end else begin
     NotifyDeviceNeedsReset;
    end;
   end else begin
    result:=false;
   end;
  end;

  VIRTIO_SND_VQ_TX:begin

   if aReadSize>=SizeOf(TVirtIOSoundPCMXfer) then begin

    GetMem(Input,aReadSize);
    try

     if CopyMemoryFromQueue(Input,aQueueIndex,aDescriptorIndex,0,aReadSize) then begin

      SoundPCMXfer:=PVirtIOSoundPCMXfer(@Input[0]);

      Size:=SizeOf(TVirtIOSoundPCMStatus);
      if aWriteSize>=Size then begin

       if SoundPCMXfer.StreamID<fSoundConfig.Streams then begin
        PCMStream:=fPCMStreams[SoundPCMXfer.StreamID];

        PCMBuffer:=nil;

        PCMStream.fBufferQueueLock.Acquire;
        try
         if not PCMStream.fBufferFreeQueue.Dequeue(PCMBuffer) then begin
          PCMBuffer:=TPCMBuffer.Create(self);
         end;
        finally
         PCMStream.fBufferQueueLock.Release;
        end;

        PCMBuffer.fPopulated:=false;
        PCMBuffer.fRawSize:=aReadSize-SizeOf(TVirtIOSoundPCMXfer);
        if length(PCMBuffer.fData)<PCMBuffer.fRawSize then begin
         SetLength(PCMBuffer.fData,PCMBuffer.fRawSize*2);
        end;
        if PCMBuffer.fRawSize>0 then begin
         Move(Input^[SizeOf(TVirtIOSoundPCMXfer)],PCMBuffer.fData[0],PCMBuffer.fRawSize);
        end;
        PCMBuffer.fRemainingSize:=PCMBuffer.fRawSize;
        PCMBuffer.fOffset:=0;
        PCMBuffer.fAvailableIndex:=-1;

        PCMStream.fBufferQueueLock.Acquire;
        try
         PCMStream.fBufferQueue.Enqueue(PCMBuffer);
        finally
         PCMStream.fBufferQueueLock.Release;
        end;

        SoundPCMStatus.Status:=VIRTIO_SND_S_OK;
       end else begin
        SoundPCMStatus.Status:=VIRTIO_SND_S_BAD_MSG;
       end;
       SoundPCMStatus.LatencyBytes:=0;
       if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,@SoundPCMStatus,SizeOf(TVirtIOSoundPCMStatus)) and
               ConsumeDescriptor(aQueueIndex,aDescriptorIndex,SizeOf(TVirtIOSoundPCMStatus)) and
               UsedRingSync(aQueueIndex)) then begin
        NotifyDeviceNeedsReset;
       end;

       result:=true;

      end else begin

       result:=false;

      end;

     end else begin
      NotifyDeviceNeedsReset;
      result:=false;
     end;

    finally
     FreeMem(Input);
    end;

   end else begin
    result:=false;
   end;

  end;

  VIRTIO_SND_VQ_RX:begin
   if aReadSize>0 then begin
    if ConsumeDescriptor(aQueueIndex,aDescriptorIndex,0) and UsedRingSync(aQueueIndex) then begin
     result:=true;
    end else begin
     NotifyDeviceNeedsReset;
     result:=false;
    end;
   end else begin
    result:=false;
   end;
  end;

  else begin
   result:=false;
  end;

 end;

end;

procedure TPasRISCV.TVirtIOSoundDevice.FreeBufferQueue(var aBufferQueue:TPCMBufferQueue);
var PCMBuffer:TPCMBuffer;
begin
 while aBufferQueue.Dequeue(PCMBuffer) do begin
  FreeAndNil(PCMBuffer);
 end;
end;

procedure TPasRISCV.TVirtIOSoundDevice.NotifyTXBuffer(const aPCMBuffer:TPCMBuffer);
var QueueIndex:TPasRISCVUInt64;
    DescriptorIndex:TPasRISCVUInt16;
    Queue:PQueue;
    SoundPCMStatus:TVirtIOSoundPCMStatus;
begin

 if assigned(aPCMBuffer) and (aPCMBuffer.fAvailableIndex>=0) then begin

  QueueIndex:=VIRTIO_SND_VQ_TX;
  Queue:=@fQueues[QueueIndex];

  DescriptorIndex:=0;

  if Queue^.Ready then begin

   TPasMPMultipleReaderSingleWriterSpinLock.AcquireWrite(Queue^.Lock);
   try

    SoundPCMStatus.Status:=VIRTIO_SND_S_OK;
    SoundPCMStatus.LatencyBytes:=0;//aPCMBuffer.fRawSize;

    if Read16((Queue^.AvailableAddress+4)+((aPCMBuffer.fAvailableIndex and (Queue^.Size-1)) shl 1),DescriptorIndex) then begin

     if not (CopyMemoryToQueue(QueueIndex,DescriptorIndex,0,@SoundPCMStatus,SizeOf(TVirtIOSoundPCMStatus)) and
             ConsumeDescriptor(QueueIndex,DescriptorIndex,SizeOf(TVirtIOSoundPCMStatus)) and
             UsedRingSync(QueueIndex)) then begin
      NotifyDeviceNeedsReset;
     end;

    end else begin
     NotifyDeviceNeedsReset;
    end;

    aPCMBuffer.fAvailableIndex:=-1;

   finally
    TPasMPMultipleReaderSingleWriterSpinLock.ReleaseWrite(Queue^.Lock);
   end;

  end;

 end;

end;

procedure TPasRISCV.TVirtIOSoundDevice.FlushTX;
var PCMStream:TPCMStream;
begin
 PCMStream:=fPCMStreams[0];
 PCMStream.fLock.Acquire;
 try
  PCMStream.fBufferQueueLock.Acquire;
  try
   repeat
    if assigned(PCMStream.fCurrentBuffer) then begin
     PCMStream.ReturnBuffer(PCMStream.fCurrentBuffer,false);
    end;
    if PCMStream.fBufferQueue.Dequeue(PCMStream.fCurrentBuffer) then begin
     if assigned(PCMStream.fCurrentBuffer) then begin
      PCMStream.ReturnBuffer(PCMStream.fCurrentBuffer,false);
     end;
    end else begin
     PCMStream.fCurrentBuffer:=nil;
    end;
   until not assigned(PCMStream.fCurrentBuffer);
  finally
   PCMStream.fBufferQueueLock.Leave;
  end;
 finally
  PCMStream.fLock.Leave;
 end;
end;

procedure TPasRISCV.TVirtIOSoundDevice.FlushRX;
begin
end;

procedure TPasRISCV.TVirtIOSoundDevice.OutputAudioFillBufferCallback(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
var Remain,ToDo,Size:TPasRISCVSizeInt;
    PCMStream:TPCMStream;
    PCMBuffer:TPCMBuffer;
    Dest:PPasRISCVUInt8;
    CountAudioSamples,CountResampledAudioSamples:TPasRISCVSizeInt;
begin

 Remain:=aCount*2*SizeOf(TPasRISCVFloat);

 FillChar(aBuffer^,Remain,#0);

 Dest:=aBuffer;

 PCMStream:=fPCMStreams[0];

 PCMStream.fLock.Acquire;
 try

  while (Remain>0) and fQueues[VIRTIO_SND_VQ_TX].Ready do begin

   if not assigned(PCMStream.fCurrentBuffer) then begin
    PCMStream.fBufferQueueLock.Acquire;
    try
     if not PCMStream.fBufferQueue.Dequeue(PCMStream.fCurrentBuffer) then begin
      PCMStream.fCurrentBuffer:=nil;
     end;
    finally
     PCMStream.fBufferQueueLock.Release;
    end;
   end;

   PCMBuffer:=PCMStream.fCurrentBuffer;

   if assigned(PCMBuffer) and (PCMBuffer.fRemainingSize>0) then begin

    if PCMStream.fActive then begin

     if not PCMBuffer.fPopulated then begin
      CountAudioSamples:=GetCountAudioSamples(PCMBuffer.fRawSize,PCMStream.fParams.Channels,PCMStream.fParams.Format);
      begin
       if PCMStream.fParams.Channels<2 then begin
        Size:=CountAudioSamples*2;
       end else begin
        Size:=CountAudioSamples*PCMStream.fParams.Channels;
       end;
       inc(Size,Size);
       if length(fTXScratchBuffer)<Size then begin
        SetLength(fTXScratchBuffer,Size*2);
       end;
      end;
      begin
       Size:=CountAudioSamples*2;
       if length(PCMBuffer.fFloatData)<Size then begin
        SetLength(PCMBuffer.fFloatData,Size*2);
       end;
      end;
      ConvertAudio(@PCMBuffer.fData[0],
                   PCMStream.fParams.Channels,
                   PCMStream.fParams.Format,
                   @PCMBuffer.fFloatData[0],
                   2,
                   TPasRISCV.TVirtIOSoundDevice.VIRTIO_SND_PCM_FMT_FLOAT,
                   @fTXScratchBuffer[0],
                   CountAudioSamples
                  );
      if SampleRates[PCMStream.fParams.Rate]<>fSoundIO.fSampleRate then begin
       CountResampledAudioSamples:=ConvertScale(CountAudioSamples,SampleRates[PCMStream.fParams.Rate],fSoundIO.fSampleRate);
       Size:=CountResampledAudioSamples*2;
       if length(PCMBuffer.fResampledFloatData)<Size then begin
        SetLength(PCMBuffer.fResampledFloatData,Size*2);
       end;
       if length(PCMBuffer.fFloatData)<Size then begin
        SetLength(PCMBuffer.fFloatData,Size*2);
       end;
       ResampleLinear(@PCMBuffer.fFloatData[0],
                      CountAudioSamples,
                      @PCMBuffer.fResampledFloatData[0],
                      CountResampledAudioSamples,
                      2,
                      pointer(@PCMStream.fPreviousFrameEndValues[0]),
                      PCMStream.fResamplerPosition,
                      ConvertScale(TPasRISCVUInt64($100000000),fSoundIO.fSampleRate,SampleRates[PCMStream.fParams.Rate]));
       Move(PCMBuffer.fResampledFloatData[0],PCMBuffer.fFloatData[0],CountResampledAudioSamples*2*SizeOf(TPasRISCVFloat));
       CountAudioSamples:=CountResampledAudioSamples;
      end else begin
       PCMBuffer.fResampledFloatData:=nil;
      end;
      PCMBuffer.fOffset:=0;
      PCMBuffer.fRemainingSize:=CountAudioSamples*2*SizeOf(TPasRISCVFloat);
      PCMBuffer.fPopulated:=true;
      if assigned(fOutputWAVStreamDump) then begin
       fOutputWAVStreamDump.Dump(@PCMBuffer.fFloatData[0],PCMBuffer.fRemainingSize,true);
       fOutputWAVStreamDump.Flush;
      end;
     end;

     if PCMBuffer.fRemainingSize>0 then begin
      repeat
       ToDo:=Remain;
       if ToDo>PCMBuffer.fRemainingSize then begin
        ToDo:=PCMBuffer.fRemainingSize;
       end;
       Move(PPasRISCVUInt8Array(Pointer(@PCMBuffer.fFloatData[0]))^[PCMBuffer.fOffset],Dest^,ToDo);
       inc(Dest,ToDo);
       inc(PCMBuffer.fOffset,ToDo);
       dec(PCMBuffer.fRemainingSize,ToDo);
       dec(Remain,ToDo);
      until (Remain=0) or (PCMBuffer.fRemainingSize=0);
     end;

    end else begin

     PCMBuffer.fRemainingSize:=0;

    end;

    if PCMBuffer.fRemainingSize=0 then begin
//   NotifyTXBuffer(PCMStream.fCurrentBuffer);
     PCMStream.ReturnBuffer(PCMStream.fCurrentBuffer,false);
     PCMStream.fCurrentBuffer:=nil;
    end;

   end else begin
    break;
   end;

  end;

{ if PCMStream.fActive and (Remain>0) then begin
   writeln('!');
  end;}

 finally
  PCMStream.fLock.Leave;
 end;

end;

procedure TPasRISCV.TVirtIOSoundDevice.InputAudioFillBufferCallback(const aBuffer:Pointer;const aCount:TPasRISCVSizeInt);
begin
 FillChar(aBuffer^,aCount*2*SizeOf(TPasRISCVFloat),#0);
end;

{ TPasRISCV.TVirtIO9PDevice.TFIDDescriptors }

constructor TPasRISCV.TVirtIO9PDevice.TFIDDescriptors.Create(const aDevice:TVirtIO9PDevice);
begin
 inherited Create;
 fDevice:=aDevice;
 fHashMap:=TFIDDescriptorHashMap.Create(nil);
 fLock:=TPasMPMultipleReaderSingleWriterLock.Create;
 fFirst:=nil;
 fLast:=nil;
end;

destructor TPasRISCV.TVirtIO9PDevice.TFIDDescriptors.Destroy;
var Current,Next:TFIDDescriptor;
begin
 fLock.AcquireWrite;
 try
  Current:=fFirst;
  while assigned(Current) do begin
   Next:=Current.fNext;
   FreeAndNil(Current);
   Current:=Next;
  end;
  fFirst:=nil;
  fLast:=nil;
 finally
  fLock.ReleaseWrite;
 end;
 FreeAndNil(fLock);
 FreeAndNil(fHashMap);
 inherited Destroy;
end;

function TPasRISCV.TVirtIO9PDevice.TFIDDescriptors.Add(const aFID:TPasRISCVUInt32;const aFile:TPasRISCV9PFileSystem.TFSFile):TFIDDescriptor;
begin
 result:=TFIDDescriptor.Create;
 result.fDevice:=fDevice;
 result.fFID:=aFID;
 result.fFile:=aFile;
 fLock.AcquireWrite;
 try
  if assigned(fLast) then begin
   fLast.fNext:=result;
   result.fPrevious:=fLast;
   fLast:=result;
  end else begin
   fFirst:=result;
   fLast:=result;
  end;
  fHashMap.Add(aFID,result);
 finally
  fLock.ReleaseWrite;
 end;
end;

function TPasRISCV.TVirtIO9PDevice.TFIDDescriptors.Remove(const aFID:TPasRISCVUInt32):TFIDDescriptor;
begin
 fLock.AcquireWrite;
 try
  result:=fHashMap[aFID];
  if assigned(result) then begin
   fHashMap.Delete(aFID);
   if assigned(result.fPrevious) then begin
    result.fPrevious.fNext:=result.fNext;
   end else begin
    fFirst:=result.fNext;
   end;
   if assigned(result.fNext) then begin
    result.fNext.fPrevious:=result.fPrevious;
   end else begin
    fLast:=result.fPrevious;
   end;
  end;
 finally
  fLock.ReleaseWrite;
 end;
end;

function TPasRISCV.TVirtIO9PDevice.TFIDDescriptors.Find(const aFID:TPasRISCVUInt32):TFIDDescriptor;
begin
 fLock.AcquireRead;
 try
  result:=fHashMap[aFID];
 finally
  fLock.ReleaseRead;
 end;
end;

{ TPasRISCV.TVirtIO9PDevice }

constructor TPasRISCV.TVirtIO9PDevice.Create(const aMachine:TPasRISCV);
const MountTag:TPasRISCVRawByteString='extern';
begin

 inherited Create(aMachine,aMachine.fConfiguration.fVirtIO9PBase,aMachine.fConfiguration.fVirtIO9PSize,TVirtIODevice.TKind.MMIO);

 fIRQ:=aMachine.fConfiguration.fVirtIO9PIRQ;

 fFileSystem:=nil;

 fMaximumMessageSize:=8192;

 fDeviceID:=DeviceID;

 fDeviceFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1 or
                  //TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX or
//                TPasRISCV.TVirtIODevice.VIRTIO_F_IN_ORDER or
                  (1 shl 0);

 fQueues[0].ManualRecv:=false;
 fQueues[0].Asynchronous:=false;

 fFIDDescriptors:=TFIDDescriptors.Create(self);

 fRequestInProcess:=false;

 fConfigSpaceSize:=length(MountTag)+2;

 fConfigSpace[0]:=length(MountTag) and $ff;
 fConfigSpace[1]:=(length(MountTag) shr 8) and $ff;
 Move(MountTag[1],fConfigSpace[2],length(MountTag));

 fRecvBuffer:=nil;
 SetLength(fRecvBuffer,65536);

 fSendBuffer:=nil;
 SetLength(fSendBuffer,65536);

 fTempBuffer:=nil;
 SetLength(fTempBuffer,65536);

 fLock:=TPasMPCriticalSection.Create;

end;

destructor TPasRISCV.TVirtIO9PDevice.Destroy;
begin
 FreeAndNil(fFIDDescriptors);
 FreeAndNiL(fLock);
//FreeAndNil(fFileSystem);
 fRecvBuffer:=nil;
 fSendBuffer:=nil;
 fTempBuffer:=nil;
 inherited Destroy;
end;

class function TPasRISCV.TVirtIO9PDevice.Get9POperationName(const aOperation:TPasRISCVUInt32):TPasRISCVRawByteString;
begin
 case aOperation of
  VIRTIO_9P_STATFS:begin
   result:='statfs';
  end;
  VIRTIO_9P_LOPEN:begin
   result:='lopen';
  end;
  VIRTIO_9P_LCREATE:begin
   result:='lcreate';
  end;
  VIRTIO_9P_SYMLINK:begin
   result:='symlink';
  end;
  VIRTIO_9P_MKNOD:begin
   result:='mknod';
  end;
  VIRTIO_9P_READLINK:begin
   result:='readlink';
  end;
  VIRTIO_9P_GETATTR:begin
   result:='getattr';
  end;
  VIRTIO_9P_SETATTR:begin
   result:='setattr';
  end;
  VIRTIO_9P_XATTRWALK:begin
   result:='xattrwalk';
  end;
  VIRTIO_9P_READDIR:begin
   result:='readdir';
  end;
  VIRTIO_9P_FSYNC:begin
   result:='fsync';
  end;
  VIRTIO_9P_LOCK:begin
   result:='lock';
  end;
  VIRTIO_9P_GETLOCK:begin
   result:='getlock';
  end;
  VIRTIO_9P_LINK:begin
   result:='link';
  end;
  VIRTIO_9P_MKDIR:begin
   result:='mkdir';
  end;
  VIRTIO_9P_RENAMEAT:begin
   result:='renameat';
  end;
  VIRTIO_9P_UNLINKAT:begin
   result:='unlinkat';
  end;
  VIRTIO_9P_VERSION:begin
   result:='version';
  end;
  VIRTIO_9P_ATTACH:begin
   result:='attach';
  end;
  VIRTIO_9P_FLUSH:begin
   result:='flush';
  end;
  VIRTIO_9P_WALK:begin
   result:='walk';
  end;
  VIRTIO_9P_READ:begin
   result:='read';
  end;
  VIRTIO_9P_WRITE:begin
   result:='write';
  end;
  VIRTIO_9P_CLUNK:begin
   result:='clunk';
  end;
  else begin
   result:='unknown';
  end;
 end;
end;

procedure TPasRISCV.TVirtIO9PDevice.SendReply(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aID:TPasRISCVUInt8;const aTag:TPasRISCVUInt16;const aPayload:Pointer;const aPayloadSize:TPasRISCVUInt32);
var Buffer:Pointer;
    Size:TPasRISCVSizeUInt;
begin
{$ifdef PasRISCVDebugVirtIO9P}
{if (fMachine.fDebug and VIRTIO_DEBUG_9P)<>0 then}begin
  if aID=6 then begin
   write(' (error)');
  end;
  writeln;
 end;
{$endif}
 if fDriverOK then begin
  Size:=aPayloadSize+7;
  GetMem(Buffer,Size);
  try
   PPasRISCVUInt32(@PPasRISCVUInt8Array(Buffer)^[0])^:=Size;
   PPasRISCVUInt8(@PPasRISCVUInt8Array(Buffer)^[4])^:=aID+1;
   PPasRISCVUInt16(@PPasRISCVUInt8Array(Buffer)^[5])^:=aTag;
   Move(aPayload^,PPasRISCVUInt8Array(Buffer)^[7],aPayloadSize);
   if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,Buffer,Size) and
           ConsumeDescriptor(aQueueIndex,aDescriptorIndex,Size) and
           UsedRingSync(aQueueIndex)) then begin
    NotifyDeviceNeedsReset;
   end;
  finally
   FreeMem(Buffer);
  end;
 end;
end;

procedure TPasRISCV.TVirtIO9PDevice.SendError(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aTag:TPasRISCVUInt16;const aError:TPasRISCVInt32);
var Buffer:array[0..3] of TPasRISCVUInt8;
    Size:TPasRISCVSizeInt;
    Val32:TPasRISCVUInt32;
begin
 Val32:=-aError;
 Size:=0;
 Marshall(@Buffer[0],SizeOf(Buffer),Size,'w',[@Val32]);
 SendReply(aQueueIndex,aDescriptorIndex,6,aTag,@Buffer[0],Size);
end;

procedure TPasRISCV.TVirtIO9PDevice.OpenReply(const aQID:TPasRISCV9PFileSystem.PFSQID;const aError:TPasRISCVInt32;const aOpenInfo:POpenInfo);
var Buffer:array[0..31] of TPasRISCVUInt8;
    Size:TPasRISCVSizeInt;
    Val32:TPasRISCVUInt32;
begin
 try
  if aError<0 then begin
   SendError(aOpenInfo^.QueueIndex,aOpenInfo^.DescriptorIndex,aOpenInfo^.Tag,aError);
  end else begin
   Val32:=fMaximumMessageSize-24;
   Size:=0;
   Marshall(@Buffer[0],SizeOf(Buffer),Size,'Qw',[aQID,@Val32]);
   SendReply(aOpenInfo^.QueueIndex,aOpenInfo^.DescriptorIndex,12,aOpenInfo^.Tag,@Buffer[0],Size);
  end;
 finally
  FreeMem(aOpenInfo);
 end;
end;

procedure TPasRISCV.TVirtIO9PDevice.OpenCallback(const aFileSystem:TPasRISCV9PFileSystem;const aQID:TPasRISCV9PFileSystem.PFSQID;const aError:TPasRISCVUInt32;const aOpaque:Pointer);
var OpenInfo:POpenInfo;
begin
 OpenInfo:=POpenInfo(aOpaque);
 OpenReply(aQID,aError,OpenInfo);
 fRequestInProcess:=false;
//DeviceNotify(OpenInfo^.QueueIndex);
end;

procedure TPasRISCV.TVirtIO9PDevice.DeviceReset;
begin
 inherited DeviceReset;
 fRequestInProcess:=false;
end;

function TPasRISCV.TVirtIO9PDevice.DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean;
const Val32Zero:TPasRISCVUInt32=0;
      Val64Zero:TPasRISCVUInt64=0;
      Val32MaxFileNameLength:TPasRISCVUInt32=256;
      HeaderLength=4+1+2;
var Index,RecvBufferOffset,SendBufferLength:TPasRISCVSizeInt;
    FID,AFID,NewFID,Flags,Mode,UID,GID,Val32,Major,Minor:TPasRISCVUInt32;
    Mask,ATimeSec,ATimeNSec,MTimeSec,MTimeNSec,CTimeSec,CTimeNSec,Size:TPasRISCVUInt64;
    StatData:TPasRISCV9PFileSystem.TFSStat;
    Error:TPasRISCVInt32;
    Count:TPasRISCVInt64;
    FSOffset:TPasRISCVUInt64;
    Val8,ID:TPasRISCVUInt8;
    Val16:TPasRISCVUInt16;
    Tag,OldTag,NWName:TPasRISCVUInt16;
    StatFS:TPasRISCV9PFileSystem.TFSStatFS;
    FIDDescriptor,OtherFIDDescriptor:TFIDDescriptor;
    OpenInfo:POpenInfo;
    QID:TPasRISCV9PFileSystem.TFSQID;
    QIDs:array of TPasRISCV9PFileSystem.TFSQID;
    Lock:TPasRISCV9PFileSystem.TFSLock;
    File_:TPasRISCV9PFileSystem.TFSFile;
    NameString,OtherNameString,VersionString,UserNameString,AuthNameString:TPasRISCVRawByteString;
    Names:array of TPasRISCVRawByteString;
begin

 result:=false;

 if aQueueIndex<>0 then begin

  result:=true;

 end else if not fRequestInProcess then begin

  if aReadSize>=HeaderLength then begin

   fLock.Acquire;
   try

    if length(fRecvBuffer)<aReadSize then begin
     SetLength(fRecvBuffer,aReadSize);
    end;

    if CopyMemoryFromQueue(@fRecvBuffer[0],aQueueIndex,aDescriptorIndex,0,aReadSize) then begin

     ID:=PPasRISCVUInt8(Pointer(@fRecvBuffer[4]))^;
     Tag:=PPasRISCVUInt16(Pointer(@fRecvBuffer[5]))^;
     RecvBufferOffset:=HeaderLength;

  {$ifdef PasRISCVDebugVirtIO9P}
 {   if (fMachine.fDebug and VIRTIO_DEBUG_9P)<>0 then}begin
      write('9p: op=',Get9POperationName(ID));
     end;
  {$endif}

     case ID of

      VIRTIO_9P_STATFS:begin
       if assigned(fFileSystem) then begin
        fFileSystem.StatFS(StatFS);
        SendBufferLength:=0;
        Marshall(@fSendBuffer[0],
                 length(fSendBuffer),
                 SendBufferLength,
                 'wwddddddw',
                 [@Val32Zero,
                  @StatFS.BSize,
                  @StatFS.Blocks,
                  @StatFS.BFree,
                  @StatFS.BAvail,
                  @StatFS.Files,
                  @StatFS.FFree,
                  @Val64Zero,
                  @Val32MaxFileNameLength]);
        SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_LOPEN:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'ww',[@FID,@Flags]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         GetMem(OpenInfo,SizeOf(TOpenInfo));
         OpenInfo^.QueueIndex:=aQueueIndex;
         OpenInfo^.DescriptorIndex:=aDescriptorIndex;
         OpenInfo^.Tag:=Tag;
         Error:=fFileSystem.Open(@QID,FIDDescriptor.fFile,Flags,OpenCallback,OpenInfo);
         if Error<=0 then begin
          OpenReply(@QID,Error,OpenInfo);
         end else begin
          fRequestInProcess:=true;
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_LCREATE:begin
       NameString:='';
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wswww',[@FID,@NameString,@Mode,@Flags,@GID]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Error:=fFileSystem.Create_(@QID,FIDDescriptor.fFile,NameString,Flags,Mode,GID);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          Val32:=fMaximumMessageSize-24;
          SendBufferLength:=0;
          Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'Qw',[@QID,@Val32]);
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_SYMLINK:begin
       NameString:='';
       OtherNameString:='';
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wssw',[@FID,@NameString,@OtherNameString,@GID]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Error:=fFileSystem.Symlink(@QID,FIDDescriptor.fFile,NameString,OtherNameString,GID);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          SendBufferLength:=0;
          Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'Q',[@QID]);
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_MKNOD:begin
       NameString:='';
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wswwww',[@FID,@NameString,@Mode,@Major,@Minor,@GID]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Error:=fFileSystem.Mknod(@QID,FIDDescriptor.fFile,NameString,Mode,Major,Minor,GID);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          SendBufferLength:=0;
          Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'Q',[@QID]);
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_READLINK:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'w',[@FID]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         FillChar(fTempBuffer[0],1025,#0);
         Error:=fFileSystem.ReadLink(@fTempBuffer[0],1024,FIDDescriptor.fFile);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          NameString:=TPasRISCVRawByteString(PAnsiChar(Pointer(@fTempBuffer[0])));
          try
           SendBufferLength:=0;
           Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'s',[@NameString]);
          finally
           NameString:='';
          end;
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_GETATTR:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wd',[@FID,@Mask]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         FillChar(StatData,SizeOf(StatData),#0);
         Error:=fFileSystem.Stat(FIDDescriptor.fFile,StatData);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          ATimeNSec:=StatData.ATimeNSec;
          MTImeNSec:=StatData.MTimeNSec;
          CTimeNSec:=StatData.CTimeNSec;
          SendBufferLength:=0;
          Marshall(@fSendBuffer[0],
                   length(fSendBuffer),
                   SendBufferLength,
                   'dQwwwddddddddddddddd',
                   [@Mask,
                    @StatData.QID,
                    @StatData.Mode,
                    @StatData.UID,
                    @StatData.GID,
                    @StatData.NLink,
                    @StatData.RDev,
                    @StatData.Size,
                    @StatData.BlkSize,
                    @StatData.Blocks,
                    @StatData.ATimeSec,
                    @ATimeNSec,
                    @StatData.MTimeSec,
                    @MTimeNSec,
                    @StatData.CTimeSec,
                    @CTimeNSec,
                    @Val64Zero,
                    @Val64Zero,
                    @Val64Zero,
                    @Val64Zero]);
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_SETATTR:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wwwwwddddd',[@FID,@Mask,@Mode,@UID,@GID,@Size,@ATimeSec,@ATimeNSec,@MTimeSec,@MTimeNSec]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         CTimeSec:=MTimeSec;
         CTimeNSec:=MTimeNSec;
         Error:=fFileSystem.SetAttr(FIDDescriptor.fFile,Mask,Mode,UID,GID,Size,ATimeSec,ATimeNSec,MTimeSec,MTimeNSec,CTimeSec,CTimeNSec);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,nil,0);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_XATTRWALK:begin
       SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_ENOTSUP);
      end;

      VIRTIO_9P_READDIR:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wdw',[@FID,@FSOffset,@Val32]) then begin
        Size:=Val32;
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         if length(fSendBuffer)<Size+4 then begin
          SetLength(fSendBuffer,(Size+4)*2);
         end;
         FillChar(fSendBuffer[0],Size+4,#0);
         Count:=fFileSystem.ReadDir(FIDDescriptor.fFile,FSOffset,@fSendBuffer[4],Size);
         if Count<0 then begin
          Error:=Count;
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          PPasRISCVUInt32(Pointer(@fSendBuffer[0]))^:=Count;
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],Count+4);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_FSYNC:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'w',[@FID]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         // Ignored for now
         SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,nil,0);
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_LOCK:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wbwddws',[@FID,@Lock.Type_,@Lock.Flags,@Lock.Start,@Lock.Length,@Lock.ProcID,@Lock.ClientID]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Lock.ClientID:=nil;
         try
          Error:=fFileSystem.Lock(FIDDescriptor.fFile,@Lock);
          if Error<0 then begin
           SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
          end else begin
           Val8:=Error;
           SendBufferLength:=0;
           Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'b',[@Val8]);
           SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
          end;
         finally
          if assigned(Lock.ClientID) then begin
           try
            FreeMem(Lock.ClientID);
           finally
            Lock.ClientID:=nil;
           end;
          end;
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_GETLOCK:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wbddws',[@FID,@Lock.Type_,@Lock.Start,@Lock.Length,@Lock.ProcID,@Lock.ClientID]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Lock.ClientID:=nil;
         try
          Error:=fFileSystem.GetLock(FIDDescriptor.fFile,@Lock);
          if Error<0 then begin
           SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
          end else begin
           SendBufferLength:=0;
           Marshall(@fSendBuffer[0],
                    length(fSendBuffer),
                    SendBufferLength,
                    'bddws',
                    [@Lock.Type_,
                     @Lock.Start,
                     @Lock.Length,
                     @Lock.ProcID,
                     @Lock.ClientID]);
           SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
          end;
         finally
          if assigned(Lock.ClientID) then begin
           try
            FreeMem(Lock.ClientID);
           finally
            Lock.ClientID:=nil;
           end;
          end;
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_LINK:begin
       NameString:='';
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wws',[@FID,@FID,@NameString]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Error:=fFileSystem.Link(FIDDescriptor.fFile,FIDDescriptor.fFile,NameString);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,nil,0);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_MKDIR:begin
       NameString:='';
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wsww',[@FID,@NameString,@Mode,@GID]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Error:=fFileSystem.MkDir(@QID,FIDDescriptor.fFile,NameString,Mode,GID);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          SendBufferLength:=0;
          Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'Q',[@QID]);
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_RENAMEAT:begin
       NameString:='';
       OtherNameString:='';
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wsws',[@FID,@NameString,@NewFID,@OtherNameString]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        OtherFIDDescriptor:=fFIDDescriptors.Find(NewFID);
        if assigned(FIDDescriptor) and assigned(OtherFIDDescriptor) then begin
         Error:=fFileSystem.RenameAt(FIDDescriptor.fFile,NameString,OtherFIDDescriptor.fFile,OtherNameString);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,nil,0);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_UNLINKAT:begin
       NameString:='';
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wsw',[@FID,@NameString,@Flags]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Error:=fFileSystem.UnlinkAt(FIDDescriptor.fFile,NameString);
         if Error<0 then begin
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,nil,0);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_VERSION:begin
       VersionString:='';
       if Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'ws',[@Val32,@VersionString]) then begin
        fMaximumMessageSize:=Val32;
        VersionString:='9P2000.L';
        SendBufferLength:=0;
        Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'ws',[@fMaximumMessageSize,@VersionString]);
        SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_ATTACH:begin
       UserNameString:='';
       AuthNameString:='';
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wwssw',[@FID,@AFID,@UserNameString,@AuthNameString,@UID]) then begin
        Error:=fFileSystem.Attach(File_,@QID,UID,UserNameString,AuthNameString);
        if Error<0 then begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
        end else begin
         fFIDDescriptors.Add(FID,File_);
         SendBufferLength:=0;
         Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'Q',[@QID]);
         SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_FLUSH:begin
       if Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'h',[@OldTag]) then begin
        // Ignored for now
        SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,nil,0);
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_WALK:begin
       FID:=0;
       NewFID:=0;
       NWName:=0;
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wwh',[@FID,@NewFID,@NWName]) then begin
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         QIDs:=nil;
         try
          SetLength(QIDs,NWName);
          Names:=nil;
          try
           SetLength(Names,NWName);
           Error:=0;
           for Index:=0 to TPasRISCVSizeInt(NWName)-1 do begin
            NameString:='';
            if Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'s',[@NameString]) then begin
             Names[Index]:=NameString;
             NameString:='';
            end else begin
             Error:=-TPasRISCV9PFileSystem.P9_EPROTO;
             break;
            end;
           end;
           if Error=0 then begin
            Count:=fFileSystem.Walk(File_,@QIDs[0],FIDDescriptor.fFile,NWName,Names);
            if Count>=0 then begin
             Val16:=Count;
             SendBufferLength:=0;
             Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'h',[@Val16]);
             for Index:=0 to Count-1 do begin
              Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'Q',[@QIDs[Index]]);
             end;
             fFIDDescriptors.Add(NewFID,File_);
             SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
            end else begin
             Error:=Count;
             SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
            end;
           end else begin
            SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
           end;
          finally
           try
            for Index:=0 to TPasRISCVSizeInt(NWName)-1 do begin
             Names[Index]:='';
            end;
           finally
            Names:=nil;
           end;
          end;
         finally
          QIDs:=nil;
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_READ:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wdw',[@FID,@FSOffset,@Val32]) then begin
        Size:=Val32;
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         if length(fSendBuffer)<Size+4 then begin
          SetLength(fSendBuffer,(Size+4)*2);
         end;
         FillChar(fSendBuffer[0],Size+4,#0);
         Count:=fFileSystem.Read(FIDDescriptor.fFile,FSOffset,@fSendBuffer[4],Size);
         if Count<0 then begin
          Error:=Count;
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          PPasRISCVUInt32(Pointer(@fSendBuffer[0]))^:=Count;
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],Count+4);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_WRITE:begin
       if assigned(fFileSystem) and Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'wdw',[@FID,@FSOffset,@Val32]) then begin
        Size:=Val32;
        FIDDescriptor:=fFIDDescriptors.Find(FID);
        if assigned(FIDDescriptor) then begin
         Count:=fFileSystem.Write(FIDDescriptor.fFile,FSOffset,@fRecvBuffer[RecvBufferOffset],Size);
         if Count<0 then begin
          Error:=Count;
          SendError(aQueueIndex,aDescriptorIndex,Tag,Error);
         end else begin
          Val32:=Count;
          SendBufferLength:=0;
          Marshall(@fSendBuffer[0],length(fSendBuffer),SendBufferLength,'w',[@Val32]);
          SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,@fSendBuffer[0],SendBufferLength);
         end;
        end else begin
         SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
        end;
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      VIRTIO_9P_CLUNK:begin
       if Unmarshall(@fRecvBuffer[0],aReadSize,RecvBufferOffset,'w',[@FID]) then begin
        fFIDDescriptors.Remove(FID);
        SendReply(aQueueIndex,aDescriptorIndex,ID,Tag,nil,0);
       end else begin
        SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
       end;
      end;

      else begin
       SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
      end;

     end;

    end else begin
     NotifyDeviceNeedsReset;
     SendError(aQueueIndex,aDescriptorIndex,Tag,-TPasRISCV9PFileSystem.P9_EPROTO);
    end;

   finally
    fLock.Release;
   end;

  end else begin

   result:=false;

  end;

 end else begin

  result:=false;

 end;

end;

{ TPasRISCV.TVirtIONetDevice }

constructor TPasRISCV.TVirtIONetDevice.Create(const aMachine:TPasRISCV);
begin

 inherited Create(aMachine,aMachine.fConfiguration.fVirtIONetBase,aMachine.fConfiguration.fVirtIONetSize,TVirtIODevice.TKind.MMIO);

 fIRQ:=aMachine.fConfiguration.fVirtIONetIRQ;

 fDeviceID:=DeviceID;

 fDeviceFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1 or
                  //TPasRISCV.TVirtIODevice.VIRTIO_F_EVENT_IDX or
                  VIRTIO_NET_F_MAC {or VIRTIO_NET_F_STATUS};

 fQueues[0].ManualRecv:=true;
 fQueues[0].Asynchronous:=false;

 fQueues[1].ManualRecv:=false;
 fQueues[1].Asynchronous:=false;

 FillChar(fConfigSpace[0],8,#0);

 // Initial MAC adresss
 fConfigSpace[0]:=$02;
 fConfigSpace[1]:=$00;
 fConfigSpace[2]:=$00;
 fConfigSpace[3]:=$00;
 fConfigSpace[4]:=$00;
 fConfigSpace[5]:=$01;

 fConfigSpaceSize:=8; // 6 + 2

 fSendBuffer:=nil;
 SetLength(fSendBuffer,65536);

 fReceiveBuffer:=nil;
 SetLength(fReceiveBuffer,65536);

 fEthernetDevice:=nil;

end;

destructor TPasRISCV.TVirtIONetDevice.Destroy;
begin
 fSendBuffer:=nil;
 fReceiveBuffer:=nil;
 fEthernetDevice:=nil;
 inherited Destroy;
end;

procedure TPasRISCV.TVirtIONetDevice.DeviceReset;
begin
 inherited DeviceReset;
end;

function TPasRISCV.TVirtIONetDevice.DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean;
var Header:PVirtIONetHeader;
    Buffer:Pointer;
    Size:TPasRISCVSizeInt;
begin
 case aQueueIndex of
  1:begin
   if length(fReceiveBuffer)<aReadSize then begin
    SetLength(fReceiveBuffer,aReadSize+((aReadSize+1) shr 1));
   end;
   if CopyMemoryFromQueue(fReceiveBuffer,aQueueIndex,aDescriptorIndex,0,aReadSize) then begin
    if aReadSize>=SizeOf(TVirtIONetHeader) then begin
     Header:=pointer(@fReceiveBuffer[0]);
     if (Header^.Flags and VIRTIO_NET_HDR_F_NEEDS_CSUM)<>0 then begin
      // Checksum offload
     end;
     if assigned(fEthernetDevice) then begin
      Size:=aReadSize-SizeOf(TVirtIONetHeader);
      if Size>0 then begin
       Buffer:=@fReceiveBuffer[SizeOf(TVirtIONetHeader)];
       if assigned(fEthernetDevice) then begin
        fEthernetDevice.WritePacket(Buffer,Size);
       end;
      end;
     end;
    end;
    if not (ConsumeDescriptor(aQueueIndex,aDescriptorIndex,0) and
            UsedRingSync(aQueueIndex)) then begin
     NotifyDeviceNeedsReset;
    end;
   end else begin
    NotifyDeviceNeedsReset;
   end;
  end;
  else begin
   // Unknown queue - consume descriptor to avoid hang
   if not (ConsumeDescriptor(aQueueIndex,aDescriptorIndex,0) and
           UsedRingSync(aQueueIndex)) then begin
    NotifyDeviceNeedsReset;
   end;
  end;
 end;
 result:=true;
end;

function TPasRISCV.TVirtIONetDevice.CanWritePacket:Boolean;
var Queue:PQueue;
    AvailableIndex:TPasRISCVUInt16;
begin
 Queue:=@fQueues[0];
 if fDriverOK and Queue^.Ready then begin
  TPasMPMultipleReaderSingleWriterSpinLock.AcquireRead(Queue^.Lock);
  try
   if Read16(Queue^.AvailableAddress+2,AvailableIndex) then begin
    result:=Queue^.ShadowAvailableIndex<>AvailableIndex;
   end else begin
    NotifyDeviceNeedsReset;
    result:=false;
   end;
  finally
   TPasMPMultipleReaderSingleWriterSpinLock.ReleaseRead(Queue^.Lock);
  end;
 end else begin
  result:=false;
 end;
end;

procedure TPasRISCV.TVirtIONetDevice.WritePacket(const aBuffer:Pointer;const aBufferSize:TPasRISCVSizeInt);
var Queue:PQueue;
    Header:PVirtIONetHeader;
    AvailableIndex,DescriptorIndex:TPasRISCVUInt16;
    ReadSize,WriteSize:TPasRISCVUInt64;
    Size:TPasRISCVSizeInt;
begin
 Queue:=@fQueues[0];
 if fDriverOK and Queue^.Ready then begin
  TPasMPMultipleReaderSingleWriterSpinLock.AcquireWrite(Queue^.Lock);
  try
   if Read16(Queue^.AvailableAddress+2,AvailableIndex) then begin
    if Queue^.ShadowAvailableIndex<>AvailableIndex then begin
     if Read16(Queue^.AvailableAddress+4+((Queue^.ShadowAvailableIndex and (Queue^.Size-1)) shl 1),DescriptorIndex) then begin
      if GetDescriptors(ReadSize,WriteSize,0,DescriptorIndex) then begin
       Size:=SizeOf(TVirtIONetHeader)+aBufferSize;
       if Size<=WriteSize then begin
        if length(fSendBuffer)<Size then begin
         SetLength(fSendBuffer,Size+((Size+1) shr 1));
        end;
        Header:=pointer(@fSendBuffer[0]);
        FillChar(Header^,SizeOf(TVirtIONetHeader),#0);
        if aBufferSize>0 then begin
         Move(aBuffer^,fSendBuffer[SizeOf(TVirtIONetHeader)],aBufferSize);
        end;
        if not (CopyMemoryToQueue(0,DescriptorIndex,0,@fSendBuffer[0],Size) and
                ConsumeDescriptor(0,DescriptorIndex,Size) and
                UsedRingSync(0) and
                AdvanceShadowAvailableIndex(0)) then begin
         NotifyDeviceNeedsReset;
        end;
       end;
      end else begin
       NotifyDeviceNeedsReset;
      end;
     end else begin
      NotifyDeviceNeedsReset;
     end;
    end;
   end else begin
    NotifyDeviceNeedsReset;
   end;
  finally
   TPasMPMultipleReaderSingleWriterSpinLock.ReleaseWrite(Queue^.Lock);
  end;
 end;
end;

procedure TPasRISCV.TVirtIONetDevice.SetCarrier(const aCarrierStatus:Boolean);
//var CurrentCarrierStatus:TPasRISCVUInt8;
begin
{CurrentCarrierStatus:=fConfigSpace[6] and 1;
 if CurrentCarrierStatus<>TPasRISCVUInt8(TPasRISCVUInt8(aCarrierStatus) and 1) then begin
  fConfigSpace[6]:=(TPasRISCVUInt8(aCarrierStatus) and 1) shl 0;
  //DeviceChangeNotify;
 end;}
end;

procedure TPasRISCV.TVirtIONetDevice.SetEthernetDevice(const aEthernetDevice:TPasRISCVEthernetDevice);
begin

 if fEthernetDevice<>aEthernetDevice then begin

  // Unassign old Ethernet device callbacks and wipe mac address in config space
  if assigned(fEthernetDevice) then begin

   fEthernetDevice.fOnCanWritePacket:=nil;
   fEthernetDevice.fOnWritePacket:=nil;
   fEthernetDevice.fOnSetCarrier:=nil;

   FillChar(fConfigSpace[0],6,#0);

  end;

  // Assign new Ethernet device
  fEthernetDevice:=aEthernetDevice;

  // Assign new Ethernet device callbacks and copy mac address to config space
  if assigned(fEthernetDevice) then begin

   fEthernetDevice.fOnCanWritePacket:=CanWritePacket;
   fEthernetDevice.fOnWritePacket:=WritePacket;
   fEthernetDevice.fOnSetCarrier:=SetCarrier;

   Move(fEthernetDevice.fMACAddress[0],fConfigSpace[0],SizeOf(TPasRISCVEthernetDevice.TMACAddress));

  end;

 end;

end;

{ TPasRISCV.TVirtIORandomGeneratorDevice }

constructor TPasRISCV.TVirtIORandomGeneratorDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fVirtIORandomGeneratorBase,aMachine.fConfiguration.fVirtIORandomGeneratorSize,TVirtIODevice.TKind.MMIO);

 fIRQ:=aMachine.fConfiguration.fVirtIORandomGeneratorIRQ;

 fDeviceID:=DeviceID;

 fDeviceFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1;

 fQueues[0].ManualRecv:=false;
 fQueues[0].Asynchronous:=false;

 fSendBuffer:=nil;
 SetLength(fSendBuffer,65536);

 fReceiveBuffer:=nil;
 SetLength(fReceiveBuffer,65536);

end;

destructor TPasRISCV.TVirtIORandomGeneratorDevice.Destroy;
begin
 fSendBuffer:=nil;
 fReceiveBuffer:=nil;
 inherited Destroy;
end;

procedure TPasRISCV.TVirtIORandomGeneratorDevice.DeviceReset;
begin
 inherited DeviceReset;
end;

function TPasRISCV.TVirtIORandomGeneratorDevice.DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean;
begin
 if length(fReceiveBuffer)<aReadSize then begin
  SetLength(fReceiveBuffer,aReadSize+((aReadSize+1) shr 1));
 end;
 if CopyMemoryFromQueue(fReceiveBuffer,aQueueIndex,aDescriptorIndex,0,aReadSize) then begin
  if length(fSendBuffer)<aWriteSize then begin
   SetLength(fSendBuffer,aWriteSize+((aWriteSize+1) shr 1));
  end;
  if aWriteSize>0 then begin
   fMachine.fRandomGeneratorLock.Acquire;
   try
    fMachine.fRandomGenerator.GetRandomBytes(fSendBuffer[0],aWriteSize);
   finally
    fMachine.fRandomGeneratorLock.Release;
   end;
  end;
  if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,@fSendBuffer[0],aWriteSize) and
          ConsumeDescriptor(aQueueIndex,aDescriptorIndex,aWriteSize) and
          UsedRingSync(aQueueIndex)) then begin
   NotifyDeviceNeedsReset;
  end;
 end else begin
  NotifyDeviceNeedsReset;
 end;
 result:=true;
end;

{ TPasRISCV.TVirtIOGPUDevice.TGPUResource }

constructor TPasRISCV.TVirtIOGPUDevice.TGPUResource.Create;
begin
 inherited Create;
 ID:=0;
 Width:=0;
 Height:=0;
 Format:=0;
 BytesPerPixel:=0;
 Data:=nil;
 BackingPages:=nil;
end;

destructor TPasRISCV.TVirtIOGPUDevice.TGPUResource.Destroy;
begin
 Data:=nil;
 BackingPages:=nil;
 inherited Destroy;
end;

{ TPasRISCV.TVirtIOGPUDevice }

constructor TPasRISCV.TVirtIOGPUDevice.Create(const aMachine:TPasRISCV);
begin

 inherited Create(aMachine,aMachine.fConfiguration.fVirtIOGPUBase,aMachine.fConfiguration.fVirtIOGPUSize,TVirtIODevice.TKind.MMIO);

 fIRQ:=aMachine.fConfiguration.fVirtIOGPUIRQ;

 fUseQueueDescriptorCaching:=true;

 fDeviceID:=TVirtIOGPUDevice.DeviceID;

 fFrameBuffer:=aMachine.fFrameBufferDevice;
 fFrameBuffer.fAutomaticRefresh:=true;
 fFrameBuffer.fSwapColorChannels:=true;
 fFrameBuffer.fIgnoreDirty:=false;

 fGPUConfig.EventsRead:=0;
 fGPUConfig.EventsClear:=0;
 fGPUConfig.NumScanouts:=VIRTIO_GPU_MAX_SCANOUTS;
 fGPUConfig.NumCapsets:=0;

 fConfigSpaceSize:=SizeOf(TVirtIOGPUConfig);
 Move(fGPUConfig,fConfigSpace[0],SizeOf(TVirtIOGPUConfig));

 fDeviceFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1 or
                  VIRTIO_GPU_F_EDID or
                  0;

 fQueues[VIRTIO_GPU_VQ_CONTROL].ManualRecv:=false;
 fQueues[VIRTIO_GPU_VQ_CONTROL].Asynchronous:=false;

 fQueues[VIRTIO_GPU_VQ_CURSOR].ManualRecv:=false;
 fQueues[VIRTIO_GPU_VQ_CURSOR].Asynchronous:=false;

 fResources:=nil;
 fResourceCount:=0;

 FillChar(fScanouts,SizeOf(TGPUScanouts),#0);
 fScanouts[0].Rect.Width:=fFrameBuffer.fWidth;
 fScanouts[0].Rect.Height:=fFrameBuffer.fHeight;
 fScanouts[0].Enabled:=true;

 fRecvBuffer:=nil;
 SetLength(fRecvBuffer,65536);

 fSendBuffer:=nil;
 SetLength(fSendBuffer,65536);

end;

destructor TPasRISCV.TVirtIOGPUDevice.Destroy;
begin
 DestroyAllResources;
 fResources:=nil;
 fRecvBuffer:=nil;
 fSendBuffer:=nil;
 fFrameBuffer:=nil;
 inherited Destroy;
end;

procedure TPasRISCV.TVirtIOGPUDevice.DeviceReset;
begin
 DestroyAllResources;
 FillChar(fScanouts,SizeOf(TGPUScanouts),#0);
 if assigned(fFrameBuffer) then begin
  fScanouts[0].Rect.Width:=fFrameBuffer.fWidth;
  fScanouts[0].Rect.Height:=fFrameBuffer.fHeight;
  fScanouts[0].Enabled:=true;
 end;
 fGPUConfig.EventsRead:=0;
 Move(fGPUConfig,fConfigSpace[0],SizeOf(TVirtIOGPUConfig));
 inherited DeviceReset;
end;

function TPasRISCV.TVirtIOGPUDevice.FindResource(const aResourceID:TPasRISCVUInt32):TGPUResource;
var Index:TPasRISCVSizeInt;
begin
 result:=nil;
 for Index:=0 to fResourceCount-1 do begin
  if fResources[Index].ID=aResourceID then begin
   result:=fResources[Index];
   exit;
  end;
 end;
end;

function TPasRISCV.TVirtIOGPUDevice.CreateResource(const aResourceID,aWidth,aHeight,aFormat:TPasRISCVUInt32):TGPUResource;
var BPP:TPasRISCVUInt32;
begin
 BPP:=GetFormatBytesPerPixel(aFormat);
 result:=TGPUResource.Create;
 result.ID:=aResourceID;
 result.Width:=aWidth;
 result.Height:=aHeight;
 result.Format:=aFormat;
 result.BytesPerPixel:=BPP;
 SetLength(result.Data,aWidth*aHeight*BPP);
 FillChar(result.Data[0],length(result.Data),#0);
 if fResourceCount>=length(fResources) then begin
  SetLength(fResources,(fResourceCount+1)*2);
 end;
 fResources[fResourceCount]:=result;
 inc(fResourceCount);
end;

procedure TPasRISCV.TVirtIOGPUDevice.DestroyResource(const aResourceID:TPasRISCVUInt32);
var Index,ScanoutIndex:TPasRISCVSizeInt;
begin
 for Index:=0 to fResourceCount-1 do begin
  if fResources[Index].ID=aResourceID then begin
   for ScanoutIndex:=0 to VIRTIO_GPU_MAX_SCANOUTS-1 do begin
    if fScanouts[ScanoutIndex].ResourceID=aResourceID then begin
     fScanouts[ScanoutIndex].ResourceID:=0;
     fScanouts[ScanoutIndex].Enabled:=false;
    end;
   end;
   FreeAndNil(fResources[Index]);
   dec(fResourceCount);
   if Index<fResourceCount then begin
    Move(fResources[Index+1],fResources[Index],(fResourceCount-Index)*SizeOf(TGPUResource));
   end;
   fResources[fResourceCount]:=nil;
   exit;
  end;
 end;
end;

procedure TPasRISCV.TVirtIOGPUDevice.DestroyAllResources;
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to fResourceCount-1 do begin
  FreeAndNil(fResources[Index]);
 end;
 fResourceCount:=0;
end;

function TPasRISCV.TVirtIOGPUDevice.GetFormatBytesPerPixel(const aFormat:TPasRISCVUInt32):TPasRISCVUInt32;
begin
 case aFormat of
  VIRTIO_GPU_FORMAT_B8G8R8A8_UNORM,
  VIRTIO_GPU_FORMAT_B8G8R8X8_UNORM,
  VIRTIO_GPU_FORMAT_A8R8G8B8_UNORM,
  VIRTIO_GPU_FORMAT_X8R8G8B8_UNORM,
  VIRTIO_GPU_FORMAT_R8G8B8A8_UNORM,
  VIRTIO_GPU_FORMAT_X8B8G8R8_UNORM,
  VIRTIO_GPU_FORMAT_A8B8G8R8_UNORM,
  VIRTIO_GPU_FORMAT_R8G8B8X8_UNORM:begin
   result:=4;
  end;
  else begin
   result:=4;
  end;
 end;
end;

procedure TPasRISCV.TVirtIOGPUDevice.SendResponse(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aData:Pointer;const aSize:TPasRISCVUInt64);
begin
 if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,aData,aSize) and
         ConsumeDescriptor(aQueueIndex,aDescriptorIndex,aSize) and
         UsedRingSync(aQueueIndex)) then begin
  NotifyDeviceNeedsReset;
 end;
end;

procedure TPasRISCV.TVirtIOGPUDevice.SendOKNoData(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aHeader:PVirtIOGPUCtrlHeader);
var Response:TVirtIOGPUCtrlHeader;
begin
 FillChar(Response,SizeOf(TVirtIOGPUCtrlHeader),#0);
 Response.CtrlType:=VIRTIO_GPU_RESP_OK_NODATA;
 Response.Flags:=aHeader^.Flags;
 Response.FenceID:=aHeader^.FenceID;
 Response.CtxID:=aHeader^.CtxID;
 SendResponse(aQueueIndex,aDescriptorIndex,@Response,SizeOf(TVirtIOGPUCtrlHeader));
end;

procedure TPasRISCV.TVirtIOGPUDevice.SendError(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aHeader:PVirtIOGPUCtrlHeader;const aErrorCode:TPasRISCVUInt32);
var Response:TVirtIOGPUCtrlHeader;
begin
 FillChar(Response,SizeOf(TVirtIOGPUCtrlHeader),#0);
 Response.CtrlType:=aErrorCode;
 Response.Flags:=aHeader^.Flags;
 Response.FenceID:=aHeader^.FenceID;
 Response.CtxID:=aHeader^.CtxID;
 SendResponse(aQueueIndex,aDescriptorIndex,@Response,SizeOf(TVirtIOGPUCtrlHeader));
end;

procedure TPasRISCV.TVirtIOGPUDevice.HandleGetDisplayInfo(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aHeader:PVirtIOGPUCtrlHeader);
var Response:TVirtIOGPURespDisplayInfo;
    Index:TPasRISCVSizeInt;
begin
 FillChar(Response,SizeOf(TVirtIOGPURespDisplayInfo),#0);
 Response.Header.CtrlType:=VIRTIO_GPU_RESP_OK_DISPLAY_INFO;
 Response.Header.Flags:=aHeader^.Flags;
 Response.Header.FenceID:=aHeader^.FenceID;
 Response.Header.CtxID:=aHeader^.CtxID;
 for Index:=0 to VIRTIO_GPU_MAX_SCANOUTS-1 do begin
  Response.PModes[Index].Rect:=fScanouts[Index].Rect;
  Response.PModes[Index].Enabled:=ord(fScanouts[Index].Enabled);
  Response.PModes[Index].Flags:=0;
 end;
 SendResponse(aQueueIndex,aDescriptorIndex,@Response,SizeOf(TVirtIOGPURespDisplayInfo));
end;

procedure TPasRISCV.TVirtIOGPUDevice.HandleResourceCreate2D(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUResourceCreate2D);
var Resource:TGPUResource;
begin
 if (aCmd^.ResourceID=0) or assigned(FindResource(aCmd^.ResourceID)) then begin
  SendError(aQueueIndex,aDescriptorIndex,@aCmd^.Header,VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID);
  exit;
 end;
 if (aCmd^.Width=0) or (aCmd^.Height=0) then begin
  SendError(aQueueIndex,aDescriptorIndex,@aCmd^.Header,VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER);
  exit;
 end;
 Resource:=CreateResource(aCmd^.ResourceID,aCmd^.Width,aCmd^.Height,aCmd^.Format);
 if assigned(Resource) then begin
  SendOKNoData(aQueueIndex,aDescriptorIndex,@aCmd^.Header);
 end else begin
  SendError(aQueueIndex,aDescriptorIndex,@aCmd^.Header,VIRTIO_GPU_RESP_ERR_OUT_OF_MEMORY);
 end;
end;

procedure TPasRISCV.TVirtIOGPUDevice.HandleResourceUnref(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUResourceUnref);
begin
 if not assigned(FindResource(aCmd^.ResourceID)) then begin
  SendError(aQueueIndex,aDescriptorIndex,@aCmd^.Header,VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID);
  exit;
 end;
 DestroyResource(aCmd^.ResourceID);
 SendOKNoData(aQueueIndex,aDescriptorIndex,@aCmd^.Header);
end;

procedure TPasRISCV.TVirtIOGPUDevice.HandleSetScanout(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUSetScanout);
var Resource:TGPUResource;
begin
 if aCmd^.ScanoutID>=VIRTIO_GPU_MAX_SCANOUTS then begin
  SendError(aQueueIndex,aDescriptorIndex,@aCmd^.Header,VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID);
  exit;
 end;
 if aCmd^.ResourceID=0 then begin
  // Disable scanout
  fScanouts[aCmd^.ScanoutID].ResourceID:=0;
  fScanouts[aCmd^.ScanoutID].Enabled:=false;
  SendOKNoData(aQueueIndex,aDescriptorIndex,@aCmd^.Header);
  exit;
 end;
 Resource:=FindResource(aCmd^.ResourceID);
 if not assigned(Resource) then begin
  SendError(aQueueIndex,aDescriptorIndex,@aCmd^.Header,VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID);
  exit;
 end;
 fScanouts[aCmd^.ScanoutID].ResourceID:=aCmd^.ResourceID;
 fScanouts[aCmd^.ScanoutID].Rect:=aCmd^.Rect;
 fScanouts[aCmd^.ScanoutID].Enabled:=true;
 // Resize framebuffer to match scanout if needed
 if (aCmd^.ScanoutID=0) and
    ((fFrameBuffer.fWidth<>aCmd^.Rect.Width) or
     (fFrameBuffer.fHeight<>aCmd^.Rect.Height)) then begin
  fFrameBuffer.ResizeFrameBuffer(aCmd^.Rect.Width,aCmd^.Rect.Height,Resource.BytesPerPixel);
 end;
 SendOKNoData(aQueueIndex,aDescriptorIndex,@aCmd^.Header);
end;

procedure TPasRISCV.TVirtIOGPUDevice.HandleResourceFlush(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUResourceFlush);
var Resource:TGPUResource;
    ScanoutIndex:TPasRISCVSizeInt;
    SrcX,SrcY,DstX,DstY,CopyWidth,CopyHeight:TPasRISCVUInt32;
    SrcStride,DstStride:TPasRISCVUInt32;
    Row:TPasRISCVUInt32;
    SrcOffset,DstOffset:TPasRISCVUInt64;
begin
 Resource:=FindResource(aCmd^.ResourceID);
 if not assigned(Resource) then begin
  SendError(aQueueIndex,aDescriptorIndex,@aCmd^.Header,VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID);
  exit;
 end;
 // Copy resource data to framebuffer for each scanout using this resource
 for ScanoutIndex:=0 to VIRTIO_GPU_MAX_SCANOUTS-1 do begin
  if fScanouts[ScanoutIndex].Enabled and (fScanouts[ScanoutIndex].ResourceID=aCmd^.ResourceID) then begin
   fFrameBuffer.fLock.AcquireWrite;
   try
    SrcX:=aCmd^.Rect.X;
    SrcY:=aCmd^.Rect.Y;
    DstX:=fScanouts[ScanoutIndex].Rect.X+aCmd^.Rect.X;
    DstY:=fScanouts[ScanoutIndex].Rect.Y+aCmd^.Rect.Y;
    CopyWidth:=aCmd^.Rect.Width;
    CopyHeight:=aCmd^.Rect.Height;
    // Clamp
    if (SrcX+CopyWidth)>Resource.Width then begin
     CopyWidth:=Resource.Width-SrcX;
    end;
    if (SrcY+CopyHeight)>Resource.Height then begin
     CopyHeight:=Resource.Height-SrcY;
    end;
    if (DstX+CopyWidth)>fFrameBuffer.fWidth then begin
     CopyWidth:=fFrameBuffer.fWidth-DstX;
    end;
    if (DstY+CopyHeight)>fFrameBuffer.fHeight then begin
     CopyHeight:=fFrameBuffer.fHeight-DstY;
    end;
    SrcStride:=Resource.Width*Resource.BytesPerPixel;
    DstStride:=fFrameBuffer.fWidth*fFrameBuffer.fBytesPerPixel;
    for Row:=0 to CopyHeight-1 do begin
     SrcOffset:=TPasRISCVUInt64(SrcY+Row)*SrcStride+TPasRISCVUInt64(SrcX)*Resource.BytesPerPixel;
     DstOffset:=TPasRISCVUInt64(DstY+Row)*DstStride+TPasRISCVUInt64(DstX)*fFrameBuffer.fBytesPerPixel;
     if (SrcOffset+(TPasRISCVUInt64(CopyWidth)*Resource.BytesPerPixel))<=length(Resource.Data) then begin
      if (DstOffset+(TPasRISCVUInt64(CopyWidth)*fFrameBuffer.fBytesPerPixel))<=length(fFrameBuffer.fData) then begin
       Move(Resource.Data[SrcOffset],fFrameBuffer.fData[DstOffset],CopyWidth*Resource.BytesPerPixel);
      end;
     end;
    end;
    fFrameBuffer.fDirty:=true;
   finally
    fFrameBuffer.fLock.ReleaseWrite;
   end;
  end;
 end;
 // VSync: Notify host that a new frame is ready
{fFrameBuffer.UpdateOutputData;
 if assigned(fMachine.OnNewFrame) then begin
  fMachine.OnNewFrame();
 end;}
 SendOKNoData(aQueueIndex,aDescriptorIndex,@aCmd^.Header);
end;

procedure TPasRISCV.TVirtIOGPUDevice.HandleTransferToHost2D(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUTransferToHost2D);
var Resource:TGPUResource;
    PageIndex:TPasRISCVSizeInt;
    SrcRow,DstRow:TPasRISCVUInt32;
    SrcStride,DstStride:TPasRISCVUInt32;
    Offset,PageOffset,CopyLen,PageRemain:TPasRISCVUInt64;
    DstOffset:TPasRISCVUInt64;
    ResourceDataSize:TPasRISCVUInt64;
begin
 Resource:=FindResource(aCmd^.ResourceID);
 if not assigned(Resource) then begin
  SendError(aQueueIndex,aDescriptorIndex,@aCmd^.Header,VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID);
  exit;
 end;
 if length(Resource.BackingPages)=0 then begin
  SendError(aQueueIndex,aDescriptorIndex,@aCmd^.Header,VIRTIO_GPU_RESP_ERR_UNSPEC);
  exit;
 end;
 // Copy from guest backing pages to resource pixel data
 DstStride:=Resource.Width*Resource.BytesPerPixel;
 ResourceDataSize:=length(Resource.Data);
 Offset:=aCmd^.Offset;
 for DstRow:=0 to aCmd^.Rect.Height-1 do begin
  DstOffset:=TPasRISCVUInt64(aCmd^.Rect.Y+DstRow)*DstStride+TPasRISCVUInt64(aCmd^.Rect.X)*Resource.BytesPerPixel;
  CopyLen:=TPasRISCVUInt64(aCmd^.Rect.Width)*Resource.BytesPerPixel;
  if (DstOffset+CopyLen)>ResourceDataSize then begin
   break;
  end;
  // Walk backing pages to find source data at Offset
  PageOffset:=Offset;
  PageIndex:=0;
  while (PageIndex<length(Resource.BackingPages)) and (PageOffset>=Resource.BackingPages[PageIndex].Length) do begin
   dec(PageOffset,Resource.BackingPages[PageIndex].Length);
   inc(PageIndex);
  end;
  if PageIndex<length(Resource.BackingPages) then begin
   PageRemain:=Resource.BackingPages[PageIndex].Length-PageOffset;
   if PageRemain>=CopyLen then begin
    CopyMemoryFromRAM(@Resource.Data[DstOffset],Resource.BackingPages[PageIndex].Addr+PageOffset,CopyLen);
   end else begin
    // Span across pages
    CopyMemoryFromRAM(@Resource.Data[DstOffset],Resource.BackingPages[PageIndex].Addr+PageOffset,PageRemain);
    inc(PageIndex);
    if PageIndex<length(Resource.BackingPages) then begin
     CopyMemoryFromRAM(@Resource.Data[DstOffset+PageRemain],Resource.BackingPages[PageIndex].Addr,CopyLen-PageRemain);
    end;
   end;
  end;
  inc(Offset,DstStride);
 end;
 SendOKNoData(aQueueIndex,aDescriptorIndex,@aCmd^.Header);
end;

procedure TPasRISCV.TVirtIOGPUDevice.HandleResourceAttachBacking(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aReadSize:TPasRISCVUInt64);
var Cmd:TVirtIOGPUResourceAttachBacking;
    Resource:TGPUResource;
    MemEntries:array of TVirtIOGPUMemEntry;
    Index:TPasRISCVSizeInt;
    EntriesSize:TPasRISCVUInt64;
begin
 if not CopyMemoryFromQueue(@Cmd,aQueueIndex,aDescriptorIndex,0,SizeOf(TVirtIOGPUResourceAttachBacking)) then begin
  NotifyDeviceNeedsReset;
  exit;
 end;
 Resource:=FindResource(Cmd.ResourceID);
 if not assigned(Resource) then begin
  SendError(aQueueIndex,aDescriptorIndex,@Cmd.Header,VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID);
  exit;
 end;
 MemEntries:=nil;
 SetLength(MemEntries,Cmd.NrEntries);
 EntriesSize:=TPasRISCVUInt64(Cmd.NrEntries)*SizeOf(TVirtIOGPUMemEntry);
 if not CopyMemoryFromQueue(@MemEntries[0],aQueueIndex,aDescriptorIndex,SizeOf(TVirtIOGPUResourceAttachBacking),EntriesSize) then begin
  MemEntries:=nil;
  NotifyDeviceNeedsReset;
  exit;
 end;
 SetLength(Resource.BackingPages,Cmd.NrEntries);
 for Index:=0 to Cmd.NrEntries-1 do begin
  Resource.BackingPages[Index].Addr:=MemEntries[Index].Addr;
  Resource.BackingPages[Index].Length:=MemEntries[Index].Length;
 end;
 MemEntries:=nil;
 SendOKNoData(aQueueIndex,aDescriptorIndex,@Cmd.Header);
end;

procedure TPasRISCV.TVirtIOGPUDevice.HandleResourceDetachBacking(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUResourceDetachBacking);
var Resource:TGPUResource;
begin
 Resource:=FindResource(aCmd^.ResourceID);
 if not assigned(Resource) then begin
  SendError(aQueueIndex,aDescriptorIndex,@aCmd^.Header,VIRTIO_GPU_RESP_ERR_INVALID_RESOURCE_ID);
  exit;
 end;
 Resource.BackingPages:=nil;
 SendOKNoData(aQueueIndex,aDescriptorIndex,@aCmd^.Header);
end;

procedure TPasRISCV.TVirtIOGPUDevice.HandleGetEDID(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUGetEDID);
var Response:TVirtIOGPURespEDID;
    CheckSum:TPasRISCVUInt8;
    Index:TPasRISCVSizeInt;
    Width,Height:TPasRISCVUInt32;
begin
 if aCmd^.Scanout>=VIRTIO_GPU_MAX_SCANOUTS then begin
  SendError(aQueueIndex,aDescriptorIndex,@aCmd^.Header,VIRTIO_GPU_RESP_ERR_INVALID_SCANOUT_ID);
  exit;
 end;
 FillChar(Response,SizeOf(TVirtIOGPURespEDID),#0);
 Response.Header.CtrlType:=VIRTIO_GPU_RESP_OK_EDID;
 Response.Header.Flags:=aCmd^.Header.Flags;
 Response.Header.FenceID:=aCmd^.Header.FenceID;
 Response.Header.CtxID:=aCmd^.Header.CtxID;
 Response.Size:=128; // Standard EDID block size
 Width:=fScanouts[aCmd^.Scanout].Rect.Width;
 Height:=fScanouts[aCmd^.Scanout].Rect.Height;
 if Width=0 then begin
  Width:=fFrameBuffer.fWidth;
 end;
 if Height=0 then begin
  Height:=fFrameBuffer.fHeight;
 end;
 // Build minimal EDID v1.3
 // Header
 Response.EDID[0]:=$00;
 Response.EDID[1]:=$ff;
 Response.EDID[2]:=$ff;
 Response.EDID[3]:=$ff;
 Response.EDID[4]:=$ff;
 Response.EDID[5]:=$ff;
 Response.EDID[6]:=$ff;
 Response.EDID[7]:=$00;
 // Manufacturer ID "PRC" (PasRISCV)
 Response.EDID[8]:=$3e; // 'P'=16, 'R'=18 compressed: ((16 shl 10) or (18 shl 5) or 3) = $40A3 -> bytes $40, $A3
 Response.EDID[9]:=$a3;
 // Product code
 Response.EDID[10]:=$01;
 Response.EDID[11]:=$00;
 // Serial
 Response.EDID[12]:=$01;
 Response.EDID[13]:=$00;
 Response.EDID[14]:=$00;
 Response.EDID[15]:=$00;
 // Week / Year
 Response.EDID[16]:=1;
 Response.EDID[17]:=26; // 2016+10 = year offset
 // Version 1.3
 Response.EDID[18]:=1;
 Response.EDID[19]:=3;
 // Digital input
 Response.EDID[20]:=$80;
 // Max horizontal/vertical image size in cm
 Response.EDID[21]:=TPasRISCVUInt8((Width*254) div 10000);  // ~cm at 96dpi
 Response.EDID[22]:=TPasRISCVUInt8((Height*254) div 10000);
 // Gamma 2.2
 Response.EDID[23]:=120;
 // Features: RGB, preferred timing in DTD 1
 Response.EDID[24]:=$0a;
 // Chromaticity skip (bytes 25-34)
 // Established timings (bytes 35-37)
 // Standard timings (bytes 38-53) - not used
 FillChar(Response.EDID[38],16,$01);
 // Detailed Timing Descriptor #1 (bytes 54-71): preferred mode
 // Pixel clock in 10 kHz units (e.g. 25175 for 640x480@60 => 2517)
 // Simplified: just set width/height, minimal valid structure
 Response.EDID[54]:=((Width*60*125) div 100000) and $ff;
 Response.EDID[55]:=(((Width*60*125) div 100000) shr 8) and $ff;
 Response.EDID[56]:=Width and $ff;
 Response.EDID[57]:=0; // H blanking low
 Response.EDID[58]:=((Width shr 4) and $f0); // H active high nibble
 Response.EDID[59]:=Height and $ff;
 Response.EDID[60]:=0; // V blanking low
 Response.EDID[61]:=((Height shr 4) and $f0); // V active high nibble
 // Bytes 62-71: various timing, keep zero
 // Monitor descriptor blocks (bytes 72-125): fill with dummy descriptors
 // Block 2: Monitor name
 Response.EDID[72]:=0;
 Response.EDID[73]:=0;
 Response.EDID[74]:=0;
 Response.EDID[75]:=$fc; // Monitor name tag
 Response.EDID[76]:=0;
 Response.EDID[77]:=ord('P');
 Response.EDID[78]:=ord('a');
 Response.EDID[79]:=ord('s');
 Response.EDID[80]:=ord('R');
 Response.EDID[81]:=ord('I');
 Response.EDID[82]:=ord('S');
 Response.EDID[83]:=ord('C');
 Response.EDID[84]:=ord('V');
 Response.EDID[85]:=$0a;
 // Block 3: Monitor range
 Response.EDID[90]:=0;
 Response.EDID[91]:=0;
 Response.EDID[92]:=0;
 Response.EDID[93]:=$fd; // Monitor range tag
 Response.EDID[94]:=0;
 Response.EDID[95]:=50; // Min V freq
 Response.EDID[96]:=75; // Max V freq
 Response.EDID[97]:=30; // Min H freq kHz
 Response.EDID[98]:=80; // Max H freq kHz
 Response.EDID[99]:=25; // Max pixel clock / 10 MHz
 Response.EDID[100]:=0; // GTF
 // Checksum
 CheckSum:=0;
 for Index:=0 to 126 do begin
  inc(CheckSum,Response.EDID[Index]);
 end;
 Response.EDID[127]:=TPasRISCVUInt8(256-CheckSum);
 SendResponse(aQueueIndex,aDescriptorIndex,@Response,SizeOf(TVirtIOGPURespEDID));
end;

procedure TPasRISCV.TVirtIOGPUDevice.HandleUpdateCursor(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUUpdateCursor);
var Resource:TGPUResource;
    CopySize:TPasRISCVUInt64;
begin
 fFrameBuffer.SetCursorPosition(aCmd^.Pos.X,aCmd^.Pos.Y);
 fFrameBuffer.SetCursorHotspot(aCmd^.HotX,aCmd^.HotY);
 if aCmd^.ResourceID<>0 then begin
  Resource:=FindResource(aCmd^.ResourceID);
  if assigned(Resource) and (length(Resource.Data)>0) then begin
   CopySize:=length(Resource.Data);
   if CopySize>TFrameBufferDevice.CURSOR_BYTES then begin
    CopySize:=TFrameBufferDevice.CURSOR_BYTES;
   end;
   fFrameBuffer.SetCursorImage(@Resource.Data[0],CopySize);
   fFrameBuffer.SetCursorVisible(true);
  end else begin
   fFrameBuffer.SetCursorVisible(false);
  end;
 end else begin
  fFrameBuffer.SetCursorVisible(false);
 end;
 fFrameBuffer.fDirty:=true;
 SendOKNoData(aQueueIndex,aDescriptorIndex,@aCmd^.Header);
end;

procedure TPasRISCV.TVirtIOGPUDevice.HandleMoveCursor(const aQueueIndex,aDescriptorIndex:TPasRISCVUInt64;const aCmd:PVirtIOGPUUpdateCursor);
begin
 fFrameBuffer.SetCursorPosition(aCmd^.Pos.X,aCmd^.Pos.Y);
 fFrameBuffer.fDirty:=true;
 SendOKNoData(aQueueIndex,aDescriptorIndex,@aCmd^.Header);
end;

function TPasRISCV.TVirtIOGPUDevice.DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean;
var Header:TVirtIOGPUCtrlHeader;
begin
 result:=true;
 if aReadSize<SizeOf(TVirtIOGPUCtrlHeader) then begin
  NotifyDeviceNeedsReset;
  exit;
 end;
 if not CopyMemoryFromQueue(@fRecvBuffer[0],aQueueIndex,aDescriptorIndex,0,aReadSize) then begin
  NotifyDeviceNeedsReset;
  exit;
 end;
 Move(fRecvBuffer[0],Header,SizeOf(TVirtIOGPUCtrlHeader));
 case aQueueIndex of
  VIRTIO_GPU_VQ_CONTROL:begin
   case Header.CtrlType of
    VIRTIO_GPU_CMD_GET_DISPLAY_INFO:begin
     HandleGetDisplayInfo(aQueueIndex,aDescriptorIndex,@Header);
    end;
    VIRTIO_GPU_CMD_RESOURCE_CREATE_2D:begin
     if aReadSize>=SizeOf(TVirtIOGPUResourceCreate2D) then begin
      HandleResourceCreate2D(aQueueIndex,aDescriptorIndex,PVirtIOGPUResourceCreate2D(@fRecvBuffer[0]));
     end else begin
      SendError(aQueueIndex,aDescriptorIndex,@Header,VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER);
     end;
    end;
    VIRTIO_GPU_CMD_RESOURCE_UNREF:begin
     if aReadSize>=SizeOf(TVirtIOGPUResourceUnref) then begin
      HandleResourceUnref(aQueueIndex,aDescriptorIndex,PVirtIOGPUResourceUnref(@fRecvBuffer[0]));
     end else begin
      SendError(aQueueIndex,aDescriptorIndex,@Header,VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER);
     end;
    end;
    VIRTIO_GPU_CMD_SET_SCANOUT:begin
     if aReadSize>=SizeOf(TVirtIOGPUSetScanout) then begin
      HandleSetScanout(aQueueIndex,aDescriptorIndex,PVirtIOGPUSetScanout(@fRecvBuffer[0]));
     end else begin
      SendError(aQueueIndex,aDescriptorIndex,@Header,VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER);
     end;
    end;
    VIRTIO_GPU_CMD_RESOURCE_FLUSH:begin
     if aReadSize>=SizeOf(TVirtIOGPUResourceFlush) then begin
      HandleResourceFlush(aQueueIndex,aDescriptorIndex,PVirtIOGPUResourceFlush(@fRecvBuffer[0]));
     end else begin
      SendError(aQueueIndex,aDescriptorIndex,@Header,VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER);
     end;
    end;
    VIRTIO_GPU_CMD_TRANSFER_TO_HOST_2D:begin
     if aReadSize>=SizeOf(TVirtIOGPUTransferToHost2D) then begin
      HandleTransferToHost2D(aQueueIndex,aDescriptorIndex,PVirtIOGPUTransferToHost2D(@fRecvBuffer[0]));
     end else begin
      SendError(aQueueIndex,aDescriptorIndex,@Header,VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER);
     end;
    end;
    VIRTIO_GPU_CMD_RESOURCE_ATTACH_BACKING:begin
     HandleResourceAttachBacking(aQueueIndex,aDescriptorIndex,aReadSize);
    end;
    VIRTIO_GPU_CMD_RESOURCE_DETACH_BACKING:begin
     if aReadSize>=SizeOf(TVirtIOGPUResourceDetachBacking) then begin
      HandleResourceDetachBacking(aQueueIndex,aDescriptorIndex,PVirtIOGPUResourceDetachBacking(@fRecvBuffer[0]));
     end else begin
      SendError(aQueueIndex,aDescriptorIndex,@Header,VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER);
     end;
    end;
    VIRTIO_GPU_CMD_GET_EDID:begin
     if aReadSize>=SizeOf(TVirtIOGPUGetEDID) then begin
      HandleGetEDID(aQueueIndex,aDescriptorIndex,PVirtIOGPUGetEDID(@fRecvBuffer[0]));
     end else begin
      SendError(aQueueIndex,aDescriptorIndex,@Header,VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER);
     end;
    end;
    VIRTIO_GPU_CMD_GET_CAPSET_INFO,
    VIRTIO_GPU_CMD_GET_CAPSET:begin
     SendError(aQueueIndex,aDescriptorIndex,@Header,VIRTIO_GPU_RESP_ERR_UNSPEC);
    end;
    else begin
     SendError(aQueueIndex,aDescriptorIndex,@Header,VIRTIO_GPU_RESP_ERR_UNSPEC);
    end;
   end;
  end;
  VIRTIO_GPU_VQ_CURSOR:begin
   case Header.CtrlType of
    VIRTIO_GPU_CMD_UPDATE_CURSOR:begin
     if aReadSize>=SizeOf(TVirtIOGPUUpdateCursor) then begin
      HandleUpdateCursor(aQueueIndex,aDescriptorIndex,PVirtIOGPUUpdateCursor(@fRecvBuffer[0]));
     end else begin
      SendError(aQueueIndex,aDescriptorIndex,@Header,VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER);
     end;
    end;
    VIRTIO_GPU_CMD_MOVE_CURSOR:begin
     if aReadSize>=SizeOf(TVirtIOGPUUpdateCursor) then begin
      HandleMoveCursor(aQueueIndex,aDescriptorIndex,PVirtIOGPUUpdateCursor(@fRecvBuffer[0]));
     end else begin
      SendError(aQueueIndex,aDescriptorIndex,@Header,VIRTIO_GPU_RESP_ERR_INVALID_PARAMETER);
     end;
    end;
    else begin
     SendError(aQueueIndex,aDescriptorIndex,@Header,VIRTIO_GPU_RESP_ERR_UNSPEC);
    end;
   end;
  end;
  else begin
   NotifyDeviceNeedsReset;
  end;
 end;
end;

{ TPasRISCV.TVirtIORTCDevice }

constructor TPasRISCV.TVirtIORTCDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fVirtIORTCBase,aMachine.fConfiguration.fVirtIORTCSize,TVirtIODevice.TKind.MMIO);

 fIRQ:=aMachine.fConfiguration.fVirtIORTCIRQ;

 fDeviceID:=DeviceID;

 fDeviceFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1;

 fQueues[0].ManualRecv:=false;
 fQueues[0].Asynchronous:=false;

 fSendBuffer:=nil;
 SetLength(fSendBuffer,256);

 fReceiveBuffer:=nil;
 SetLength(fReceiveBuffer,256);

 fMonotonicEpoch:={$if declared(NowUTC)}NowUTC{$else}Now{$ifend};

end;

destructor TPasRISCV.TVirtIORTCDevice.Destroy;
begin
 fSendBuffer:=nil;
 fReceiveBuffer:=nil;
 inherited Destroy;
end;

procedure TPasRISCV.TVirtIORTCDevice.DeviceReset;
begin
 fMonotonicEpoch:={$if declared(NowUTC)}NowUTC{$else}Now{$ifend};
 inherited DeviceReset;
end;

function TPasRISCV.TVirtIORTCDevice.DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean;
var MsgType:TPasRISCVUInt16;
    ClockID:TPasRISCVUInt16;
    NowTime:TDateTime;
    UnixEpoch:TDateTime;
    NanoSeconds:TPasRISCVUInt64;
    ResponseSize:TPasRISCVUInt64;
begin
 result:=true;
 if aReadSize<SIZE_REQ_HEAD then begin
  NotifyDeviceNeedsReset;
  exit;
 end;
 if TPasRISCVSizeInt(length(fReceiveBuffer))<TPasRISCVSizeInt(aReadSize) then begin
  SetLength(fReceiveBuffer,aReadSize+((aReadSize+1) shr 1));
 end;
 if not CopyMemoryFromQueue(fReceiveBuffer,aQueueIndex,aDescriptorIndex,0,aReadSize) then begin
  NotifyDeviceNeedsReset;
  exit;
 end;
 // Read msg_type (le16 at offset 0)
 MsgType:=TPasRISCVUInt16(fReceiveBuffer[0]) or (TPasRISCVUInt16(fReceiveBuffer[1]) shl 8);
 // Prepare send buffer
 if TPasRISCVSizeInt(length(fSendBuffer))<TPasRISCVSizeInt(aWriteSize) then begin
  SetLength(fSendBuffer,aWriteSize+((aWriteSize+1) shr 1));
 end;
 FillChar(fSendBuffer[0],aWriteSize,0);
 case MsgType of
  VIRTIO_RTC_REQ_CFG:begin
   // Response: head(8) + le16 num_clocks + reserved[6] = 16 bytes
   ResponseSize:=SIZE_RESP_CFG;
   if aWriteSize<ResponseSize then begin
    fSendBuffer[0]:=VIRTIO_RTC_S_EINVAL; // status
   end else begin
    fSendBuffer[0]:=VIRTIO_RTC_S_OK; // status
    // num_clocks = 3 (UTC, TAI, MONOTONIC) at offset 8
    fSendBuffer[8]:=3;
    fSendBuffer[9]:=0;
   end;
  end;
  VIRTIO_RTC_REQ_CLOCK_CAP:begin
   // Request: head(8) + le16 clock_id + reserved[6]
   ResponseSize:=SIZE_RESP_CLOCK_CAP;
   if (aReadSize<SIZE_REQ_CLOCK_CAP) or (aWriteSize<ResponseSize) then begin
    fSendBuffer[0]:=VIRTIO_RTC_S_EINVAL;
   end else begin
    ClockID:=TPasRISCVUInt16(fReceiveBuffer[8]) or (TPasRISCVUInt16(fReceiveBuffer[9]) shl 8);
    case ClockID of
     0:begin // UTC
      fSendBuffer[0]:=VIRTIO_RTC_S_OK;
      fSendBuffer[8]:=VIRTIO_RTC_CLOCK_UTC; // type
     end;
     1:begin // TAI
      fSendBuffer[0]:=VIRTIO_RTC_S_OK;
      fSendBuffer[8]:=VIRTIO_RTC_CLOCK_TAI; // type
     end;
     2:begin // MONOTONIC
      fSendBuffer[0]:=VIRTIO_RTC_S_OK;
      fSendBuffer[8]:=VIRTIO_RTC_CLOCK_MONOTONIC; // type
     end;
     else begin
      fSendBuffer[0]:=VIRTIO_RTC_S_ENODEV;
     end;
    end;
   end;
  end;
  VIRTIO_RTC_REQ_CROSS_CAP:begin
   // We don't support cross-timestamping
   ResponseSize:=SIZE_RESP_CROSS_CAP;
   if aWriteSize<ResponseSize then begin
    fSendBuffer[0]:=VIRTIO_RTC_S_EINVAL;
   end else begin
    fSendBuffer[0]:=VIRTIO_RTC_S_OK;
    fSendBuffer[8]:=0; // flags: no CROSS_CAP
   end;
  end;
  VIRTIO_RTC_REQ_READ:begin
   // Request: head(8) + le16 clock_id + reserved[6]
   ResponseSize:=SIZE_RESP_READ;
   if (aReadSize<SIZE_REQ_READ) or (aWriteSize<ResponseSize) then begin
    fSendBuffer[0]:=VIRTIO_RTC_S_EINVAL;
   end else begin
    ClockID:=TPasRISCVUInt16(fReceiveBuffer[8]) or (TPasRISCVUInt16(fReceiveBuffer[9]) shl 8);
    NowTime:={$if declared(NowUTC)}NowUTC{$else}Now{$ifend};
    UnixEpoch:=EncodeDate(1970,1,1);
    case ClockID of
     0:begin // UTC — nanoseconds since Unix epoch
      NanoSeconds:=Round(((NowTime-UnixEpoch)*86400.0)*1000000000.0);
      fSendBuffer[0]:=VIRTIO_RTC_S_OK;
      fSendBuffer[8]:=TPasRISCVUInt8(NanoSeconds);
      fSendBuffer[9]:=TPasRISCVUInt8(NanoSeconds shr 8);
      fSendBuffer[10]:=TPasRISCVUInt8(NanoSeconds shr 16);
      fSendBuffer[11]:=TPasRISCVUInt8(NanoSeconds shr 24);
      fSendBuffer[12]:=TPasRISCVUInt8(NanoSeconds shr 32);
      fSendBuffer[13]:=TPasRISCVUInt8(NanoSeconds shr 40);
      fSendBuffer[14]:=TPasRISCVUInt8(NanoSeconds shr 48);
      fSendBuffer[15]:=TPasRISCVUInt8(NanoSeconds shr 56);
     end;
     1:begin // TAI — UTC + 37 leap seconds (as of 2017, still valid)
      NanoSeconds:=Round(((NowTime-UnixEpoch)*86400.0)*1000000000.0)+(TPasRISCVUInt64(37)*1000000000);
      fSendBuffer[0]:=VIRTIO_RTC_S_OK;
      fSendBuffer[8]:=TPasRISCVUInt8(NanoSeconds);
      fSendBuffer[9]:=TPasRISCVUInt8(NanoSeconds shr 8);
      fSendBuffer[10]:=TPasRISCVUInt8(NanoSeconds shr 16);
      fSendBuffer[11]:=TPasRISCVUInt8(NanoSeconds shr 24);
      fSendBuffer[12]:=TPasRISCVUInt8(NanoSeconds shr 32);
      fSendBuffer[13]:=TPasRISCVUInt8(NanoSeconds shr 40);
      fSendBuffer[14]:=TPasRISCVUInt8(NanoSeconds shr 48);
      fSendBuffer[15]:=TPasRISCVUInt8(NanoSeconds shr 56);
     end;
     2:begin // MONOTONIC — nanoseconds since device reset
      NanoSeconds:=Round(((NowTime-fMonotonicEpoch)*86400.0)*1000000000.0);
      fSendBuffer[0]:=VIRTIO_RTC_S_OK;
      fSendBuffer[8]:=TPasRISCVUInt8(NanoSeconds);
      fSendBuffer[9]:=TPasRISCVUInt8(NanoSeconds shr 8);
      fSendBuffer[10]:=TPasRISCVUInt8(NanoSeconds shr 16);
      fSendBuffer[11]:=TPasRISCVUInt8(NanoSeconds shr 24);
      fSendBuffer[12]:=TPasRISCVUInt8(NanoSeconds shr 32);
      fSendBuffer[13]:=TPasRISCVUInt8(NanoSeconds shr 40);
      fSendBuffer[14]:=TPasRISCVUInt8(NanoSeconds shr 48);
      fSendBuffer[15]:=TPasRISCVUInt8(NanoSeconds shr 56);
     end;
     else begin
      fSendBuffer[0]:=VIRTIO_RTC_S_ENODEV;
     end;
    end;
   end;
  end;
  else begin
   // Unknown message type
   ResponseSize:=SIZE_RESP_HEAD;
   if aWriteSize>=ResponseSize then begin
    fSendBuffer[0]:=VIRTIO_RTC_S_EOPNOTSUPP;
   end;
  end;
 end;
 if ResponseSize>aWriteSize then begin
  ResponseSize:=aWriteSize;
 end;
 if not (CopyMemoryToQueue(aQueueIndex,aDescriptorIndex,0,@fSendBuffer[0],ResponseSize) and
         ConsumeDescriptor(aQueueIndex,aDescriptorIndex,ResponseSize) and
         UsedRingSync(aQueueIndex)) then begin
  NotifyDeviceNeedsReset;
 end;
end;

{ TPasRISCV.TVirtIOVSockDevice }

constructor TPasRISCV.TVirtIOVSockDevice.Create(const aMachine:TPasRISCV);
begin

 fConnections:=nil;
 fConnectionCount:=0;

 fConnectionLock:=TPasMPSlimReaderWriterLock.Create;

 inherited Create(aMachine,aMachine.fConfiguration.fVirtIOVSockBase,aMachine.fConfiguration.fVirtIOVSockSize,TVirtIODevice.TKind.MMIO);

 fIRQ:=aMachine.fConfiguration.fVirtIOVSockIRQ;

 fDeviceID:=VSOCK_DEVICE_ID;

 fDeviceFeatures:=TPasRISCV.TVirtIODevice.VIRTIO_F_VERSION_1 or
                  VIRTIO_VSOCK_F_STREAM or
                  VIRTIO_VSOCK_F_SEQPACKET;

 fQueues[VSOCK_RXQ].ManualRecv:=true;
 fQueues[VSOCK_RXQ].Asynchronous:=false;

 fQueues[VSOCK_TXQ].ManualRecv:=false;
 fQueues[VSOCK_TXQ].Asynchronous:=false;

 fQueues[VSOCK_EVQ].ManualRecv:=true;
 fQueues[VSOCK_EVQ].Asynchronous:=false;

 fGuestCID:=aMachine.fConfiguration.fVirtIOVSockGuestCID;

 // Config space: le64 guest_cid
 FillChar(fConfigSpace[0],8,#0);
 fConfigSpace[0]:=TPasRISCVUInt8(fGuestCID and $ff);
 fConfigSpace[1]:=TPasRISCVUInt8((fGuestCID shr 8) and $ff);
 fConfigSpace[2]:=TPasRISCVUInt8((fGuestCID shr 16) and $ff);
 fConfigSpace[3]:=TPasRISCVUInt8((fGuestCID shr 24) and $ff);
 fConfigSpace[4]:=TPasRISCVUInt8((fGuestCID shr 32) and $ff);
 fConfigSpace[5]:=TPasRISCVUInt8((fGuestCID shr 40) and $ff);
 fConfigSpace[6]:=TPasRISCVUInt8((fGuestCID shr 48) and $ff);
 fConfigSpace[7]:=TPasRISCVUInt8((fGuestCID shr 56) and $ff);
 fConfigSpaceSize:=8;

 fSendBuffer:=nil;
 SetLength(fSendBuffer,VSOCK_MAX_PKT_BUF_SIZE+VSOCK_HDR_SIZE);

 fRecvBuffer:=nil;
 SetLength(fRecvBuffer,VSOCK_MAX_PKT_BUF_SIZE+VSOCK_HDR_SIZE);

 fOnConnect:=nil;
 fOnConnected:=nil;
 fOnDisconnect:=nil;
 fOnReceive:=nil;

end;

destructor TPasRISCV.TVirtIOVSockDevice.Destroy;
begin
 DestroyAllConnections;
 fConnections:=nil;
 FreeAndNil(fConnectionLock);
 fSendBuffer:=nil;
 fRecvBuffer:=nil;
 inherited Destroy;
end;

procedure TPasRISCV.TVirtIOVSockDevice.DeviceReset;
begin
 fConnectionLock.Acquire;
 try
  DestroyAllConnections;
 finally
  fConnectionLock.Release;
 end;
 inherited DeviceReset;
end;

function TPasRISCV.TVirtIOVSockDevice.FindConnection(const aLocalPort:TPasRISCVUInt32;const aRemoteCID:TPasRISCVUInt64;const aRemotePort:TPasRISCVUInt32):TVSockConnection;
var Index:TPasRISCVSizeInt;
    Connection:TVSockConnection;
begin
 result:=nil;
 for Index:=0 to fConnectionCount-1 do begin
  Connection:=fConnections[Index];
  if assigned(Connection) and
     (Connection.LocalPort=aLocalPort) and
     (Connection.RemoteCID=aRemoteCID) and
     (Connection.RemotePort=aRemotePort) then begin
   result:=Connection;
   exit;
  end;
 end;
end;

function TPasRISCV.TVirtIOVSockDevice.CreateConnection(const aLocalPort:TPasRISCVUInt32;const aRemoteCID:TPasRISCVUInt64;const aRemotePort:TPasRISCVUInt32;const aSocketType:TPasRISCVUInt16):TVSockConnection;
var Index:TPasRISCVSizeInt;
begin
 result:=TVSockConnection.Create;
 result.LocalPort:=aLocalPort;
 result.RemoteCID:=aRemoteCID;
 result.RemotePort:=aRemotePort;
 result.State:=TVSockConnectionState.Closed;
 result.SocketType:=aSocketType;
 result.BufAlloc:=VSOCK_DEFAULT_BUF_ALLOC;
 result.FwdCnt:=0;
 result.TxCnt:=0;
 result.PeerBufAlloc:=0;
 result.PeerFwdCnt:=0;
 result.ShutdownFlags:=0;
 result.PeerShutdownFlags:=0;
 result.LastFwdCntReported:=0;
 // Find free slot or grow
 for Index:=0 to fConnectionCount-1 do begin
  if not assigned(fConnections[Index]) then begin
   fConnections[Index]:=result;
   exit;
  end;
 end;
 if fConnectionCount>=length(fConnections) then begin
  SetLength(fConnections,(fConnectionCount+1)+((fConnectionCount+1) shr 1));
 end;
 fConnections[fConnectionCount]:=result;
 inc(fConnectionCount);
end;

procedure TPasRISCV.TVirtIOVSockDevice.DestroyConnection(const aConnection:TVSockConnection);
var Index:TPasRISCVSizeInt;
begin
 if assigned(aConnection) then begin
  for Index:=0 to fConnectionCount-1 do begin
   if fConnections[Index]=aConnection then begin
    fConnections[Index]:=nil;
    break;
   end;
  end;
  aConnection.Free;
 end;
end;

procedure TPasRISCV.TVirtIOVSockDevice.DestroyAllConnections;
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to fConnectionCount-1 do begin
  FreeAndNil(fConnections[Index]);
 end;
 fConnectionCount:=0;
end;

procedure TPasRISCV.TVirtIOVSockDevice.SendControlPacket(const aConnection:TVSockConnection;const aOp:TPasRISCVUInt16;const aFlags:TPasRISCVUInt32=0);
var Header:TVSockHeader;
begin
 FillChar(Header,SizeOf(TVSockHeader),#0);
 Header.SrcCID:=VSOCK_CID_HOST;
 Header.DstCID:=fGuestCID;
 Header.SrcPort:=aConnection.LocalPort;
 Header.DstPort:=aConnection.RemotePort;
 Header.Len:=0;
 Header.SocketType:=aConnection.SocketType;
 Header.Op:=aOp;
 Header.Flags:=aFlags;
 Header.BufAlloc:=aConnection.BufAlloc;
 Header.FwdCnt:=aConnection.FwdCnt;
 WriteRxPacket(Header,nil,0);
end;

procedure TPasRISCV.TVirtIOVSockDevice.WriteRxPacket(const aHeader:TVSockHeader;const aData:Pointer;const aSize:TPasRISCVUInt32);
var Queue:PQueue;
    AvailableIndex,DescriptorIndex:TPasRISCVUInt16;
    ReadSize,WriteSize:TPasRISCVUInt64;
    TotalSize:TPasRISCVSizeInt;
begin
 Queue:=@fQueues[VSOCK_RXQ];
 if fDriverOK and Queue^.Ready then begin
  TPasMPMultipleReaderSingleWriterSpinLock.AcquireWrite(Queue^.Lock);
  try
   if Read16(Queue^.AvailableAddress+2,AvailableIndex) then begin
    if Queue^.ShadowAvailableIndex<>AvailableIndex then begin
     if Read16(Queue^.AvailableAddress+4+((Queue^.ShadowAvailableIndex and (Queue^.Size-1)) shl 1),DescriptorIndex) then begin
      if GetDescriptors(ReadSize,WriteSize,VSOCK_RXQ,DescriptorIndex) then begin
       TotalSize:=VSOCK_HDR_SIZE+TPasRISCVSizeInt(aSize);
       if TotalSize<=WriteSize then begin
        if length(fSendBuffer)<TotalSize then begin
         SetLength(fSendBuffer,TotalSize+((TotalSize+1) shr 1));
        end;
        Move(aHeader,fSendBuffer[0],VSOCK_HDR_SIZE);
        if (aSize>0) and assigned(aData) then begin
         Move(aData^,fSendBuffer[VSOCK_HDR_SIZE],aSize);
        end;
        if not (CopyMemoryToQueue(VSOCK_RXQ,DescriptorIndex,0,@fSendBuffer[0],TotalSize) and
                ConsumeDescriptor(VSOCK_RXQ,DescriptorIndex,TotalSize) and
                UsedRingSync(VSOCK_RXQ) and
                AdvanceShadowAvailableIndex(VSOCK_RXQ)) then begin
         NotifyDeviceNeedsReset;
        end;
       end;
      end else begin
       NotifyDeviceNeedsReset;
      end;
     end else begin
      NotifyDeviceNeedsReset;
     end;
    end;
   end else begin
    NotifyDeviceNeedsReset;
   end;
  finally
   TPasMPMultipleReaderSingleWriterSpinLock.ReleaseWrite(Queue^.Lock);
  end;
 end;
end;

procedure TPasRISCV.TVirtIOVSockDevice.WriteEvent(const aEventID:TPasRISCVUInt32);
var Queue:PQueue;
    Event:TVSockEvent;
    AvailableIndex,DescriptorIndex:TPasRISCVUInt16;
    ReadSize,WriteSize:TPasRISCVUInt64;
begin
 Queue:=@fQueues[VSOCK_EVQ];
 if fDriverOK and Queue^.Ready then begin
  TPasMPMultipleReaderSingleWriterSpinLock.AcquireWrite(Queue^.Lock);
  try
   if Read16(Queue^.AvailableAddress+2,AvailableIndex) then begin
    if Queue^.ShadowAvailableIndex<>AvailableIndex then begin
     if Read16(Queue^.AvailableAddress+4+((Queue^.ShadowAvailableIndex and (Queue^.Size-1)) shl 1),DescriptorIndex) then begin
      if GetDescriptors(ReadSize,WriteSize,VSOCK_EVQ,DescriptorIndex) then begin
       if VSOCK_EVENT_SIZE<=WriteSize then begin
        Event.ID:=aEventID;
        if not (CopyMemoryToQueue(VSOCK_EVQ,DescriptorIndex,0,@Event,VSOCK_EVENT_SIZE) and
                ConsumeDescriptor(VSOCK_EVQ,DescriptorIndex,VSOCK_EVENT_SIZE) and
                UsedRingSync(VSOCK_EVQ) and
                AdvanceShadowAvailableIndex(VSOCK_EVQ)) then begin
         NotifyDeviceNeedsReset;
        end;
       end;
      end else begin
       NotifyDeviceNeedsReset;
      end;
     end else begin
      NotifyDeviceNeedsReset;
     end;
    end;
   end else begin
    NotifyDeviceNeedsReset;
   end;
  finally
   TPasMPMultipleReaderSingleWriterSpinLock.ReleaseWrite(Queue^.Lock);
  end;
 end;
end;

procedure TPasRISCV.TVirtIOVSockDevice.HandleRequest(var aHeader:TVSockHeader);
var Connection:TVSockConnection;
begin
 if (aHeader.SocketType<>VIRTIO_VSOCK_TYPE_STREAM) and (aHeader.SocketType<>VIRTIO_VSOCK_TYPE_SEQPACKET) then begin
  // Unknown socket type, send RST via a temporary connection
  Connection:=CreateConnection(aHeader.DstPort,aHeader.SrcCID,aHeader.SrcPort,aHeader.SocketType);
  try
   SendControlPacket(Connection,VIRTIO_VSOCK_OP_RST);
  finally
   DestroyConnection(Connection);
  end;
  exit;
 end;
 Connection:=FindConnection(aHeader.DstPort,aHeader.SrcCID,aHeader.SrcPort);
 if assigned(Connection) then begin
  // Connection already exists, send RST
  SendControlPacket(Connection,VIRTIO_VSOCK_OP_RST);
  exit;
 end;
 Connection:=CreateConnection(aHeader.DstPort,aHeader.SrcCID,aHeader.SrcPort,aHeader.SocketType);
 Connection.State:=TVSockConnectionState.PeerConnecting;
 Connection.PeerBufAlloc:=aHeader.BufAlloc;
 Connection.PeerFwdCnt:=aHeader.FwdCnt;
 if assigned(fOnConnect) then begin
  fOnConnect(self,aHeader.DstPort,aHeader.SrcPort,aHeader.SocketType);
 end;
end;

procedure TPasRISCV.TVirtIOVSockDevice.HandleResponse(var aHeader:TVSockHeader);
var Connection:TVSockConnection;
begin
 Connection:=FindConnection(aHeader.DstPort,aHeader.SrcCID,aHeader.SrcPort);
 if (not assigned(Connection)) or (Connection.State<>TVSockConnectionState.Connecting) then begin
  // Unexpected response, create temp connection for RST if needed
  if not assigned(Connection) then begin
   Connection:=CreateConnection(aHeader.DstPort,aHeader.SrcCID,aHeader.SrcPort,aHeader.SocketType);
   try
    SendControlPacket(Connection,VIRTIO_VSOCK_OP_RST);
   finally
    DestroyConnection(Connection);
   end;
  end else begin
   SendControlPacket(Connection,VIRTIO_VSOCK_OP_RST);
  end;
  exit;
 end;
 Connection.PeerBufAlloc:=aHeader.BufAlloc;
 Connection.PeerFwdCnt:=aHeader.FwdCnt;
 Connection.State:=TVSockConnectionState.Connected;
 if assigned(fOnConnected) then begin
  fOnConnected(self,aHeader.DstPort,aHeader.SrcPort,Connection.SocketType,true);
 end;
end;

procedure TPasRISCV.TVirtIOVSockDevice.HandleRW(var aHeader:TVSockHeader;const aPayload:Pointer);
var Connection:TVSockConnection;
begin
 Connection:=FindConnection(aHeader.DstPort,aHeader.SrcCID,aHeader.SrcPort);
 if (not assigned(Connection)) or (Connection.State<>TVSockConnectionState.Connected) then begin
  if not assigned(Connection) then begin
   Connection:=CreateConnection(aHeader.DstPort,aHeader.SrcCID,aHeader.SrcPort,aHeader.SocketType);
   try
    SendControlPacket(Connection,VIRTIO_VSOCK_OP_RST);
   finally
    DestroyConnection(Connection);
   end;
  end else begin
   SendControlPacket(Connection,VIRTIO_VSOCK_OP_RST);
  end;
  exit;
 end;
 Connection.PeerBufAlloc:=aHeader.BufAlloc;
 Connection.PeerFwdCnt:=aHeader.FwdCnt;
 Connection.FwdCnt:=Connection.FwdCnt+aHeader.Len;
 if assigned(fOnReceive) then begin
  fOnReceive(self,aHeader.DstPort,aHeader.SrcPort,Connection.SocketType,aPayload,aHeader.Len,aHeader.Flags);
 end;
 // For stream sockets, send credit update if we've consumed enough buffer space
 if Connection.SocketType=VIRTIO_VSOCK_TYPE_STREAM then begin
  if (Connection.FwdCnt-Connection.LastFwdCntReported)>=(Connection.BufAlloc shr 1) then begin
   Connection.LastFwdCntReported:=Connection.FwdCnt;
   SendControlPacket(Connection,VIRTIO_VSOCK_OP_CREDIT_UPDATE);
  end;
 end;
end;

procedure TPasRISCV.TVirtIOVSockDevice.HandleShutdown(var aHeader:TVSockHeader);
var Connection:TVSockConnection;
begin
 Connection:=FindConnection(aHeader.DstPort,aHeader.SrcCID,aHeader.SrcPort);
 if (not assigned(Connection)) or (Connection.State<>TVSockConnectionState.Connected) then begin
  if not assigned(Connection) then begin
   Connection:=CreateConnection(aHeader.DstPort,aHeader.SrcCID,aHeader.SrcPort,aHeader.SocketType);
   try
    SendControlPacket(Connection,VIRTIO_VSOCK_OP_RST);
   finally
    DestroyConnection(Connection);
   end;
  end else begin
   SendControlPacket(Connection,VIRTIO_VSOCK_OP_RST);
  end;
  exit;
 end;
 Connection.PeerShutdownFlags:=Connection.PeerShutdownFlags or aHeader.Flags;
 if (Connection.PeerShutdownFlags and (VIRTIO_VSOCK_SHUTDOWN_F_RECEIVE or VIRTIO_VSOCK_SHUTDOWN_F_SEND))=(VIRTIO_VSOCK_SHUTDOWN_F_RECEIVE or VIRTIO_VSOCK_SHUTDOWN_F_SEND) then begin
  SendControlPacket(Connection,VIRTIO_VSOCK_OP_RST);
  if assigned(fOnDisconnect) then begin
   fOnDisconnect(self,aHeader.DstPort,aHeader.SrcPort);
  end;
  DestroyConnection(Connection);
 end else begin
  if assigned(fOnDisconnect) then begin
   fOnDisconnect(self,aHeader.DstPort,aHeader.SrcPort);
  end;
 end;
end;

procedure TPasRISCV.TVirtIOVSockDevice.HandleRST(var aHeader:TVSockHeader);
var Connection:TVSockConnection;
begin
 Connection:=FindConnection(aHeader.DstPort,aHeader.SrcCID,aHeader.SrcPort);
 if not assigned(Connection) then begin
  exit;
 end;
 if Connection.State=TVSockConnectionState.Connecting then begin
  if assigned(fOnConnected) then begin
   fOnConnected(self,aHeader.DstPort,aHeader.SrcPort,Connection.SocketType,false);
  end;
 end else begin
  if assigned(fOnDisconnect) then begin
   fOnDisconnect(self,aHeader.DstPort,aHeader.SrcPort);
  end;
 end;
 DestroyConnection(Connection);
end;

procedure TPasRISCV.TVirtIOVSockDevice.HandleCreditUpdate(var aHeader:TVSockHeader);
var Connection:TVSockConnection;
begin
 Connection:=FindConnection(aHeader.DstPort,aHeader.SrcCID,aHeader.SrcPort);
 if assigned(Connection) then begin
  Connection.PeerBufAlloc:=aHeader.BufAlloc;
  Connection.PeerFwdCnt:=aHeader.FwdCnt;
 end;
end;

procedure TPasRISCV.TVirtIOVSockDevice.HandleCreditRequest(var aHeader:TVSockHeader);
var Connection:TVSockConnection;
begin
 Connection:=FindConnection(aHeader.DstPort,aHeader.SrcCID,aHeader.SrcPort);
 if assigned(Connection) then begin
  SendControlPacket(Connection,VIRTIO_VSOCK_OP_CREDIT_UPDATE);
 end;
end;

function TPasRISCV.TVirtIOVSockDevice.DeviceRecv(const aQueueIndex,aDescriptorIndex,aReadSize,aWriteSize:TPasRISCVUInt64):Boolean;
var Header:TVSockHeader;
    PayloadPtr:Pointer;
begin
 result:=true;
 if aQueueIndex<>VSOCK_TXQ then begin
  exit;
 end;
 if aReadSize<VSOCK_HDR_SIZE then begin
  if not (ConsumeDescriptor(VSOCK_TXQ,aDescriptorIndex,0) and
          UsedRingSync(VSOCK_TXQ)) then begin
   NotifyDeviceNeedsReset;
  end;
  exit;
 end;
 FillChar(Header,SizeOf(TVSockHeader),#0);
 if not CopyMemoryFromQueue(@Header,VSOCK_TXQ,aDescriptorIndex,0,VSOCK_HDR_SIZE) then begin
  NotifyDeviceNeedsReset;
  exit;
 end;
 PayloadPtr:=nil;
 if (Header.Op=VIRTIO_VSOCK_OP_RW) and (Header.Len>0) then begin
  if Header.Len>VSOCK_MAX_PKT_BUF_SIZE then begin
   Header.Len:=VSOCK_MAX_PKT_BUF_SIZE;
  end;
  if length(fRecvBuffer)<TPasRISCVSizeInt(Header.Len) then begin
   SetLength(fRecvBuffer,Header.Len+((Header.Len+1) shr 1));
  end;
  if not CopyMemoryFromQueue(@fRecvBuffer[0],VSOCK_TXQ,aDescriptorIndex,VSOCK_HDR_SIZE,Header.Len) then begin
   NotifyDeviceNeedsReset;
   exit;
  end;
  PayloadPtr:=@fRecvBuffer[0];
 end;
 fConnectionLock.Acquire;
 try
  case Header.Op of
   VIRTIO_VSOCK_OP_REQUEST:begin
    HandleRequest(Header);
   end;
   VIRTIO_VSOCK_OP_RESPONSE:begin
    HandleResponse(Header);
   end;
   VIRTIO_VSOCK_OP_RW:begin
    HandleRW(Header,PayloadPtr);
   end;
   VIRTIO_VSOCK_OP_SHUTDOWN:begin
    HandleShutdown(Header);
   end;
   VIRTIO_VSOCK_OP_RST:begin
    HandleRST(Header);
   end;
   VIRTIO_VSOCK_OP_CREDIT_UPDATE:begin
    HandleCreditUpdate(Header);
   end;
   VIRTIO_VSOCK_OP_CREDIT_REQUEST:begin
    HandleCreditRequest(Header);
   end;
  end;
 finally
  fConnectionLock.Release;
 end;
 if not (ConsumeDescriptor(VSOCK_TXQ,aDescriptorIndex,0) and
         UsedRingSync(VSOCK_TXQ)) then begin
  NotifyDeviceNeedsReset;
 end;
end;

procedure TPasRISCV.TVirtIOVSockDevice.AcceptConnection(const aRemotePort,aLocalPort:TPasRISCVUInt32);
var Connection:TVSockConnection;
begin
 fConnectionLock.Acquire;
 try
  Connection:=FindConnection(aLocalPort,fGuestCID,aRemotePort);
  if assigned(Connection) and (Connection.State=TVSockConnectionState.PeerConnecting) then begin
   Connection.State:=TVSockConnectionState.Connected;
   SendControlPacket(Connection,VIRTIO_VSOCK_OP_RESPONSE);
  end;
 finally
  fConnectionLock.Release;
 end;
end;

procedure TPasRISCV.TVirtIOVSockDevice.RejectConnection(const aRemotePort,aLocalPort:TPasRISCVUInt32);
var Connection:TVSockConnection;
begin
 fConnectionLock.Acquire;
 try
  Connection:=FindConnection(aLocalPort,fGuestCID,aRemotePort);
  if assigned(Connection) and (Connection.State=TVSockConnectionState.PeerConnecting) then begin
   SendControlPacket(Connection,VIRTIO_VSOCK_OP_RST);
   DestroyConnection(Connection);
  end;
 finally
  fConnectionLock.Release;
 end;
end;

procedure TPasRISCV.TVirtIOVSockDevice.Connect(const aLocalPort,aRemotePort:TPasRISCVUInt32;const aSocketType:TPasRISCVUInt16=VIRTIO_VSOCK_TYPE_STREAM);
var Connection:TVSockConnection;
begin
 fConnectionLock.Acquire;
 try
  Connection:=FindConnection(aLocalPort,fGuestCID,aRemotePort);
  if assigned(Connection) then begin
   exit;
  end;
  Connection:=CreateConnection(aLocalPort,fGuestCID,aRemotePort,aSocketType);
  Connection.State:=TVSockConnectionState.Connecting;
  SendControlPacket(Connection,VIRTIO_VSOCK_OP_REQUEST);
 finally
  fConnectionLock.Release;
 end;
end;

procedure TPasRISCV.TVirtIOVSockDevice.CloseConnection(const aRemotePort,aLocalPort:TPasRISCVUInt32);
var Connection:TVSockConnection;
begin
 fConnectionLock.Acquire;
 try
  Connection:=FindConnection(aLocalPort,fGuestCID,aRemotePort);
  if not assigned(Connection) then begin
   exit;
  end;
  case Connection.State of
   TVSockConnectionState.Connected:begin
    SendControlPacket(Connection,VIRTIO_VSOCK_OP_SHUTDOWN,VIRTIO_VSOCK_SHUTDOWN_F_RECEIVE or VIRTIO_VSOCK_SHUTDOWN_F_SEND);
    Connection.ShutdownFlags:=VIRTIO_VSOCK_SHUTDOWN_F_RECEIVE or VIRTIO_VSOCK_SHUTDOWN_F_SEND;
    SendControlPacket(Connection,VIRTIO_VSOCK_OP_RST);
    if assigned(fOnDisconnect) then begin
     fOnDisconnect(self,aLocalPort,aRemotePort);
    end;
    DestroyConnection(Connection);
   end;
   TVSockConnectionState.PeerConnecting:begin
    SendControlPacket(Connection,VIRTIO_VSOCK_OP_RST);
    DestroyConnection(Connection);
   end;
   TVSockConnectionState.Connecting:begin
    SendControlPacket(Connection,VIRTIO_VSOCK_OP_RST);
    DestroyConnection(Connection);
   end;
   TVSockConnectionState.Closing:begin
    SendControlPacket(Connection,VIRTIO_VSOCK_OP_RST);
    DestroyConnection(Connection);
   end;
  end;
 finally
  fConnectionLock.Release;
 end;
end;

procedure TPasRISCV.TVirtIOVSockDevice.SendPacket(const aRemotePort,aLocalPort:TPasRISCVUInt32;const aData:Pointer;const aSize:TPasRISCVUInt32;const aFlags:TPasRISCVUInt32=0);
var Connection:TVSockConnection;
    Header:TVSockHeader;
    ActualSize:TPasRISCVUInt32;
    PeerFree:TPasRISCVInt64;
begin
 fConnectionLock.Acquire;
 try
  Connection:=FindConnection(aLocalPort,fGuestCID,aRemotePort);
  if (not assigned(Connection)) or (Connection.State<>TVSockConnectionState.Connected) then begin
   exit;
  end;
  ActualSize:=aSize;
  if ActualSize>VSOCK_MAX_PKT_BUF_SIZE then begin
   ActualSize:=VSOCK_MAX_PKT_BUF_SIZE;
  end;
  FillChar(Header,SizeOf(TVSockHeader),#0);
  Header.SrcCID:=VSOCK_CID_HOST;
  Header.DstCID:=fGuestCID;
  Header.SrcPort:=aLocalPort;
  Header.DstPort:=aRemotePort;
  Header.SocketType:=Connection.SocketType;
  Header.Op:=VIRTIO_VSOCK_OP_RW;
  Header.BufAlloc:=Connection.BufAlloc;
  Header.FwdCnt:=Connection.FwdCnt;
  if Connection.SocketType=VIRTIO_VSOCK_TYPE_STREAM then begin
   PeerFree:=TPasRISCVInt64(Connection.PeerBufAlloc)-TPasRISCVInt64(Connection.TxCnt-Connection.PeerFwdCnt);
   if PeerFree<=0 then begin
    exit;
   end;
   if ActualSize>TPasRISCVUInt32(PeerFree) then begin
    ActualSize:=TPasRISCVUInt32(PeerFree);
   end;
   Connection.TxCnt:=Connection.TxCnt+ActualSize;
   Header.Flags:=0;
  end else begin
   Header.Flags:=aFlags;
  end;
  Header.Len:=ActualSize;
  WriteRxPacket(Header,aData,ActualSize);
 finally
  fConnectionLock.Release;
 end;
end;

procedure TPasRISCV.TVirtIOVSockDevice.SendData(const aRemotePort,aLocalPort:TPasRISCVUInt32;const aData:Pointer;const aSize:TPasRISCVUInt32;const aEOR:Boolean=false);
var Connection:TVSockConnection;
    Header:TVSockHeader;
    Remaining,ChunkSize,Offset:TPasRISCVUInt32;
    PeerFree:TPasRISCVInt64;
    Flags:TPasRISCVUInt32;
    RetryCount:TPasRISCVUInt32;
begin
 fConnectionLock.Acquire;
 try
  Connection:=FindConnection(aLocalPort,fGuestCID,aRemotePort);
  if (not assigned(Connection)) or (Connection.State<>TVSockConnectionState.Connected) then begin
   exit;
  end;
  Remaining:=aSize;
  Offset:=0;
  while Remaining>0 do begin
   ChunkSize:=Remaining;
   if ChunkSize>VSOCK_MAX_PKT_BUF_SIZE then begin
    ChunkSize:=VSOCK_MAX_PKT_BUF_SIZE;
   end;
   FillChar(Header,SizeOf(TVSockHeader),#0);
   Header.SrcCID:=VSOCK_CID_HOST;
   Header.DstCID:=fGuestCID;
   Header.SrcPort:=aLocalPort;
   Header.DstPort:=aRemotePort;
   Header.SocketType:=Connection.SocketType;
   Header.Op:=VIRTIO_VSOCK_OP_RW;
   Header.BufAlloc:=Connection.BufAlloc;
   Header.FwdCnt:=Connection.FwdCnt;
   if Connection.SocketType=VIRTIO_VSOCK_TYPE_STREAM then begin
    PeerFree:=TPasRISCVInt64(Connection.PeerBufAlloc)-TPasRISCVInt64(Connection.TxCnt-Connection.PeerFwdCnt);
    if PeerFree<=0 then begin
     // Request credit update and retry
     SendControlPacket(Connection,VIRTIO_VSOCK_OP_CREDIT_REQUEST);
     RetryCount:=0;
     while PeerFree<=0 do begin
      inc(RetryCount);
      if RetryCount>1000 then begin
       exit; // Give up after too many retries
      end;
      PeerFree:=TPasRISCVInt64(Connection.PeerBufAlloc)-TPasRISCVInt64(Connection.TxCnt-Connection.PeerFwdCnt);
     end;
    end;
    if ChunkSize>TPasRISCVUInt32(PeerFree) then begin
     ChunkSize:=TPasRISCVUInt32(PeerFree);
    end;
    Connection.TxCnt:=Connection.TxCnt+ChunkSize;
    Header.Flags:=0;
   end else begin
    // Seqpacket: set EOM (and optionally EOR) only on last fragment
    Flags:=0;
    if (Offset+ChunkSize)>=aSize then begin
     Flags:=VIRTIO_VSOCK_SEQ_EOM;
     if aEOR then begin
      Flags:=Flags or VIRTIO_VSOCK_SEQ_EOR;
     end;
    end;
    Header.Flags:=Flags;
   end;
   Header.Len:=ChunkSize;
   WriteRxPacket(Header,Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+Offset)),ChunkSize);
   inc(Offset,ChunkSize);
   dec(Remaining,ChunkSize);
  end;
 finally
  fConnectionLock.Release;
 end;
end;

procedure TPasRISCV.TVirtIOVSockDevice.SendTransportReset;
begin
 WriteEvent(VIRTIO_VSOCK_EVENT_TRANSPORT_RESET);
 fConnectionLock.Acquire;
 try
  DestroyAllConnections;
 finally
  fConnectionLock.Release;
 end;
end;

{$if defined(PasRISCVUseRealConsole)}

{ TPasRISCV.TUARTDevice.TUARTInputThread }

constructor TPasRISCV.TUARTDevice.TUARTInputThread.Create(const aUARTDevice:TUARTDevice);
begin
{$if defined(Windows) and not defined(fpc)}
 fConsoleInputHandle:=GetStdHandle(STD_INPUT_HANDLE);
{$ifend}
 fUARTDevice:=aUARTDevice;
 fEvent:=TEvent.Create(nil,false,false,'');
 inherited Create(false);
end;

destructor TPasRISCV.TUARTDevice.TUARTInputThread.Destroy;
begin
 Shutdown;
 inherited Destroy;
end;

procedure TPasRISCV.TUARTDevice.TUARTInputThread.Shutdown;
begin
 if not Finished then begin
  Terminate;
  fEvent.SetEvent;
  WaitFor;
 end;
end;

procedure TPasRISCV.TUARTDevice.TUARTInputThread.Execute;
{$if defined(Windows) and not defined(fpc)}
var ReadCount,ResultLen,Index:DWORD;
    InputRecord:_INPUT_RECORD;
    Data:array[0..7] of AnsiChar;
 procedure ReadInput;
 var Surrogate,CharValue:DWORD;
 begin

  ResultLen:=0;

  repeat

   if not ReadConsoleInputW(fConsoleInputHandle,InputRecord,1,ReadCount) then begin
    exit;
   end;

   if (ReadCount=1) and (InputRecord.EventType=KEY_EVENT) and InputRecord.Event.KeyEvent.bKeyDown then begin

    CharValue:=ord(InputRecord.Event.KeyEvent.UnicodeChar);

    while CharValue=0 do begin

     if not ReadConsoleInputW(fConsoleInputHandle,InputRecord,1,ReadCount) then begin
      exit;
     end;

     if (ReadCount=1) and (InputRecord.EventType=KEY_EVENT) then begin
      CharValue:=ord(InputRecord.Event.KeyEvent.UnicodeChar);
      if not InputRecord.Event.KeyEvent.bKeyDown then begin
       break;
      end;
     end;
    end;

    if CharValue>=$80 then begin

     if (CharValue>=$d800) and (CharValue<$e000) then begin
      if not ReadConsoleInputW(fConsoleInputHandle,InputRecord,1,ReadCount) then begin
       exit;
      end;
      if (ReadCount=1) and (InputRecord.EventType=KEY_EVENT) and InputRecord.Event.KeyEvent.bKeyDown then begin
       Surrogate:=ord(InputRecord.Event.KeyEvent.UnicodeChar);
       while Surrogate=0 do begin
        if not ReadConsoleInputW(fConsoleInputHandle,InputRecord,1,ReadCount) then begin
         exit;
        end;
        if (ReadCount=1) and (InputRecord.EventType=KEY_EVENT) then begin
         Surrogate:=ord(InputRecord.Event.KeyEvent.UnicodeChar);
         if not InputRecord.Event.KeyEvent.bKeyDown then begin
          break;
         end;
        end;
       end;
       CharValue:=($010000-$dc00)+((CharValue-$d800) shl 10)+Surrogate;
      end;
     end;

     if CharValue=0 then begin
      exit;
     end else begin
      if CharValue<=$7f then begin
       Data[0]:=AnsiChar(TPasRISCVUInt8(CharValue));
       ResultLen:=1;
      end else if CharValue<=$7ff then begin
       Data[0]:=AnsiChar(TPasRISCVUInt8($c0 or ((CharValue shr 6) and $1f)));
       Data[1]:=AnsiChar(TPasRISCVUInt8($80 or (CharValue and $3f)));
       ResultLen:=2;
{     end else if CharValue<=$d7ff then begin
       Data[0]:=AnsiChar(TPasRISCVUInt8($e0 or ((CharValue shr 12) and $0f)));
       Data[1]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 6) and $3f)));
       Data[2]:=AnsiChar(TPasRISCVUInt8($80 or (CharValue and $3f)));
       ResultLen:=3;
      end else if CharValue<=$dfff then begin
       Data[0]:=#$ef; // $fffd
       Data[1]:=#$bf;
       Data[2]:=#$bd;
       ResultLen:=3;}
      end else if CharValue<=$ffff then begin
       Data[0]:=AnsiChar(TPasRISCVUInt8($e0 or ((CharValue shr 12) and $0f)));
       Data[1]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 6) and $3f)));
       Data[2]:=AnsiChar(TPasRISCVUInt8($80 or (CharValue and $3f)));
       ResultLen:=3;
      end else if CharValue<=$1fffff then begin
       Data[0]:=AnsiChar(TPasRISCVUInt8($f0 or ((CharValue shr 18) and $07)));
       Data[1]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 12) and $3f)));
       Data[2]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 6) and $3f)));
       Data[3]:=AnsiChar(TPasRISCVUInt8($80 or (CharValue and $3f)));
       ResultLen:=4;
//{
      end else if CharValue<=$3ffffff then begin
       Data[0]:=AnsiChar(TPasRISCVUInt8($f8 or ((CharValue shr 24) and $03)));
       Data[1]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 18) and $3f)));
       Data[2]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 12) and $3f)));
       Data[3]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 6) and $3f)));
       Data[4]:=AnsiChar(TPasRISCVUInt8($80 or (CharValue and $3f)));
       ResultLen:=5;
      end else if CharValue<=$7fffffff then begin
       Data[0]:=AnsiChar(TPasRISCVUInt8($fc or ((CharValue shr 30) and $01)));
       Data[1]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 24) and $3f)));
       Data[2]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 18) and $3f)));
       Data[3]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 12) and $3f)));
       Data[4]:=AnsiChar(TPasRISCVUInt8($80 or ((CharValue shr 6) and $3f)));
       Data[5]:=AnsiChar(TPasRISCVUInt8($80 or (CharValue and $3f)));
       ResultLen:=6;//}
      end else begin
       Data[0]:=#$ef; // $fffd
       Data[1]:=#$bf;
       Data[2]:=#$bd;
       ResultLen:=3;
      end;

     end;

    end else begin

     Data[0]:=AnsiChar(TPasRISCVUInt8(CharValue));
     ResultLen:=1;

    end;

    break;

   end;

  until false;
 end;
{$elseif defined(fpc) and defined(Unix)}
var InputFD:pollfd;
    InputChar:AnsiChar;
{$else}
var InputChar:AnsiChar;
{$ifend}
begin
 NameThreadForDebugging(' TPasRISCV.TUARTInputThread');
{$if defined(fpc) and defined(Unix)}
 InputFD.fd:=StdInputHandle;
 InputFD.events:=POLLIN;
{$ifend}
 while not Terminated do begin
{$if defined(Windows) and not defined(fpc)}
  ReadCount:=0;
  if PeekConsoleInputW(fConsoleInputHandle,InputRecord,1,ReadCount) and
     (ReadCount=1) and
     (InputRecord.EventType=KEY_EVENT) and
     InputRecord.Event.KeyEvent.bKeyDown then begin
   ReadInput;
   if ResultLen>0 then begin
    repeat
     if fUARTDevice.fInputQueue.AvailableForEnqueue>=ResultLen then begin
      for Index:=1 to ResultLen do begin
       fUARTDevice.fInputQueue.Enqueue(Data[Index-1]);
      end;
      fUARTDevice.fMachine.UARTDevice.Notify;
      fUARTDevice.fMachine.Interrupt;
      fUARTDevice.fMachine.WakeUp;
      break;
     end else begin
      fEvent.WaitFor(1);
     end;
    until Terminated;
   end;
  end else begin
   if ReadCount=1 then begin
    ReadConsoleInputW(fConsoleInputHandle,InputRecord,1,ReadCount);
   end else begin
    fEvent.WaitFor(1);
   end;
  end;
{$elseif defined(fpc)}
{$if defined(Unix)}
  if FpPoll(@InputFD,1,1000)>0 then begin
   if fpRead(StdInputHandle,@InputChar,1)<>0 then begin
    repeat
     if fUARTDevice.fInputQueue.AvailableForEnqueue>0 then begin
      fUARTDevice.fInputQueue.Enqueue(InputChar);
      fUARTDevice.fMachine.UARTDevice.Notify;
      fUARTDevice.fMachine.Interrupt;
      fUARTDevice.fMachine.WakeUp;
      break;
     end else begin
      fEvent.WaitFor(1);
     end;
    until Terminated;
   end;
  end;
{$else}
  if KeyPressed then begin
   InputChar:=ReadKey;
   if InputChar<>#0 then begin
    repeat
     if fUARTDevice.fInputQueue.AvailableForEnqueue>0 then begin
      fUARTDevice.fInputQueue.Enqueue(InputChar);
      fUARTDevice.fMachine.UARTDevice.Notify;
      fUARTDevice.fMachine.Interrupt;
      fUARTDevice.fMachine.WakeUp;
      break;
     end else begin
      fEvent.WaitFor(1);
     end;
    until Terminated;
   end;
  end else begin
   fEvent.WaitFor(1);
  end;
{$ifend}
{$else}
  Read(InputChar);
  if InputChar<>#0 then begin
   repeat
    if fUARTDevice.fInputQueue.AvailableForEnqueue>0 then begin
     fUARTDevice.fInputQueue.Enqueue(InputChar);
     fUARTDevice.fMachine.UARTDevice.Notify;
     fUARTDevice.fMachine.Interrupt;
     fUARTDevice.fMachine.WakeUp;
     break;
    end else begin
     fEvent.WaitFor(1);
    end;
   until Terminated;
  end;
{$ifend}
 end;
end;

{ TPasRISCV.TUARTDevice.TUARTOutputThread }

constructor TPasRISCV.TUARTDevice.TUARTOutputThread.Create(const aUARTDevice:TUARTDevice);
begin
{$if defined(Windows) and not defined(fpc)}
 fConsoleOutputHandle:=GetStdHandle(STD_OUTPUT_HANDLE);
{$ifend}
 fUARTDevice:=aUARTDevice;
 fEvent:=TEvent.Create(nil,false,false,'');
 inherited Create(false);
end;

destructor TPasRISCV.TUARTDevice.TUARTOutputThread.Destroy;
begin
 Shutdown;
 inherited Destroy;
end;

procedure TPasRISCV.TUARTDevice.TUARTOutputThread.Shutdown;
begin
 if not Finished then begin
  Terminate;
  fEvent.SetEvent;
  WaitFor;
 end;
end;

procedure TPasRISCV.TUARTDevice.TUARTOutputThread.Execute;
var Count:TPasMPSizeInt;
{$if defined(Windows) and not defined(fpc)}
    Written:DWORD;
{$ifend}
begin
 NameThreadForDebugging(' TPasRISCV.TUARTOutputThread');
 while not Terminated do begin
{$if defined(Windows) and not defined(fpc)}
  while not Terminated do begin
   fEvent.WaitFor(1000);
   Count:=fUARTDevice.fOutputRingBuffer.ReadAsMuchAsPossible(@fBuffer[0],SizeOf(fBuffer)-1);
   if Count>0 then begin
    fBuffer[Count]:=#0;
    WriteFile(fConsoleOutputHandle,fBuffer,Count,Written,nil);
   end;
  end;
{$elseif defined(fpc) and defined(Unix)}
  while not Terminated do begin
   fEvent.WaitFor(1000);
   Count:=fUARTDevice.fOutputRingBuffer.ReadAsMuchAsPossible(@fBuffer[0],SizeOf(fBuffer));
   if Count>0 then begin
    fpWrite(StdOutputHandle,@fBuffer[0],Count);
   end;
  end;
{$else}
  while not Terminated do begin
   fEvent.WaitFor(1000);
   Count:=fUARTDevice.fOutputRingBuffer.ReadAsMuchAsPossible(@fBuffer[0],SizeOf(fBuffer)-1);
   if Count>0 then begin
    fBuffer[Count]:=#0;
    Write(PAnsiChar(@fBuffer[0]));
   end;
  end;
{$ifend}
 end;
end;

{$ifend}

{ TPasRISCV.TUARTDevice }

constructor TPasRISCV.TUARTDevice.Create(const aMachine:TPasRISCV);
{$if defined(PasRISCVUseRealConsole)}
{$if defined(fpc) and defined(Unix)}
var Term:TTermios;
{$ifend}
{$ifend}
begin
 inherited Create(aMachine,aMachine.fConfiguration.fUARTBase,aMachine.fConfiguration.fUARTSize);

 fIRQ:=aMachine.fConfiguration.fUARTIRQ;

 fDLL:=0;
 fDLM:=0;
 fISR:=0;
 fIER:=0;
 fFCR:=0;
 fLCR:=0;
 fMCR:=0;
 fMSR:=0;
 fSCR:=0;

{$if defined(PasRISCVUseRealConsole)}
{$if defined(fpc) and defined(Unix)}
 Term.c_line:=#0;
 TCGetAttr(0,Term);
 fOriginalTerm:=Term;
 Term.c_lflag:=Term.c_lflag and not (termio.ECHO or termio.ICANON or termio.ISIG or termio.IEXTEN);
 Term.c_iflag:=Term.c_iflag and not (termio.IXON or termio.ICRNL);
 TCSetAttr(0,TCSAFLUSH,Term);
{$ifend}
{$ifend}

 fInputQueue:=TCharQueue.Create(1048576);

 fOutputRingBuffer:=TPasMPSingleProducerSingleConsumerRingBuffer.Create(1048576);

{$if not defined(PasRISCVUseRealConsole)}
 fOutputEvent:=TPasMPEvent.Create(nil,false,false,'');
{$ifend}

{$if defined(PasRISCVUseRealConsole)}
 fUARTInputThread:=TUARTInputThread.Create(self);

 fUARTOutputThread:=TUARTOutputThread.Create(self);
{$ifend}

end;

destructor TPasRISCV.TUARTDevice.Destroy;
begin
{$if defined(PasRISCVUseRealConsole)}
 fUARTInputThread.Shutdown;
 fUARTOutputThread.Shutdown;
 FreeAndNil(fUARTInputThread);
 FreeAndNil(fUARTOutputThread);
{$ifend}
{$if not defined(PasRISCVUseRealConsole)}
 FreeAndNil(fOutputEvent);
{$ifend}
 FreeAndNil(fOutputRingBuffer);
 FreeAndNil(fInputQueue);
{$if defined(PasRISCVUseRealConsole)}
{$if defined(fpc) and defined(Unix)}
 TCSetAttr(0,TCSAFLUSH,fOriginalTerm);
{$ifend}
{$ifend}
inherited Destroy;
end;

function TPasRISCV.TUARTDevice.Poll:TPasRISCVUInt32;
begin
 result:=0;
 if fInputQueue.AvailableForDequeue>0 then begin
  result:=result or POLL_RX;
 end;
 if fInputQueue.AvailableForEnqueue>0 then begin
  result:=result or POLL_TX;
 end;
end;

function TPasRISCV.TUARTDevice.ReadChar:TPasRISCVUInt32;
var c:AnsiChar;
begin
 if fInputQueue.Dequeue(c) then begin
  result:=TPasRISCVUInt8(c);
 end else begin
  result:=0;
 end;
end;

procedure TPasRISCV.TUARTDevice.WriteChar(const aValue:TPasRISCVUInt32);
var c:AnsiChar;
begin
 c:=AnsiChar(TPasRISCVUInt8(aValue and $ff));
 fOutputRingBuffer.Write(@c,SizeOf(AnsiChar));
{$if defined(PasRISCVUseRealConsole)}
 fUARTOutputThread.fEvent.SetEvent;
{$else}
 fOutputEvent.SetEvent;
{$ifend}
end;

function TPasRISCV.TUARTDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address,Flags,IER_:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case Address of
  thr{dll}:begin
   if (TPasMPInterlocked.Read(fLCR) and lcr_dlab)<>0 then begin
    result:=TPasMPInterlocked.Read(fDLL) and $ff;
   end else if (Poll and POLL_RX)<>0 then begin
    result:=ReadChar and $ff;
   end else begin
    result:=0;
   end;
  end;
  ier{dlm}:begin
   if (TPasMPInterlocked.Read(fLCR) and lcr_dlab)<>0 then begin
    result:=TPasMPInterlocked.Read(fDLM) and $ff;
   end else begin
    result:=TPasMPInterlocked.Read(fIER) and $ff;
   end;
  end;
  isr:begin
   Flags:=Poll;
   IER_:=TPasMPInterlocked.Read(fIER) and $ff;
   if ((Flags and POLL_RX)<>0) and ((IER_ and ier_rdi)<>0) then begin
    result:=iir_recv or iir_fifo;
   end else if ((Flags and POLL_TX)<>0) and ((IER_ and ier_thri)<>0) then begin
    result:=iir_thr or iir_fifo;
   end else begin
    result:=iir_none or iir_fifo;
   end;
// result:=TPasMPInterlocked.Read(fISR) and $ff;
  end;
  lcr:begin
   result:=TPasMPInterlocked.Read(fLCR) and $ff;
  end;
  mcr:begin
   result:=TPasMPInterlocked.Read(fMCR) and $ff;
  end;
  lsr:begin
   Flags:=Poll;
   result:=0;
   if (Flags and POLL_RX)<>0 then begin
    result:=result or lsr_dr;
   end;
   if (Flags and POLL_TX)<>0 then begin
    result:=result or (lsr_thre or lsr_temt);
   end;
// result:=TPasMPInterlocked.Read(fLSR) and $ff;
  end;
  msr:begin
   result:=TPasMPInterlocked.Read(fMSR) and $ff;
  end;
  scr:begin
   result:=TPasMPInterlocked.Read(fSCR) and $ff;
  end;
  else begin
   result:=0;
  end;
 end;
end;

procedure TPasRISCV.TUARTDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case Address of
  thr{dll}:begin
   if (TPasMPInterlocked.Read(fLCR) and lcr_dlab)<>0 then begin
    TPasMPInterlocked.Write(fDLL,aValue and $ff);
   end else begin
    WriteChar(aValue);
   end;
  end;
  ier{dlm}:begin
   if (TPasMPInterlocked.Read(fLCR) and lcr_dlab)<>0 then begin
    TPasMPInterlocked.Write(fDLM,aValue and $ff);
   end else begin
    TPasMPInterlocked.Write(fIER,aValue and $ff);
    DispatchInterrupt(Poll);
   end;
  end;
  fcr:begin
   TPasMPInterlocked.Write(fFCR,aValue and $ff);
  end;
  lcr:begin
   TPasMPInterlocked.Write(fLCR,aValue and $ff);
  end;
  mcr:begin
   TPasMPInterlocked.Write(fMCR,aValue and $ff);
  end;
  scr:begin
   TPasMPInterlocked.Write(fSCR,aValue and $ff);
  end;
  else begin
  end;
 end;
end;

procedure TPasRISCV.TUARTDevice.DispatchInterrupt(const aFlags:TPasRISCVUInt32);
var IER_:TPasRISCVUInt32;
begin
 IER_:=TPasMPInterlocked.Read(fIER);
 if (((aFlags and POLL_RX)<>0) and ((IER_ and ier_rdi)<>0)) or
    (((aFlags and POLL_TX)<>0) and ((IER_ and ier_thri)<>0)) then begin
  fMachine.fInterrupts.SendIRQ(fIRQ);
 end;
end;

procedure TPasRISCV.TUARTDevice.Notify;
begin
 DispatchInterrupt(Poll);
end;

{ TPasRISCV.TGoldfishRTCDevice }

constructor TPasRISCV.TGoldfishRTCDevice.Create(const aMachine:TPasRISCV);
var CurrentTime:TDateTime;
    UnixSeconds:TPasRISCVInt64;
begin
 inherited Create(aMachine,aMachine.fConfiguration.fGoldfishRTCBase,aMachine.fConfiguration.fGoldfishRTCSize);
 fIRQ:=aMachine.fConfiguration.fGoldfishRTCIRQ;
 fUnalignedAccessSupport:=false;
 fMinOpSize:=4;
 fMaxOpSize:=4;
 // Compute tick offset so GetCount returns ns since Unix epoch
 CurrentTime:={$if declared(NowUTC)}NowUTC{$else}Now{$ifend};
 UnixSeconds:=DateTimeToUnix(CurrentTime{$if declared(NowUTC)},true{$else},false{$ifend});
 fTickOffset:=(UnixSeconds*TPasRISCVInt64(1000000000))-TPasRISCVInt64(GetCurrentFrequencyTime(1000000000));
 fTimeHigh:=0;
 fAlarmNext:=0;
 fAlarmRunning:=false;
 fIRQEnabled:=false;
 fIRQPending:=false;
end;

destructor TPasRISCV.TGoldfishRTCDevice.Destroy;
begin
 inherited Destroy;
end;

function TPasRISCV.TGoldfishRTCDevice.GetCount:TPasRISCVUInt64;
begin
 result:=TPasRISCVUInt64(TPasRISCVInt64(GetCurrentFrequencyTime(1000000000))+fTickOffset);
end;

procedure TPasRISCV.TGoldfishRTCDevice.UpdateIRQ;
begin
 if fIRQPending and fIRQEnabled then begin
  fMachine.fInterrupts.RaiseIRQ(fIRQ);
 end else begin
  fMachine.fInterrupts.LowerIRQ(fIRQ);
 end;
end;

procedure TPasRISCV.TGoldfishRTCDevice.CheckAlarm;
begin
 if fAlarmRunning and (GetCount>=fAlarmNext) then begin
  fAlarmRunning:=false;
  fIRQPending:=true;
  UpdateIRQ;
 end;
end;

function TPasRISCV.TGoldfishRTCDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
    Count:TPasRISCVUInt64;
begin
 if fAlarmRunning then begin
  CheckAlarm;
 end;
 Address:=aAddress-fBase;
 case Address of
  REG_TIME_LOW:begin
   Count:=GetCount;
   fTimeHigh:=TPasRISCVUInt32(Count shr 32);
   result:=TPasRISCVUInt32(Count);
  end;
  REG_TIME_HIGH:begin
   result:=fTimeHigh;
  end;
  REG_ALARM_LOW:begin
   result:=TPasRISCVUInt32(fAlarmNext);
  end;
  REG_ALARM_HIGH:begin
   result:=TPasRISCVUInt32(fAlarmNext shr 32);
  end;
  REG_IRQ_ENABLED:begin
   result:=ord(fIRQEnabled);
  end;
  REG_ALARM_STATUS:begin
   result:=ord(fAlarmRunning);
  end;
  else begin
   result:=0;
  end;
 end;
end;

procedure TPasRISCV.TGoldfishRTCDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
    Current,NewTime:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case Address of
  REG_TIME_LOW:begin
   Current:=GetCount;
   NewTime:=(Current and TPasRISCVUInt64($ffffffff00000000)) or TPasRISCVUInt64(TPasRISCVUInt32(aValue));
   fTickOffset:=fTickOffset+TPasRISCVInt64(NewTime)-TPasRISCVInt64(Current);
  end;
  REG_TIME_HIGH:begin
   Current:=GetCount;
   NewTime:=(Current and TPasRISCVUInt64($00000000ffffffff)) or (TPasRISCVUInt64(TPasRISCVUInt32(aValue)) shl 32);
   fTickOffset:=fTickOffset+TPasRISCVInt64(NewTime)-TPasRISCVInt64(Current);
  end;
  REG_ALARM_LOW:begin
   fAlarmNext:=(fAlarmNext and TPasRISCVUInt64($ffffffff00000000)) or TPasRISCVUInt64(TPasRISCVUInt32(aValue));
   // Writing ALARM_LOW activates the alarm
   fAlarmRunning:=true;
   CheckAlarm;
  end;
  REG_ALARM_HIGH:begin
   fAlarmNext:=(fAlarmNext and TPasRISCVUInt64($00000000ffffffff)) or (TPasRISCVUInt64(TPasRISCVUInt32(aValue)) shl 32);
  end;
  REG_IRQ_ENABLED:begin
   fIRQEnabled:=(aValue and 1)<>0;
   UpdateIRQ;
  end;
  REG_CLEAR_ALARM:begin
   fAlarmRunning:=false;
   fAlarmNext:=0;
  end;
  REG_CLEAR_INTERRUPT:begin
   fIRQPending:=false;
   UpdateIRQ;
  end;
 end;
end;

{ TPasRISCV.TDS1742Device }

constructor TPasRISCV.TDS1742Device.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fDS1742Base,aMachine.fConfiguration.fDS1742Size);
 fCtl:=0;
 FillChar(fRegisters,SizeOf(fRegisters),#0);
 UpdateRegisters;
end;

destructor TPasRISCV.TDS1742Device.Destroy;
begin
 inherited Destroy;
end;

class function TPasRISCV.TDS1742Device.ConvertBCD(const aValue:TPasRISCVUInt8):TPasRISCVUInt8;
begin
 result:=((aValue div 10) shl 4) or (aValue mod 10);
end;

class function TPasRISCV.TDS1742Device.ConvertFromBCD(const aValue:TPasRISCVUInt8):TPasRISCVUInt8;
begin
 result:=((aValue shr 4)*10)+(aValue and $f);
end;

procedure TPasRISCV.TDS1742Device.UpdateRegisters;
var CurrentTime:TDateTime;
//  UnixTime:TPasRISCVInt64;
    Year,Month,Day,DayOfWeek,Hour,Minute,Second,Millisecond:TPasRISCVUInt16;
begin
//UnixTime:=DateTimeToUnix({$if declared(NowUTC)}NowUTC,true{$else}Now,false{$ifend});
 CurrentTime:={$if declared(NowUTC)}NowUTC{$else}Now{$ifend};
 DecodeDateFully(CurrentTime,Year,Month,Day,DayOfWeek);
 DecodeTime(CurrentTime,Hour,Minute,Second,Millisecond);
 fRegisters[REG_CTL_CENT]:=ConvertBCD(Year div 100);
 fRegisters[REG_SECONDS]:=ConvertBCD(Min(59,Second));
 fRegisters[REG_MINUTES]:=ConvertBCD(Minute);
 fRegisters[REG_HOURS]:=ConvertBCD(Hour);
 fRegisters[REG_DAY]:=ConvertBCD(DayOfWeek);
 fRegisters[REG_DATE]:=ConvertBCD(Day);
 fRegisters[REG_MONTH]:=ConvertBCD(Month);
 fRegisters[REG_YEAR]:=ConvertBCD(Year mod 100);
end;

function TPasRISCV.TDS1742Device.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
//writeln('DS1742: ',Address);
 case Address of
  REG_CTL_CENT:begin
   result:=fRegisters[REG_CTL_CENT] or fCtl;
  end;
  REG_DAY:begin
   result:=fRegisters[REG_DAY] or DAY_BATT;
  end;
  else begin
   if Address<length(fRegisters) then begin
    result:=fRegisters[Address];
   end else begin
    result:=0;
   end;
  end;
 end;
end;

procedure TPasRISCV.TDS1742Device.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address,NewCtl:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case Address of
  REG_CTL_CENT:begin
   NewCtl:=aValue and CTL_MASK;
   if ((fCtl and CTL_READ)=0) and ((NewCtl and CTL_READ)<>0) then begin
    UpdateRegisters;
   end;
   fCtl:=NewCtl;
  end;
  else begin
  end;
 end;
end;

{ TPasRISCV.TFrameBufferDevice }

constructor TPasRISCV.TFrameBufferDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create;
 fMachine:=aMachine;
 fLock:=TPasMPMultipleReaderSingleWriterLock.Create;
 fActive:=false;
 fAutomaticRefresh:=false;
 fWidth:=aMachine.fConfiguration.fFrameBufferWidth;
 fHeight:=aMachine.fConfiguration.fFrameBufferHeight;
 fBytesPerPixel:=aMachine.fConfiguration.fFrameBufferBytesPerPixel;
 fData:=nil;
 SetLength(fData,fWidth*fHeight*fBytesPerPixel);
 fRGBA32Data:=nil;
 SetLength(fRGBA32Data,fWidth*fHeight*4);
 fComposited:=nil;
 SetLength(fComposited,fWidth*fHeight*4);
 FillChar(fCursor,SizeOf(fCursor),#0);
 fCursor.Visible:=false;
 fCursorCompositing:=false;
 fDirectRGBA32:=false;
 fSwapColorChannels:=false;
 fDirty:=true;
 fIgnoreDirty:=false;
 ClearFrameBuffer;
end;

destructor TPasRISCV.TFrameBufferDevice.Destroy;
begin
 fData:=nil;
 fRGBA32Data:=nil;
 fComposited:=nil;
 FreeAndNil(fLock);
 inherited Destroy;
end;

procedure TPasRISCV.TFrameBufferDevice.ResizeFrameBuffer(const aWidth,aHeight,aBytesPerPixel:TPasRISCVUInt32);
var NewData:TPasRISCVUInt8DynamicArray;
    NewSize:TPasRISCVSizeInt;
begin
 fLock.AcquireWrite;
 try
  fWidth:=aWidth;
  fHeight:=aHeight;
  fBytesPerPixel:=aBytesPerPixel;
  NewSize:=fWidth*fHeight*fBytesPerPixel;
  if length(fData)<NewSize then begin
   NewData:=nil;
   try
    SetLength(NewData,NewSize*2);
    Move(fData[0],NewData[0],length(fData));
   finally
    fData:=NewData;
   end;
  end;
  if length(fRGBA32Data)<(fWidth*fHeight*4) then begin
   SetLength(fRGBA32Data,fWidth*fHeight*4);
  end;
  if fCursorCompositing and (length(fComposited)<(fWidth*fHeight*4)) then begin
   SetLength(fComposited,fWidth*fHeight*4);
  end;
  fDirty:=true;
 finally
  fLock.ReleaseWrite;
 end;
end;

procedure TPasRISCV.TFrameBufferDevice.ClearFrameBuffer;
var Index:TPasRISCVSizeInt;
    Pixel:PPasRISCVUInt32;
begin
 if length(fData)>0 then begin
  Pixel:=@fData[0];
  for Index:=1 to fWidth*fHeight do begin
   Pixel^:=$00000000;
   inc(Pixel);
  end;
 end;
 fDirty:=true;
end;

function TPasRISCV.TFrameBufferDevice.CheckDirtyAndFlush:Boolean;
begin
 result:=TPasMPInterlocked.CompareExchange(fDirty,TPasMPBool32(false),TPasMPBool32(true)) or fIgnoreDirty;
end;

procedure TPasRISCV.TFrameBufferDevice.MarkDirty;
begin
 fDirty:=true;
end;

procedure TPasRISCV.TFrameBufferDevice.SetCursorImage(const aData:Pointer;const aSize:TPasRISCVUInt32);
var CopySize:TPasRISCVUInt32;
begin
 CopySize:=aSize;
 if CopySize>CURSOR_BYTES then begin
  CopySize:=CURSOR_BYTES;
 end;
 Move(aData^,fCursor.Data[0],CopySize);
 if CopySize<CURSOR_BYTES then begin
  FillChar(fCursor.Data[CopySize],CURSOR_BYTES-CopySize,#0);
 end;
 fDirty:=true;
end;

procedure TPasRISCV.TFrameBufferDevice.SetCursorPosition(const aX,aY:TPasRISCVInt32);
begin
 fCursor.X:=aX;
 fCursor.Y:=aY;
end;

procedure TPasRISCV.TFrameBufferDevice.SetCursorHotspot(const aHotX,aHotY:TPasRISCVInt32);
begin
 fCursor.HotX:=aHotX;
 fCursor.HotY:=aHotY;
end;

procedure TPasRISCV.TFrameBufferDevice.SetCursorVisible(const aVisible:Boolean);
begin
 fCursor.Visible:=aVisible;
 fDirty:=true;
end;

procedure TPasRISCV.TFrameBufferDevice.CompositeCursor;
var CurX,CurY:TPasRISCVInt32;
    StartX,StartY,EndX,EndY:TPasRISCVInt32;
    Row,Col:TPasRISCVInt32;
    SrcOffset,DstOffset:TPasRISCVUInt64;
    Stride:TPasRISCVUInt64;
    SrcPixel,DstPixel:PPasRISCVUInt8Array;
    Alpha,InvAlpha:TPasRISCVUInt32;
    SourceData:TPasRISCVUInt8DynamicArray;
    PixelCount32:TPasRISCVSizeInt;
begin    
 // Use converted RGBA32 data when not 32bpp, otherwise use raw fData
 if fBytesPerPixel=4 then begin
  SourceData:=fData;
 end else begin
  SourceData:=fRGBA32Data;
 end;
 // Composite buffer is always 32bpp
 PixelCount32:=fWidth*fHeight*4;
 if length(fComposited)<PixelCount32 then begin
  SetLength(fComposited,PixelCount32);
 end;
 Move(SourceData[0],fComposited[0],PixelCount32);
 if fCursor.Visible then begin
  // Calculate cursor draw position (top-left corner = cursor pos - hotspot)
  CurX:=fCursor.X-fCursor.HotX;
  CurY:=fCursor.Y-fCursor.HotY;
  // Clip to framebuffer
  StartX:=0;
  StartY:=0;
  EndX:=CURSOR_SIZE;
  EndY:=CURSOR_SIZE;
  if CurX<0 then begin
   StartX:=-CurX;
  end;
  if CurY<0 then begin
   StartY:=-CurY;
  end;
  if (CurX+EndX)>TPasRISCVInt32(fWidth) then begin
   EndX:=TPasRISCVInt32(fWidth)-CurX;
  end;
  if (CurY+EndY)>TPasRISCVInt32(fHeight) then begin
   EndY:=TPasRISCVInt32(fHeight)-CurY;
  end;
  if (StartX<EndX) and (StartY<EndY) then begin
   Stride:=TPasRISCVUInt64(fWidth)*4;
   for Row:=StartY to EndY-1 do begin
    for Col:=StartX to EndX-1 do begin
     SrcOffset:=(TPasRISCVUInt64(Row)*CURSOR_SIZE+TPasRISCVUInt64(Col))*4;
     SrcPixel:=PPasRISCVUInt8Array(@fCursor.Data[SrcOffset]);
     Alpha:=SrcPixel^[3];
     if Alpha<>0 then begin
      DstOffset:=TPasRISCVUInt64(CurY+Row)*Stride+TPasRISCVUInt64(CurX+Col)*4;
      DstPixel:=PPasRISCVUInt8Array(@PPasRISCVUInt8Array(fComposited)^[DstOffset]);
      if Alpha=255 then begin
       // Opaque — direct copy
       DstPixel^[0]:=SrcPixel^[0];
       DstPixel^[1]:=SrcPixel^[1];
       DstPixel^[2]:=SrcPixel^[2];
       DstPixel^[3]:=255;
      end else begin
       // Alpha blend
       InvAlpha:=255-Alpha;
       DstPixel^[0]:=TPasRISCVUInt8(((SrcPixel^[0]*Alpha)+(DstPixel^[0]*InvAlpha)+127) shr 8);
       DstPixel^[1]:=TPasRISCVUInt8(((SrcPixel^[1]*Alpha)+(DstPixel^[1]*InvAlpha)+127) shr 8);
       DstPixel^[2]:=TPasRISCVUInt8(((SrcPixel^[2]*Alpha)+(DstPixel^[2]*InvAlpha)+127) shr 8);
       DstPixel^[3]:=255;
      end;
     end; 
    end;
   end;
  end;
 end;
end; 

procedure TPasRISCV.TFrameBufferDevice.ConvertToRGBA32(const aSrc:TPasRISCVUInt8DynamicArray);
var PixelCount,PixelIndex:TPasRISCVSizeInt;
    SrcPtr:PPasRISCVUInt8;
    DstPtr:PPasRISCVUInt32;
    Pixel16,Pixel,r,g,b:TPasRISCVUInt32;
    RGBA32DataSize:TPasRISCVSizeInt;
begin
 PixelCount:=fWidth*fHeight;
 RGBA32DataSize:=PixelCount*4;
 if length(fRGBA32Data)<RGBA32DataSize then begin
  SetLength(fRGBA32Data,RGBA32DataSize);
 end;
 case fBytesPerPixel of
  4:begin
   // BGRA8888/RGBA8888 — copy with optional channel swap
   if length(aSrc)>=(PixelCount*4) then begin
    if fSwapColorChannels then begin
     SrcPtr:=@aSrc[0];
     DstPtr:=PPasRISCVUInt32(@fRGBA32Data[0]);
     for PixelIndex:=1 to PixelCount do begin
      Pixel:=PPasRISCVUInt32(SrcPtr)^;
      DstPtr^:=(Pixel and $ff00ff00) or ((Pixel and $00ff0000) shr 16) or ((Pixel and $000000ff) shl 16);
      inc(SrcPtr,4);
      inc(DstPtr);
     end;
    end else begin
     Move(aSrc[0],fRGBA32Data[0],RGBA32DataSize);
    end;
   end else begin
    FillChar(fRGBA32Data[0],RGBA32DataSize,#0);
   end;
  end;
  2:begin
   // RGB565 to RGBA8888 conversion (with optional channel swap)
   if length(aSrc)>=(PixelCount*2) then begin
    SrcPtr:=@aSrc[0];
    DstPtr:=PPasRISCVUInt32(@fRGBA32Data[0]);
    if fSwapColorChannels then begin
     for PixelIndex:=1 to PixelCount do begin
      Pixel16:=PPasRISCVUInt16(SrcPtr)^;
      b:=(Pixel16 shr 11) and $1f;
      g:=(Pixel16 shr 5) and $3f;
      r:=Pixel16 and $1f;
      DstPtr^:=$ff000000 or (((r shl 3) or (r shr 2)) shl 16) or (((g shl 2) or (g shr 4)) shl 8) or ((b shl 3) or (b shr 2));
      inc(SrcPtr,2);
      inc(DstPtr);
     end;
    end else begin
     for PixelIndex:=1 to PixelCount do begin
      Pixel16:=PPasRISCVUInt16(SrcPtr)^;
      r:=(Pixel16 shr 11) and $1f;
      g:=(Pixel16 shr 5) and $3f;
      b:=Pixel16 and $1f;
      DstPtr^:=$ff000000 or (((r shl 3) or (r shr 2)) shl 16) or (((g shl 2) or (g shr 4)) shl 8) or ((b shl 3) or (b shr 2));
      inc(SrcPtr,2);
      inc(DstPtr);
     end;
    end;
   end else begin
    FillChar(fRGBA32Data[0],RGBA32DataSize,#0);
   end;
  end;
  3:begin
   // BGR888/RGB888 to RGBA8888 conversion (with optional channel swap)
   if length(aSrc)>=(PixelCount*3) then begin
    SrcPtr:=@aSrc[0];
    DstPtr:=PPasRISCVUInt32(@fRGBA32Data[0]);
    if fSwapColorChannels then begin
     for PixelIndex:=1 to PixelCount do begin
      DstPtr^:=$ff000000 or (TPasRISCVUInt32(PPasRISCVUInt8Array(SrcPtr)^[0]) shl 16) or (TPasRISCVUInt32(PPasRISCVUInt8Array(SrcPtr)^[1]) shl 8) or TPasRISCVUInt32(PPasRISCVUInt8Array(SrcPtr)^[2]);
      inc(SrcPtr,3);
      inc(DstPtr);
     end;
    end else begin
     for PixelIndex:=1 to PixelCount do begin
      DstPtr^:=$ff000000 or (TPasRISCVUInt32(PPasRISCVUInt8Array(SrcPtr)^[2]) shl 16) or (TPasRISCVUInt32(PPasRISCVUInt8Array(SrcPtr)^[1]) shl 8) or TPasRISCVUInt32(PPasRISCVUInt8Array(SrcPtr)^[0]);
      inc(SrcPtr,3);
      inc(DstPtr);
     end;
    end;
   end else begin
    FillChar(fRGBA32Data[0],RGBA32DataSize,#0);
   end;
  end;
  1:begin
   // 8bpp grayscale to RGBA8888 conversion (no palette support yet)
   if length(aSrc)>=PixelCount then begin
    SrcPtr:=@aSrc[0];
    DstPtr:=PPasRISCVUInt32(@fRGBA32Data[0]);
    for PixelIndex:=1 to PixelCount do begin
     DstPtr^:=$ff000000 or (TPasRISCVUInt32(SrcPtr^)*$010101);
     inc(SrcPtr);
     inc(DstPtr);
    end;
   end else begin
    FillChar(fRGBA32Data[0],RGBA32DataSize,#0);
   end;
  end;
  else begin
   FillChar(fRGBA32Data[0],RGBA32DataSize,#0);
  end;
 end;
end;

procedure TPasRISCV.TFrameBufferDevice.UpdateOutputData;
begin
 if (fCursorCompositing and fCursor.Visible) or (fBytesPerPixel<>4) or fSwapColorChannels or not fDirectRGBA32 then begin
  ConvertToRGBA32(fData);
  if fCursorCompositing and fCursor.Visible then begin
   CompositeCursor;
   fRGBA32Data:=fComposited;
  end;
 end else begin 
  fRGBA32Data:=fData;
 end;
end; 

function TPasRISCV.TFrameBufferDevice.GetOutputData:TPasRISCVUInt8DynamicArray;
begin
 if fDirectRGBA32 then begin
  result:=fData;
 end else begin
  result:=fRGBA32Data;
 end;
end;

{ TPasRISCV.TSimpleFBDevice }

constructor TPasRISCV.TSimpleFBDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fFrameBufferBase,FrameBufferAddress+aMachine.fConfiguration.fFrameBufferSize);
 fFrameBuffer:=aMachine.fFrameBufferDevice;
 fFrameBuffer.fAutomaticRefresh:=true;
 fFrameBuffer.fDirectRGBA32:=true;
 fFrameBuffer.fIgnoreDirty:=true;
end;

destructor TPasRISCV.TSimpleFBDevice.Destroy;
begin
 fFrameBuffer:=nil;
 inherited Destroy;
end;

function TPasRISCV.TSimpleFBDevice.GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
var Address:TPasRISCVUInt64;
begin
 if (aAddress>=fBase) and ((aAddress-fBase)<fSize) then begin
  Address:=aAddress-fBase;
  if (Address>=FrameBufferAddress) and ((Address-FrameBufferAddress)<length(fFrameBuffer.fData)) then begin
   if aWrite then begin
    fFrameBuffer.fDirty:=true;
   end;
   result:=@fFrameBuffer.fData[Address-FrameBufferAddress];
  end else begin
   result:=aBounce;
  end;
 end else begin
  result:=nil;
 end;
end;

function TPasRISCV.TSimpleFBDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case Address of
  FrameReadyAddress:begin
   result:=0;
  end;
  ActiveAddress:begin
   result:=ord(fFrameBuffer.fActive);
  end;
  ResolutionAddress:begin
   result:=(TPasRISCVUInt64(fFrameBuffer.fWidth) or (TPasRISCVUInt64(fFrameBuffer.fHeight) shl 16));
  end;
  BytesPerPixelAddress:begin
   result:=TPasRISCVUInt64(fFrameBuffer.fBytesPerPixel);
  end;
  WidthAddress:begin
   result:=TPasRISCVUInt64(fFrameBuffer.fWidth);
  end;
  HeightAddress:begin
   result:=TPasRISCVUInt64(fFrameBuffer.fHeight);
  end;
  else begin
   if (Address>=FrameBufferAddress) and ((Address+aSize)<=(FrameBufferAddress+length(fFrameBuffer.fData))) then begin
    dec(Address,FrameBufferAddress);
    case aSize of
     1:begin
      result:=fFrameBuffer.fData[Address];
     end;
     2:begin
      result:=TPasRISCVUInt16(Pointer(@fFrameBuffer.fData[Address])^);
     end;
     4:begin
      result:=TPasRISCVUInt32(Pointer(@fFrameBuffer.fData[Address])^);
     end;
     8:begin
      result:=TPasRISCVUInt64(Pointer(@fFrameBuffer.fData[Address])^);
     end;
     else begin
      result:=0;
     end;
    end;
   end else begin
    result:=0;
   end;
  end;
 end;
end;

procedure TPasRISCV.TSimpleFBDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case Address of
  FrameReadyAddress:begin
   if (aValue<>0) then begin
    fFrameBuffer.UpdateOutputData;
    if assigned(fMachine.OnNewFrame) then begin
     fMachine.OnNewFrame();
    end;
   end;
  end;
  ActiveAddress:begin
   if fFrameBuffer.fActive<>((aValue and 1)<>0) then begin
    fFrameBuffer.fActive:=(aValue and 1)<>0;
    if (aValue and 2)=0 then begin
     fFrameBuffer.ClearFrameBuffer;
    end;
    fFrameBuffer.UpdateOutputData;
    if assigned(fMachine.OnNewFrame) then begin
     fMachine.OnNewFrame();
    end;
   end;
   fFrameBuffer.fAutomaticRefresh:=(aValue and 4)<>0;
   fFrameBuffer.fDirectRGBA32:=fFrameBuffer.fAutomaticRefresh;
  end;
  ResolutionAddress:begin
   fFrameBuffer.ResizeFrameBuffer(TPasRISCVUInt32(aValue and $ffff),TPasRISCVUInt32((aValue shr 16) and $ffff),fFrameBuffer.fBytesPerPixel);
  end;
  BytesPerPixelAddress:begin
   fFrameBuffer.ResizeFrameBuffer(fFrameBuffer.fWidth,fFrameBuffer.fHeight,TPasRISCVUInt32(aValue));
  end;
  WidthAddress:begin
   fFrameBuffer.ResizeFrameBuffer(TPasRISCVUInt32(aValue),fFrameBuffer.fHeight,fFrameBuffer.fBytesPerPixel);
  end;
  HeightAddress:begin
   fFrameBuffer.ResizeFrameBuffer(fFrameBuffer.fWidth,TPasRISCVUInt32(aValue),fFrameBuffer.fBytesPerPixel);
  end;
  else begin
   if (Address>=FrameBufferAddress) and ((Address+aSize)<=(FrameBufferAddress+length(fFrameBuffer.fData))) then begin
    dec(Address,FrameBufferAddress);
    fFrameBuffer.fDirty:=true;
    case aSize of
     1:begin
      fFrameBuffer.fData[Address]:=TPasRISCVUInt8(aValue);
     end;
     2:begin
      TPasRISCVUInt16(Pointer(@fFrameBuffer.fData[Address])^):=TPasRISCVUInt16(aValue);
     end;
     4:begin
      TPasRISCVUInt32(Pointer(@fFrameBuffer.fData[Address])^):=TPasRISCVUInt32(aValue);
     end;
     8:begin
      TPasRISCVUInt64(Pointer(@fFrameBuffer.fData[Address])^):=TPasRISCVUInt64(aValue);
     end;
    end;
   end;
  end;
 end;
end;

{ TPasRISCV.TSharedMemoryDevice }

constructor TPasRISCV.TSharedMemoryDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fSharedMemoryBase,aMachine.fConfiguration.fSharedMemorySize);
 fIRQ:=aMachine.fConfiguration.fSharedMemoryIRQ;
 fLock:=TPasMPMultipleReaderSingleWriterLock.Create;
 fDataSize:=fSize-DATA_OFFSET;
 fData:=nil;
 SetLength(fData,fDataSize);
 FillChar(fData[0],fDataSize,#0);
 fHostFlags:=0;
 fGuestFlags:=0;
 fIRQStatus:=0;
 fOnDoorbell:=nil;
end;

destructor TPasRISCV.TSharedMemoryDevice.Destroy;
begin
 fData:=nil;
 FreeAndNil(fLock);
 inherited Destroy;
end;

function TPasRISCV.TSharedMemoryDevice.GetDataPointer:Pointer;
begin
 if length(fData)>0 then begin
  result:=@fData[0];
 end else begin
  result:=nil;
 end;
end;

function TPasRISCV.TSharedMemoryDevice.GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
var Address:TPasRISCVUInt64;
begin
 if (aAddress>=fBase) and ((aAddress-fBase)<fSize) then begin
  Address:=aAddress-fBase;
  if (Address>=DATA_OFFSET) and ((Address-DATA_OFFSET+aSize)<=fDataSize) then begin
   result:=@fData[Address-DATA_OFFSET];
  end else begin
   result:=aBounce;
  end;
 end else begin
  result:=nil;
 end;
end;

function TPasRISCV.TSharedMemoryDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case Address of
  REG_DOORBELL:begin
   result:=0;
  end;
  REG_HOST_FLAGS:begin
   result:=TPasRISCVUInt64(fHostFlags);
  end;
  REG_GUEST_FLAGS:begin
   result:=TPasRISCVUInt64(fGuestFlags);
  end;
  REG_SIZE:begin
   result:=fDataSize;
  end;
  REG_IRQ_STATUS:begin
   result:=TPasRISCVUInt64(fIRQStatus);
  end;
  REG_IRQ_ACK:begin
   result:=0;
  end;
  else begin
   if (Address>=DATA_OFFSET) and ((Address-DATA_OFFSET+aSize)<=fDataSize) then begin
    dec(Address,DATA_OFFSET);
    case aSize of
     1:begin
      result:=fData[Address];
     end;
     2:begin
      result:=TPasRISCVUInt16(Pointer(@fData[Address])^);
     end;
     4:begin
      result:=TPasRISCVUInt32(Pointer(@fData[Address])^);
     end;
     8:begin
      result:=TPasRISCVUInt64(Pointer(@fData[Address])^);
     end;
     else begin
      result:=0;
     end;
    end;
   end else begin
    result:=0;
   end;
  end;
 end;
end;

procedure TPasRISCV.TSharedMemoryDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case Address of
  REG_DOORBELL:begin
   if assigned(fOnDoorbell) then begin
    fOnDoorbell(self,TPasRISCVUInt32(aValue));
   end;
  end;
  REG_HOST_FLAGS:begin
   // Read-only for guest, ignore
  end;
  REG_GUEST_FLAGS:begin
   fGuestFlags:=TPasRISCVUInt32(aValue);
  end;
  REG_SIZE:begin
   // Read-only, ignore
  end;
  REG_IRQ_STATUS:begin
   // Read-only, ignore
  end;
  REG_IRQ_ACK:begin
   fIRQStatus:=fIRQStatus and (not TPasRISCVUInt32(aValue));
   if fIRQStatus=0 then begin
    fMachine.fInterrupts.LowerIRQ(fIRQ);
   end;
  end;
  else begin
   if (Address>=DATA_OFFSET) and ((Address-DATA_OFFSET+aSize)<=fDataSize) then begin
    dec(Address,DATA_OFFSET);
    case aSize of
     1:begin
      fData[Address]:=TPasRISCVUInt8(aValue);
     end;
     2:begin
      TPasRISCVUInt16(Pointer(@fData[Address])^):=TPasRISCVUInt16(aValue);
     end;
     4:begin
      TPasRISCVUInt32(Pointer(@fData[Address])^):=TPasRISCVUInt32(aValue);
     end;
     8:begin
      TPasRISCVUInt64(Pointer(@fData[Address])^):=TPasRISCVUInt64(aValue);
     end;
    end;
   end;
  end;
 end;
end;

procedure TPasRISCV.TSharedMemoryDevice.RingDoorbell;
begin
 fIRQStatus:=fIRQStatus or 1;
 fMachine.fInterrupts.SendIRQ(fIRQ);
end;

{ TPasRISCV.TRawKeyboardDevice }

constructor TPasRISCV.TRawKeyboardDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fRawKeyboardBase,aMachine.fConfiguration.fRawKeyboardSize);
 fPointerToData:=@fData;
 FillChar(fData,SizeOf(fData),#0);
end;

destructor TPasRISCV.TRawKeyboardDevice.Destroy;
begin
 inherited Destroy;
end;

function TPasRISCV.TRawKeyboardDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case Address of
  KeyArrayAddress..ModifiersAddress:begin
   case aSize of
    1:begin
     result:=TPasRISCVUInt8(Pointer(@PPasRISCVUInt8Array(fPointerToData)^[Address])^);
    end;
    2:begin
     result:=TPasRISCVUInt16(Pointer(@PPasRISCVUInt8Array(fPointerToData)^[Address])^);
    end;
    4:begin
     result:=TPasRISCVUInt32(Pointer(@PPasRISCVUInt8Array(fPointerToData)^[Address])^);
    end;
    8:begin
     result:=TPasRISCVUInt64(Pointer(@PPasRISCVUInt8Array(fPointerToData)^[Address])^);
    end;
    else begin
     result:=0;
    end;
   end;
  end;
  else begin
   result:=0;
  end;
 end;
end;

procedure TPasRISCV.TRawKeyboardDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 case Address of
  KeyArrayAddress..ModifiersAddress:begin
   case aSize of
    1:begin
     TPasRISCVUInt8(Pointer(@PPasRISCVUInt8Array(fPointerToData)^[Address])^):=TPasRISCVUInt8(aValue);
    end;
    2:begin
     TPasRISCVUInt16(Pointer(@PPasRISCVUInt8Array(fPointerToData)^[Address])^):=TPasRISCVUInt16(aValue);
    end;
    4:begin
     TPasRISCVUInt32(Pointer(@PPasRISCVUInt8Array(fPointerToData)^[Address])^):=TPasRISCVUInt32(aValue);
    end;
    8:begin
     TPasRISCVUInt64(Pointer(@PPasRISCVUInt8Array(fPointerToData)^[Address])^):=TPasRISCVUInt64(aValue);
    end;
   end;
  end;
 end;
end;

procedure TPasRISCV.TRawKeyboardDevice.KeyDown(const aKeyCode:TPasRISCVUInt64);
begin
 if (aKeyCode shr 3)<KeyArraySize then begin
  TPasMPInterlocked.BitwiseOr(PPasRISCVUInt32Array(Pointer(fPointerToData))^[aKeyCode shr 5],TPasRISCVUInt32(1) shl TPasRISCVUInt32(aKeyCode and 31));
 end;
end;

procedure TPasRISCV.TRawKeyboardDevice.KeyUp(const aKeyCode:TPasRISCVUInt64);
begin
 if (aKeyCode shr 3)<KeyArraySize then begin
  TPasMPInterlocked.BitwiseAnd(PPasRISCVUInt32Array(Pointer(fPointerToData))^[aKeyCode shr 5],not (TPasRISCVUInt32(1) shl TPasRISCVUInt32(aKeyCode and 31)));
 end;
end;

procedure TPasRISCV.TRawKeyboardDevice.ModifierDown(const aModifier:TPasRISCVUInt64);
begin
 fData[ModifiersAddress]:=fData[ModifiersAddress] or TPasRISCVUInt8(aModifier);
end;

procedure TPasRISCV.TRawKeyboardDevice.ModifierUp(const aModifier:TPasRISCVUInt64);
begin
 fData[ModifiersAddress]:=fData[ModifiersAddress] and not TPasRISCVUInt8(aModifier);
end;

{ TPasRISCV.TI2CBusDevice }

constructor TPasRISCV.TI2CBusDevice.Create(const aI2CDevice:TPasRISCV.TI2CDevice);
begin
 inherited Create;
 fMachine:=aI2CDevice.fMachine;
 fI2CDevice:=aI2CDevice;
 fIndex:=-1;
 fAddress:=0;
end;

destructor TPasRISCV.TI2CBusDevice.Destroy;
begin
 inherited Destroy;
end;

function TPasRISCV.TI2CBusDevice.Start(const aIsWrite:Boolean):Boolean;
begin
 result:=true;
end;

procedure TPasRISCV.TI2CBusDevice.Stop;
begin
end;

function TPasRISCV.TI2CBusDevice.Read(out aValue:TPasRISCVUInt8):Boolean;
begin
 result:=false;
end;

function TPasRISCV.TI2CBusDevice.Write(const aValue:TPasRISCVUInt8):Boolean;
begin
 result:=false;
end;

{ TPasRISCV.TI2CHIDBusDevice.TReportIDQueue }

procedure TPasRISCV.TI2CHIDBusDevice.TReportIDQueue.Initialize;
var Index:TPasRISCVUInt8;
begin
 fFirst:=-1;
 fLast:=-1;
 for Index:=0 to 255 do begin
  fList[Index]:=-1;
 end;
end;

procedure TPasRISCV.TI2CHIDBusDevice.TReportIDQueue.Insert(const aReportID:TPasRISCVUInt8);
begin
 if (aReportID=fLast) or (fList[aReportID]>=0) then begin
  exit;
 end;
 if fFirst<0 then begin
  fFirst:=aReportID;
 end else begin
  fList[fLast]:=aReportID;
 end;
 fLast:=aReportID;
end;

function TPasRISCV.TI2CHIDBusDevice.TReportIDQueue.Get:TPasRISCVInt16;
begin
 result:=fFirst;
end;

procedure TPasRISCV.TI2CHIDBusDevice.TReportIDQueue.RemoveAt(const aReportID:TPasRISCVUInt8);
var Previous:TPasRISCVInt16;
begin
 if fFirst<0 then begin
  exit;
 end;
 if aReportID=fFirst then begin
  fFirst:=fList[aReportID];
  if fFirst<0 then begin
   fLast:=-1;
  end;
 end else begin
  Previous:=fFirst;
  while (Previous>=0) and (fList[Previous]<>aReportID) do begin
   Previous:=fList[Previous];
  end;
  if Previous<0 then begin
   exit;
  end;
  fList[Previous]:=fList[aReportID];
 end;
 fList[aReportID]:=-1;
end;

{ TPasRISCV.TI2CHIDBusDevice }

constructor TPasRISCV.TI2CHIDBusDevice.Create(const aI2CDevice:TPasRISCV.TI2CDevice);
begin
 inherited Create(aI2CDevice);
 fLock:=TPasMPSlimReaderWriterLock.Create;
 fIRQ:=0;
 fReportIDQueue.Initialize;
 fIsWrite:=false;
 fIOOffset:=0;
 fRegister:=0;
 fCommand:=0;
 fReportType:=0;
 fReportID:=0;
 fDataSize:=0;
 fDataValue:=0;
 fIsReset:=false;
 fReportDescriptor:=nil;
 fMaxInputSize:=0;
 fMaxOutputSize:=0;
 fVendorID:=0;
 fProductID:=0;
 fVersionID:=0;
end;

destructor TPasRISCV.TI2CHIDBusDevice.Destroy;
begin
 FreeAndNil(fLock);
 inherited Destroy;
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDReset;
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDInputAvailable(const aReportID:TPasRISCVUInt8);
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDReadReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;out aValue:TPasRISCVUInt8);
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDWriteReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8);
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDGetIdle(const aReportID:TPasRISCVUInt8;out aIdle:TPasRISCVUInt16);
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDSetIdle(const aReportID:TPasRISCVUInt8;const aIdle:TPasRISCVUInt16);
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDGetProtocol(out aProtocol:TPasRISCVUInt16);
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDSetProtocol(const aProtocol:TPasRISCVUInt16);
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.HIDSetPower(const aPower:TPasRISCVUInt16);
begin
end;

procedure TPasRISCV.TI2CHIDBusDevice.Reset(const aIsInit:Boolean);
begin
 fReportIDQueue.Initialize;
 fRegister:=INPUT_REG;
 fCommand:=0;
 fReportType:=0;
 fReportID:=0;
 fIsReset:=not aIsInit;
 HIDReset;
 if assigned(fI2CDevice) and assigned(fI2CDevice.fMachine) and assigned(fI2CDevice.fMachine.fINTCDevice) and not aIsInit then begin
  fI2CDevice.fMachine.fInterrupts.RaiseIRQ(fIRQ);
 end;
end;

procedure TPasRISCV.TI2CHIDBusDevice.InputAvailable(const aReportID:TPasRISCVUInt8);
begin
 fLock.Acquire;
 try
  if not fIsReset then begin
   fReportIDQueue.Insert(aReportID);
   if assigned(fI2CDevice) and assigned(fI2CDevice.fMachine) and assigned(fI2CDevice.fMachine.fINTCDevice) then begin
    fI2CDevice.fMachine.fInterrupts.RaiseIRQ(fIRQ);
   end;
  end;
 finally
  fLock.Release;
 end;
end;

function TPasRISCV.TI2CHIDBusDevice.ReadDataSize(const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8):Boolean;
begin
 if aOffset<2 then begin
  fDataSize:=TPasRISCVUInt16(TPasRISCVUInt32(fDataSize) and not (TPasRISCVUInt32($ff) shl (aOffset*8))) or (TPasRISCVUInt16(aValue) shl (aOffset*8));
 end;
 result:=not ((aOffset>=1) and (aOffset>=fDataSize));
end;

procedure TPasRISCV.TI2CHIDBusDevice.ReadReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;out aValue:TPasRISCVUInt8);
begin
 HIDReadReport(aReportType,aReportID,aOffset,aValue);
 if aOffset<2 then begin
  fDataSize:=TPasRISCVUInt16(TPasRISCVUInt32(fDataSize) and not (TPasRISCVUInt32($ff) shl (aOffset shl 3))) or (TPasRISCVUInt16(aValue) shl (aOffset shl 3));
 end;
 if (aReportType=REPORT_TYPE_INPUT) and (aOffset>=1) and (aOffset=TPasRISCVUInt32(IfThen(fDataSize>2,fDataSize-1,1))) then begin
  fLock.Acquire;
  try
   fReportIDQueue.RemoveAt(aReportID);
   if fReportIDQueue.Get>=0 then begin
    if assigned(fI2CDevice) and assigned(fI2CDevice.fMachine) and assigned(fI2CDevice.fMachine.fINTCDevice) then begin
     fI2CDevice.fMachine.fInterrupts.RaiseIRQ(fIRQ);
    end;
   end else begin
    if assigned(fI2CDevice) and assigned(fI2CDevice.fMachine) and assigned(fI2CDevice.fMachine.fINTCDevice) then begin
     fI2CDevice.fMachine.fInterrupts.LowerIRQ(fIRQ);
    end;
   end;
  finally
   fLock.Release;
  end;
 end;
end;

function TPasRISCV.TI2CHIDBusDevice.WriteReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8):Boolean;
begin
 result:=ReadDataSize(aOffset,aValue);
 if result then begin
  HIDWriteReport(aReportType,aReportID,aOffset,aValue);
 end;
end;

function TPasRISCV.TI2CHIDBusDevice.ReadRegister(const aRegister:TPasRISCVUInt16;const aOffset:TPasRISCVUInt32):TPasRISCVUInt8;
var FieldValue:TPasRISCVUInt16;
    ReportID:TPasRISCVInt16;
begin
 case aRegister of
  DESC_REG:begin
   case aOffset shr 1 of
    wHIDDescLength:begin
     FieldValue:=$1e;
    end;
    bcdVersion:begin
     FieldValue:=$0100;
    end;
    wReportDescLength:begin
     FieldValue:=length(fReportDescriptor);
    end;
    wReportDescRegister:begin
     FieldValue:=REPORT_REG;
    end;
    wInputRegister:begin
     FieldValue:=INPUT_REG;
    end;
    wMaxInputLength:begin
     FieldValue:=fMaxInputSize;
    end;
    wOutputRegister:begin
     FieldValue:=OUTPUT_REG;
    end;
    wMaxOutputLength:begin
     FieldValue:=fMaxOutputSize;
    end;
    wCommandRegister:begin
     FieldValue:=COMMAND_REG;
    end;
    wDataRegister:begin
     FieldValue:=DATA_REG;
    end;
    wVendorID:begin
     FieldValue:=fVendorID;
    end;
    wProductID:begin
     FieldValue:=fProductID;
    end;
    wVersionID:begin
     FieldValue:=fVersionID;
    end
    else begin
     FieldValue:=0;
    end;
   end;
   result:=TPasRISCVUInt8((FieldValue shr ((aOffset and 1) shl 3)) and $ff);
  end;
  REPORT_REG:begin
   if aOffset<length(fReportDescriptor) then begin
    result:=fReportDescriptor[aOffset];
   end else begin
    result:=0;
   end;
  end;
  INPUT_REG:begin
   fLock.Acquire;
   try
    ReportID:=fReportIDQueue.Get;
    if ReportID<0 then begin
     if assigned(fI2CDevice) and assigned(fI2CDevice.fMachine) and assigned(fI2CDevice.fMachine.fINTCDevice) then begin
      fI2CDevice.fMachine.fInterrupts.LowerIRQ(fIRQ);
     end;
     result:=0;
    end else begin
     result:=0;
     HIDReadReport(REPORT_TYPE_INPUT,fReportIDQueue.Get,aOffset,result);
    end;
   finally
    fLock.Release;
   end;
  end;
  DATA_REG:begin
   case fCommand of
    COMMAND_GET_REPORT:begin
     HIDReadReport(fReportType,fReportID,aOffset,result);
    end;
    COMMAND_GET_IDLE:begin
     case aOffset shr 1 of
      0:begin
       FieldValue:=4;
      end;
      1:begin
       FieldValue:=0;
       HIDGetIdle(fReportID,FieldValue);
      end;
      else begin
       FieldValue:=0;
      end;
     end;
     result:=TPasRISCVUInt8((FieldValue shr ((aOffset and 1) shl 3)) and $ff);
    end;
    COMMAND_GET_PROTOCOL:begin
     FieldValue:=0;
     case aOffset shr 1 of
      0:begin
       FieldValue:=4;
      end;
      1:begin
       HIDGetProtocol(FieldValue);
      end;
      else begin
       FieldValue:=0;
      end;
     end;
     result:=TPasRISCVUInt8((FieldValue shr ((aOffset and 1) shl 3)) and $ff);
    end;
    else begin
     result:=0;
    end;
   end;
  end;
  else begin
   result:=0;
  end;
 end;
end;

function TPasRISCV.TI2CHIDBusDevice.WriteRegister(const aRegister:TPasRISCVUInt16;const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8):Boolean;
begin
 result:=false;
 case aRegister of
  OUTPUT_REG:begin
   result:=WriteReport(REPORT_TYPE_OUTPUT,0,aOffset,aValue);
  end;
  COMMAND_REG:begin
   case aOffset of
    0:begin
     fReportID:=(aValue and $f);
     fReportType:=(aValue shr 4) and 3;
     result:=true;
     exit;
    end;
    1:begin
     fCommand:=aValue and $f;
     result:=fReportID=$f;
     if result then begin
      exit;
     end;
    end;
    2:begin
     fReportID:=aValue;
     result:=false;
    end;
   end;
   case fCommand of
    COMMAND_SET_IDLE:begin
     if fDataSize=4 then begin
      HIDSetIdle(fReportID,fDataValue);
     end;
    end;
    COMMAND_SET_PROTOCOL:begin
     if fDataSize=4 then begin
      HIDSetProtocol(fDataValue);
     end;
    end;
    COMMAND_SET_POWER:begin
     HIDSetPower(fDataValue and 3);
    end;
   end;
  end;
  DATA_REG:begin
   case fCommand of
    COMMAND_SET_REPORT:begin
     result:=WriteReport(fReportType,fReportID,aOffset,aValue);
    end;
    else begin
     result:=ReadDataSize(aOffset,aValue);
     if result and ((aOffset shr 1)=1) then begin
      fDataValue:=TPasRISCVUInt16(TPasRISCVUInt32(fDataValue) and not (TPasRISCVUInt32($ff) shl (aOffset shl 3))) or (TPasRISCVUInt16(aValue) shl (aOffset shl 3));
     end;
    end;
   end;
  end;
  else begin
   result:=false;
  end;
 end;
end;

function TPasRISCV.TI2CHIDBusDevice.Start(const aIsWrite:Boolean):Boolean;
begin
 fLock.Acquire;
 try
  fIsWrite:=aIsWrite;
  fIOOffset:=0;
  result:=true;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TI2CHIDBusDevice.Stop;
begin
 fLock.Acquire;
 try
  fIsReset:=false;
  if fCommand=COMMAND_RESET then begin
   Reset(false);
  end;
  fRegister:=INPUT_REG;
  fCommand:=0;
  fDataSize:=0;
 finally
  fLock.Release;
 end;
end;

function TPasRISCV.TI2CHIDBusDevice.Read(out aValue:TPasRISCVUInt8):Boolean;
begin
 fLock.Acquire;
 try
  aValue:=ReadRegister(fRegister,fIOOffset);
  inc(fIOOffset);
 finally
  fLock.Release;
 end;
 result:=true;
end;

function TPasRISCV.TI2CHIDBusDevice.Write(const aValue:TPasRISCVUInt8):Boolean;
begin
 fLock.Acquire;
 try
  case fIOOffset of
   0,1:begin
    fRegister:=TPasRISCVUInt16(TPasRISCVUInt32(fRegister) and not (TPasRISCVUInt32($ff) shl (fIOOffset shl 3))) or (TPasRISCVUInt16(aValue) shl (fIOOffset shl 3));
    inc(fIOOffset);
   end;
   else begin
    if WriteRegister(fRegister,fIOOffset-2,aValue) then begin
     inc(fIOOffset);
    end else begin
     fIOOffset:=0;
    end;
   end;
  end;
 finally
  fLock.Release;
 end;
 result:=true;
end;

{ TPasRISCV.TDS1307I2CBusDevice }

constructor TPasRISCV.TDS1307I2CBusDevice.Create(const aI2CDevice:TI2CDevice);
begin
 inherited Create(aI2CDevice);
 fAddress:=DS1307_ADDRESS;
 FillChar(fRegisters,SizeOf(fRegisters),#0);
 fRegPointer:=0;
 fWriteState:=0;
 UpdateRegisters;
end;

destructor TPasRISCV.TDS1307I2CBusDevice.Destroy;
begin
 inherited Destroy;
end;

class function TPasRISCV.TDS1307I2CBusDevice.ToBCD(const aValue:TPasRISCVUInt8):TPasRISCVUInt8;
begin
 result:=((aValue div 10) shl 4) or (aValue mod 10);
end;

class function TPasRISCV.TDS1307I2CBusDevice.FromBCD(const aValue:TPasRISCVUInt8):TPasRISCVUInt8;
begin
 result:=((aValue shr 4)*10)+(aValue and $f);
end;

procedure TPasRISCV.TDS1307I2CBusDevice.UpdateRegisters;
var CurrentTime:TDateTime;
    Year,Month,Day,DayOfWeek,Hour,Minute,Second,Millisecond:TPasRISCVUInt16;
begin
 CurrentTime:={$if declared(NowUTC)}NowUTC{$else}Now{$ifend};
 DecodeDateFully(CurrentTime,Year,Month,Day,DayOfWeek);
 DecodeTime(CurrentTime,Hour,Minute,Second,Millisecond);
 fRegisters[REG_SECONDS]:=ToBCD(Min(59,Second)); // bit 7 (CH) = 0, clock running
 fRegisters[REG_MINUTES]:=ToBCD(Minute);
 fRegisters[REG_HOURS]:=ToBCD(Hour); // 24h mode (bit 6 = 0)
 fRegisters[REG_DAY]:=ToBCD(DayOfWeek);
 fRegisters[REG_DATE]:=ToBCD(Day);
 fRegisters[REG_MONTH]:=ToBCD(Month);
 fRegisters[REG_YEAR]:=ToBCD(Year mod 100);
end;

function TPasRISCV.TDS1307I2CBusDevice.Start(const aIsWrite:Boolean):Boolean;
begin
{$ifdef I2CDebug}
 WriteLn('[DS1307] Start isWrite=',aIsWrite);
{$endif}
 fWriteState:=0;
 if not aIsWrite then begin
  // Read start — refresh time registers
  UpdateRegisters;
 end;
 result:=true;
end;

procedure TPasRISCV.TDS1307I2CBusDevice.Stop;
begin
 // Nothing special needed
end;

function TPasRISCV.TDS1307I2CBusDevice.Read(out aValue:TPasRISCVUInt8):Boolean;
begin
 aValue:=fRegisters[fRegPointer and $3f];
{$ifdef I2CDebug}
 WriteLn('[DS1307] Read reg=0x',HexStr(fRegPointer and $3f,2),' val=0x',HexStr(aValue,2));
{$endif}
 fRegPointer:=(fRegPointer+1) and $3f; // auto-increment with wrap
 result:=true;
end;

function TPasRISCV.TDS1307I2CBusDevice.Write(const aValue:TPasRISCVUInt8):Boolean;
begin
 if fWriteState=0 then begin
  // First byte after START+W is the register pointer
  fRegPointer:=aValue and $3f;
{$ifdef I2CDebug}
  WriteLn('[DS1307] Write regPtr=0x',HexStr(fRegPointer,2));
{$endif}
  fWriteState:=1;
 end else begin
  // Subsequent bytes are data writes
{$ifdef I2CDebug}
  WriteLn('[DS1307] Write reg=0x',HexStr(fRegPointer and $3f,2),' val=0x',HexStr(aValue,2));
{$endif}
  fRegisters[fRegPointer and $3f]:=aValue;
  fRegPointer:=(fRegPointer+1) and $3f;
 end;
 result:=true;
end;

{ TPasRISCV.TI2CHIDKeyboardBusDevice }

constructor TPasRISCV.TI2CHIDKeyboardBusDevice.Create(const aI2CDevice:TPasRISCV.TI2CDevice);
begin
 inherited Create(aI2CDevice);
 fAddress:=TI2CHIDKeyboardBusDevice.Address;
 fIRQ:=TI2CHIDKeyboardBusDevice.IRQ;
 FillChar(fInputReport,SizeOf(fInputReport),#0);
 FillChar(fOutputReport,SizeOf(fOutputReport),#0);
 FillChar(fKeysPressedRow,SizeOf(fKeysPressedRow),#0);
 FillChar(fKeysPressed,SizeOf(fKeysPressed),#0);
 fLEDs:=0;
 SetLength(fReportDescriptor,SizeOf(ReportDescriptor));
 Move(ReportDescriptor[0],fReportDescriptor[0],SizeOf(ReportDescriptor));
 fVendorID:=1;
 fProductID:=1;
 fVersionID:=1;
end;

destructor TPasRISCV.TI2CHIDKeyboardBusDevice.Destroy;
begin
 fReportDescriptor:=nil;
 inherited Destroy;
end;

procedure TPasRISCV.TI2CHIDKeyboardBusDevice.HIDReset;
begin
 TPasMPInterlocked.Write(fLEDs,0);
end;

procedure TPasRISCV.TI2CHIDKeyboardBusDevice.HIDFillPressedKeys(const aPressed:PPasRISCVUInt8);
var Count,CodeHi,CodeLo,Keys:TPasRISCVUInt32;
    p:PPasRISCVUInt8;
begin
 Count:=0;
 FillChar(aPressed^,CountMaximumPressedKeys,#0);
 p:=aPressed;
 for CodeHi:=0 to 7 do begin
  Keys:=TPasMPInterlocked.Exchange(fKeysPressed[CodeHi],0) or TPasMPInterlocked.Read(fKeysPressedRow[CodeHi]);
  if Keys<>0 then begin
   for CodeLo:=0 to 31 do begin
    if (Keys and (1 shl CodeLo))<>0 then begin
     p^:=(CodeHi shl 5) or CodeLo;
     inc(p);
     inc(Count);
     if Count=CountMaximumPressedKeys then begin
      exit;
     end;
    end;
   end;
  end;
 end;
end;

procedure TPasRISCV.TI2CHIDKeyboardBusDevice.HIDReadReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;out aValue:TPasRISCVUInt8);
begin
 fLock.Acquire;
 try
  if aReportType=REPORT_TYPE_INPUT then begin
   if aOffset=0 then begin
    fInputReport[0]:=(SizeOf(fInputReport) shr 0) and $ff;
    fInputReport[1]:=(SizeOf(fInputReport) shr 8) and $ff;
    fInputReport[2]:=(TPasMPInterlocked.Read(fKeysPressed[7]) or TPasMPInterlocked.Read(fKeysPressedRow[7])) and $ff;
    fInputReport[3]:=0;
    HIDFillPressedKeys(@fInputReport[4]);
   end;
   if aOffset<SizeOf(fInputReport) then begin
    aValue:=fInputReport[aOffset];
   end;
  end else begin
   aValue:=0;
  end;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TI2CHIDKeyboardBusDevice.HIDWriteReport(const aReportType,aReportID:TPasRISCVUInt8;const aOffset:TPasRISCVUInt32;const aValue:TPasRISCVUInt8);
begin
 fLock.Acquire;
 try
  if aReportType=REPORT_TYPE_OUTPUT then begin
   if aOffset<SizeOf(fOutputReport) then begin
    fOutputReport[aOffset]:=aValue;
    if aOffset=(SizeOf(fOutputReport)-1) then begin
     TPasMPInterlocked.Write(fLEDs,fOutputReport[2]);
    end;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TI2CHIDKeyboardBusDevice.HandleKeyboard(const aKey:TPasRISCVUInt32;const aDown:Boolean);
var Offset,Bit,OldPressed:TPasRISCVUInt32;
begin
 if aKey<>THID.KEY_NONE then begin
  Offset:=aKey shr 5;
  Bit:=TPasRISCVUInt32(1) shl (aKey and $1f);
  if aDown then begin
   OldPressed:=TPasMPInterlocked.ExchangeBitwiseOr(fKeysPressed[Offset],Bit);
   if (Bit and not OldPressed)<>0 then begin
    TPasMPInterlocked.BitwiseOr(fKeysPressedRow[Offset],Bit);
    InputAvailable(0);
   end;
  end else begin
   OldPressed:=TPasMPInterlocked.ExchangeBitwiseAnd(fKeysPressed[Offset],not Bit);
   if (OldPressed and Bit)<>0 then begin
    InputAvailable(0);
   end;
  end;
 end;
end;

{ TPasRISCV.TI2CDevice - base class }

constructor TPasRISCV.TI2CDevice.Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64);
begin
 inherited Create(aMachine,aBase,aSize);
 fLock:=TPasMPSlimReaderWriterLock.Create;
 fBusDevices:=nil;
 fCountBusDevices:=0;
 FillChar(fBusDeviceAddressMap,SizeOf(fBusDeviceAddressMap),#0);
end;

destructor TPasRISCV.TI2CDevice.Destroy;
begin
 FreeAndNil(fLock);
 inherited Destroy;
end;

procedure TPasRISCV.TI2CDevice.AttachBusDevice(const aI2CBusDevice:TPasRISCV.TI2CBusDevice);
var Index:TPasRISCVSizeInt;
    Address:TPasRISCVUInt16;
begin
 if assigned(aI2CBusDevice) then begin
  fLock.Acquire;
  try
   Address:=aI2CBusDevice.fAddress;
   if Address=AUTO_ADDR then begin
    Address:=8; // Start from address 8 (I2C addresses 0-7 are reserved)
    while ((Address+1)<65535) and assigned(fBusDeviceAddressMap[Address]) do begin
     inc(Address);
    end;
   end;
   if assigned(fBusDeviceAddressMap[Address]) then begin
    raise EPasRISCV.Create('No free I2C bus device address');
   end else begin
    Index:=fCountBusDevices;
    inc(fCountBusDevices);
    if length(fBusDevices)<fCountBusDevices then begin
     SetLength(fBusDevices,fCountBusDevices*2);
    end;
    fBusDevices[Index]:=aI2CBusDevice;
    aI2CBusDevice.fIndex:=Index;
    aI2CBusDevice.fAddress:=Address;
    fBusDeviceAddressMap[aI2CBusDevice.fAddress]:=aI2CBusDevice;
   end;
  finally
   fLock.Release;
  end;
 end;
end;

procedure TPasRISCV.TI2CDevice.DetachBusDevice(const aI2CBusDevice:TPasRISCV.TI2CBusDevice);
var Index:TPasRISCVSizeInt;
begin
 if assigned(aI2CBusDevice) then begin
  fLock.Acquire;
  try
   if aI2CBusDevice.fIndex>=0 then begin
    Index:=aI2CBusDevice.fIndex;
    aI2CBusDevice.fIndex:=-1;
    if Index<>(fCountBusDevices-1) then begin
     fBusDevices[Index]:=fBusDevices[fCountBusDevices-1];
     fBusDevices[Index].fIndex:=Index;
    end;
    dec(fCountBusDevices);
    fBusDeviceAddressMap[aI2CBusDevice.fAddress]:=nil;
   end;
  finally
   fLock.Release;
  end;
 end;
end;

function TPasRISCV.TI2CDevice.GetBusDevice(const aAddress:TPasRISCVUInt16):TPasRISCV.TI2CBusDevice;
begin
 result:=fBusDeviceAddressMap[aAddress];
end;

function TPasRISCV.TI2CDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 result:=0;
end;

procedure TPasRISCV.TI2CDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
begin
end;

{ TPasRISCV.TOpenCoresI2CDevice }

constructor TPasRISCV.TOpenCoresI2CDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fOpenCoresI2CBase,aMachine.fConfiguration.fOpenCoresI2CSize);
 fSelectedAddress:=$ffff;
 fClock:=0;
 fControl:=0;
 fStatus:=0;
 fTXByte:=0;
 fRXByte:=0;
end;

destructor TPasRISCV.TOpenCoresI2CDevice.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV.TOpenCoresI2CDevice.DispatchInterrupt;
begin
 fStatus:=fStatus or SR_IF;
 if (fControl and CTR_IEN)<>0 then begin
{$ifdef I2CDebug}
  WriteLn('[I2C-OC] DispatchInterrupt: SendIRQ(',IRQ,') status=0x',HexStr(fStatus,2));
{$endif}
  fMachine.fInterrupts.SendIRQ(IRQ);
 end else begin
{$ifdef I2CDebug}
  WriteLn('[I2C-OC] DispatchInterrupt: IEN disabled, NOT sending IRQ, status=0x',HexStr(fStatus,2));
{$endif}
 end;
end;

function TPasRISCV.TOpenCoresI2CDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 fLock.Acquire;
 try
{$ifdef I2CDebug}
  WriteLn('[I2C-OC] Load reg=0x',HexStr(Address,2),' size=',aSize);
{$endif}
  case Address of
   CLKLO:begin
    result:=fClock and $ff;
   end;
   CLKHI:begin
    result:=(fClock shr 8) and $ff;
   end;
   CTR:begin
    result:=fControl;
   end;
   TXRXR:begin
    result:=fRXByte;
   end;
   CRSR:begin
    result:=fStatus;
   end;
   else begin
    result:=0;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TOpenCoresI2CDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address,Cmd:TPasRISCVUInt64;
    I2CBusDevice:TI2CBusDevice;
    IsWrite,TriggerIRQ:Boolean;
begin
 Address:=aAddress-fBase;
 fLock.Acquire;
 try
{$ifdef I2CDebug}
  WriteLn('[I2C-OC] Store reg=0x',HexStr(Address,2),' val=0x',HexStr(aValue,2),' size=',aSize);
{$endif}
  case Address of
   CLKLO:begin
    fClock:=(fClock and $ff00) or (TPasRISCVUInt16(aValue) and $ff);
   end;
   CLKHI:begin
    fClock:=(fClock and $ff) or ((TPasRISCVUInt16(aValue) and $ff) shl 8);
   end;
   CTR:begin
    fControl:=TPasRISCVUInt8(aValue) and CTR_MASK;
    if (fControl and CTR_IEN)=0 then begin
     if (fStatus and SR_IF)<>0 then begin
      fMachine.fInterrupts.LowerIRQ(IRQ);
     end;
    end;
   end;
   TXRXR:begin
    fTXByte:=TPasRISCVUInt8(aValue);
   end;
   CRSR:begin

    TriggerIRQ:=false;

    Cmd:=TPasRISCVUInt8(aValue);

    fStatus:=fStatus or SR_ACK;

    if (Cmd and CR_IACK)<>0 then begin
     // Clear a pending interrupt
     fStatus:=fStatus and not SR_IF;
    end;

    // Set Transfer in Progress when any bus operation is requested
    if (Cmd and (CR_STA or CR_WR or CR_RD or CR_STO))<>0 then begin
     fStatus:=fStatus or SR_TIP;
    end;

    if (Cmd and CR_STA)<>0 then begin
     // Start the transaction
     fSelectedAddress:=$ffff;
     fStatus:=fStatus or SR_BSY;
    end;

    if (Cmd and CR_WR)<>0 then begin
     // Write byte
     if fSelectedAddress=$ffff then begin

      fSelectedAddress:=(fTXByte shr 1) and $7f; // Get I2CBusDevice address, signal start of transaction

      I2CBusDevice:=GetBusDevice(fSelectedAddress);

{$ifdef I2CDebug}
      WriteLn('[I2C-OC] Address phase: TXByte=0x',HexStr(fTXByte,2),' addr=0x',HexStr(fSelectedAddress,4),' found=',assigned(I2CBusDevice));
{$endif}

      IsWrite:=(fTXByte and 1)=0;

      if assigned(I2CBusDevice) and I2CBusDevice.Start(IsWrite) then begin
       fStatus:=fStatus and not SR_ACK;
{     end else begin
       fStatus:=fStatus or SR_ACK;}
      end;

     end else begin

      I2CBusDevice:=GetBusDevice(fSelectedAddress);
      if assigned(I2CBusDevice) and I2CBusDevice.Write(fTXByte) then begin
       fStatus:=fStatus and not SR_ACK;
{     end else begin
       fStatus:=fStatus or SR_ACK;}
      end;

     end;

     TriggerIRQ:=true;

    end;

    if (Cmd and CR_RD)<>0 then begin
     // Read byte
     I2CBusDevice:=GetBusDevice(fSelectedAddress);
     if assigned(I2CBusDevice) and I2CBusDevice.Read(fRXByte) then begin
      fStatus:=fStatus and not SR_ACK;
{    end else begin
      fStatus:=fStatus or SR_ACK;}
     end;
     TriggerIRQ:=true;
    end;

    if (Cmd and CR_STO)<>0 then begin
     // End of transaction
     I2CBusDevice:=GetBusDevice(fSelectedAddress);
     if assigned(I2CBusDevice) then begin
      I2CBusDevice.Stop;
     end;
     fSelectedAddress:=$ffff;
     fStatus:=fStatus and not SR_BSY;
     TriggerIRQ:=true;
    end;

    // Transfer complete — clear TIP and dispatch interrupt
    fStatus:=fStatus and not SR_TIP;

    if TriggerIRQ then begin
     DispatchInterrupt;
    end;

//  fStatus:=fStatus and not SR_TIP;

   end;

  end;

 finally
  fLock.Release;
 end;

end;

{ TPasRISCV.TDesignWareI2CDevice }

constructor TPasRISCV.TDesignWareI2CDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.fDesignWareI2CBase,aMachine.fConfiguration.fDesignWareI2CSize);
 fCon:=IC_CON_MASTER_MODE or IC_CON_SPEED_FS or IC_CON_RESTART_EN or IC_CON_SLAVE_DISABLE;
 fTar:=0;
 fSar:=0;
 fEnable:=0;
 fIntrMask:=0;
 fRawIntrStat:=0;
 fRxTL:=0;
 fTxTL:=0;
 fSSHCNT:=$0190;
 fSSLCNT:=$01d6;
 fFSHCNT:=$003c;
 fFSLCNT:=$0082;
 fSDAHold:=1;
 fSDASetup:=$64;
 fTxAbrtSource:=0;
 fFSSpkLen:=$05;
 fHSSpkLen:=$01;
 fAckGeneralCall:=1;
 fRxFIFOHead:=0;
 fRxFIFOTail:=0;
 fRxFIFOCount:=0;
 fTransactionActive:=false;
 fTransactionIsWrite:=false;
 fSelectedAddress:=$ffff;
end;

destructor TPasRISCV.TDesignWareI2CDevice.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV.TDesignWareI2CDevice.RxFIFOPush(const aValue:TPasRISCVUInt8);
begin
 if fRxFIFOCount<RX_FIFO_DEPTH then begin
  fRxFIFO[fRxFIFOTail]:=aValue;
  fRxFIFOTail:=(fRxFIFOTail+1) mod RX_FIFO_DEPTH;
  inc(fRxFIFOCount);
 end else begin
  // RX FIFO overflow
  fRawIntrStat:=fRawIntrStat or IC_INTR_RX_OVER;
 end;
end;

function TPasRISCV.TDesignWareI2CDevice.RxFIFOPop:TPasRISCVUInt8;
begin
 if fRxFIFOCount>0 then begin
  result:=fRxFIFO[fRxFIFOHead];
  fRxFIFOHead:=(fRxFIFOHead+1) mod RX_FIFO_DEPTH;
  dec(fRxFIFOCount);
 end else begin
  // RX FIFO underflow
  fRawIntrStat:=fRawIntrStat or IC_INTR_RX_UNDER;
  result:=0;
 end;
end;

procedure TPasRISCV.TDesignWareI2CDevice.UpdateInterrupts;
var MaskedStat:TPasRISCVUInt32;
begin
 // TX_EMPTY is level-triggered: set when TX FIFO level <= TX_TL
 // Since we process commands immediately, TX FIFO is always empty
 if (fEnable and 1)<>0 then begin
  fRawIntrStat:=fRawIntrStat or IC_INTR_TX_EMPTY;
 end else begin
  fRawIntrStat:=fRawIntrStat and not IC_INTR_TX_EMPTY;
 end;
 // RX_FULL is level-triggered: set when RX FIFO level > RX_TL
 if fRxFIFOCount>fRxTL then begin
  fRawIntrStat:=fRawIntrStat or IC_INTR_RX_FULL;
 end else begin
  fRawIntrStat:=fRawIntrStat and not IC_INTR_RX_FULL;
 end;
 MaskedStat:=fRawIntrStat and fIntrMask;
 if MaskedStat<>0 then begin
{$ifdef I2CDebug}
  WriteLn('[I2C-DW] UpdateInterrupts: SendIRQ(',IRQ,') masked=0x',HexStr(MaskedStat,4));
{$endif}
  fMachine.fInterrupts.SendIRQ(IRQ);
 end else begin
  fMachine.fInterrupts.LowerIRQ(IRQ);
 end;
end;

procedure TPasRISCV.TDesignWareI2CDevice.ProcessDataCmd(const aValue:TPasRISCVUInt32);
var I2CBusDevice:TI2CBusDevice;
    ReadByte:TPasRISCVUInt8;
begin
 // RESTART flag — end current transaction, start new one
 if (aValue and IC_DATA_CMD_RESTART)<>0 then begin
  if fTransactionActive then begin
   I2CBusDevice:=GetBusDevice(fSelectedAddress);
   if assigned(I2CBusDevice) then begin
    I2CBusDevice.Stop;
   end;
   fTransactionActive:=false;
  end;
 end;

 // Determine if read or write
 if (aValue and IC_DATA_CMD_READ)<>0 then begin
  // READ command
  if (not fTransactionActive) or fTransactionIsWrite then begin
   // Need to start a read transaction
   fSelectedAddress:=fTar and $7f;
   I2CBusDevice:=GetBusDevice(fSelectedAddress);
{$ifdef I2CDebug}
   WriteLn('[I2C-DW] Read START addr=0x',HexStr(fSelectedAddress,2),' found=',assigned(I2CBusDevice));
{$endif}
   if assigned(I2CBusDevice) then begin
    I2CBusDevice.Start(false);
    fTransactionActive:=true;
    fTransactionIsWrite:=false;
   end else begin
    fTxAbrtSource:=fTxAbrtSource or (1 shl 0); // ABRT_7B_ADDR_NOACK
    fRawIntrStat:=fRawIntrStat or IC_INTR_TX_ABRT;
    exit;
   end;
  end;
  I2CBusDevice:=GetBusDevice(fSelectedAddress);
  if assigned(I2CBusDevice) then begin
   if I2CBusDevice.Read(ReadByte) then begin
{$ifdef I2CDebug}
    WriteLn('[I2C-DW] Read byte=0x',HexStr(ReadByte,2));
{$endif}
    RxFIFOPush(ReadByte);
   end;
  end;
 end else begin
  // WRITE command
  if (not fTransactionActive) or (not fTransactionIsWrite) then begin
   // Need to start a write transaction
   fSelectedAddress:=fTar and $7f;
   I2CBusDevice:=GetBusDevice(fSelectedAddress);
{$ifdef I2CDebug}
   WriteLn('[I2C-DW] Write START addr=0x',HexStr(fSelectedAddress,2),' found=',assigned(I2CBusDevice));
{$endif}
   if assigned(I2CBusDevice) then begin
    I2CBusDevice.Start(true);
    fTransactionActive:=true;
    fTransactionIsWrite:=true;
   end else begin
    fTxAbrtSource:=fTxAbrtSource or (1 shl 0); // ABRT_7B_ADDR_NOACK
    fRawIntrStat:=fRawIntrStat or IC_INTR_TX_ABRT;
    exit;
   end;
  end;
  I2CBusDevice:=GetBusDevice(fSelectedAddress);
  if assigned(I2CBusDevice) then begin
{$ifdef I2CDebug}
   WriteLn('[I2C-DW] Write byte=0x',HexStr(aValue and $ff,2));
{$endif}
   I2CBusDevice.Write(TPasRISCVUInt8(aValue and $ff));
  end;
 end;

 // STOP flag — end transaction
 if (aValue and IC_DATA_CMD_STOP)<>0 then begin
  if fTransactionActive then begin
   I2CBusDevice:=GetBusDevice(fSelectedAddress);
   if assigned(I2CBusDevice) then begin
    I2CBusDevice.Stop;
   end;
   fTransactionActive:=false;
  end;
  fRawIntrStat:=fRawIntrStat or IC_INTR_STOP_DET;
 end;

 fRawIntrStat:=fRawIntrStat or IC_INTR_ACTIVITY;
end;

function TPasRISCV.TDesignWareI2CDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
begin
 Address:=aAddress-fBase;
 fLock.Acquire;
 try
{$ifdef I2CDebug}
  WriteLn('[I2C-DW] Load reg=0x',HexStr(Address,2),' size=',aSize);
{$endif}
  case Address of
   DW_IC_CON:begin
    result:=fCon;
   end;
   DW_IC_TAR:begin
    result:=fTar;
   end;
   DW_IC_SAR:begin
    result:=fSar;
   end;
   DW_IC_DATA_CMD:begin
    result:=RxFIFOPop;
    UpdateInterrupts;
   end;
   DW_IC_SS_SCL_HCNT:begin
    result:=fSSHCNT;
   end;
   DW_IC_SS_SCL_LCNT:begin
    result:=fSSLCNT;
   end;
   DW_IC_FS_SCL_HCNT:begin
    result:=fFSHCNT;
   end;
   DW_IC_FS_SCL_LCNT:begin
    result:=fFSLCNT;
   end;
   DW_IC_INTR_STAT:begin
    result:=fRawIntrStat and fIntrMask;
   end;
   DW_IC_INTR_MASK:begin
    result:=fIntrMask;
   end;
   DW_IC_RAW_INTR_STAT:begin
    result:=fRawIntrStat;
   end;
   DW_IC_RX_TL:begin
    result:=fRxTL;
   end;
   DW_IC_TX_TL:begin
    result:=fTxTL;
   end;
   DW_IC_CLR_INTR:begin
    fRawIntrStat:=0;
    result:=fRawIntrStat;
    UpdateInterrupts;
   end;
   DW_IC_CLR_RX_UNDER:begin
    fRawIntrStat:=fRawIntrStat and not IC_INTR_RX_UNDER;
    result:=0;
    UpdateInterrupts;
   end;
   DW_IC_CLR_RX_OVER:begin
    fRawIntrStat:=fRawIntrStat and not IC_INTR_RX_OVER;
    result:=0;
    UpdateInterrupts;
   end;
   DW_IC_CLR_TX_OVER:begin
    fRawIntrStat:=fRawIntrStat and not IC_INTR_TX_OVER;
    result:=0;
    UpdateInterrupts;
   end;
   DW_IC_CLR_RD_REQ:begin
    fRawIntrStat:=fRawIntrStat and not IC_INTR_RD_REQ;
    result:=0;
    UpdateInterrupts;
   end;
   DW_IC_CLR_TX_ABRT:begin
    fRawIntrStat:=fRawIntrStat and not IC_INTR_TX_ABRT;
    fTxAbrtSource:=0;
    result:=0;
    UpdateInterrupts;
   end;
   DW_IC_CLR_RX_DONE:begin
    fRawIntrStat:=fRawIntrStat and not IC_INTR_RX_DONE;
    result:=0;
    UpdateInterrupts;
   end;
   DW_IC_CLR_ACTIVITY:begin
    fRawIntrStat:=fRawIntrStat and not IC_INTR_ACTIVITY;
    result:=0;
    UpdateInterrupts;
   end;
   DW_IC_CLR_STOP_DET:begin
    fRawIntrStat:=fRawIntrStat and not IC_INTR_STOP_DET;
    result:=0;
    UpdateInterrupts;
   end;
   DW_IC_CLR_START_DET:begin
    fRawIntrStat:=fRawIntrStat and not IC_INTR_START_DET;
    result:=0;
    UpdateInterrupts;
   end;
   DW_IC_CLR_GEN_CALL:begin
    fRawIntrStat:=fRawIntrStat and not IC_INTR_GEN_CALL;
    result:=0;
    UpdateInterrupts;
   end;
   DW_IC_CLR_RESTART_DET:begin
    fRawIntrStat:=fRawIntrStat and not IC_INTR_RESTART_DET;
    result:=0;
    UpdateInterrupts;
   end;
   DW_IC_ENABLE:begin
    result:=fEnable;
   end;
   DW_IC_STATUS:begin
    result:=IC_STATUS_TFNF or IC_STATUS_TFE; // TX FIFO always not-full and empty
    if fRxFIFOCount>0 then begin
     result:=result or IC_STATUS_RFNE;
    end;
    if fRxFIFOCount>=RX_FIFO_DEPTH then begin
     result:=result or IC_STATUS_RFF;
    end;
   end;
   DW_IC_TXFLR:begin
    result:=0; // TX FIFO always empty (commands processed immediately)
   end;
   DW_IC_RXFLR:begin
    result:=fRxFIFOCount;
   end;
   DW_IC_SDA_HOLD:begin
    result:=fSDAHold;
   end;
   DW_IC_TX_ABRT_SOURCE:begin
    result:=fTxAbrtSource;
   end;
   DW_IC_SDA_SETUP:begin
    result:=fSDASetup;
   end;
   DW_IC_ACK_GENERAL_CALL:begin
    result:=fAckGeneralCall;
   end;
   DW_IC_ENABLE_STATUS:begin
    result:=fEnable and 1; // Mirror enable bit
   end;
   DW_IC_FS_SPKLEN:begin
    result:=fFSSpkLen;
   end;
   DW_IC_HS_SPKLEN:begin
    result:=fHSSpkLen;
   end;
   DW_IC_COMP_PARAM_1:begin
    result:=DW_IC_COMP_PARAM_1_VALUE;
   end;
   DW_IC_COMP_VERSION:begin
    result:=DW_IC_COMP_VERSION_VALUE;
   end;
   DW_IC_COMP_TYPE:begin
    result:=DW_IC_COMP_TYPE_VALUE;
   end;
   else begin
    result:=0;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TDesignWareI2CDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
    I2CBusDevice:TI2CBusDevice;
begin
 Address:=aAddress-fBase;
 fLock.Acquire;
 try
{$ifdef I2CDebug}
  WriteLn('[I2C-DW] Store reg=0x',HexStr(Address,2),' val=0x',HexStr(aValue,4),' size=',aSize);
{$endif}
  case Address of
   DW_IC_CON:begin
    if (fEnable and 1)=0 then begin // Only writable when disabled
     fCon:=TPasRISCVUInt32(aValue);
    end;
   end;
   DW_IC_TAR:begin
    if (fEnable and 1)=0 then begin
     fTar:=TPasRISCVUInt16(aValue) and $3ff;
    end;
   end;
   DW_IC_SAR:begin
    if (fEnable and 1)=0 then begin
     fSar:=TPasRISCVUInt16(aValue) and $3ff;
    end;
   end;
   DW_IC_DATA_CMD:begin
    if (fEnable and 1)<>0 then begin
     ProcessDataCmd(TPasRISCVUInt32(aValue));
     UpdateInterrupts;
    end;
   end;
   DW_IC_SS_SCL_HCNT:begin
    fSSHCNT:=TPasRISCVUInt16(aValue);
   end;
   DW_IC_SS_SCL_LCNT:begin
    fSSLCNT:=TPasRISCVUInt16(aValue);
   end;
   DW_IC_FS_SCL_HCNT:begin
    fFSHCNT:=TPasRISCVUInt16(aValue);
   end;
   DW_IC_FS_SCL_LCNT:begin
    fFSLCNT:=TPasRISCVUInt16(aValue);
   end;
   DW_IC_INTR_MASK:begin
    fIntrMask:=TPasRISCVUInt32(aValue) and $1fff;
    UpdateInterrupts;
   end;
   DW_IC_RX_TL:begin
    fRxTL:=TPasRISCVUInt8(aValue);
    if fRxTL>=RX_FIFO_DEPTH then begin
     fRxTL:=RX_FIFO_DEPTH-1;
    end;
   end;
   DW_IC_TX_TL:begin
    fTxTL:=TPasRISCVUInt8(aValue);
    if fTxTL>=TX_FIFO_DEPTH then begin
     fTxTL:=TX_FIFO_DEPTH-1;
    end;
   end;
   DW_IC_ENABLE:begin
    if ((aValue and 1)=0) and ((fEnable and 1)<>0) then begin
     // Disabling controller — abort any active transaction
     if fTransactionActive then begin
      I2CBusDevice:=GetBusDevice(fSelectedAddress);
      if assigned(I2CBusDevice) then begin
       I2CBusDevice.Stop;
      end;
      fTransactionActive:=false;
     end;
     fSelectedAddress:=$ffff;
     // Clear FIFOs
     fRxFIFOHead:=0;
     fRxFIFOTail:=0;
     fRxFIFOCount:=0;
     // Clear raw interrupt status
     fRawIntrStat:=0;
     fTxAbrtSource:=0;
    end;
    fEnable:=TPasRISCVUInt32(aValue) and 1;
    if (fEnable and 1)<>0 then begin
     // Enabling controller — TX_EMPTY is immediately true
     fRawIntrStat:=fRawIntrStat or IC_INTR_TX_EMPTY;
    end else begin
     // Disabling controller — clear TX_EMPTY
     fRawIntrStat:=fRawIntrStat and not IC_INTR_TX_EMPTY;
    end;
    UpdateInterrupts;
   end;
   DW_IC_SDA_HOLD:begin
    fSDAHold:=TPasRISCVUInt32(aValue);
   end;
   DW_IC_SDA_SETUP:begin
    fSDASetup:=TPasRISCVUInt8(aValue);
   end;
   DW_IC_ACK_GENERAL_CALL:begin
    fAckGeneralCall:=TPasRISCVUInt8(aValue) and 1;
   end;
   DW_IC_FS_SPKLEN:begin
    fFSSpkLen:=TPasRISCVUInt8(aValue);
   end;
   DW_IC_HS_SPKLEN:begin
    fHSSpkLen:=TPasRISCVUInt8(aValue);
   end;
   // Read-only registers: INTR_STAT, RAW_INTR_STAT, STATUS, TXFLR, RXFLR,
   // TX_ABRT_SOURCE, ENABLE_STATUS, COMP_* — ignore writes
  end;
 finally
  fLock.Release;
 end;
end;

{ TPasRTISCV.TPS2Device }

constructor TPasRISCV.TPS2Device.Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64);
begin
 inherited Create(aMachine,aBase,aSize);
 fLock:=TPasMPSlimReaderWriterLock.Create;
 fIRQ:=0;
 fControl:=0;
end;

destructor TPasRISCV.TPS2Device.Destroy;
begin
 FreeAndNil(fLock);
 inherited Destroy;
end;

function TPasRISCV.TPS2Device.Read(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt;
begin
 result:=0;
end;

function TPasRISCV.TPS2Device.Write(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt;
begin
 result:=0;
end;

function TPasRISCV.TPS2Device.Poll:TPasRISCVSizeInt;
begin
 result:=0;
end;

procedure TPasRISCV.TPS2Device.Notify(const aFlags:TPasRISCVUInt32);
begin
 if assigned(fMachine) and
    assigned(fMachine.fINTCDevice) and
    ((aFlags and POLL_RX)<>0) and
    ((TPasMPInterlocked.ExchangeBitwiseOr(fControl,CTRL_RI) and CTRL_RE)<>0) then begin
  fMachine.fInterrupts.SendIRQ(fIRQ);
 end;
end;

procedure TPasRISCV.TPS2Device.Update;
begin
end;

function TPasRISCV.TPS2Device.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Address:TPasRISCVUInt64;
    Value:TPasRISCVUInt32;
    Available:TPasRISCVUInt32;
begin
 Address:=aAddress-fBase;
 case Address of
  REG_DATA:begin
   Value:=0;
   Available:=Read(@Value,1);
   result:=Value or (TPasRISCVUInt32(ord(Available<>0) and 1) shl 15) or (TPasRISCVUInt32(Available) shl 16);
  end;
  REG_CTRL:begin
   result:=TPasMPInterlocked.Read(fControl);
  end;
  else begin
   result:=0;
  end;
 end;
end;

procedure TPasRISCV.TPS2Device.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Address:TPasRISCVUInt64;
    Value:TPasRISCVUInt32;
    Available:TPasRISCVUInt32;
begin
 Address:=aAddress-fBase;
 case Address of
  REG_DATA:begin
   Value:=aValue and $ff;
   Available:=Write(@Value,1);
   if Available=0 then begin
    TPasMPInterlocked.BitwiseOr(fControl,CTRL_CE);
   end;
  end;
  REG_CTRL:begin
   TPasMPInterlocked.BitwiseOr(fControl,aValue and CTRL_RE);
   TPasMPInterlocked.BitwiseAnd(fControl,CTRL_RI or (aValue and (CTRL_RE or CTRL_CE)));
  end;
 end;
end;

{ TPasRISCV.TPS2KeyboardDevice }

constructor TPasRISCV.TPS2KeyboardDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.PS2KeyboardBase,aMachine.fConfiguration.PS2KeyboardSize);
 fActive:=true;
 fIRQ:=aMachine.fConfiguration.PS2KeyboardIRQ;
 FillChar(fKeyState,SizeOf(fKeyState),#0);
 fState:=STATE_CMD;
 fRate:=$c;
 fDelay:=1;
 fReporting:=false;
 fLastKey:='';
 fRingBuffer:=TPasMPSingleProducerSingleConsumerRingBuffer.Create(65536);
 fTimer.Initialize(CLOCK_FREQUENCY);
 fTimeCmp:=TPasRISCVUInt64($ffffffffffffffff);
 FillChar(fHIDToPS2ByteMap,SizeOf(fHIDToPS2ByteMap),#0);
 fHIDToPS2ByteMap[THID.KEY_NONE]:=$00;
 fHIDToPS2ByteMap[THID.KEY_ERR_ROLLOVER]:=$ff;
 fHIDToPS2ByteMap[THID.KEY_A]:=$1c;
 fHIDToPS2ByteMap[THID.KEY_B]:=$32;
 fHIDToPS2ByteMap[THID.KEY_C]:=$21;
 fHIDToPS2ByteMap[THID.KEY_D]:=$23;
 fHIDToPS2ByteMap[THID.KEY_E]:=$24;
 fHIDToPS2ByteMap[THID.KEY_F]:=$2b;
 fHIDToPS2ByteMap[THID.KEY_G]:=$34;
 fHIDToPS2ByteMap[THID.KEY_H]:=$33;
 fHIDToPS2ByteMap[THID.KEY_I]:=$43;
 fHIDToPS2ByteMap[THID.KEY_J]:=$3b;
 fHIDToPS2ByteMap[THID.KEY_K]:=$42;
 fHIDToPS2ByteMap[THID.KEY_L]:=$4b;
 fHIDToPS2ByteMap[THID.KEY_M]:=$3a;
 fHIDToPS2ByteMap[THID.KEY_N]:=$31;
 fHIDToPS2ByteMap[THID.KEY_O]:=$44;
 fHIDToPS2ByteMap[THID.KEY_P]:=$4d;
 fHIDToPS2ByteMap[THID.KEY_Q]:=$15;
 fHIDToPS2ByteMap[THID.KEY_R]:=$2d;
 fHIDToPS2ByteMap[THID.KEY_S]:=$1b;
 fHIDToPS2ByteMap[THID.KEY_T]:=$2c;
 fHIDToPS2ByteMap[THID.KEY_U]:=$3c;
 fHIDToPS2ByteMap[THID.KEY_V]:=$2a;
 fHIDToPS2ByteMap[THID.KEY_W]:=$1d;
 fHIDToPS2ByteMap[THID.KEY_X]:=$22;
 fHIDToPS2ByteMap[THID.KEY_Y]:=$35;
 fHIDToPS2ByteMap[THID.KEY_Z]:=$1a;
 fHIDToPS2ByteMap[THID.KEY_1]:=$16;
 fHIDToPS2ByteMap[THID.KEY_2]:=$1e;
 fHIDToPS2ByteMap[THID.KEY_3]:=$26;
 fHIDToPS2ByteMap[THID.KEY_4]:=$25;
 fHIDToPS2ByteMap[THID.KEY_5]:=$2e;
 fHIDToPS2ByteMap[THID.KEY_6]:=$36;
 fHIDToPS2ByteMap[THID.KEY_7]:=$3d;
 fHIDToPS2ByteMap[THID.KEY_8]:=$3e;
 fHIDToPS2ByteMap[THID.KEY_9]:=$46;
 fHIDToPS2ByteMap[THID.KEY_0]:=$45;
 fHIDToPS2ByteMap[THID.KEY_RETURN]:=$5a;
 fHIDToPS2ByteMap[THID.KEY_ESCAPE]:=$76;
 fHIDToPS2ByteMap[THID.KEY_BACKSPACE]:=$66;
 fHIDToPS2ByteMap[THID.KEY_TAB]:=$0d;
 fHIDToPS2ByteMap[THID.KEY_SPACE]:=$29;
 fHIDToPS2ByteMap[THID.KEY_MINUS]:=$4e;
 fHIDToPS2ByteMap[THID.KEY_EQUAL]:=$55;
 fHIDToPS2ByteMap[THID.KEY_LEFTBRACE]:=$54;
 fHIDToPS2ByteMap[THID.KEY_RIGHTBRACE]:=$5b;
 fHIDToPS2ByteMap[THID.KEY_BACKSLASH]:=$5d;
 fHIDToPS2ByteMap[THID.KEY_SEMICOLON]:=$4c;
 fHIDToPS2ByteMap[THID.KEY_APOSTROPHE]:=$52;
 fHIDToPS2ByteMap[THID.KEY_GRAVE]:=$0e;
 fHIDToPS2ByteMap[THID.KEY_COMMA]:=$41;
 fHIDToPS2ByteMap[THID.KEY_DOT]:=$49;
 fHIDToPS2ByteMap[THID.KEY_SLASH]:=$4a;
 fHIDToPS2ByteMap[THID.KEY_CAPSLOCK]:=$58;
 fHIDToPS2ByteMap[THID.KEY_LEFTCTRL]:=$14;
 fHIDToPS2ByteMap[THID.KEY_LEFTSHIFT]:=$12;
 fHIDToPS2ByteMap[THID.KEY_LEFTALT]:=$11;
 fHIDToPS2ByteMap[THID.KEY_RIGHTSHIFT]:=$59;
 fHIDToPS2ByteMap[THID.KEY_F1]:=$05;
 fHIDToPS2ByteMap[THID.KEY_F2]:=$06;
 fHIDToPS2ByteMap[THID.KEY_F3]:=$04;
 fHIDToPS2ByteMap[THID.KEY_F4]:=$0c;
 fHIDToPS2ByteMap[THID.KEY_F5]:=$03;
 fHIDToPS2ByteMap[THID.KEY_F6]:=$0b;
 fHIDToPS2ByteMap[THID.KEY_F7]:=$83;
 fHIDToPS2ByteMap[THID.KEY_F8]:=$0a;
 fHIDToPS2ByteMap[THID.KEY_F9]:=$01;
 fHIDToPS2ByteMap[THID.KEY_F10]:=$09;
 fHIDToPS2ByteMap[THID.KEY_F11]:=$78;
 fHIDToPS2ByteMap[THID.KEY_F12]:=$07;
 fHIDToPS2ByteMap[THID.KEY_NUMLOCK]:=$77;
 fHIDToPS2ByteMap[THID.KEY_SYSRQ]:=$7c;
 fHIDToPS2ByteMap[THID.KEY_SCROLLLOCK]:=$7e;
 fHIDToPS2ByteMap[THID.KEY_KPASTERISK]:=$7c;
 fHIDToPS2ByteMap[THID.KEY_KPMINUS]:=$7b;
 fHIDToPS2ByteMap[THID.KEY_KPPLUS]:=$79;
 fHIDToPS2ByteMap[THID.KEY_KP1]:=$69;
 fHIDToPS2ByteMap[THID.KEY_KP2]:=$72;
 fHIDToPS2ByteMap[THID.KEY_KP3]:=$7a;
 fHIDToPS2ByteMap[THID.KEY_KP4]:=$6b;
 fHIDToPS2ByteMap[THID.KEY_KP5]:=$73;
 fHIDToPS2ByteMap[THID.KEY_KP6]:=$74;
 fHIDToPS2ByteMap[THID.KEY_KP7]:=$6c;
 fHIDToPS2ByteMap[THID.KEY_KP8]:=$75;
 fHIDToPS2ByteMap[THID.KEY_KP9]:=$7d;
 fHIDToPS2ByteMap[THID.KEY_KP0]:=$70;
 fHIDToPS2ByteMap[THID.KEY_KPDOT]:=$71;
{fHIDToPS2ByteMap[THID.KEY_PAUSE]:=$77;
 fHIDToPS2ByteMap[THID.KEY_INSERT]:=$70;
 fHIDToPS2ByteMap[THID.KEY_HOME]:=$6c;
 fHIDToPS2ByteMap[THID.KEY_PAGEUP]:=$7d;
 fHIDToPS2ByteMap[THID.KEY_DELETE]:=$71;
 fHIDToPS2ByteMap[THID.KEY_END]:=$69;
 fHIDToPS2ByteMap[THID.KEY_PAGEDOWN]:=$7a;
 fHIDToPS2ByteMap[THID.KEY_RIGHT]:=$74;
 fHIDToPS2ByteMap[THID.KEY_LEFT]:=$6b;
 fHIDToPS2ByteMap[THID.KEY_DOWN]:=$72;
 fHIDToPS2ByteMap[THID.KEY_UP]:=$75;
 fHIDToPS2ByteMap[THID.KEY_KPSLASH]:=$4a;
 fHIDToPS2ByteMap[THID.KEY_KPENTER]:=$5a;
 fHIDToPS2ByteMap[THID.KEY_102ND]:=$61;
 fHIDToPS2ByteMap[THID.KEY_COMPOSE]:=$65;
 fHIDToPS2ByteMap[THID.KEY_POWER]:=$66;
 fHIDToPS2ByteMap[THID.KEY_KPEQUAL]:=$8d;
 fHIDToPS2ByteMap[THID.KEY_F13]:=$68;
 fHIDToPS2ByteMap[THID.KEY_F14]:=$84;
 fHIDToPS2ByteMap[THID.KEY_F15]:=$8c;
 fHIDToPS2ByteMap[THID.KEY_F16]:=$67;
 fHIDToPS2ByteMap[THID.KEY_F17]:=$8f;
 fHIDToPS2ByteMap[THID.KEY_F18]:=$8e;
 fHIDToPS2ByteMap[THID.KEY_F19]:=$8d;
 fHIDToPS2ByteMap[THID.KEY_F20]:=$8b;
 fHIDToPS2ByteMap[THID.KEY_F21]:=$8a;
 fHIDToPS2ByteMap[THID.KEY_F22]:=$89;
 fHIDToPS2ByteMap[THID.KEY_F23]:=$88;
 fHIDToPS2ByteMap[THID.KEY_F24]:=$87;
 fHIDToPS2ByteMap[THID.KEY_OPEN]:=$5d;
 fHIDToPS2ByteMap[THID.KEY_HELP]:=$75;
 fHIDToPS2ByteMap[THID.KEY_PROPS]:=$7e;
 fHIDToPS2ByteMap[THID.KEY_FRONT]:=$6d;
 fHIDToPS2ByteMap[THID.KEY_STOP]:=$6e;
 fHIDToPS2ByteMap[THID.KEY_AGAIN]:=$7c;
 fHIDToPS2ByteMap[THID.KEY_UNDO]:=$7a;
 fHIDToPS2ByteMap[THID.KEY_CUT]:=$7d;
 fHIDToPS2ByteMap[THID.KEY_COPY]:=$7b;
 fHIDToPS2ByteMap[THID.KEY_PASTE]:=$79;
 fHIDToPS2ByteMap[THID.KEY_FIND]:=$78;
 fHIDToPS2ByteMap[THID.KEY_MUTE]:=$7f;
 fHIDToPS2ByteMap[THID.KEY_VOLUMEUP]:=$80;
 fHIDToPS2ByteMap[THID.KEY_VOLUMEDOWN]:=$81;
 fHIDToPS2ByteMap[THID.KEY_KPCOMMA]:=$71;
 fHIDToPS2ByteMap[THID.KEY_RO]:=$61;
 fHIDToPS2ByteMap[THID.KEY_KATAKANAHIRAGANA]:=$8a;
 fHIDToPS2ByteMap[THID.KEY_YEN]:=$89;
 fHIDToPS2ByteMap[THID.KEY_HENKAN]:=$8b;
 fHIDToPS2ByteMap[THID.KEY_MUHENKAN]:=$8a;
 fHIDToPS2ByteMap[THID.KEY_KPJPCOMMA]:=$8c;
 fHIDToPS2ByteMap[THID.KEY_HANGEUL]:=$90;
 fHIDToPS2ByteMap[THID.KEY_HANJA]:=$91;
 fHIDToPS2ByteMap[THID.KEY_KATAKANA]:=$92;
 fHIDToPS2ByteMap[THID.KEY_HIRAGANA]:=$93;
 fHIDToPS2ByteMap[THID.KEY_ZENKAKUHANKAKU]:=$94;
 fHIDToPS2ByteMap[THID.KEY_KPLEFTPAREN]:=$b6;
 fHIDToPS2ByteMap[THID.KEY_KPRIGHTPAREN]:=$b7;
 fHIDToPS2ByteMap[THID.KEY_LEFTALT]:=$11;
 fHIDToPS2ByteMap[THID.KEY_LEFTMETA]:=$e0;
 fHIDToPS2ByteMap[THID.KEY_RIGHTALT]:=$11;
 fHIDToPS2ByteMap[THID.KEY_RIGHTMETA]:=$e7;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_PLAYPAUSE]:=$e8;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_STOPCD]:=$e9;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_PREVIOUSSONG]:=$ea;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_NEXTSONG]:=$eb;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_EJECTCD]:=$ec;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_VOLUMEUP]:=$ed;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_VOLUMEDOWN]:=$ee;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_MUTE]:=$ef;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_WWW]:=$f0;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_BACK]:=$f1;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_FORWARD]:=$f2;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_STOP]:=$f3;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_FIND]:=$f4;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_SCROLLUP]:=$f5;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_SCROLLDOWN]:=$f6;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_EDIT]:=$f7;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_SLEEP]:=$f8;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_COFFEE]:=$f9;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_REFRESH]:=$fa;
 fHIDToPS2ByteMap[THID.KEY_MEDIA_CALC]:=$fb; }
end;

destructor TPasRISCV.TPS2KeyboardDevice.Destroy;
begin
 FreeAndNil(fRingBuffer);
 fLastKey:='';
 inherited Destroy;
end;

procedure TPasRISCV.TPS2KeyboardDevice.Reset;
begin
 fActive:=true;
 inherited Reset;
end;

procedure TPasRISCV.TPS2KeyboardDevice.RingBufferWrite(const aData:TPasRISCVUInt8);
begin
 fRingBuffer.Write(@aData,1);
end;

function TPasRISCV.TPS2KeyboardDevice.RingBufferRead(out aData:TPasRISCVUInt8):Boolean;
begin
 result:=fRingBuffer.TryRead(@aData,1)=1;
end;

procedure TPasRISCV.TPS2KeyboardDevice.SetRate(const aRate:TPasRISCVUInt8);
begin
 fRate:=aRate and $1f;
 fDelay:=(aRate shr 5) and 3;
 fTimer.Initialize(1000);
 fTimeCmp:=(fDelay+1)*250;
end;

procedure TPasRISCV.TPS2KeyboardDevice.ResetToDefaults;
begin
 FillChar(fKeyState,SizeOf(fKeyState),#0);
 fState:=STATE_CMD;
 fRate:=$c;
 fDelay:=1;
end;

function TPasRISCV.TPS2KeyboardDevice.Command(const aCmd:TPasRISCVUInt8):Boolean;
begin
 case aCmd of
  CMD_RESET:begin
   ResetToDefaults;
   RingBufferWrite(RSP_ACK);
   RingBufferWrite($aa);
   result:=true;
  end;
  CMD_RESEND:begin
   result:=false;
  end;
  CMD_SET_DEFAULTS:begin
   ResetToDefaults;
   RingBufferWrite(RSP_ACK);
   result:=true;
  end;
  CMD_DISABLE_DATA_REPORTING:begin
   fReporting:=false;
   ResetToDefaults;
   RingBufferWrite(RSP_ACK);
   result:=true;
  end;
  CMD_ENABLE_DATA_REPORTING:begin
   fReporting:=true;
   RingBufferWrite(RSP_ACK);
   result:=true;
  end;
  CMD_SET_SAMPLE_RATE:begin
   fState:=STATE_SET_SAMPLE_RATE;
   RingBufferWrite(RSP_ACK);
   result:=true;
  end;
  CMD_GET_DEV_ID:begin
   RingBufferWrite(RSP_ACK);
   RingBufferWrite($ab);
   RingBufferWrite($83);
   result:=true;
  end;
  CMD_SET_SCAN_CODE_SET:begin
   fState:=STATE_SET_SCAN_CODE_SET;
   RingBufferWrite(RSP_ACK);
   result:=true;
  end;
  CMD_ECHO:begin
   RingBufferWrite($ee);
   result:=true;
  end;
  CMD_LEDS:begin
   fState:=STATE_SET_LEDS;
   RingBufferWrite(RSP_ACK);
   result:=true;
  end;
  else begin
   RingBufferWrite(RSP_NAK);
   result:=true;
  end;
 end;
end;

function TPasRISCV.TPS2KeyboardDevice.Read(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt;
begin
 fLock.Acquire;
 try
  result:=fRingBuffer.ReadAsMuchAsPossible(aBuffer,aSize);
 finally
  fLock.Release;
 end;
end;

function TPasRISCV.TPS2KeyboardDevice.Write(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt;
var Index:TPasRISCVSizeInt;
    Value:TPasRISCVUInt8;
begin
 fLock.Acquire;
 try
  result:=0;
  for Index:=0 to aSize-1 do begin
   Value:=TPasRISCVUInt8(PPasRISCVUInt8Array(aBuffer)^[Index]);
   case fState of
    STATE_CMD:begin
     Command(Value);
    end;
    STATE_SET_SAMPLE_RATE:begin
     SetRate(Value);
     fState:=STATE_CMD;
     RingBufferWrite(RSP_ACK);
    end;
    STATE_SET_SCAN_CODE_SET:begin
     case Value of
      0:begin
       RingBufferWrite(RSP_ACK);
       RingBufferWrite(2);
      end;
      2:begin
       RingBufferWrite(RSP_ACK);
      end;
      else begin
       RingBufferWrite(RSP_NAK);
      end;
     end;
     fState:=STATE_CMD;
     RingBufferWrite(RSP_ACK);
    end;
    STATE_SET_LEDS:begin
     fState:=STATE_CMD;
     RingBufferWrite(RSP_ACK);
    end;
   end;
  end;
 finally
  fLock.Release;
 end;
 Notify(POLL_RX);
 result:=aSize;
end;

procedure TPasRISCV.TPS2KeyboardDevice.Update;
begin
 fLock.Acquire;
 try
  if fReporting and (length(fLastKey)<>0) and (fTimer.Get>=fTimeCmp) then begin
   fTimer.Initialize(Max(1,RateToRealRate[fRate]));
   fTimeCmp:=10;
   fRingBuffer.Write(@fLastKey[1],length(fLastKey));
   Notify(POLL_RX);
   fMachine.Interrupt;
   fMachine.WakeUp;
  end;
 finally
  fLock.Release;
 end;
end;

function TPasRISCV.TPS2KeyboardDevice.HIDToPS2KeyCode(const aKey:TPasRISCVUInt32):TPasRISCVRawByteString;
begin
 if (aKey<sizeof(fHIDToPS2ByteMap)) and (fHIDToPS2ByteMap[aKey]<>0) then begin
  result:=TPasRISCVRawByteString(TPasRISCVRawByteChar(fHIDToPS2ByteMap[aKey]));
 end else begin
  case aKey of
   THID.KEY_LEFTMETA:begin
    result:=#$e0#$1f;
   end;
   THID.KEY_RIGHTCTRL:begin
    result:=#$e0#$14;
   end;
   THID.KEY_RIGHTALT:begin
    result:=#$e0#$11;
   end;
   THID.KEY_RIGHTMETA:begin
    result:=#$e0#$27;
   end;
   THID.KEY_SYSRQ:begin
    result:=#$e0#$12#$e0#$7c;
   end;
   THID.KEY_PAUSE:begin
    result:=#$e1#$14#$77#$e1#$f0#$14#$f0#$77;
   end;
   THID.KEY_INSERT:begin
    result:=#$e0#$70;
   end;
   THID.KEY_HOME:begin
    result:=#$e0#$6c;
   end;
   THID.KEY_PAGEUP:begin
    result:=#$e0#$7d;
   end;
   THID.KEY_DELETE:begin
    result:=#$e0#$71;
   end;
   THID.KEY_END:begin
    result:=#$e0#$69;
   end;
   THID.KEY_PAGEDOWN:begin
    result:=#$e0#$7a;
   end;
   THID.KEY_RIGHT:begin
    result:=#$e0#$74;
   end;
   THID.KEY_LEFT:begin
    result:=#$e0#$6b;
   end;
   THID.KEY_DOWN:begin
    result:=#$e0#$72;
   end;
   THID.KEY_UP:begin
    result:=#$e0#$75;
   end;
   THID.KEY_MENU:begin
    result:=#$e0#$2f;
   end;
   THID.KEY_KPSLASH:begin
    result:=#$e0#$4a;
   end;
   THID.KEY_KPENTER:begin
    result:=#$e0#$5a;
   end;
   else begin
    result:='';
   end;
  end;
 end;
end;

procedure TPasRISCV.TPS2KeyboardDevice.HandleKeyboard(const aKey:TPasRISCVUInt32;const aPressed:Boolean);
var KeyState:Boolean;
    KeyCode:TPasRISCVRawByteString;
    KeyBuf:array[0..7] of TPasRISCVUInt8;
    KeyLen:TPasRISCVSizeInt;
begin
 if fActive then begin
  fLock.Acquire;
  try
   KeyState:=(fKeyState[aKey shr 3] and (1 shl (aKey and 7)))<>0;
   if (aKey<>THID.KEY_NONE) and (KeyState<>aPressed) and fReporting then begin
    KeyCode:=HIDToPS2KeyCode(aKey);
    if length(KeyCode)<>0 then begin
     if aPressed then begin
      fKeyState[aKey shr 3]:=fKeyState[aKey shr 3] or (1 shl (aKey and 7));
      fLastKey:=KeyCode;
      fRingBuffer.Write(@KeyCode[1],length(KeyCode));
      fTimer.Initialize(1000);
      fTimeCmp:=(fDelay+1)*250;
     end else begin
      fKeyState[aKey shr 3]:=fKeyState[aKey shr 3] and not (1 shl (aKey and 7));
      if fLastKey=KeyCode then begin
       fLastKey:='';
      end;
      if length(KeyCode)=1 then begin
       KeyBuf[0]:=$f0;
       KeyBuf[1]:=TPasRISCVUInt8(KeyCode[1]);
       KeyLen:=2;
      end else if (length(KeyCode)=2) and (KeyCode[1]=#$e0) then begin
       KeyBuf[0]:=$e0;
       KeyBuf[1]:=$f0;
       KeyBuf[2]:=TPasRISCVUInt8(KeyCode[2]);
       KeyLen:=3;
      end else if (length(KeyCode)=4) and (KeyCode[1]=#$e0) and (KeyCode[3]=#$e0) then begin
       KeyBuf[0]:=$e0;
       KeyBuf[1]:=$f0;
       KeyBuf[2]:=TPasRISCVUInt8(KeyCode[4]);
       KeyBuf[3]:=$e0;
       KeyBuf[4]:=$f0;
       KeyBuf[5]:=TPasRISCVUInt8(KeyCode[2]);
       KeyLen:=6;
      end;
      fRingBuffer.Write(@KeyBuf,KeyLen);
     end;
     Notify(POLL_RX);
    end;
   end;
  finally
   fLock.Release;
  end;
 end;
end;

{ TPasRISCV.TPS2MouseDevice }

constructor TPasRISCV.TPS2MouseDevice.Create(const aMachine:TPasRISCV);
begin
 inherited Create(aMachine,aMachine.fConfiguration.PS2MouseBase,aMachine.fConfiguration.PS2MouseSize);
 fIRQ:=aMachine.fConfiguration.PS2MouseIRQ;
 fActive:=true;
 fButtons:=0;
 fResolutionInitialized:=false;
 fX:=0;
 fY:=0;
 fXMovementCounter:=0;
 fYMovementCounter:=0;
 fXOverflow:=false;
 fYOverflow:=false;
 fScroll:=0;
 fMode:=MODE_STREAM;
 fState:=STATE_CMD;
 fResolution:=0;
 fRate:=0;
 fWheelDetect:=0;
 fReporting:=false;
 fRingBuffer:=TPasMPSingleProducerSingleConsumerRingBuffer.Create(65536);
end;

destructor TPasRISCV.TPS2MouseDevice.Destroy;
begin
 FreeAndNil(fRingBuffer);
 inherited Destroy;
end;

procedure TPasRISCV.TPS2MouseDevice.ResetToDefaults;
begin
 fMode:=MODE_STREAM;
 fState:=STATE_CMD;
 fReporting:=false;
 fResolution:=2;
end;

procedure TPasRISCV.TPS2MouseDevice.Reset;
begin
 fActive:=true;
 ResetToDefaults;
 inherited Reset;
end;

procedure TPasRISCV.TPS2MouseDevice.Flush;
begin
 fXMovementCounter:=0;
 fYMovementCounter:=0;
 fXOverflow:=false;
 fYOverflow:=false;
 fScroll:=0;
end;

procedure TPasRISCV.TPS2MouseDevice.MovePacket;
var Value:TPasRISCVUInt8;
    MousePacket:array[0..3] of TPasRISCVUInt8;
begin

 Value:=(fButtons and (1 or 2 or 4)) or
        (1 shl 3) or
        ((ord(fXMovementCounter<0) and 1) shl 4) or
        ((ord(fYMovementCounter<0) and 1) shl 5) or
        ((ord(fXOverflow) and 1) shl 6) or
        ((ord(fYOverflow) and 1) shl 7);

 MousePacket[0]:=Value;
 MousePacket[1]:=fXMovementCounter and $ff;
 MousePacket[2]:=fYMovementCounter and $ff;
 if fWheelDetect=3 then begin
  MousePacket[3]:=fScroll;
 end;

 fRingBuffer.Write(@MousePacket[0],3+(ord(fWheelDetect=3) and 1));

 Flush;

 Notify(POLL_RX);

end;

function TPasRISCV.TPS2MouseDevice.Command(const aCmd:TPasRISCVUInt8):Boolean;
var SendBuffer:array[0..3] of TPasRISCVUInt8;
begin
 case aCmd of
  CMD_RESET:begin
   ResetToDefaults;
   SendBuffer[0]:=RSP_ACK;
   SendBuffer[1]:=$aa;
   SendBuffer[2]:=$00;
   fRingBuffer.Write(@SendBuffer[0],3);
   result:=true;
  end;
  CMD_RESEND:begin
   result:=false;
  end;
  CMD_SET_DEFAULTS:begin
   ResetToDefaults;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_DISABLE_DATA_REPORTING:begin
   fReporting:=false;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_ENABLE_DATA_REPORTING:begin
   fReporting:=true;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_SET_SAMPLE_RATE:begin
   fState:=STATE_SET_SAMPLE_RATE;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_GET_DEV_ID:begin
   SendBuffer[0]:=RSP_ACK;
   if fWheelDetect=3 then begin
    SendBuffer[1]:=MOUSE_WHEEL;
   end else begin
    SendBuffer[1]:=MOUSE_GENERIC;
   end;
   fRingBuffer.Write(@SendBuffer[0],2);
   result:=true;
  end;
  CMD_SET_REMOTE_MODE:begin
   Flush;
   fMode:=MODE_REMOTE;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_SET_WRAP_MODE:begin
   Flush;
   fState:=STATE_WRAP;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_RESET_WRAP_MODE:begin
   Flush;
   fState:=STATE_CMD;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_READ_DATA:begin
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   MovePacket;
   result:=true;
  end;
  CMD_SET_STREAM_MODE:begin
   Flush;
   fMode:=MODE_STREAM;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_STATUS_REQ:begin
   SendBuffer[0]:=RSP_ACK;
   SendBuffer[1]:=(fButtons and (1 or 2 or 4)) or
                  (ord(fReporting) shl 5) or
                  ((ord(fMode=MODE_REMOTE) and 1) shl 6);
   SendBuffer[2]:=fResolution;
   SendBuffer[3]:=fRate;
   fRingBuffer.Write(@SendBuffer[0],4);
   result:=true;
  end;
  CMD_SET_RESOLUTION:begin
   fState:=STATE_SET_RESOLUTION;
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  CMD_SET_SCALING_1_1,
  CMD_SET_SCALING_2_1:begin
   SendBuffer[0]:=RSP_ACK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
  else begin
   SendBuffer[0]:=RSP_NAK;
   fRingBuffer.Write(@SendBuffer[0],1);
   result:=true;
  end;
 end;
end;

function TPasRISCV.TPS2MouseDevice.Read(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt;
begin
 fLock.Acquire;
 try
  result:=fRingBuffer.ReadAsMuchAsPossible(aBuffer,aSize);
 finally
  fLock.Release;
 end;
end;

function TPasRISCV.TPS2MouseDevice.Write(const aBuffer:Pointer;const aSize:TPasRISCVSizeInt):TPasRISCVSizeInt;
var Index:TPasRISCVSizeInt;
    Value:TPasRISCVUInt8;
    SendBuffer:array[0..3] of TPasRISCVUInt8;
begin
 fLock.Acquire;
 try
  result:=0;
  for Index:=0 to aSize-1 do begin
   Value:=PPasRISCVUInt8Array(aBuffer)^[Index];
   case fState of
    STATE_CMD:begin
     Command(Value);
    end;
    STATE_SET_SAMPLE_RATE:begin
     fRate:=Value;
     if fWheelDetect=0 then begin // Magical sequence for detecting Intellimouse extension
      if fRate=200 then begin
       fWheelDetect:=1;
      end else begin
       fWheelDetect:=0;
      end;
     end else if fWheelDetect=1 then begin
      if fRate=100 then begin
       fWheelDetect:=2;
      end else begin
       fWheelDetect:=0;
      end;
     end else if fWheelDetect=2 then begin
      if fRate=80 then begin
       fWheelDetect:=3;
      end else begin
       fWheelDetect:=0;
      end;
     end else if fWheelDetect<3 then begin
      fWheelDetect:=0;
     end;
     fState:=STATE_CMD;
     SendBuffer[0]:=RSP_ACK;
     fRingBuffer.Write(@SendBuffer[0],1);
    end;
    STATE_WRAP:begin
     if (Value<>CMD_RESET_WRAP_MODE) and (Value<>CMD_RESET) then begin
      fRingBuffer.Write(@Value,1);
     end;
    end;
    STATE_SET_RESOLUTION:begin
     fResolution:=Value;
     fState:=STATE_CMD;
     SendBuffer[0]:=RSP_ACK;
     fRingBuffer.Write(@SendBuffer[0],1);
    end;
   end;
  end;
 finally
  fLock.Release;
 end;
 Notify(POLL_RX);
 result:=aSize;
end;

procedure TPasRISCV.TPS2MouseDevice.ButtonPress(const aButtons:TPasRISCVUInt32);
begin
 fLock.Acquire;
 try
  if fActive then begin
   if (fButtons and aButtons)<>aButtons then begin
    fButtons:=fButtons or aButtons;
    if (fMode=MODE_STREAM) and fReporting then begin
     MovePacket;
    end;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TPS2MouseDevice.ButtonRelease(const aButtons:TPasRISCVUInt32);
begin
 fLock.Acquire;
 try
  if fActive then begin
   if (fButtons and aButtons)<>0 then begin
    fButtons:=fButtons and not aButtons;
    if (fMode=MODE_STREAM) and fReporting then begin
     MovePacket;
    end;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TPS2MouseDevice.Scroll(const aOffset:TPasRISCVInt32);
begin
 fLock.Acquire;
 try
  if fActive then begin
   fScroll:=fScroll+aOffset;
   if (fMode=MODE_STREAM) and fReporting then begin
    MovePacket;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TPS2MouseDevice.RelativeMove(const aDeltaX,aDeltaY:TPasRISCVInt32);
var Shift:TPasRISCVInt32;
    NewX,NewY:TPasRISCVInt32;
begin
 fLock.Acquire;
 try
  if fActive then begin
   Shift:=3-fResolution;
   inc(fX,aDeltaX);
   inc(fY,aDeltaY);
   if Shift>=0 then begin
    NewX:=fXMovementCounter+(aDeltaX shr Shift);
    NewY:=fYMovementCounter-(aDeltaY shr Shift);
   end else begin
    NewX:=fXMovementCounter+(aDeltaX shl (-Shift));
    NewY:=fYMovementCounter-(aDeltaY shl (-Shift));
   end;
   if (NewX>255) or (NewX<-512) then begin
    fXOverflow:=true;
    NewX:=TPasRISCVInt8(NewX);
   end;
   if (NewY>255) or (NewY<-512) then begin
    fYOverflow:=true;
    NewY:=TPasRISCVInt8(NewY);
   end;
   fXMovementCounter:=NewX;
   fYMovementCounter:=NewY;
   if (fMode=MODE_STREAM) and fReporting then begin
    MovePacket;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

procedure TPasRISCV.TPS2MouseDevice.AbsoluteMove(const aX,aY:TPasRISCVInt32);
begin
 fLock.Acquire;
 try
  if fActive then begin
   fX:=aX;
   fY:=aY;
   if (fMode=MODE_STREAM) and fReporting then begin
    MovePacket;
   end;
  end;
 finally
  fLock.Release;
 end;
end;

{ TPasRISCV.TMemoryDevice }

constructor TPasRISCV.TMemoryDevice.Create(const aMachine:TPasRISCV;const aBase,aSize:TPasRISCVUInt64;const aData:Pointer;const aOwnData:Boolean);
begin
 fOwnData:=aOwnData;
 if aOwnData then begin
  fData:=aData;
 end else begin
  fData:=nil;
  if aSize>0 then begin
   GetMem(fData,aSize);
   FillChar(fData^,aSize,#0);
  end;
 end;
 inherited Create(aMachine,aBase,aSize);
end;

destructor TPasRISCV.TMemoryDevice.Destroy;
begin
 if (not fOwnData) and assigned(fData) then begin
  FreeMem(Data);
 end;
 fData:=nil;
 inherited Destroy;
end;

procedure TPasRISCV.TMemoryDevice.SetSize(const aValue:TPasRISCVUInt64);
var OldSize:TPasRISCVUInt64;
begin
 if not fOwnData then begin
  OldSize:=fSize;
  inherited SetSize(aValue);
  if OldSize<>aValue then begin
   ReallocMem(fData,aValue);
  end;
 end;
end;

function TPasRISCV.TMemoryDevice.GetDeviceDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
begin
 if (aAddress>=fBase) and ((aAddress-fBase)<fSize) then begin
  result:=@PPasRISCVUInt8Array(fData)^[aAddress-fBase];
 end else begin
  result:=nil;
 end;
end;

function TPasRISCV.TMemoryDevice.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Offset:TPasRISCVUInt64;
begin
 Offset:=aAddress-fBase;
 if (Offset+aSize)<=fSize then begin
{$ifdef LITTLE_ENDIAN}
  if aSize=8 then begin
   result:=TPasRISCVUInt64(Pointer(@PPasRISCVUInt8Array(fData)^[Offset])^);
  end else begin
   result:=TPasRISCVUInt64(Pointer(@PPasRISCVUInt8Array(fData)^[Offset])^) and ((TPasRISCVUInt64(1) shl (aSize shl 3))-1);
  end;
{$else}
  case aSize of
   1:begin
    result:=TPasRISCVUInt64(fData[Offset]) and $ff;
   end;
   2:begin
    result:=(TPasRISCVUInt64(fData[Offset]) and $ff) or ((TPasRISCVUInt64(fData[Offset+1]) and $ff) shl 8);
   end;
   4:begin
    result:=(TPasRISCVUInt64(fData[Offset]) and $ff) or ((TPasRISCVUInt64(fData[Offset+1]) and $ff) shl 8) or ((TPasRISCVUInt64(fData[Offset+2]) and $ff) shl 16) or ((TPasRISCVUInt64(fData[Offset+3]) and $ff) shl 24);
   end;
   8:begin
    result:=(TPasRISCVUInt64(fData[Offset]) and $ff) or ((TPasRISCVUInt64(fData[Offset+1]) and $ff) shl 8) or ((TPasRISCVUInt64(fData[Offset+2]) and $ff) shl 16) or ((TPasRISCVUInt64(fData[Offset+3]) and $ff) shl 24) or ((TPasRISCVUInt64(fData[Offset+4]) and $ff) shl 32) or ((TPasRISCVUInt64(fData[Offset+5]) and $ff) shl 40) or ((TPasRISCVUInt64(fData[Offset+6]) and $ff) shl 48) or ((TPasRISCVUInt64(fData[Offset+7]) and $ff) shl 56);
   end;
   else begin
    result:=0;
   end;
  end;
{$endif}
 end else begin
  result:=0;
 end;
end;

procedure TPasRISCV.TMemoryDevice.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var Offset{$ifdef LITTLE_ENDIAN},Mask{$endif}:TPasRISCVUInt64;
begin
 Offset:=aAddress-fBase;
 if (Offset+aSize)<=fSize then begin
{$ifdef LITTLE_ENDIAN}
  if aSize=8 then begin
   TPasRISCVUInt64(Pointer(@PPasRISCVUInt8Array(fData)^[Offset])^):=aValue;
  end else begin
   Mask:=(TPasRISCVUInt64(1) shl (aSize shl 3))-1;
   TPasRISCVUInt64(Pointer(@PPasRISCVUInt8Array(fData)^[Offset])^):=(TPasRISCVUInt64(Pointer(@PPasRISCVUInt8Array(fData)^[Offset])^) and not Mask) or (aValue and Mask);
  end;
{$else}
  case aSize of
   1:begin
    fData[Offset]:=aValue and $ff;
   end;
   2:begin
    fData[Offset]:=aValue and $ff;
    fData[Offset+1]:=(aValue shr 8) and $ff;
   end;
   4:begin
    fData[Offset]:=aValue and $ff;
    fData[Offset+1]:=(aValue shr 8) and $ff;
    fData[Offset+2]:=(aValue shr 16) and $ff;
    fData[Offset+3]:=(aValue shr 24) and $ff;
   end;
   8:begin
    fData[Offset]:=aValue and $ff;
    fData[Offset+1]:=(aValue shr 8) and $ff;
    fData[Offset+2]:=(aValue shr 16) and $ff;
    fData[Offset+3]:=(aValue shr 24) and $ff;
    fData[Offset+4]:=(aValue shr 32) and $ff;
    fData[Offset+5]:=(aValue shr 40) and $ff;
    fData[Offset+6]:=(aValue shr 48) and $ff;
    fData[Offset+7]:=(aValue shr 56) and $ff;
   end;
  end;
{$endif}
 end;
end;

procedure TPasRISCV.TMemoryDevice.LoadFromStream(const aStream:TStream);
begin
 if fSize>0 then begin
  aStream.Seek(0,soBeginning);
  aStream.ReadBuffer(fData^,Min(TPasRISCVInt64(fSize),TPasRISCVInt64(aStream.Size)));
 end;
end;

procedure TPasRISCV.TMemoryDevice.LoadFromFile(const aFileName:TPasRISCVUTF8String);
var FileStream:TFileStream;
begin
 FileStream:=TFileStream.Create(aFileName,fmOpenRead);
 try
  LoadFromStream(FileStream);
 finally
  FileStream.Free;
 end;
end;

procedure TPasRISCV.TMemoryDevice.SaveToStream(const aStream:TStream);
begin
 if fSize>0 then begin
  aStream.Seek(0,soBeginning);
  aStream.WriteBuffer(fData^,fSize);
 end;
end;

procedure TPasRISCV.TMemoryDevice.SaveToFile(const aFileName:TPasRISCVUTF8String);
var FileStream:TFileStream;
begin
 FileStream:=TFileStream.Create(aFileName,fmCreate);
 try
  SaveToStream(FileStream);
 finally
  FileStream.Free;
 end;
end;

{ TPasRISCV.TBus }

constructor TPasRISCV.TBus.Create(const aMachine:TPasRISCV);
begin
 inherited Create;
 fMachine:=aMachine;
 fBusDevices:=nil;
 fCountBusDevices:=0;
end;

destructor TPasRISCV.TBus.Destroy;
begin
 fBusDevices:=nil;
 fCountBusDevices:=0;
 inherited Destroy;
end;

function TPasRISCV.TBus.GetAutoMemoryAddress(const aAddress,aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var Index:TPasRISCVSizeInt;
    OK:Boolean;
    BusDevice:TBusDevice;
begin
 result:=aAddress;
 if aSize<>0 then begin
  repeat
   OK:=true;
   for Index:=0 to fCountBusDevices-1 do begin
    BusDevice:=fBusDevices[Index];
    if (result<(BusDevice.fBase+BusDevice.fSize)) and (BusDevice.fBase<(result+aSize)) then begin
     result:=((BusDevice.fBase+BusDevice.fSize)+TPasRISCVUInt64($fff)) and TPasRISCVUInt64($fffffffffffff000);
     OK:=false;
    end;
   end;
  until OK;
 end;
end;

procedure TPasRISCV.TBus.AddBusDevice(const aBusDevice:TBusDevice);
var Index:TPasRISCVSizeInt;
begin
 Index:=fCountBusDevices;
 inc(fCountBusDevices);
 if length(fBusDevices)<fCountBusDevices then begin
  SetLength(fBusDevices,fCountBusDevices+((fCountBusDevices+1) shr 1)); // Grow by 1.5
 end;
 fBusDevices[Index]:=aBusDevice;
end;

procedure TPasRISCV.TBus.RemoveBusDevice(const aBusDevice:TBusDevice);
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to fCountBusDevices-1 do begin
  if fBusDevices[Index]=aBusDevice then begin
   if (Index+1)<fCountBusDevices then begin
    fBusDevices[Index]:=fBusDevices[fCountBusDevices-1];
    fBusDevices[fCountBusDevices-1]:=nil;
   end else begin
    fBusDevices[Index]:=nil;
   end;
   dec(fCountBusDevices);
   break;
  end;
 end;
end;

function TPasRISCV.TBus.FindBusDevice(const aAddress:TPasRISCVUInt64):TBusDevice;
var Index:TPasRISCVSizeInt;
begin
 for Index:=0 to fCountBusDevices-1 do begin
  result:=fBusDevices[Index];
  if assigned(result) and (aAddress>=result.fBase) and ((aAddress-result.fBase)<result.fSize) then begin
   if result.fCountSubBusDevices>0 then begin
    result:=result.FindSubBusDevice(aAddress);
   end;
   exit;
  end;
 end;
 result:=nil;
end;

function TPasRISCV.TBus.GetDirectMemoryAccessPointer(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aWrite:Boolean;const aBounce:Pointer):Pointer;
var BusDevice:TBusDevice;
begin
 result:=fMachine.fMemoryDevice.GetDeviceDirectMemoryAccessPointer(aAddress,aSize,aWrite,aBounce);
 if not assigned(result) then begin
  BusDevice:=FindBusDevice(aAddress);
  if assigned(BusDevice) then begin
   result:=BusDevice.GetDeviceDirectMemoryAccessPointer(aAddress,aSize,aWrite,aBounce);
  end else begin
   result:=nil;
  end;
 end;
end;

function TPasRISCV.TBus.Fetch(const aHART:THART;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var BusDevice:TBusDevice;
begin
 BusDevice:=FindBusDevice(aAddress);
 if assigned(BusDevice) then begin
  result:=BusDevice.Load(aAddress,aSize);
 end else begin
  if {((aAddress and THART.TMMU.PHYSICAL_INVERSE_MASK)=0) and} assigned(aHART) then begin
   aHART.SetException(THART.TExceptionValue.InstructionAccessFault,aAddress,aHART.fState.PC);
  end;
  result:=0;
 end;
end;

function TPasRISCV.TBus.LoadUnaligned(const aBusDevice:TBusDevice;const aAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
var Temp,Dest:array[0..15] of TPasRISCVUInt8;
    Align,OffsetAlign,OffsetDiff,OffsetDest,SizeDest,Value,Size:TPasRISCVUInt64;
begin

//writeln(aBusDevice.ClassName);

 if aSize<aBusDevice.fMinOpSize then begin
  Align:=aBusDevice.fMinOpSize;
 end else if aSize>aBusDevice.fMaxOpSize then begin
  Align:=aBusDevice.fMaxOpSize;
 end else begin
  Align:=aSize;
 end;

 if Align>SizeOf(Temp) then begin
  aValue:=0;
  result:=false;
  exit;
 end;

 FillChar(Temp[0],SizeOf(Temp),#0);
 FillChar(Dest[0],SizeOf(Dest),#0);

 OffsetAlign:=aAddress and not TPasRISCVUInt64(Align-1);
 OffsetDiff:=aAddress-OffsetAlign;
 OffsetDest:=0;
 SizeDest:=0;

 Size:=aSize;
 while Size>0 do begin

  // Calculate amount of bytes to read
  if (Align-OffsetDiff)>Size then begin
   SizeDest:=Size;
  end else begin
   SizeDest:=Align-OffsetDiff;
  end;

  // Read the aligned bytes
  Value:=aBusDevice.Load(OffsetAlign,Align);
  case Align of
   1:begin
    TPasRISCVUInt8(Pointer(@Temp[0])^):=Value;
   end;
   2:begin
    TPasRISCVUInt16(Pointer(@Temp[0])^):=Value;
   end;
   3:begin
    TPasRISCVUInt16(Pointer(@Temp[0])^):=Value and $ffff;
    TPasRISCVUInt8(Pointer(@Temp[2])^):=(Value shr 16) and $ff;
   end;
   4:begin
    TPasRISCVUInt32(Pointer(@Temp[0])^):=Value;
   end;
   5:begin
    TPasRISCVUInt32(Pointer(@Temp[0])^):=Value and $ffffffff;
    TPasRISCVUInt8(Pointer(@Temp[4])^):=(Value shr 32) and $ff;
   end;
   6:begin
    TPasRISCVUInt32(Pointer(@Temp[OffsetDest])^):=Value and $ffff;
    TPasRISCVUInt16(Pointer(@Temp[OffsetDest+4])^):=(Value shr 32) and $ffff;
   end;
   7:begin
    TPasRISCVUInt32(Pointer(@Temp[OffsetDest])^):=Value and $ffff;
    TPasRISCVUInt16(Pointer(@Temp[OffsetDest+4])^):=(Value shr 32) and $ffff;
    TPasRISCVUInt8(Pointer(@Temp[OffsetDest+6])^):=(Value shr 48) and $ff;
   end;
   8:begin
    TPasRISCVUInt64(Pointer(@Temp[OffsetDest])^):=Value;
   end;
   else begin
    aValue:=0;
    result:=false;
    exit;
   end;
  end;

  // Copy the read bytes to the aligned destination offset
  Move(Temp[OffsetDiff],Dest[OffsetDest],SizeDest);

  // Advance the pointers
  inc(OffsetDest,SizeDest);
  inc(OffsetAlign,Align);
  dec(Size,SizeDest);

  // Reset the unaligned offset
  OffsetDiff:=0;

 end;

 // Return the aligned value
 case aSize of
  1:begin
   aValue:=TPasRISCVUInt8(Pointer(@Dest[0])^);
  end;
  2:begin
   aValue:=TPasRISCVUInt16(Pointer(@Dest[0])^);
  end;
  4:begin
   aValue:=TPasRISCVUInt32(Pointer(@Dest[0])^);
  end;
  8:begin
   aValue:=TPasRISCVUInt64(Pointer(@Dest[0])^);
  end;
  else begin
   aValue:=0;
   result:=false;
   exit;
  end;
 end;

 result:=true;

end;

function TPasRISCV.TBus.StoreUnaligned(const aBusDevice:TBusDevice;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
var Temp,Dest:array[0..15] of TPasRISCVUInt8;
    Align,OffsetAlign,OffsetDiff,OffsetDest,SizeDest,Value,Size:TPasRISCVUInt64;
begin

//writeln(aBusDevice.ClassName);

 if aSize<aBusDevice.fMinOpSize then begin
  Align:=aBusDevice.fMinOpSize;
 end else if aSize>aBusDevice.fMaxOpSize then begin
  Align:=aBusDevice.fMaxOpSize;
 end else begin
  Align:=aSize;
 end;

 if Align>SizeOf(Temp) then begin
  result:=false;
  exit;
 end;

 FillChar(Temp[0],SizeOf(Temp),#0);
 FillChar(Dest[0],SizeOf(Dest),#0);

 case aSize of
  1:begin
   TPasRISCVUInt8(Pointer(@Dest[0])^):=aValue;
  end;
  2:begin
   TPasRISCVUInt16(Pointer(@Dest[0])^):=aValue;
  end;
  4:begin
   TPasRISCVUInt32(Pointer(@Dest[0])^):=aValue;
  end;
  8:begin
   TPasRISCVUInt64(Pointer(@Dest[0])^):=aValue;
  end;
  else begin
   result:=false;
   exit;
  end;
 end;

 OffsetAlign:=aAddress and not TPasRISCVUInt64(Align-1);
 OffsetDiff:=aAddress-OffsetAlign;
 OffsetDest:=0;
 SizeDest:=0;

 Size:=aSize;
 while Size>0 do begin

   // Calculate amount of bytes to read
  if (Align-OffsetDiff)>Size then begin
   SizeDest:=Size;
  end else begin
   SizeDest:=Align-OffsetDiff;
  end;

  // Load the aligned value for RMW operation, if needed
  if (OffsetDiff<>0) or (SizeDest<>Align) then begin
   Value:=aBusDevice.Load(OffsetAlign,Align);
   case Align of
    1:begin
     TPasRISCVUInt8(Pointer(@Temp[0])^):=Value;
    end;
    2:begin
     TPasRISCVUInt16(Pointer(@Temp[0])^):=Value;
    end;
    3:begin
     TPasRISCVUInt16(Pointer(@Temp[0])^):=Value and $ffff;
     TPasRISCVUInt8(Pointer(@Temp[2])^):=(Value shr 16) and $ff;
    end;
    4:begin
     TPasRISCVUInt32(Pointer(@Temp[0])^):=Value;
    end;
    5:begin
     TPasRISCVUInt32(Pointer(@Temp[0])^):=Value and $ffffffff;
     TPasRISCVUInt8(Pointer(@Temp[4])^):=(Value shr 32) and $ff;
    end;
    6:begin
     TPasRISCVUInt32(Pointer(@Temp[0])^):=Value and $ffff;
     TPasRISCVUInt16(Pointer(@Temp[4])^):=(Value shr 32) and $ffff;
    end;
    7:begin
     TPasRISCVUInt32(Pointer(@Temp[0])^):=Value and $ffff;
     TPasRISCVUInt16(Pointer(@Temp[4])^):=(Value shr 32) and $ffff;
     TPasRISCVUInt8(Pointer(@Temp[6])^):=(Value shr 48) and $ff;
    end;
    8:begin
     TPasRISCVUInt64(Pointer(@Temp[0])^):=Value;
    end;
    else begin
     result:=false;
     exit;
    end;
   end;
  end;

  // Carry the changed bytes from the RMW operation
  Move(Dest[OffsetDest],Temp[OffsetDiff],SizeDest);

  // Get the aligned value for aligned store
  case Align of
   1:begin
    Value:=TPasRISCVUInt8(Pointer(@Temp[0])^);
   end;
   2:begin
    Value:=TPasRISCVUInt16(Pointer(@Temp[0])^);
   end;
   4:begin
    Value:=TPasRISCVUInt32(Pointer(@Temp[0])^);
   end;
   8:begin
    Value:=TPasRISCVUInt64(Pointer(@Temp[0])^);
   end;
   else begin
    result:=false;
    exit;
   end;
  end;

  // Write the aligned value back
  aBusDevice.Store(OffsetAlign,Value,Align);

  // Advance the pointers
  inc(OffsetDest,SizeDest);
  inc(OffsetAlign,Align);
  dec(Size,SizeDest);

  // Reset the unaligned offset
  OffsetDiff:=0;

 end;

 result:=true;

end;

function TPasRISCV.TBus.Load(const aHART:THART;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var BusDevice:TBusDevice;
begin
 BusDevice:=FindBusDevice(aAddress);
 if assigned(BusDevice) then begin
  if (aSize>=BusDevice.fMinOpSize) and (aSize<=BusDevice.fMaxOpSize) and (BusDevice.fUnalignedAccessSupport or ((aAddress and (aSize-1))=0)) then begin
   result:=BusDevice.Load(aAddress,aSize);
  end else begin
   if not LoadUnaligned(BusDevice,aAddress,result,aSize) then begin
    if assigned(aHART) then begin
     aHART.SetException(THART.TExceptionValue.LoadAccessFault,aAddress,aHART.fState.PC);
    end;
   end;
  end;
 end else begin
  if {((aAddress and THART.TMMU.PHYSICAL_INVERSE_MASK)=0) and} assigned(aHART) then begin
   aHART.SetException(THART.TExceptionValue.LoadAccessFault,aAddress,aHART.fState.PC);
  end;
  result:=0;
 end;
end;

procedure TPasRISCV.TBus.Store(const aHART:THART;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var BusDevice:TBusDevice;
begin
 BusDevice:=FindBusDevice(aAddress);
 if assigned(BusDevice) then begin
  if (aSize>=BusDevice.fMinOpSize) and (aSize<=BusDevice.fMaxOpSize) and (BusDevice.fUnalignedAccessSupport or ((aAddress and (aSize-1))=0)) then begin
   BusDevice.Store(aAddress,aValue,aSize);
  end else begin
   if not StoreUnaligned(BusDevice,aAddress,aValue,aSize) then begin
    if assigned(aHART) then begin
     aHART.SetException(THART.TExceptionValue.StoreAccessFault,aAddress,aHART.fState.PC);
    end;
   end;
  end;
 end else begin
  if {((aAddress and THART.TMMU.PHYSICAL_INVERSE_MASK)=0) and} assigned(aHART) then begin
   aHART.SetException(THART.TExceptionValue.StoreAccessFault,aAddress,aHART.fState.PC);
  end;
 end;
end;

function TPasRISCV.TBus.LoadEx(const aAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
var BusDevice:TBusDevice;
begin
 BusDevice:=FindBusDevice(aAddress);
 if assigned(BusDevice) then begin
  if (aSize>=BusDevice.fMinOpSize) and (aSize<=BusDevice.fMaxOpSize) and (BusDevice.fUnalignedAccessSupport or ((aAddress and (aSize-1))=0)) then begin
   aValue:=BusDevice.Load(aAddress,aSize);
   result:=true;
  end else begin
   result:=LoadUnaligned(BusDevice,aAddress,aValue,aSize);
  end;
 end else begin
  aValue:=0;
  result:=false;
 end;
end;

function TPasRISCV.TBus.StoreEx(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
var BusDevice:TBusDevice;
begin
 BusDevice:=FindBusDevice(aAddress);
 if assigned(BusDevice) then begin
  if (aSize>=BusDevice.fMinOpSize) and (aSize<=BusDevice.fMaxOpSize) and (BusDevice.fUnalignedAccessSupport or ((aAddress and (aSize-1))=0)) then begin
   BusDevice.Store(aAddress,aValue,aSize);
   result:=true;
  end else begin
   result:=StoreUnaligned(BusDevice,aAddress,aValue,aSize);
  end;
 end else begin
  result:=false;
 end;
end;

procedure TPasRISCV.TBus.Step;
begin
end;

{ TPasRISCV.THART.TException }

constructor TPasRISCV.THART.TException.Create(const aExceptionValue:TExceptionValue;const aExceptionData,aExceptionPC:TPasRISCVUInt64);
begin
 fExceptionValue:=aExceptionValue;
 fExceptionData:=aExceptionData;
 fExceptionPC:=aExceptionPC;
 inherited Create(TPasRISCV.THART.ExceptionNames[aExceptionValue]+' at '+IntToStr(aExceptionPC)+' with data '+IntToStr(aExceptionData));
end;

destructor TPasRISCV.THART.TException.Destroy;
begin
 inherited Destroy;
end;

{ TPasRISCV.THART.TCSR }

procedure TPasRISCV.THART.TCSR.Init(const aHART:THART);
begin

 fHART:=aHART;

 FillChar(fData,SizeOf(fData),#0);

 fData[TAddress.MISA]:=TMISA.TExtension.XLEN_64 or
                       TMISA.TExtension.A_EXT or
                       TMISA.TExtension.C_EXT or
                       TMISA.TExtension.F_EXT or
                       TMISA.TExtension.D_EXT or
                       TMISA.TExtension.RV32I_64I_128I or
                       TMISA.TExtension.M_EXT or
                       TMISA.TExtension.SUPERVISOR or
                       TMISA.TExtension.HYPERVISOR or // Sha: H-extension enabled
                       TMISA.TExtension.USER;

 fData[TAddress.MHARTID]:=fHART.fHARTID;

 fData[TAddress.MARCHID]:=(TPasRISCVUInt32(Ord('P')) shl 0) or
                          (TPasRISCVUInt32(Ord('A')) shl 8) or
                          (TPasRISCVUInt32(Ord('S')) shl 16) or
                          (TPasRISCVUInt32(Ord('R')) shl 24);

 fData[TAddress.MIMPID]:=0;

 fData[TAddress.MVENDORID]:=0;

 fData[TAddress.MSTATUS]:=TPasRISCVUInt64($200000000);

 fData[TAddress.MENVCFG]:=TPasRISCVUInt64($e0000000000000d0); // $e
 fData[TAddress.MENVCFGH]:=fData[TAddress.MENVCFG] shr 32;

 fData[TAddress.SENVCFG]:=TPasRISCVUInt64($00000000000000d0);

 fData[TAddress.HENVCFG]:=TPasRISCVUInt64($e0000003000000d0); // All features enabled by default
 fData[TAddress.HENVCFGH]:=fData[TAddress.HENVCFG] shr 32;

 // H-extension: HSTATUS initial value with VSXL=2 (64-bit)
 fData[TAddress.HSTATUS]:=TPasRISCVUInt64(2) shl 32; // VSXL=2

 fData[TAddress.STIMECMP]:=TPasRISCVUInt64($ffffffffffffffff);

end;

function TPasRISCV.THART.TCSR.Load(const aAddress:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 case aAddress of
  TAddress.SEED:begin // Seed (Zkr)
   // A fast per-HART PCG32 random generator, initialized with a ChaCha20-based random source.
   // The generator draws initial entropy from an arc4random-like mechanism, which relies on
   // ChaCha20 instead of RC4. If a more robust and direct entropy source is needed, the guest
   // system should use virtio-rng. Note, however, that virtio-rng may block when its entropy
   // pool is exhausted, causing delays as the pool is rekeyed.
   result:=(fHART.fPCG32.Get32 shr 16) and TPasRISCVUInt64($ffff); // limited to 16 physical entropy bits
  end;
  TAddress.SSTATUS:begin
   result:=fData[TAddress.MSTATUS] and TMask.SSTATUS;
  end;
  TAddress.MSTATUS:begin
   result:=fData[TAddress.MSTATUS];
  end;
  TAddress.TIME:begin
   result:=fHART.fMachine.fACLINTDevice.GetTime;
  end;
  TAddress.TIMEH:begin
   result:=fHART.fMachine.fACLINTDevice.GetTime shr 32;
  end;
  TAddress.MCYCLE:begin
   result:=fHART.fState.Cycle;
  end;
  TAddress.MCYCLEH:begin
   result:=fHART.fState.Cycle shr 32;
  end;
  TAddress.CYCLE:begin
   result:=fHART.fState.Cycle;
  end;
  TAddress.CYCLEH:begin
   result:=fHART.fState.Cycle shr 32;
  end;
  TAddress.MINSTRET:begin
   result:=fHART.fState.Cycle;
  end;
  TAddress.MINSTRETH:begin
   result:=fHART.fState.Cycle shr 32;
  end;
  TAddress.INSTRET:begin
   result:=fHART.fState.Cycle;
  end;
  TAddress.INSTRETH:begin
   result:=fHART.fState.Cycle shr 32;
  end;
  TAddress.MENVCFG:begin
   result:=TPasRISCVUInt64(TPasRISCVUInt64(fData[TAddress.MENVCFG] and TPasRISCVUInt64($e0000003000000d0)));
  end;
{ TAddress.MENVCFGH:begin
   result:=TPasRISCVUInt32(TPasRISCVUInt64(fData[TAddress.MENVCFG] and TPasRISCVUInt64($80000000000000d0)) shr 32);
  end;}
  TAddress.SENVCFG:begin
   result:=TPasRISCVUInt64(TPasRISCVUInt64(fData[TAddress.SENVCFG] and TPasRISCVUInt64($00000003000000d0)));
  end;
  TAddress.STIMECMP:begin
   result:=fHART.fSTIMECMP;
  end;
  TAddress.VSTIMECMP:begin
   result:=fHART.fVSTIMECMP;
  end;
{TAddress.STIMECMPH:begin
   result:=TPasRISCVUInt32(TPasRISCVUInt64(fData[TAddress.STIMECMP] shr 32));
  end}
  else begin
   result:=fData[aAddress];
  end;
 end;
end;

procedure TPasRISCV.THART.TCSR.Store(const aAddress,aValue:TPasRISCVUInt64);
var Value,Mask:TPasRISCVUInt64;
begin
 case aAddress of
  TAddress.SSTATUS:begin
   Value:=(fData[TAddress.MSTATUS] and not TPasRISCVUInt64(TMask.SSTATUS)) or (aValue and TPasRISCVUInt64(TMask.SSTATUS));
   fData[TAddress.MSTATUS]:=Value;
  end;
  TAddress.MENVCFG:begin
   fData[TAddress.MENVCFG]:=aValue and TPasRISCVUInt64($e0000003000000d0);
  end;
{ TAddress.MENVCFG:begin
   fData[TAddress.MENVCFG]:=((fData[TAddress.MENVCFG] and TPasRISCVUInt64($ffffffff00000000)) or
                             (TPasRISCVUInt64(aValue) and TPasRISCVUInt64($00000000ffffffff))) and TPasRISCVUInt64($80000000000000d0);
  end;
  TAddress.MENVCFGH:begin
   fData[TAddress.MENVCFG]:=((fData[TAddress.MENVCFG] and TPasRISCVUInt64($00000000ffffffff)) or
                              ((TPasRISCVUInt64(aValue) shl 32) and TPasRISCVUInt64($ffffffff00000000))) and TPasRISCVUInt64($80000000000000d0);
   fData[TAddress.MENVCFGH]:=fData[TAddress.MENVCFG] shr 32;
  end;}
  TAddress.SENVCFG:begin
   fData[TAddress.SENVCFG]:=aValue and TPasRISCVUInt64($00000003000000d0);
  end;
  TAddress.STIMECMP:begin
   fHART.fSTIMECMP:=aValue;
   fData[TAddress.STIMECMP]:=aValue;
  end;
  TAddress.VSTIMECMP:begin
   fHART.fVSTIMECMP:=aValue;
   fData[TAddress.VSTIMECMP]:=aValue;
  end;
  TAddress.HVICTL:begin
   fData[TAddress.HVICTL]:=aValue and HVICTL_VALID_MASK;
  end;
  TAddress.HEDELEG:begin
   fData[TAddress.HEDELEG]:=aValue and CSR_HEDELEG_MASK;
  end;
  TAddress.HIDELEG:begin
   fData[TAddress.HIDELEG]:=aValue and CSR_HIDELEG_MASK;
  end;
  TAddress.MEDELEG:begin
   fData[TAddress.MEDELEG]:=aValue and CSR_MEDELEG_MASK;
  end;
  TAddress.MIDELEG:begin
   fData[TAddress.MIDELEG]:=aValue and CSR_MIDELEG_MASK;
  end;
{ TAddress.STIMECMPH:begin
   fData[TAddress.STIMECMP]:=((TPasRISCVUInt64(aValue) shl 32) and TPasRISCVUInt64($ffffffff00000000)) or
                             (fData[TAddress.STIMECMP] and TPasRISCVUInt64($00000000ffffffff));
  end;}
  else begin
   fData[aAddress]:=aValue;
  end;
 end;
end;

procedure TPasRISCV.THART.TCSR.SetFPUException(const aValue:TPasRISCVUInt64);
begin
 fData[TAddress.FFLAGS]:=(fData[TAddress.FFLAGS] and not TFPUExceptionMasks.Mask) or (aValue and TPasRISCVUInt64(TFPUExceptionMasks.Mask));
end;

procedure TPasRISCV.THART.TCSR.ClearFPUExceptions;
begin
 fData[TAddress.FFLAGS]:=fData[TAddress.FFLAGS] and not TPasRISCVUInt64(TFPUExceptionMasks.Mask);
end;

procedure TPasRISCV.THART.TCSR.SetFPURM(const aValue:TPasRISCVUInt64);
begin
 fData[TAddress.FRM]:=(fData[TAddress.FRM] and not TPasRISCVUInt64(TFloatingPointRoundingModes.Mask)) or (aValue and TPasRISCVUInt64(TFloatingPointRoundingModes.Mask));
 case TFloatingPointRoundingModes(aValue and TPasRISCVUInt64(TFloatingPointRoundingModes.Mask)) of
  TFloatingPointRoundingModes.RoundToNearestEven:begin
{$ifdef fpc}
   SetRoundMode(TFPURoundingMode.rmNearest);
{$else}
   SetRoundMode(rmNearest);
{$endif}
  end;
  TFloatingPointRoundingModes.RoundToZero:begin
{$ifdef fpc}
   SetRoundMode(TFPURoundingMode.rmTruncate);
{$else}
   SetRoundMode(rmTruncate);
{$endif}
  end;
  TFloatingPointRoundingModes.RoundDown:begin
{$ifdef fpc}
   SetRoundMode(TFPURoundingMode.rmDown);
{$else}
   SetRoundMode(rmDown);
{$endif}
  end;
  TFloatingPointRoundingModes.RoundUp:begin
{$ifdef fpc}
   SetRoundMode(TFPURoundingMode.rmUp);
{$else}
   SetRoundMode(rmUp);
{$endif}
  end;
  TFloatingPointRoundingModes.RoundNearestMaxMagnitude:begin
{$ifdef fpc}
   SetRoundMode(TFPURoundingMode.rmNearest);
{$else}
   SetRoundMode(rmNearest);
{$endif}
  end;
  TFloatingPointRoundingModes.RoundDynamic:begin
{$ifdef fpc}
   SetRoundMode(TFPURoundingMode.rmNearest);
{$else}
   SetRoundMode(rmNearest);
{$endif}
  end;
  else {TFloatingPointRoundingModes.RoundToNearest:}begin
  end;
 end;
end;

procedure TPasRISCV.THART.TCSR.ClearFPURM;
begin
 fData[TAddress.FRM]:=fData[TAddress.FRM] and not TPasRISCVUInt64(TFloatingPointRoundingModes.Mask);
end;

procedure TPasRISCV.THART.TCSR.SetFS(const aValue:TPasRISCVUInt64);
begin
 fData[TAddress.MSTATUS]:=(fData[TAddress.MSTATUS] and not (TPasRISCVUInt64(3) shl 13)) or (TPasRISCVUInt64(TPasRISCVUInt64(aValue) and 3) shl 13);
end;

function TPasRISCV.THART.TCSR.GetFS:TPasRISCVUInt64;
begin
 result:=(fData[TAddress.MSTATUS] shr 13) and 3;
end;

procedure TPasRISCV.THART.TCSR.ClearFS;
begin
 fData[TAddress.MSTATUS]:=fData[TAddress.MSTATUS] and not (TPasRISCVUInt64(3) shl 13);
end;

procedure TPasRISCV.THART.TCSR.SetFSDirty;
begin
 if ((fData[TCSR.TAddress.MSTATUS] shr 13) and 3)<>TCSR.TFS.Dirty then begin
  fData[TCSR.TAddress.MSTATUS]:=fData[TCSR.TAddress.MSTATUS] or (TCSR.TFS.Dirty shl 13);
 end;
end;

function TPasRISCV.THART.TCSR.IsFPUEnabled:Boolean;
begin
 result:=((fData[TAddress.MSTATUS] shr 13) and 3)<>TFS.Off;
end;

{ TPasRISCV.THART.TAIARegFile }

constructor TPasRISCV.THART.TAIARegFile.Create(const aMachine:TPasRISCV;const aHART:THART);
begin
 inherited Create;
 fMachine:=aMachine;
 fHART:=aHART;
 Reset;
end;

destructor TPasRISCV.THART.TAIARegFile.Destroy;
begin
 inherited Destroy;
end;

procedure TPasRISCV.THART.TAIARegFile.Reset;
begin
 fEIDelivery:=0;
 fEIThreshold:=0;
 FillChar(fEIP,ARRAY_LENGTH*SizeOf(TPasRISCVUInt32),#0);
 FillChar(fEIE,ARRAY_LENGTH*SizeOf(TPasRISCVUInt32),#0);
end;

{ TPasRISCV.THART.TExecutionThread }

constructor TPasRISCV.THART.TExecutionThread.Create(const aHART:THART);
begin
 fHART:=aHART;
 fHART.fExecutionThread:=self;
 inherited Create(false);
end;

destructor TPasRISCV.THART.TExecutionThread.Destroy;
begin
 if assigned(fHART) then begin
  fHART.fExecutionThread:=nil;
 end;
 inherited Destroy;
end;

procedure TPasRISCV.THART.TExecutionThread.Execute;
begin
 if assigned(fHART) then begin
  NameThreadForDebugging('THART['+IntToStr(fHART.fHARTID)+'].TExecutionThread');
  fHART.ThreadProc;
 end else begin
  NameThreadForDebugging('THART.TExecutionThread');
 end;
end;

procedure TPasRISCV.THART.TExecutionThread.Shutdown;
begin
 if not Finished then begin
  Terminate;
  WaitFor;
 end;
end;

{ TPasRISCV.THART }

constructor TPasRISCV.THART.Create(const aMachine:TPasRISCV;const aHARTID:TPasRISCVUInt32);
var CSRIndex:TPasRISCVSizeInt;
    AIARegFileMode:TAIARegFileMode;
begin
 inherited Create;

 fMachine:=aMachine;

 fPHandle:=fMachine.AllocatePHandle;

 fHARTID:=aHARTID;

 fHARTMask:=TPasRISCVUInt32(1) shl fHARTID;

 fMachine.fAllHARTMask:=fMachine.fAllHARTMask or fHARTMask;

 fPointerToState:=@fState;

 if fMachine.fConfiguration.fAIA then begin
  for AIARegFileMode:=Low(TAIARegFileMode) to High(TAIARegFileMode) do begin
   fAIARegFiles[AIARegFileMode]:=TAIARegFile.Create(self.fMachine,self);
  end;
 end else begin
  for AIARegFileMode:=Low(TAIARegFileMode) to High(TAIARegFileMode) do begin
   fAIARegFiles[AIARegFileMode]:=nil;
  end;
 end;

 fACLINTDevice:=fMachine.fACLINTDevice;

 fMTIMECMP:=TPasRISCVUInt64($ffffffffffffffff);

 fSTIMECMP:=TPasRISCVUInt64($ffffffffffffffff);

 fVSTIMECMP:=TPasRISCVUInt64($ffffffffffffffff);

 fBus:=fMachine.fBus;

 fMMUMode:=TMMU.TMMUMode.SV39;
 fRootPageTable:=0;
 FlushTLB(false);

 for CSRIndex:=Low(TCSRHandlerMap) to High(TCSRHandlerMap) do begin

  case CSRIndex of

   TCSR.TAddress.FFLAGS,
   TCSR.TAddress.FRM,
   TCSR.TAddress.FCSR,

   TCSR.TAddress.SEED,

   TCSR.TAddress.CYCLE,
// TCSR.TAddress.CYCLEH,
   TCSR.TAddress.TIME,
// TCSR.TAddress.TIMEH,
   TCSR.TAddress.INSTRET,
// TCSR.TAddress.INSTRETH,

   TCSR.TAddress.SSTATUS,
   TCSR.TAddress.SEDELEG,
   TCSR.TAddress.SIDELEG,
// TCSR.TAddress.SIE,
   TCSR.TAddress.STVEC,
   TCSR.TAddress.SCOUNTEREN,

   TCSR.TAddress.SENVCFG,

   TCSR.TAddress.SCOUNTOVF, // Sscofpmf

   TCSR.TAddress.SSCRATCH,
   TCSR.TAddress.SEPC,
   TCSR.TAddress.SCAUSE,
   TCSR.TAddress.STVAL,
// TCSR.TAddress.SIP,
// TCSR.TAddress.STIMECMP,
// TCSR.TAddress.STIMECMPH,

   TCSR.TAddress.SATP,

   // H-extension CSRs
   TCSR.TAddress.HSTATUS,
   TCSR.TAddress.HEDELEG,
   TCSR.TAddress.HIDELEG,
   TCSR.TAddress.HIE,
   TCSR.TAddress.HTIMEDELTA,
   TCSR.TAddress.HCOUNTEREN,
   TCSR.TAddress.HGEIE,
   TCSR.TAddress.HVICTL,
   TCSR.TAddress.HENVCFG,
   TCSR.TAddress.HTVAL,
   TCSR.TAddress.HIP,
   TCSR.TAddress.HVIP,
   TCSR.TAddress.HTINST,
   TCSR.TAddress.HGATP,
   TCSR.TAddress.HGEIP,
   // VS-mode CSRs
   TCSR.TAddress.VSSTATUS,
   TCSR.TAddress.VSIE,
   TCSR.TAddress.VSTVEC,
   TCSR.TAddress.VSSCRATCH,
   TCSR.TAddress.VSEPC,
   TCSR.TAddress.VSCAUSE,
   TCSR.TAddress.VSTVAL,
   TCSR.TAddress.VSIP,
   TCSR.TAddress.VSTIMECMP,
   TCSR.TAddress.VSATP,
   // Ssstateen CSRs
   TCSR.TAddress.MSTATEEN0,
   TCSR.TAddress.MSTATEEN1,
   TCSR.TAddress.MSTATEEN2,
   TCSR.TAddress.MSTATEEN3,
   TCSR.TAddress.SSTATEEN0,
   TCSR.TAddress.SSTATEEN1,
   TCSR.TAddress.SSTATEEN2,
   TCSR.TAddress.SSTATEEN3,
   TCSR.TAddress.HSTATEEN0,
   TCSR.TAddress.HSTATEEN1,
   TCSR.TAddress.HSTATEEN2,
   TCSR.TAddress.HSTATEEN3,

   TCSR.TAddress.MVENDORID,
   TCSR.TAddress.MARCHID,
   TCSR.TAddress.MIMPID,
   TCSR.TAddress.MHARTID,
   TCSR.TAddress.MCONFIGPTR,

   TCSR.TAddress.MSTATUS,
// TCSR.TAddress.MSTATUSH,
   TCSR.TAddress.MISA,
   TCSR.TAddress.MEDELEG,
// TCSR.TAddress.MEDELEGH,
   TCSR.TAddress.MIDELEG,
// TCSR.TAddress.MIE,
   TCSR.TAddress.MTVEC,
   TCSR.TAddress.MCOUNTEREN,

   TCSR.TAddress.MSCRATCH,
   TCSR.TAddress.MEPC,
   TCSR.TAddress.MCAUSE,
   TCSR.TAddress.MTVAL,
   TCSR.TAddress.MTINST, // H-extension
   TCSR.TAddress.MTVAL2, // H-extension
// TCSR.TAddress.MIP,

   TCSR.TAddress.MCYCLE,
// TCSR.TAddress.MCYCLEH,
   TCSR.TAddress.MINSTRET,
// TCSR.TAddress.MINSTRETH,

   TCSR.TAddress.MNSCRATCH,
   TCSR.TAddress.MNEPC,
   TCSR.TAddress.MNCAUSE,
   TCSR.TAddress.MNSTATUS,

   TCSR.TAddress.MENVCFG,
// TCSR.TAddress.MENVCFGH,
   TCSR.TAddress.MSECCFG,
// TCSR.TAddress.MSECCFGH,

   TCSR.TAddress.TSELECT,
   TCSR.TAddress.TDATA1,
   TCSR.TAddress.TDATA2,
   TCSR.TAddress.TINFO,
   TCSR.TAddress.DCSR,
   TCSR.TAddress.DPC,
   TCSR.TAddress.DSCRATCH0,
   TCSR.TAddress.DSCRATCH2,

   $3a0..$3a3, // pmpcfg0 .. pmpcfg3
   $3b0..$3bf, // pmpaddr0 .. pmpaddr15

   $321..$33f, // mhpmevent1 - mhpmevent31
   $b03..$b1f, // mhpmcounter3..mhpmcounter31
   $b83..$b9f, // mhpmcounter3h..mhpmcounter31h
   $c03..$c1f, // hpmcounter3..hpmcounter31 (U-Mode read-only mirrors, Zihpm)
   $c83..$c9f, // hpmcounter3h..hpmcounter31h (U-Mode read-only mirrors, Zihpm)

   TCSR.TAddress.MCOUNTINHIBIT:begin

    if ((CSRIndex shr 8) and 3)<>0 then begin
     if ((CSRIndex shr 10) and 3)=3 then begin
      fCSRHandlerMap[CSRIndex]:=CSRHandlerPrivilegedReadOnly;
     end else begin
      fCSRHandlerMap[CSRIndex]:=CSRHandlerPrivileged;
     end;
    end else begin
     if ((CSRIndex shr 10) and 3)=3 then begin
      fCSRHandlerMap[CSRIndex]:=CSRHandlerDefaultReadOnly;
     end else begin
      fCSRHandlerMap[CSRIndex]:=CSRHandlerDefault;
     end;
    end;
   end
   else begin
    fCSRHandlerMap[CSRIndex]:=CSRHandlerIllegal;
   end;
  end;

  //fCSRHandlerMap[CSRIndex]:=CSRHandlerDefault;

 end;

 fCSRHandlerMap[TCSR.TAddress.FFLAGS]:=CSRHandlerFFLAGS; /// FFLAGS
 fCSRHandlerMap[TCSR.TAddress.FRM]:=CSRHandlerFRM; // FRM
 fCSRHandlerMap[TCSR.TAddress.FCSR]:=CSRHandlerFCSR; // FCSR

 fCSRHandlerMap[TCSR.TAddress.STIMECMP]:=CSRHandlerSTIMECMP; // STIMECMP
 fCSRHandlerMap[TCSR.TAddress.VSTIMECMP]:=CSRHandlerVSTIMECMP; // VSTIMECMP

 fCSRHandlerMap[TCSR.TAddress.SATP]:=CSRHandlerSATP; // SATP

 fCSRHandlerMap[TCSR.TAddress.SSTATUS]:=CSRHandlerSTATUS; // SSTATUS
 fCSRHandlerMap[TCSR.TAddress.MSTATUS]:=CSRHandlerSTATUS; // MSTATUS
 fCSRHandlerMap[TCSR.TAddress.MISA]:=CSRHandlerDefaultReadOnly; // MISA
 fCSRHandlerMap[TCSR.TAddress.TDATA1]:=CSRHandlerDefaultReadOnly; // TDATA1
 fCSRHandlerMap[TCSR.TAddress.CYCLE]:=CSRHandlerEnforcedReadOnly; // CYCLE
//CSRHandlerMap[TCSR.TAddress.CYCLEH]:=CSRHandlerEnforcedReadOnly; // CYCLE
 fCSRHandlerMap[TCSR.TAddress.MVENDORID]:=CSRHandlerDefaultReadOnly; // MVENDORID
 fCSRHandlerMap[TCSR.TAddress.MARCHID]:=CSRHandlerDefaultReadOnly; // MARCHID
 fCSRHandlerMap[TCSR.TAddress.MIMPID]:=CSRHandlerDefaultReadOnly; // MIMPID
 fCSRHandlerMap[TCSR.TAddress.MHARTID]:=CSRHandlerDefaultReadOnly; // MHARTID

 fCSRHandlerMap[TCSR.TAddress.MIE]:=CSRHandlerMIE; // MIE
 fCSRHandlerMap[TCSR.TAddress.SIE]:=CSRHandlerSIE; // SIE

 fCSRHandlerMap[TCSR.TAddress.MIP]:=CSRHandlerMIP; // MIP
 fCSRHandlerMap[TCSR.TAddress.SIP]:=CSRHandlerSIP; // SIP

 // H-extension CSR handlers
 fCSRHandlerMap[TCSR.TAddress.HSTATUS]:=CSRHandlerHSTATUS;
 fCSRHandlerMap[TCSR.TAddress.HEDELEG]:=CSRHandlerHPrivileged;
 fCSRHandlerMap[TCSR.TAddress.HIDELEG]:=CSRHandlerHPrivileged;
 fCSRHandlerMap[TCSR.TAddress.HIE]:=CSRHandlerHIE;
 fCSRHandlerMap[TCSR.TAddress.HTIMEDELTA]:=CSRHandlerHPrivileged;
 fCSRHandlerMap[TCSR.TAddress.HCOUNTEREN]:=CSRHandlerHPrivileged;
 fCSRHandlerMap[TCSR.TAddress.HGEIE]:=CSRHandlerHPrivileged;
 fCSRHandlerMap[TCSR.TAddress.HVICTL]:=CSRHandlerHPrivileged;
 fCSRHandlerMap[TCSR.TAddress.HENVCFG]:=CSRHandlerHPrivileged;
 fCSRHandlerMap[TCSR.TAddress.HTVAL]:=CSRHandlerHPrivileged;
 fCSRHandlerMap[TCSR.TAddress.HIP]:=CSRHandlerHIP;
 fCSRHandlerMap[TCSR.TAddress.HVIP]:=CSRHandlerHVIP;
 fCSRHandlerMap[TCSR.TAddress.HTINST]:=CSRHandlerHPrivileged;
 fCSRHandlerMap[TCSR.TAddress.HGATP]:=CSRHandlerHGATP;
 fCSRHandlerMap[TCSR.TAddress.HGEIP]:=CSRHandlerHPrivilegedReadOnly;
 // VS-mode CSR handlers
 fCSRHandlerMap[TCSR.TAddress.VSSTATUS]:=CSRHandlerVSSTATUS;
 fCSRHandlerMap[TCSR.TAddress.VSIE]:=CSRHandlerVSIE;
 fCSRHandlerMap[TCSR.TAddress.VSTVEC]:=CSRHandlerVSCSR;
 fCSRHandlerMap[TCSR.TAddress.VSSCRATCH]:=CSRHandlerVSCSR;
 fCSRHandlerMap[TCSR.TAddress.VSEPC]:=CSRHandlerVSCSR;
 fCSRHandlerMap[TCSR.TAddress.VSCAUSE]:=CSRHandlerVSCSR;
 fCSRHandlerMap[TCSR.TAddress.VSTVAL]:=CSRHandlerVSCSR;
 fCSRHandlerMap[TCSR.TAddress.VSIP]:=CSRHandlerVSIP;
 fCSRHandlerMap[TCSR.TAddress.VSATP]:=CSRHandlerVSCSR;
 // Ssstateen CSR handlers
 fCSRHandlerMap[TCSR.TAddress.MSTATEEN0]:=CSRHandlerPrivileged;
 fCSRHandlerMap[TCSR.TAddress.MSTATEEN1]:=CSRHandlerPrivileged;
 fCSRHandlerMap[TCSR.TAddress.MSTATEEN2]:=CSRHandlerPrivileged;
 fCSRHandlerMap[TCSR.TAddress.MSTATEEN3]:=CSRHandlerPrivileged;
 fCSRHandlerMap[TCSR.TAddress.SSTATEEN0]:=CSRHandlerPrivileged;
 fCSRHandlerMap[TCSR.TAddress.SSTATEEN1]:=CSRHandlerPrivileged;
 fCSRHandlerMap[TCSR.TAddress.SSTATEEN2]:=CSRHandlerPrivileged;
 fCSRHandlerMap[TCSR.TAddress.SSTATEEN3]:=CSRHandlerPrivileged;
 fCSRHandlerMap[TCSR.TAddress.HSTATEEN0]:=CSRHandlerPrivileged;
 fCSRHandlerMap[TCSR.TAddress.HSTATEEN1]:=CSRHandlerPrivileged;
 fCSRHandlerMap[TCSR.TAddress.HSTATEEN2]:=CSRHandlerPrivileged;
 fCSRHandlerMap[TCSR.TAddress.HSTATEEN3]:=CSRHandlerPrivileged;

 if fMachine.fConfiguration.fAIA then begin

  fCSRHandlerMap[TCSR.TAddress.STOPEI]:=CSRHandlerSTOPEI; // MTOPEI
  fCSRHandlerMap[TCSR.TAddress.STOPI]:=CSRHandlerSTOPI; // MTOPI

  fCSRHandlerMap[TCSR.TAddress.MTOPEI]:=CSRHandlerMTOPEI; // MTOPEI
  fCSRHandlerMap[TCSR.TAddress.MTOPI]:=CSRHandlerMTOPI; // MTOPI

  fCSRHandlerMap[TCSR.TAddress.MISELECT]:=CSRHandlerPrivileged; // MISELECT
  fCSRHandlerMap[TCSR.TAddress.SISELECT]:=CSRHandlerPrivileged; // SISELECT

  fCSRHandlerMap[TCSR.TAddress.MIREG]:=CSRHandlerIndirect; // MIREG
  fCSRHandlerMap[TCSR.TAddress.SIREG]:=CSRHandlerIndirect; // SIREG

 end else begin

  fCSRHandlerMap[TCSR.TAddress.STOPEI]:=CSRHandlerIllegal; // STOPEI
  fCSRHandlerMap[TCSR.TAddress.STOPI]:=CSRHandlerIllegal; // STOPI

  fCSRHandlerMap[TCSR.TAddress.MTOPEI]:=CSRHandlerIllegal; // MTOPEI
  fCSRHandlerMap[TCSR.TAddress.MTOPI]:=CSRHandlerIllegal; // MTOPI

  fCSRHandlerMap[TCSR.TAddress.MISELECT]:=CSRHandlerIllegal; // MISELECT
  fCSRHandlerMap[TCSR.TAddress.SISELECT]:=CSRHandlerIllegal; // SISELECT

  fCSRHandlerMap[TCSR.TAddress.MIREG]:=CSRHandlerIllegal; // MIREG
  fCSRHandlerMap[TCSR.TAddress.SIREG]:=CSRHandlerIllegal; // SIREG

 end;

 fExecutionThread:=TExecutionThread.Create(self);

end;

destructor TPasRISCV.THART.Destroy;
var AIARegFileMode:TAIARegFileMode;
begin
 fExecutionThread.Shutdown;
 FreeAndNil(fExecutionThread);
 if fMachine.fConfiguration.fAIA then begin
  for AIARegFileMode:=Low(TAIARegFileMode) to High(TAIARegFileMode) do begin
   FreeAndNil(fAIARegFiles[AIARegFileMode]);
  end;
 end;
 inherited Destroy;
end;

procedure TPasRISCV.THART.Init;
var AIARegFileMode:TAIARegFileMode;
begin

 if fMachine.fConfiguration.fAIA then begin
  for AIARegFileMode:=Low(TAIARegFileMode) to High(TAIARegFileMode) do begin
   fAIARegFiles[AIARegFileMode].Reset;
  end;
 end;

 FillChar(fState,SizeOf(TState),#0);
 fState.CSR.Init(self);
 fState.Mode:=TPasRISCV.THART.TMode.Machine;
 fState.Registers[TRegister.Zero]:=0;
 fState.Registers[TRegister.SP]:=fMachine.fStartStackPointer-(fHARTID shl 16);
 fState.Registers[TRegister.A0]:=fHARTID;
 fState.Registers[TRegister.A1]:=fMachine.fFDTMemoryOffset;
 fState.PC:=$80000000; //-$1000;
 fState.PendingIRQs:=0;
 fState.ExceptionValue:=TExceptionValue.None;
 fState.ExceptionData:=0;
 fState.ExceptionPC:=0;
 fState.LRSC:=false;
 fState.LRSCCycle:=0;
 fState.LRSCAddress:=0;
 fState.LRSCCAS:=0;

 fMTIMECMP:=TPasRISCVUInt64($ffffffffffffffff);

 fSTIMECMP:=TPasRISCVUInt64($ffffffffffffffff);

 fVSTIMECMP:=TPasRISCVUInt64($ffffffffffffffff);

 fMachine.fRandomGeneratorLock.Acquire;
 try
  fPCG32.Init((fMachine.fRandomGenerator.GetUInt64 xor TPasRISCVPtrUInt(self)) xor GetCurrentTime);
 finally
  fMachine.fRandomGeneratorLock.Release;
 end;

end;

procedure TPasRISCV.THART.SetMode(const aMode:TMode);
begin

 // Check if the privilege mode is changing
 if fState.Mode<>aMode then begin

  // Update the current privilege mode
  fState.Mode:=aMode;

  // Flush the Translation Lookaside Buffer (TLB) to ensure memory access consistency after mode change
  FlushTLB(true);

  // Clear LR/SC reservation on privilege mode change (like QEMU's riscv_cpu_set_mode)
  fState.LRSC:=false;

 end;

end;

procedure TPasRISCV.THART.SetException(const aExceptionValue:TExceptionValue;
                                       const aExceptionData:TPasRISCVUInt64;
                                       const aExceptionPC:TPasRISCVUInt64);
begin
 if not (assigned(fMachine.fOnCPUException) and fMachine.fOnCPUException(self,aExceptionValue,aExceptionData,aExceptionPC)) then begin
  fState.ExceptionValue:=aExceptionValue;
  fState.ExceptionData:=aExceptionData;
  fState.ExceptionPC:=aExceptionPC;
  TPasMPInterlocked.BitwiseOr(fMachine.fRunState,fHARTMask);
 end;
end;

procedure TPasRISCV.THART.ClearException;
begin
 fState.ExceptionValue:=TExceptionValue.None;
 fState.ExceptionData:=0;
 fState.ExceptionPC:=0;
end;

procedure TPasRISCV.THART.UpdateMMU;
var SATP:TPasRISCVUInt64;
begin
 SATP:=fState.CSR.Load(THART.TCSR.TAddress.SATP);
 fMMUMode:=TMMU.TMMUMode(SATP shr 60);
 fRootPageTable:=(SATP and ((TPasRISCVUInt64(1) shl 44)-1)) shl 12;
 FlushTLB(true);
end;

procedure TPasRISCV.THART.RaisePhysicalFault(const aAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType);
begin
 case aAccessType of
  TMMU.TAccessType.LoadInstruction,
  TMMU.TAccessType.Load:begin
   SetException(TExceptionValue.LoadAccessFault,aAddress,fState.PC);
  end;
  TMMU.TAccessType.Store:begin
   SetException(TExceptionValue.StoreAccessFault,aAddress,fState.PC);
  end;
  TMMU.TAccessType.Instruction:begin
   SetException(TExceptionValue.InstructionAccessFault,aAddress,fState.PC);
  end;
 end;
end;

procedure TPasRISCV.THART.RaisePageFault(const aAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType);
begin
 case aAccessType of
  TMMU.TAccessType.LoadInstruction,
  TMMU.TAccessType.Load:begin
   SetException(TExceptionValue.LoadPageFault,aAddress,fState.PC);
  end;
  TMMU.TAccessType.Store:begin
   SetException(TExceptionValue.StorePageFault,aAddress,fState.PC);
  end;
  TMMU.TAccessType.Instruction:begin
   SetException(TExceptionValue.InstructionPageFault,aAddress,fState.PC);
  end;
 end;
 FlushTLB(true);
end;

procedure TPasRISCV.THART.RaiseGuestPageFault(const aGuestAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType);
begin
 // Guest page faults: set htval to faulting GPA >> 2
 fState.CSR.fData[TCSR.TAddress.HTVAL]:=aGuestAddress shr 2;
 fState.CSR.fData[TCSR.TAddress.HTINST]:=0;
 case aAccessType of
  TMMU.TAccessType.LoadInstruction,
  TMMU.TAccessType.Load:begin
   SetException(TExceptionValue.LoadGuestPageFault,aGuestAddress,fState.PC);
  end;
  TMMU.TAccessType.Store:begin
   SetException(TExceptionValue.StoreGuestPageFault,aGuestAddress,fState.PC);
  end;
  TMMU.TAccessType.Instruction:begin
   SetException(TExceptionValue.InstructionGuestPageFault,aGuestAddress,fState.PC);
  end;
 end;
 FlushTLB(true);
end;

function TPasRISCV.THART.GStageTranslate(const aGuestPhysical:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType;const aIsImplicit:Boolean):TPasRISCVUInt64;
// G-stage address translation: Guest Physical Address → Host Physical Address using hgatp
// aIsImplicit: true when translating PTE addresses during VS-stage page walk
var HGATP,PageTable,PageTableEntry,BitOffset,PageTableOffset,
    VirtualMask,PhysicalMask,PageTableEntryShift,
    PhysicalAddress,PageTableEntryAccessDirty:TPasRISCVUInt64;
    PageTableEntryPointer:Pointer;
    Levels,Index:TPasRISCVSizeInt;
    GStageMode:TPasRISCVUInt64;
    ADUE{$ifdef GStageQEMUParity},PBMTE{$endif}:Boolean;
begin
 HGATP:=fState.CSR.fData[TCSR.TAddress.HGATP];
 GStageMode:=(HGATP shr 60) and $f;

 // ADUE: hardware A/D bit update for G-stage controlled by menvcfg.ADUE
 // (Spike uses menvcfg directly for G-stage; henvcfg.ADUE gates VS-stage only)
 ADUE:=(fState.CSR.fData[TCSR.TAddress.MENVCFG] and TCSR.ENVCFG_ADUE)<>0;

{$ifdef GStageQEMUParity}
 // PBMTE for G-stage: QEMU checks Svpbmt enablement via menvcfg for second-stage
 PBMTE:=(fState.CSR.fData[TCSR.TAddress.MENVCFG] and TCSR.ENVCFG_PBMTE)<>0;
{$endif}

 case GStageMode of
  0:begin // Bare: no G-stage translation
   result:=aGuestPhysical;
   exit;
  end;
  8:begin // Sv39x4
   Levels:=3;
  end;
  9:begin // Sv48x4
   Levels:=4;
  end;
  10:begin // Sv57x4
   Levels:=5;
  end;
  else begin
   // Invalid mode: guest page fault
   RaiseGuestPageFault(aGuestPhysical,aAccessType);
   result:=0;
   exit;
  end;
 end;

 // Root page table from hgatp.PPN
 PageTable:=(HGATP and $00000fffffffffff) shl TMMU.PAGE_SHIFT; // PPN field (44 bits)

 // G-stage first level has 2 extra bits (16 KiB root page table)
 BitOffset:=(Levels*TMMU.VPN_BITS)+(TMMU.PAGE_SHIFT-TMMU.VPN_BITS);

 for Index:=0 to Levels-1 do begin

  if Index=0 then begin
   // First level of G-stage: 11 bits instead of 9 (2 extra bits)
   PageTableOffset:=((aGuestPhysical shr BitOffset) and $7ff) shl 3;
  end else begin
   PageTableOffset:=((aGuestPhysical shr BitOffset) and TMMU.VPN_MASK) shl 3;
  end;

  PageTableEntryPointer:=fBus.GetDirectMemoryAccessPointer(PageTable+PageTableOffset,SizeOf(TPasRISCVUInt64),true,nil);
  if not assigned(PageTableEntryPointer) then begin
   RaiseGuestPageFault(aGuestPhysical,aAccessType);
   result:=0;
   exit;
  end;

  PageTableEntry:=PPasRISCVUInt64(PageTableEntryPointer)^;

  // Check Valid bit
  if (PageTableEntry and TMMU.TPTEMasks.Valid)=0 then begin
   RaiseGuestPageFault(aGuestPhysical,aAccessType);
   result:=0;
   exit;
  end;

  // Check reserved bits (bits 63:54 excluding PBMT/N)
  if (PageTableEntry and TMMU.TPTEMasks.Reserved)<>0 then begin
   RaiseGuestPageFault(aGuestPhysical,aAccessType);
   result:=0;
   exit;
  end;

  // Check PBMT: reserved without Svpbmt, mode 3 (11) always reserved
{$ifdef GStageQEMUParity}
  // QEMU behavior: honor Svpbmt via menvcfg.PBMTE for G-stage
  if (not PBMTE) and ((PageTableEntry and TMMU.TPTEMasks.PBMT)<>0) then begin
   // Reserved without Svpbmt
   RaiseGuestPageFault(aGuestPhysical,aAccessType);
   result:=0;
   exit;
  end;
  if PBMTE and ((PageTableEntry and TMMU.TPTEMasks.PBMT)=TMMU.TPTEMasks.PBMT) then begin
   // PBMT mode 3 (11) is reserved even with Svpbmt
   RaiseGuestPageFault(aGuestPhysical,aAccessType);
   result:=0;
   exit;
  end;
{$else}
  // Spike behavior: PBMT bits are always reserved in G-stage PTEs
  if (PageTableEntry and TMMU.TPTEMasks.PBMT)<>0 then begin
   // G-stage: PBMT is reserved (G-stage PTEs don't support PBMT per spec)
   RaiseGuestPageFault(aGuestPhysical,aAccessType);
   result:=0;
   exit;
  end;
{$endif}

  // Check for leaf
  if (PageTableEntry and TMMU.TPTEMasks.Leaf)<>0 then begin
   // Leaf PTE found

   // Check for invalid RWX combinations: R=0,W=1 is reserved regardless of X
   if ((PageTableEntry and TMMU.TPTEMasks.Read_)=0) and ((PageTableEntry and TMMU.TPTEMasks.Write_)<>0) then begin
    RaiseGuestPageFault(aGuestPhysical,aAccessType);
    result:=0;
    exit;
   end;

   // Check permissions (G-stage permissions checked against access type)
{$ifdef GStageQEMUParity}
   // QEMU behavior: G-stage leaf PTE with U=1 is invalid
   if (PageTableEntry and TMMU.TPTEMasks.User)<>0 then begin
    RaiseGuestPageFault(aGuestPhysical,aAccessType);
    result:=0;
    exit;
   end;
{$else}
   // Spike/Spec behavior: G-stage does not check U-bit (reserved for future use)
{$endif}
   case aAccessType of
    TMMU.TAccessType.Instruction:begin
     if (PageTableEntry and TMMU.TPTEMasks.Execute)=0 then begin
      RaiseGuestPageFault(aGuestPhysical,aAccessType);
      result:=0;
      exit;
     end;
    end;
    TMMU.TAccessType.Store:begin
     if (PageTableEntry and TMMU.TPTEMasks.Write_)=0 then begin
      RaiseGuestPageFault(aGuestPhysical,aAccessType);
      result:=0;
      exit;
     end;
    end;
    else begin // Load, LoadInstruction
     if (PageTableEntry and TMMU.TPTEMasks.Read_)=0 then begin
      RaiseGuestPageFault(aGuestPhysical,aAccessType);
      result:=0;
      exit;
     end;
    end;
   end;

   // Check A/D bits with ADUE support
   if ADUE then begin
    // Hardware A/D update: set A (and D for stores) automatically
    PageTableEntryAccessDirty:=PageTableEntry or TMMU.TPTEMasks.Accessed;
    if aAccessType=TMMU.TAccessType.Store then begin
     PageTableEntryAccessDirty:=PageTableEntryAccessDirty or TMMU.TPTEMasks.Dirty;
    end;
    if PageTableEntry<>PageTableEntryAccessDirty then begin
     PPasRISCVUInt64(PageTableEntryPointer)^:=PageTableEntryAccessDirty;
    end;
   end else begin
    // No ADUE: fault if A=0 or (store and D=0)
    if (PageTableEntry and TMMU.TPTEMasks.Accessed)=0 then begin
     RaiseGuestPageFault(aGuestPhysical,aAccessType);
     result:=0;
     exit;
    end;
    if (aAccessType=TMMU.TAccessType.Store) and ((PageTableEntry and TMMU.TPTEMasks.Dirty)=0) then begin
     RaiseGuestPageFault(aGuestPhysical,aAccessType);
     result:=0;
     exit;
    end;
   end;

   // Check superpage alignment
   VirtualMask:=(TPasRISCVUInt64(1) shl BitOffset)-1;
   PhysicalMask:=((TPasRISCVUInt64(1) shl (TMMU.PHYSICAL_BITS-BitOffset))-1) shl BitOffset;
   PageTableEntryShift:=PageTableEntry shl 2;

   if ((PageTableEntryShift and VirtualMask) and TMMU.PAGE_PNMASK)<>0 then begin
    // Misaligned superpage
    RaiseGuestPageFault(aGuestPhysical,aAccessType);
    result:=0;
    exit;
   end;

   PhysicalAddress:=(PageTableEntryShift and PhysicalMask) or (aGuestPhysical and VirtualMask);
   result:=PhysicalAddress;
   exit;

  end else begin
   // Non-leaf PTE: follow to next level
   // Non-leaf with W/D/A/U/PBMT/N bits set is invalid (QEMU/Spike check these)
   if (PageTableEntry and (TMMU.TPTEMasks.Write_ or TMMU.TPTEMasks.Dirty or TMMU.TPTEMasks.Accessed or TMMU.TPTEMasks.User or TMMU.TPTEMasks.Attr))<>0 then begin
    RaiseGuestPageFault(aGuestPhysical,aAccessType);
    result:=0;
    exit;
   end;
   PageTable:=((PageTableEntry shr 10) shl TMMU.PAGE_SHIFT) and TMMU.PHYSICAL_MASK;
   dec(BitOffset,TMMU.VPN_BITS);
  end;

 end;

 // No leaf found after all levels
 RaiseGuestPageFault(aGuestPhysical,aAccessType);
 result:=0;
end;

function TPasRISCV.THART.ForcedVirtualTranslate(const aGuestVA:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType):TPasRISCVUInt64;
// HLV/HSV/HLVX: two-stage translation as if V=1, using vsatp for VS-stage and hgatp for G-stage.
// Effective privilege for VS-stage comes from hstatus.SPVP.
// MXR/SUM for VS-stage come from vsstatus (not current mstatus).
// Matches QEMU's forced-virt MMU index and Spike's guest_load/guest_store with forced_virt.
var SavedMMUMode:TMMU.TMMUMode;
    SavedRootPageTable:TPasRISCVUInt64;
    SavedVirtualMode:Boolean;
    SavedMode:TMode;
    SavedMSTATUS:TPasRISCVUInt64;
    VSATP,HStatus,MSTATUS,VsStatus:TPasRISCVUInt64;
begin
 // Save current state
 SavedMMUMode:=fMMUMode;
 SavedRootPageTable:=fRootPageTable;
 SavedVirtualMode:=fState.VirtualMode;
 SavedMode:=fState.Mode;
 SavedMSTATUS:=fState.CSR.fData[TCSR.TAddress.MSTATUS];

 // Set up vsatp-based MMU for VS-stage translation
 VSATP:=fState.CSR.fData[TCSR.TAddress.VSATP];
 fMMUMode:=TMMU.TMMUMode(VSATP shr 60);
 fRootPageTable:=(VSATP and ((TPasRISCVUInt64(1) shl 44)-1)) shl 12;

 // Enable two-stage translation (AddressTranslate checks fState.VirtualMode for TwoStage)
 fState.VirtualMode:=true;

 // Set effective privilege from hstatus.SPVP
 HStatus:=fState.CSR.fData[TCSR.TAddress.HSTATUS];
 if (HStatus and (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.SPVP))<>0 then begin
  fState.Mode:=TMode.Supervisor;
 end else begin
  fState.Mode:=TMode.User;
 end;

 // Set MXR/SUM from vsstatus instead of current mstatus, clear MPRV
 MSTATUS:=fState.CSR.fData[TCSR.TAddress.MSTATUS];
 VsStatus:=fState.CSR.fData[TCSR.TAddress.VSSTATUS];
 MSTATUS:=MSTATUS and not (TCSR.TMask.TStatus.MXR or TCSR.TMask.TStatus.SUM or TCSR.TMask.TStatus.MPRV);
 MSTATUS:=MSTATUS or (VsStatus and (TCSR.TMask.TStatus.MXR or TCSR.TMask.TStatus.SUM));
 fState.CSR.fData[TCSR.TAddress.MSTATUS]:=MSTATUS;

 // Perform two-stage translation (VS-stage via vsatp + G-stage via hgatp)
 // NoTLBUpdate: don't pollute TLB with forced-virt entries
 result:=AddressTranslate(aGuestVA,aAccessType,[TMMU.TAccessFlag.NoTLBUpdate]);

 // Restore state
 fState.CSR.fData[TCSR.TAddress.MSTATUS]:=SavedMSTATUS;
 fState.Mode:=SavedMode;
 fState.VirtualMode:=SavedVirtualMode;
 fRootPageTable:=SavedRootPageTable;
 fMMUMode:=SavedMMUMode;
end;

procedure TPasRISCV.THART.FlushTLB(const aInterrupt:Boolean);
var DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin
 FillChar(fDirectAccessTLBCache,SizeOf(TMMU.TDirectAccessTLBEntries),#0);
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[0];
 DirectAccessTLBEntry^.Read:=TPasRISCVUInt64($ffffffffffffffff);
 DirectAccessTLBEntry^.Write:=TPasRISCVUInt64($ffffffffffffffff);
 DirectAccessTLBEntry^.Execute:=TPasRISCVUInt64($ffffffffffffffff);
 if aInterrupt then begin
  TPasMPInterlocked.BitwiseOr(fMachine.fRunState,fHARTMask);
 end;
end;

procedure TPasRISCV.THART.FlushTLBPage(const aInterrupt:Boolean;const aAddress:TPasRISCVUInt64);
var VPN:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin
 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
{$ifdef CombinedDirectAccessTLBCache}
 DirectAccessTLBEntry^.Read:=VPN-1;
 DirectAccessTLBEntry^.Write:=VPN-1;
 DirectAccessTLBEntry^.Execute:=VPN-1;
{$else}
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[(aAddress shr PAGE_SHIFT) and TMMU.DIRECT_ACCESS_TLB_MASK];
 if DirectAccessTLBEntry^.Read=VPN then begin
  DirectAccessTLBEntry^.Read:=VPN-1;
 end;
 if DirectAccessTLBEntry^.Write=VPN then begin
  DirectAccessTLBEntry^.Write:=VPN-1;
 end;
 if DEntry^.Execute=VPN then begin
  DirectAccessTLBEntry^.Execute:=VPN-1;
 end;
{$endif}
 if aInterrupt then begin
  TPasMPInterlocked.BitwiseOr(fMachine.fRunState,fHARTMask);
 end;
end;

procedure TPasRISCV.THART.TLBPut(const aVirtualAddress:TPasRISCVUInt64;const aTarget:TPasRISCVPtrUInt;const aAccessType:TMMU.TAccessType);
var VPN:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin
 VPN:=aVirtualAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
{$ifdef CombinedDirectAccessTLBCache}
 case aAccessType of
  TMMU.TAccessType.LoadInstruction,
  TMMU.TAccessType.Load:begin
   DirectAccessTLBEntry^.Read:=VPN;
   if DirectAccessTLBEntry^.Write<>VPN then begin
    DirectAccessTLBEntry^.Write:=VPN-1;
   end;
   if DirectAccessTLBEntry^.Execute<>VPN then begin
    DirectAccessTLBEntry^.Execute:=VPN-1;
   end;
  end;
  TMMU.TAccessType.Store:begin
   DirectAccessTLBEntry^.Read:=VPN;
   DirectAccessTLBEntry^.Write:=VPN;
   if DirectAccessTLBEntry^.Execute<>VPN then begin
    DirectAccessTLBEntry^.Execute:=VPN-1;
   end;
  end;
  TMMU.TAccessType.Instruction:begin
   if DirectAccessTLBEntry^.Read<>VPN then begin
    DirectAccessTLBEntry^.Read:=VPN-1;
   end;
   DirectAccessTLBEntry^.Write:=VPN-1;
   DirectAccessTLBEntry^.Execute:=VPN;
  end;
  else begin
   DirectAccessTLBEntry^.Read:=VPN-1;
   DirectAccessTLBEntry^.Write:=VPN-1;
   DirectAccessTLBEntry^.Execute:=VPN-1;
  end;
 end;
 DirectAccessTLBEntry^.RelativeMemory:=aTarget-TPasRISCVPtrUInt(aVirtualAddress and PAGE_ADDRESS_MASK);
{$else}
 case aAccessType of
  TMMU.TAccessType.LoadInstruction,
  TMMU.TAccessType.Load:begin
   DirectAccessTLBEntry^.Read:=VPN;
   DirectAccessTLBEntry^.RelativeMemoryRead:=aTarget-TPasRISCVPtrUInt(aVirtualAddress and PAGE_ADDRESS_MASK);
  end;
  TMMU.TAccessType.Store:begin
   DirectAccessTLBEntry^.Write:=VPN;
{  if DirectAccessTLBEntry^.Execute=VPN then begin
    DirectAccessTLBEntry^.Execute:=VPN-1;
   end;}
   DirectAccessTLBEntry^.RelativeMemoryWrite:=aTarget-TPasRISCVPtrUInt(aVirtualAddress and PAGE_ADDRESS_MASK);
  end;
  TMMU.TAccessType.Instruction:begin
{  if DirectAccessTLBEntry^.Write=VPN then begin
    DirectAccessTLBEntry^.Write:=VPN-1;
   end;}
   DirectAccessTLBEntry^.Execute:=VPN;
   DirectAccessTLBEntry^.RelativeMemoryExecute:=aTarget-TPasRISCVPtrUInt(aVirtualAddress and PAGE_ADDRESS_MASK);
  end;
  else begin
   DirectAccessTLBEntry^.Read:=VPN-1;
   DirectAccessTLBEntry^.Write:=VPN-1;
   DirectAccessTLBEntry^.Execute:=VPN-1;
  end;
 end;
{$endif}
end;

procedure TPasRISCV.THART.TLBPutBusDevice(const aVirtualAddress,aPhysicalAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType);
var Target:Pointer;
begin
 Target:=fBus.GetDirectMemoryAccessPointer(aPhysicalAddress and PAGE_ADDRESS_MASK,PAGE_SIZE,TMMU.AccessWrite[aAccessType],nil);
 if assigned(Target) then begin
  TLBPut(aVirtualAddress and PAGE_ADDRESS_MASK,TPasRISCVPtrUInt(Target),aAccessType);
 end;
end;

function TPasRISCV.THART.CheckPrivilege(const aCPUMode:THART.TMode;const aAccessType:TMMU.TAccessType):Boolean;
begin
 if aAccessType=TMMU.TAccessType.Instruction then begin
  // Disallow allow executing user pages in supervisor mode and vice versa, but not in the MXR case (TMMU.TAccessType.LoadInstruction)
  result:=false;
 end else if (aCPUMode<>THART.TMode.Supervisor) or ((fState.CSR.fData[TCSR.TAddress.MSTATUS] and TCSR.TMask.TStatus.SUM)=0) then begin
  // RW operations on user pages are allowed in supervisor mode when the SUM bit is set
  result:=false;
 end else begin
  result:=true;
 end;
end;

function TPasRISCV.THART.AddressTranslate(aVirtualAddress:TPasRISCVUInt64;const aAccessType:TMMU.TAccessType;const aAccessFlags:TMMU.TAccessFlags):TPasRISCVUInt64;
var Index:TPasRISCVSizeInt;
    CPUMode:THART.TMode;
    MSTATUS,Levels,PMM,CSRHENVCFGMask:TPasRISCVUInt64;
    EffectiveAccessType:TMMU.TAccessType;
    PageTable,BitOffset,PageTableOffset,PageTableEntry,VirtualMask,PhysicalMask,
    PageTableEntryShift,PageTableEntryAccessDirty,PhysicalAddress,PPN,
    NAPOTBits,NAPOTMask,PTEFetchAddress:TPasRISCVUInt64;
    PageTableEntryPointer:Pointer;
    PBMTE,ADUE,NAPOT,TwoStage:boolean;
begin

 CPUMode:=fState.Mode;

 MSTATUS:=fState.CSR.fData[THART.TCSR.TAddress.MSTATUS];

 // H-extension: two-stage translation when running in virtual mode
 TwoStage:=fState.VirtualMode;

 // When running in virtualized mode (VS/VU), gate with henvcfg
 if fState.VirtualMode then begin
  CSRHENVCFGMask:=fState.CSR.fData[THART.TCSR.TAddress.HENVCFG];
 end else begin
  CSRHENVCFGMask:=TPasRISCVUInt64($ffffffffffffffff);
 end;

 PBMTE:=((fState.CSR.fData[THART.TCSR.TAddress.MENVCFG] and CSRHENVCFGMask) and THART.TCSR.ENVCFG_PBMTE)<>0;

 ADUE:=((fState.CSR.fData[THART.TCSR.TAddress.MENVCFG] and CSRHENVCFGMask) and THART.TCSR.ENVCFG_ADUE)<>0;

 NAPOT:=true;

 EffectiveAccessType:=aAccessType;

 if EffectiveAccessType<>TMMU.TAccessType.Instruction then begin

  if (MSTATUS and (TPasRISCVUInt64(1) shl THART.TCSR.TMask.TMSTATUSBit.MPRV))<>0 then begin
   CPUMode:=TPasRISCV.THART.TMode(TPasRISCVUInt64((fState.CSR.fData[TCSR.TAddress.MSTATUS] shr 11) and 3));
  end;

  // Pointer masking (Supm/Ssnpm)
  // TODO-Optimize: TLB fast-paths in Load32/Store32 etc. see the unmasked address and will
  // always miss when pointer masking is active, falling through to AddressTranslate. This is
  // performance-neutral when PMM=0, but could be optimized for PMM<>0 by masking the address
  // before the TLB lookup in the fast-paths as well.
  case CPUMode of
   THART.TMode.User:begin
    PMM:=(fState.CSR.fData[TCSR.TAddress.SENVCFG] shr 32) and 3;
   end;
   THART.TMode.Supervisor:begin
    PMM:=(fState.CSR.fData[TCSR.TAddress.MENVCFG] shr 32) and 3;
   end;
   else begin
    PMM:=0;
   end;
  end;
  case PMM of
   2:begin // PMLEN=7
    aVirtualAddress:=TPasRISCVUInt64(SARInt64(TPasRISCVInt64(aVirtualAddress shl 7),7));
   end;
   3:begin // PMLEN=16
    aVirtualAddress:=TPasRISCVUInt64(SARInt64(TPasRISCVInt64(aVirtualAddress shl 16),16));
   end;
  end;
 
 end;

 if (EffectiveAccessType=TMMU.TAccessType.Load) and
    ((MSTATUS and (TPasRISCVUInt64(1) shl THART.TCSR.TMask.TMSTATUSBit.MXR))<>0) then begin
  EffectiveAccessType:=TMMU.TAccessType.LoadInstruction;
 end;

 case CPUMode of

  THART.TMode.User,
  THART.TMode.Supervisor,
  THART.TMode.Hypervisor:begin

   case fMMUMode of
    TMMU.TMMUMode.SV39:begin
     Levels:=3;
    end;
    TMMU.TMMUMode.SV48:begin
     Levels:=4;
    end;
    TMMU.TMMUMode.SV57:begin
     Levels:=5;
    end;
    else {TMMU.TMMUMode.None:}begin
     // No VS-stage paging; but in virtual mode, still need G-stage
     if TwoStage then begin
      PhysicalAddress:=GStageTranslate(aVirtualAddress,aAccessType,false);
      if fState.ExceptionValue<>TExceptionValue.None then begin
       result:=0;
       exit;
      end;
      if not (TMMU.TAccessFlag.NoTLBUpdate in aAccessFlags) then begin
       TLBPutBusDevice(aVirtualAddress and PAGE_ADDRESS_MASK,PhysicalAddress and PAGE_ADDRESS_MASK,aAccessType);
      end;
      result:=PhysicalAddress;
      exit;
     end;
     if not (TMMU.TAccessFlag.NoTLBUpdate in aAccessFlags) then begin
      TLBPutBusDevice(aVirtualAddress and PAGE_ADDRESS_MASK,aVirtualAddress and PAGE_ADDRESS_MASK,aAccessType);
     end;
     result:=aVirtualAddress;
     exit;
    end;
   end;

   PageTable:=fRootPageTable;
   BitOffset:=(Levels*TMMU.VPN_BITS)+(TMMU.PAGE_SHIFT-TMMU.VPN_BITS);

   // Check for canonical virtual address
   if aVirtualAddress<>TPasRISCVUInt64(SignExtend(aVirtualAddress,BitOffset+TMMU.VPN_BITS)) then begin
    if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
     RaisePageFault(aVirtualAddress,aAccessType);
    end;
    result:=0;
    exit;
   end;

   for Index:=0 to Levels-1 do begin

    PageTableOffset:=((aVirtualAddress shr BitOffset) and TMMU.VPN_MASK) shl 3;

    // H-extension: G-stage translate PTE fetch addresses during VS-stage walk
    PTEFetchAddress:=PageTable+PageTableOffset;
    if TwoStage then begin
     PTEFetchAddress:=GStageTranslate(PTEFetchAddress,TMMU.TAccessType.Load,true);
     if fState.ExceptionValue<>TExceptionValue.None then begin
      // G-stage fault during PTE fetch: stval should be original VA, not GPA
      fState.ExceptionData:=aVirtualAddress;
      fState.CSR.fData[TCSR.TAddress.HTINST]:=$3000; // pseudoinstruction for implicit G-stage fault
      result:=0;
      exit;
     end;
    end;

    PageTableEntryPointer:=fBus.GetDirectMemoryAccessPointer(PTEFetchAddress,SizeOf(TPasRISCVUInt64),true,nil);
    if not assigned(PageTableEntryPointer) then begin
     // Physical fault
     if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
      RaisePageFault(aVirtualAddress,aAccessType);
     end;
     result:=0;
     exit;
    end;

    repeat

     PageTableEntry:=PPasRISCVUInt64(PageTableEntryPointer)^;

     if (PageTableEntry and TMMU.TPTEMasks.Reserved)<>0 then begin
      // Reserved
      if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
       RaisePageFault(aVirtualAddress,aAccessType);
      end;
      result:=0;
      exit;
     end;

     if (not PBMTE) and ((PageTableEntry and TMMU.TPTEMasks.PBMT)<>0) then begin
      // Reserved without Svpbmt
      if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
       RaisePageFault(aVirtualAddress,aAccessType);
      end;
      result:=0;
      exit;
     end;

     if PBMTE and ((PageTableEntry and TMMU.TPTEMasks.PBMT)=TMMU.TPTEMasks.PBMT) then begin
      // PBMT mode 3 (11) is reserved even with Svpbmt
      if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
       RaisePageFault(aVirtualAddress,aAccessType);
      end;
      result:=0;
      exit;
     end;

     if (not NAPOT) and ((PageTableEntry and TMMU.TPTEMasks.N)<>0) then begin
      // Reserved without Svnapot
      if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
       RaisePageFault(aVirtualAddress,aAccessType);
      end;
      result:=0;
      exit;
     end;

     if (PageTableEntry and TMMU.TPTEMasks.Valid)<>0 then begin

      if (PageTableEntry and TMMU.TPTEMasks.Leaf)<>0 then begin

       if ((PageTableEntry and TMMU.TPTEMasks.User)<>0)=(CPUMode<>THART.TMode.User) then begin
        if not (TMMU.TAccessFlag.IgnoreMMUProtection in aAccessFlags) then begin
         if not CheckPrivilege(CPUMode,EffectiveAccessType) then begin
          if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
           RaisePageFault(aVirtualAddress,aAccessType);
          end;
          result:=0;
          exit;
         end;
        end;
       end;

       if (PageTableEntry and TMMU.AccessMasks[EffectiveAccessType])<>0 then begin

        VirtualMask:=(TPasRISCVUInt64(1) shl BitOffset)-1;
        PhysicalMask:=((TPasRISCVUInt64(1) shl (TMMU.PHYSICAL_BITS-BitOffset))-1) shl BitOffset;
        PageTableEntryShift:=PageTableEntry shl 2;

        if ADUE then begin
         PageTableEntryAccessDirty:=PageTableEntry or TMMU.TPTEMasks.Accessed;
         if EffectiveAccessType=TMMU.TAccessType.Store then begin
          PageTableEntryAccessDirty:=PageTableEntryAccessDirty or TMMU.TPTEMasks.Dirty;
         end;
        end else begin
         if ((PageTableEntry and TMMU.TPTEMasks.Accessed)=0) or
            ((EffectiveAccessType=TMMU.TAccessType.Store) and ((PageTableEntry and TMMU.TPTEMasks.Dirty)=0)) then begin
          if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
           RaisePageFault(aVirtualAddress,aAccessType);
          end;
          result:=0;
          exit;
         end else begin
          PageTableEntryAccessDirty:=PageTableEntry;
         end;
        end;

        if ((PageTableEntryShift and VirtualMask) and TMMU.PAGE_PNMASK)<>0 then begin
         // Misaligned
         if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
          RaisePageFault(aVirtualAddress,aAccessType);
         end;
         result:=0;
         exit;
        end;

        if PageTableEntry<>PageTableEntryAccessDirty then begin
         if (not ADUE) and (not (TMMU.TAccessFlag.IgnoreMMUProtection in aAccessFlags)) then begin
          if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
           RaisePageFault(aVirtualAddress,aAccessType);
          end;
          result:=0;
          exit;
         end;

         if TPasMPInterlocked.CompareExchange(TPasMPUInt64(PageTableEntryPointer^),PageTableEntryAccessDirty,PageTableEntry)<>PageTableEntry then begin
          continue;
         end;
        end;

        if NAPOT and ((PageTableEntry and TMMU.TPTEMasks.N)<>0) then begin

         PPN:=(PageTableEntry and TMMU.TPTEMasks.PPN_MASK) shr TMMU.PPN_BITS;

         NAPOTBits:=CTZQWord(PPN)+1;
         if (Index<>(Levels-1)) or (NAPOTBits<>4) then begin
          if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
           RaisePageFault(aVirtualAddress,aAccessType);
          end;
          result:=0;
          exit;
         end;

         NAPOTMask:=(TPasRISCVUInt64(1) shl NAPOTBits)-1;

         PhysicalAddress:=(((PPN and not NAPOTMask) or
                            ((aVirtualAddress shr TMMU.PAGE_SHIFT) and (NAPOTMask or ((TPasRISCVUInt64(1) shl (BitOffset-(TMMU.PAGE_VPN_DIFF+TMMU.VPN_BITS)))-1)))) shl TMMU.PAGE_SHIFT) or
                           (aVirtualAddress and PAGE_MASK);

        end else begin

         PhysicalAddress:=(PageTableEntryShift and PhysicalMask) or (aVirtualAddress and VirtualMask);

        end;

        // H-extension: G-stage translate the final guest physical address
        if TwoStage then begin
         PhysicalAddress:=GStageTranslate(PhysicalAddress,aAccessType,false);
         if fState.ExceptionValue<>TExceptionValue.None then begin
          // G-stage fault: stval should be original VA, not GPA
          fState.ExceptionData:=aVirtualAddress;
          result:=0;
          exit;
         end;
        end;

        if not (TMMU.TAccessFlag.NoTLBUpdate in aAccessFlags) then begin
         TLBPutBusDevice(aVirtualAddress and PAGE_ADDRESS_MASK,PhysicalAddress and PAGE_ADDRESS_MASK,aAccessType);
        end;
        result:=PhysicalAddress;
        exit;

       end;

      end else if (PageTableEntry and TMMU.TPTEMasks.Write_)=0 then begin
{      if PBMTE and ((PageTableEntry and TMMU.TPTEMasks.PBMT)<>0) then begin
        // Non-leaf PTE must have PBMT=0 }      
       if (PageTableEntry and (TMMU.TPTEMasks.Dirty or TMMU.TPTEMasks.Accessed or TMMU.TPTEMasks.User or TMMU.TPTEMasks.Attr))<>0 then begin
        // Non-leaf PTE: D, A, U, PBMT, N bits are reserved
        if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
         RaisePageFault(aVirtualAddress,aAccessType);
        end;
        result:=0;
        exit;
       end;
       PageTable:=((PageTableEntry shr 10) shl TMMU.PAGE_SHIFT) and TMMU.PHYSICAL_MASK;
       dec(BitOffset,TMMU.VPN_BITS);
      end;

     end;

     break;

    until false;

   end;

   if not (TMMU.TAccessFlag.NoTrap in aAccessFlags) then begin
    RaisePageFault(aVirtualAddress,aAccessType);
   end;
   result:=0;
   exit;

  end;

  else {THART.TMode.Machine:}begin

   if not (TMMU.TAccessFlag.NoTLBUpdate in aAccessFlags) then begin
    TLBPutBusDevice(aVirtualAddress and PAGE_ADDRESS_MASK,aVirtualAddress and PAGE_ADDRESS_MASK,aAccessType);
   end;
   result:=aVirtualAddress;

  end;

 end;

end;

function TPasRISCV.THART.Load8(const aAddress:TPasRISCVUInt64):TPasRISCVUInt8;
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if DirectAccessTLBEntry^.Read=VPN then begin
  result:=PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
  exit;
 end;

 TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
 if fState.ExceptionValue<>TExceptionValue.None then begin
  result:=0;
{$ifdef PreferDirectMemoryAccess}
 end else if DirectAccessTLBEntry^.Read=VPN then begin
  result:=PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$endif}
 end else begin
  result:=TPasRISCVUInt8(fBus.Load(self,TranslatedAddress,1));
 end;

end;

procedure TPasRISCV.THART.LoadRegisterS8(const aRegister:TRegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if DirectAccessTLBEntry^.Read=VPN then begin
  Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^)));
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
   fState.Registers[aRegister]:=Value;
  end;
  exit;
 end;

 TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
 if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
  if DirectAccessTLBEntry^.Read=VPN then begin
   Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^)));
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
    fState.Registers[aRegister]:=Value;
   end;
  end else{$endif}begin
   Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(TPasRISCVUInt8(fBus.Load(self,TranslatedAddress,1)))));
   if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
    fState.Registers[aRegister]:=Value;
   end;
  end;
 end;

end;

procedure TPasRISCV.THART.LoadRegisterU8(const aRegister:TRegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if DirectAccessTLBEntry^.Read=VPN then begin
  Value:=PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
   fState.Registers[aRegister]:=Value;
  end;
  exit;
 end;

 TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
 if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
  if DirectAccessTLBEntry^.Read=VPN then begin
   Value:=PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
    fState.Registers[aRegister]:=Value;
   end;
  end else{$endif}begin
   Value:=TPasRISCVUInt8(fBus.Load(self,TranslatedAddress,1));
   if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
    fState.Registers[aRegister]:=Value;
   end;
  end;
 end;

end;

procedure TPasRISCV.THART.Store8(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt8);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if DirectAccessTLBEntry^.Write=VPN then begin
  PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=aValue;
  exit;
 end;

 TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
 if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
  if DirectAccessTLBEntry^.Write=VPN then begin
   PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=aValue;
  end else{$endif}begin
   fBus.Store(self,TranslatedAddress,aValue,1);
  end;
 end;

end;

procedure TPasRISCV.THART.StoreRegisterU8(const aAddress:TPasRISCVUInt64;const aRegister:TRegister);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt8;
begin

 Value:=fState.Registers[aRegister];

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if DirectAccessTLBEntry^.Write=VPN then begin
  PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
  exit;
 end;

 TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
 if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
  if DirectAccessTLBEntry^.Write=VPN then begin
   PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
  end else{$endif}begin
   fBus.Store(self,TranslatedAddress,Value,1);
  end;
 end;

end;

function TPasRISCV.THART.Load16(const aAddress:TPasRISCVUInt64):TPasRISCVUInt16;
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+1)<PAGE_SIZE) then begin
  result:=PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+1)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue<>TExceptionValue.None then begin
   result:=0;
{$ifdef PreferDirectMemoryAccess}
  end else if DirectAccessTLBEntry^.Read=VPN then begin
   result:=PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$endif}
  end else begin
   result:=TPasRISCVUInt16(fBus.Load(self,TranslatedAddress,2));
  end;
 end else begin
  result:=TPasRISCVUInt8(Load(aAddress,1));
  if fState.ExceptionValue=TExceptionValue.None then begin
   result:=result or (TPasRISCVUInt16(TPasRISCVUInt8(Load(aAddress+1,1))) shl 8);
  end;
 end;

end;

procedure TPasRISCV.THART.LoadRegisterS16(const aRegister:TRegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+1)<PAGE_SIZE) then begin
  Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^)));
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
   fState.Registers[aRegister]:=Value;
  end;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+1)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Read=VPN then begin
    Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^)));
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
    fState.Registers[aRegister]:=Value;
    end;
   end else {$endif}begin
    Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(TPasRISCVUInt16(fBus.Load(self,TranslatedAddress,2)))));
    if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
     fState.Registers[aRegister]:=Value;
    end;
   end;
  end;
 end else begin
  Value:=TPasRISCVUInt8(Load(aAddress,1));
  if fState.ExceptionValue=TExceptionValue.None then begin
   Value:=Value or (TPasRISCVUInt16(TPasRISCVUInt8(Load(aAddress+1,1))) shl 8);
   if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
    fState.Registers[aRegister]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(TPasRISCVUInt16(Value))));
   end;
  end;
 end;

end;

procedure TPasRISCV.THART.LoadRegisterU16(const aRegister:TRegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+1)<PAGE_SIZE) then begin
  Value:=PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
   fState.Registers[aRegister]:=Value;
  end;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+1)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Read=VPN then begin
    Value:=PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
     fState.Registers[aRegister]:=Value;
    end;
   end else{$endif}begin
    Value:=TPasRISCVUInt16(fBus.Load(self,TranslatedAddress,2));
    if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
     fState.Registers[aRegister]:=Value;
    end;
   end;
  end;
 end else begin
  Value:=TPasRISCVUInt8(Load(aAddress,1));
  if fState.ExceptionValue=TExceptionValue.None then begin
   Value:=Value or (TPasRISCVUInt16(TPasRISCVUInt8(Load(aAddress+1,1))) shl 8);
   if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
    fState.Registers[aRegister]:=Value;
   end;
  end;
 end;

end;

procedure TPasRISCV.THART.Store16(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt16);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+1)<PAGE_SIZE) then begin
  PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=aValue;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+1)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Write=VPN then begin
    PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=aValue;
   end else{$endif}begin
    fBus.Store(self,TranslatedAddress,aValue,2);
   end;
  end;
 end else begin
  Store(aAddress,(aValue shr 0) and $ff,1);
  if fState.ExceptionValue=TExceptionValue.None then begin
   Store(aAddress+1,(aValue shr 8) and $ff,1);
  end;
 end;

end;

procedure TPasRISCV.THART.StoreRegisterU16(const aAddress:TPasRISCVUInt64;const aRegister:TRegister);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt16;
begin

 Value:=fState.Registers[aRegister];

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+1)<PAGE_SIZE) then begin
  PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+1)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Write=VPN then begin
    PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
   end else{$endif}begin
    fBus.Store(self,TranslatedAddress,Value,2);
   end;
  end;
 end else begin
  Store(aAddress,(Value shr 0) and $ff,1);
  if fState.ExceptionValue=TExceptionValue.None then begin
   Store(aAddress+1,(Value shr 8) and $ff,1);
  end;
 end;

end;

function TPasRISCV.THART.Load32(const aAddress:TPasRISCVUInt64):TPasRISCVUInt32;
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
  result:=PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+3)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue<>TExceptionValue.None then begin
   result:=0;
{$ifdef PreferDirectMemoryAccess}
  end else if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
   result:=PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$endif}
  end else begin
   result:=TPasRISCVUInt32(fBus.Load(self,TranslatedAddress,4));
  end;
 end else begin
  result:=Load(aAddress,4);
 end;

end;

procedure TPasRISCV.THART.LoadRegisterS32(const aRegister:TRegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
  Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^)));
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
   fState.Registers[aRegister]:=Value;
  end;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+3)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Read=VPN then begin
    Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^)));
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
     fState.Registers[aRegister]:=Value;
    end;
   end else{$endif}begin
    Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(fBus.Load(self,TranslatedAddress,4)))));
    if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
     fState.Registers[aRegister]:=Value;
    end;
   end;
  end;
 end else begin
  Value:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Load(aAddress,4))));
  if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
   fState.Registers[aRegister]:=Value;
  end;
 end;

end;

procedure TPasRISCV.THART.LoadRegisterU32(const aRegister:TRegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
  Value:=PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
   fState.Registers[aRegister]:=Value;
  end;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+3)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Read=VPN then begin
    Value:=PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
     fState.Registers[aRegister]:=Value;
    end;
   end else{$endif}begin
    Value:=TPasRISCVUInt32(fBus.Load(self,TranslatedAddress,4));
    if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
     fState.Registers[aRegister]:=Value;
    end;
   end;
  end;
 end else begin
  Value:=TPasRISCVUInt32(Load(aAddress,4));
  if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
   fState.Registers[aRegister]:=Value;
  end;
 end;

end;

procedure TPasRISCV.THART.LoadRegisterF32(const aRegister:TFPURegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
  Value:=PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
  fState.FPURegisters[aRegister].ui64:=TPasRISCVUInt64(TPasRISCVUInt32(Value)) or TPasRISCVUInt64($ffffffff00000000);
  fState.CSR.SetFSDirty;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+3)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Read=VPN then begin
    Value:=PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
    fState.FPURegisters[aRegister].ui64:=TPasRISCVUInt64(TPasRISCVUInt32(Value)) or TPasRISCVUInt64($ffffffff00000000);
    fState.CSR.SetFSDirty;
   end else{$endif}begin
    Value:=TPasRISCVUInt32(fBus.Load(self,TranslatedAddress,4));
    if fState.ExceptionValue=TExceptionValue.None then begin
     fState.FPURegisters[aRegister].ui64:=TPasRISCVUInt64(TPasRISCVUInt32(Value)) or TPasRISCVUInt64($ffffffff00000000);
     fState.CSR.SetFSDirty;
    end;
   end;
  end;
 end else begin
  Value:=TPasRISCVUInt32(Load(aAddress,4));
  if fState.ExceptionValue=TExceptionValue.None then begin
   fState.FPURegisters[aRegister].ui64:=TPasRISCVUInt64(TPasRISCVUInt32(Value)) or TPasRISCVUInt64($ffffffff00000000);
   fState.CSR.SetFSDirty;
  end;
 end;

end;

procedure TPasRISCV.THART.Store32(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt32);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
  PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=aValue;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+3)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
    PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=aValue;
   end else{$endif} begin
    fBus.Store(self,TranslatedAddress,aValue,4);
   end;
  end;
 end else begin
  Store(aAddress,aValue,4);
 end;

end;

procedure TPasRISCV.THART.StoreRegisterU32(const aAddress:TPasRISCVUInt64;const aRegister:TRegister);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt32;
begin

 Value:=fState.Registers[aRegister];

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
  PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+3)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
    PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
   end else{$endif} begin
    fBus.Store(self,TranslatedAddress,Value,4);
   end;
  end;
 end else begin
  Store(aAddress,Value,4);
 end;

end;

procedure TPasRISCV.THART.StoreRegisterF32(const aAddress:TPasRISCVUInt64;const aRegister:TFPURegister);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt32;
begin

 Value:=fState.FPURegisters[aRegister].ui32;

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
  PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+3)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
    PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
   end else{$endif} begin
    fBus.Store(self,TranslatedAddress,Value,4);
   end;
  end;
 end else begin
  Store(aAddress,Value,4);
 end;

end;

function TPasRISCV.THART.Load64(const aAddress:TPasRISCVUInt64):TPasRISCVUInt64;
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+7)<PAGE_SIZE) then begin
  result:=PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+7)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue<>TExceptionValue.None then begin
   result:=0;
{$ifdef PreferDirectMemoryAccess}
  end else if DirectAccessTLBEntry^.Read=VPN then begin
   result:=PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$endif}
  end else begin
   result:=fBus.Load(self,TranslatedAddress,8);
  end;
 end else begin
  result:=Load(aAddress,8);
 end;

end;

procedure TPasRISCV.THART.LoadRegisterS64(const aRegister:TRegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+7)<PAGE_SIZE) then begin
  Value:=TPasRISCVUInt64(TPasRISCVInt64(PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^));
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
   fState.Registers[aRegister]:=Value;
  end;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+7)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Read=VPN then begin
    Value:=TPasRISCVUInt64(TPasRISCVInt64(PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^)));
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
     fState.Registers[aRegister]:=Value;
    end;
   end else{$endif}begin
    Value:=TPasRISCVUInt64(TPasRISCVInt64(fBus.Load(self,TranslatedAddress,8)));
    if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
     fState.Registers[aRegister]:=Value;
    end;
   end;
  end;
 end else begin
  Value:=TPasRISCVUInt64(TPasRISCVInt64(Load(aAddress,8)));
  if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
   fState.Registers[aRegister]:=Value;
  end;
 end;

end;

procedure TPasRISCV.THART.LoadRegisterU64(const aRegister:TRegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+7)<PAGE_SIZE) then begin
  Value:=PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
   fState.Registers[aRegister]:=Value;
  end;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+7)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Read=VPN then begin
    Value:=PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
{$ifndef ExplicitEnforceZeroRegister}if aRegister<>TRegister.Zero then{$endif}begin
     fState.Registers[aRegister]:=Value;
    end;
   end else{$endif}begin
    Value:=TPasRISCVUInt64(fBus.Load(self,TranslatedAddress,8));
    if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
     fState.Registers[aRegister]:=Value;
    end;
   end;
  end;
 end else begin
  Value:=Load(aAddress,8);
  if (fState.ExceptionValue=TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (aRegister<>TRegister.Zero){$endif}then begin
   fState.Registers[aRegister]:=Value;
  end;
 end;

end;

procedure TPasRISCV.THART.LoadRegisterF64(const aRegister:TFPURegister;const aAddress:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+7)<PAGE_SIZE) then begin
  Value:=PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
  fState.FPURegisters[aRegister].ui64:=Value;
  fState.CSR.SetFSDirty;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+7)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Read=VPN then begin
    Value:=PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress)))^;
    fState.FPURegisters[aRegister].ui64:=Value;
    fState.CSR.SetFSDirty;
   end else{$endif}begin
    Value:=TPasRISCVUInt64(fBus.Load(self,TranslatedAddress,8));
    if fState.ExceptionValue=TExceptionValue.None then begin
     fState.FPURegisters[aRegister].ui64:=Value;
     fState.CSR.SetFSDirty;
    end;
   end;
  end;
 end else begin
  Value:=Load(aAddress,8);
  if fState.ExceptionValue=TExceptionValue.None then begin
   fState.FPURegisters[aRegister].ui64:=Value;
   fState.CSR.SetFSDirty;
  end;
 end;

end;

procedure TPasRISCV.THART.Store64(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+7)<PAGE_SIZE) then begin
  PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=aValue;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+7)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Write=VPN then begin
    PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=aValue;
   end else{$endif}begin
    fBus.Store(self,TranslatedAddress,aValue,8);
   end;
  end;
 end else begin
  Store(aAddress,aValue,8);
 end;

end;

procedure TPasRISCV.THART.StoreRegisterU64(const aAddress:TPasRISCVUInt64;const aRegister:TRegister);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 Value:=fState.Registers[aRegister];

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+7)<PAGE_SIZE) then begin
  PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+7)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Write=VPN then begin
    PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
   end else{$endif}begin
    fBus.Store(self,TranslatedAddress,Value,8);
   end;
  end;
 end else begin
  Store(aAddress,Value,8);
 end;

end;

procedure TPasRISCV.THART.StoreRegisterF64(const aAddress:TPasRISCVUInt64;const aRegister:TFPURegister);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
    Value:TPasRISCVUInt64;
begin

 Value:=fState.FPURegisters[aRegister].ui64;

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+7)<PAGE_SIZE) then begin
  PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+7)<PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
{$ifdef PreferDirectMemoryAccess}
   if DirectAccessTLBEntry^.Write=VPN then begin
    PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=Value;
   end else{$endif}begin
    fBus.Store(self,TranslatedAddress,Value,8);
   end;
  end;
 end else begin
  Store(aAddress,Value,8);
 end;

end;

function TPasRISCV.THART.MemoryPointerTranslate(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aBounce:Pointer;const aReadOnly:Boolean):Pointer;
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if aReadOnly then begin
  if (DirectAccessTLBEntry^.Read=VPN) and (((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE) then begin
   result:=Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryRead{$endif}+aAddress));
   exit;
  end;
 end else begin
  if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE) then begin
   result:=Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress));
   exit;
  end;
 end;

 if ((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE then begin
  if aReadOnly then begin
   TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[TMMU.TAccessFlag.TranslateIntoPhysicalAddress,TMMU.TAccessFlag.DirectMemoryPointer]);
  end else begin
   TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[TMMU.TAccessFlag.TranslateIntoPhysicalAddress,TMMU.TAccessFlag.DirectMemoryPointer]);
  end;
  if fState.ExceptionValue<>TExceptionValue.None then begin
   result:=nil;
  end else begin
   result:=fBus.GetDirectMemoryAccessPointer(TranslatedAddress,aSize,not aReadOnly,aBounce);
   if result=@aBounce then begin
    case aSize of
     4:begin
      PPasRISCVUInt32(aBounce)^:=fBus.Load(self,aAddress,aSize);
     end;
     8:begin
      PPasRISCVUInt64(aBounce)^:=fBus.Load(self,aAddress,aSize);
     end;
     16:begin
      PPasMPInt128Record(aBounce)^.Lo:=fBus.Load(self,aAddress,8);
      PPasMPInt128Record(aBounce)^.Hi:=fBus.Load(self,aAddress+8,8);
     end;
     else begin
      if aReadOnly then begin
       SetException(TExceptionValue.LoadAddressMisaligned,aAddress,fState.PC);
      end else begin
       SetException(TExceptionValue.StoreAddressMisaligned,aAddress,fState.PC);
      end;
     end;
    end;
   end;
  end;
 end else begin
  if aReadOnly then begin
   SetException(TExceptionValue.LoadAddressMisaligned,aAddress,fState.PC);
  end else begin
   SetException(TExceptionValue.StoreAddressMisaligned,aAddress,fState.PC);
  end;
  result:=nil;
 end;

end;

procedure TPasRISCV.THART.RMWCommit(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aBounce:Pointer);
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Write=VPN) and (((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE) then begin
  if assigned(aBounce) then begin
   case aSize of
    4:begin
     PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=PPasRISCVUInt32(aBounce)^;
    end;
    8:begin
     PPasRISCVUInt64(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=PPasRISCVUInt64(aBounce)^;
    end;
    16:begin
     PPasMPInt128Record(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryWrite{$endif}+aAddress)))^:=PPasMPInt128Record(aBounce)^;
    end;
    else begin
     SetException(TExceptionValue.StoreAddressMisaligned,aAddress,fState.PC);
    end;
   end;
  end;
  exit;
 end;

 if ((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[TMMU.TAccessFlag.NoTrap,TMMU.TAccessFlag.DirectMemoryPointer]);
  if (fState.ExceptionValue=TExceptionValue.None) and assigned(aBounce) then begin
   case aSize of
    1,2,4,8:begin
     fBus.Store(self,TranslatedAddress,PPasRISCVUInt32(aBounce)^,aSize);
    end;
    16:begin
     fBus.Store(self,TranslatedAddress,PPasMPInt128Record(aBounce)^.Lo,8);
     fBus.Store(self,TranslatedAddress+8,PPasMPInt128Record(aBounce)^.Hi,8);
    end;
    else begin
     SetException(TExceptionValue.StoreAddressMisaligned,aAddress,fState.PC);
    end;
   end;
  end;
 end else begin
  SetException(TExceptionValue.StoreAddressMisaligned,aAddress,fState.PC);
 end;

end;

function TPasRISCV.THART.Load(const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):TPasRISCVUInt64;
var TranslatedAddress,PartSize:TPasRISCVUInt64;
begin
 if ((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Load,[]);
  if fState.ExceptionValue<>TExceptionValue.None then begin
   result:=0;
  end else begin
   case aSize of
    3:begin
     result:=TPasRISCVUInt64(fBus.Load(self,TranslatedAddress,2));
     if fState.ExceptionValue=TExceptionValue.None then begin
      result:=result or (TPasRISCVUInt64(TPasRISCVUInt8(fBus.Load(self,TranslatedAddress+2,1))) shl 16);
     end;
    end;
    5:begin
     result:=TPasRISCVUInt32(fBus.Load(self,TranslatedAddress,4));
     if fState.ExceptionValue=TExceptionValue.None then begin
      result:=result or (TPasRISCVUInt64(TPasRISCVUInt8(fBus.Load(self,TranslatedAddress+4,1))) shl 32);
     end;
    end;
    6:begin
     result:=TPasRISCVUInt32(fBus.Load(self,TranslatedAddress,4));
     if fState.ExceptionValue=TExceptionValue.None then begin
      result:=result or (TPasRISCVUInt64(TPasRISCVUInt16(fBus.Load(self,TranslatedAddress+4,2))) shl 32);
     end;
    end;
    7:begin
     result:=TPasRISCVUInt32(fBus.Load(self,TranslatedAddress,4));
     if fState.ExceptionValue=TExceptionValue.None then begin
      result:=result or (TPasRISCVUInt64(TPasRISCVUInt16(fBus.Load(self,TranslatedAddress+4,2))) shl 32);
      if fState.ExceptionValue=TExceptionValue.None then begin
       result:=result or (TPasRISCVUInt64(TPasRISCVUInt8(fBus.Load(self,TranslatedAddress+6,1))) shl 48);
      end;
     end;
    end;
    else begin
     result:=fBus.Load(self,TranslatedAddress,aSize);
    end;
   end;
  end;
 end else begin
  PartSize:=PAGE_SIZE-(aAddress and PAGE_MASK);
  result:=Load(aAddress,PartSize) and ((TPasRISCVUInt64(1) shl (PartSize shl 3))-1);
  if fState.ExceptionValue=TExceptionValue.None then begin
   result:=result or ((Load(aAddress+PartSize,aSize-PartSize) and ((TPasRISCVUInt64(1) shl ((aSize-PartSize) shl 3))-1)) shl (PartSize shl 3));
  end;
 end;
end;

procedure TPasRISCV.THART.Store(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
var TranslatedAddress,PartSize:TPasRISCVUInt64;
begin
 if ((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Store,[]);
  if fState.ExceptionValue=TExceptionValue.None then begin
   case aSize of
    3:begin
     fBus.Store(self,TranslatedAddress,(aValue shr 0) and TPasRISCVUInt64($ffff),2);
     if fState.ExceptionValue=TExceptionValue.None then begin
      fBus.Store(self,TranslatedAddress+2,(aValue shr 16) and TPasRISCVUInt64($ff),1);
     end;
    end;
    5:begin
     fBus.Store(self,TranslatedAddress,(aValue shr 0) and TPasRISCVUInt64($ffffffff),4);
     if fState.ExceptionValue=TExceptionValue.None then begin
      fBus.Store(self,TranslatedAddress+4,(aValue shr 32) and TPasRISCVUInt64($ff),1);
     end;
    end;
    6:begin
     fBus.Store(self,TranslatedAddress,(aValue shr 0) and TPasRISCVUInt64($ffffffff),4);
     if fState.ExceptionValue=TExceptionValue.None then begin
      fBus.Store(self,TranslatedAddress+4,(aValue shr 32) and TPasRISCVUInt64($ffff),2);
     end;
    end;
    7:begin
     fBus.Store(self,TranslatedAddress,(aValue shr 0) and TPasRISCVUInt64($ffffffff),4);
     if fState.ExceptionValue=TExceptionValue.None then begin
      fBus.Store(self,TranslatedAddress+4,(aValue shr 32) and TPasRISCVUInt64($ffff),2);
      if fState.ExceptionValue=TExceptionValue.None then begin
       fBus.Store(self,TranslatedAddress+6,(aValue shr 48) and TPasRISCVUInt64($ff),1);
      end;
     end;
    end;
    else begin
     fBus.Store(self,TranslatedAddress,aValue,aSize);
    end;
   end;
  end;
 end else begin
  PartSize:=PAGE_SIZE-(aAddress and PAGE_MASK);
  Store(aAddress,aValue and ((TPasRISCVUInt64(1) shl (PartSize shl 3))-1),PartSize);
  if fState.ExceptionValue=TExceptionValue.None then begin
   Store(aAddress+PartSize,(aValue shr (PartSize shl 3)) and ((TPasRISCVUInt64(1) shl ((aSize-PartSize) shl 3))-1),aSize-PartSize);
  end;
 end;
end;

function TPasRISCV.THART.LoadEx(const aAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
var TranslatedAddress,PartSize,PartValue:TPasRISCVUInt64;
begin
 result:=false;
 if ((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.DebuggerLoad,[TMMU.TAccessFlag.IgnoreMMUProtection,TMMU.TAccessFlag.NoTrap]);
  if TranslatedAddress<>0 then begin
   case aSize of
    3:begin
     if not fBus.LoadEx(TranslatedAddress,PartValue,2) then begin
      aValue:=0;
      exit;
     end;
     aValue:=PartValue and TPasRISCVUInt64($ffff);
     if not fBus.LoadEx(TranslatedAddress+2,PartValue,1) then begin
      aValue:=0;
      exit;
     end;
     aValue:=aValue or ((PartValue and TPasRISCVUInt64($ff)) shl 16);
    end;
    5:begin
     if not fBus.LoadEx(TranslatedAddress,PartValue,4) then begin
      aValue:=0;
      exit;
     end;
     aValue:=PartValue and TPasRISCVUInt64($ffffffff);
     if not fBus.LoadEx(TranslatedAddress+4,PartValue,1) then begin
      aValue:=0;
      exit;
     end;
     aValue:=aValue or ((PartValue and TPasRISCVUInt64($ff)) shl 32);
    end;
    6:begin
     if not fBus.LoadEx(TranslatedAddress,PartValue,4) then begin
      aValue:=0;
      exit;
     end;
     aValue:=PartValue and TPasRISCVUInt64($ffffffff);
     if not fBus.LoadEx(TranslatedAddress+4,PartValue,2) then begin
      aValue:=0;
      exit;
     end;
     aValue:=aValue or ((PartValue and TPasRISCVUInt64($ffff)) shl 32);
    end;
    7:begin
     if not fBus.LoadEx(TranslatedAddress,PartValue,4) then begin
      aValue:=0;
      exit;
     end;
     aValue:=PartValue and TPasRISCVUInt64($ffffffff);
     if not fBus.LoadEx(TranslatedAddress+4,PartValue,2) then begin
      aValue:=0;
      exit;
     end;
     aValue:=aValue or ((PartValue and TPasRISCVUInt64($ffff)) shl 32);
     if not fBus.LoadEx(TranslatedAddress+6,PartValue,1) then begin
      aValue:=0;
      exit;
     end;
     aValue:=aValue or ((PartValue and TPasRISCVUInt64($ff)) shl 48);
    end;
    else begin
     if fBus.LoadEx(TranslatedAddress,PartValue,aSize) then begin
      aValue:=PartValue;
     end else begin
      aValue:=0;
      exit;
     end;
    end;
   end;
   result:=true;
  end;
 end else begin
  PartSize:=PAGE_SIZE-(aAddress and PAGE_MASK);
  if LoadEx(aAddress,PartValue,PartSize) then begin
   aValue:=PartValue and ((TPasRISCVUInt64(1) shl (PartSize shl 3))-1);
   if LoadEx(aAddress+PartSize,PartValue,aSize-PartSize) then begin
    aValue:=aValue or ((PartValue and ((TPasRISCVUInt64(1) shl ((aSize-PartSize) shl 3))-1)) shl (PartSize shl 3));
    result:=true;
   end;
  end;
 end;
end;

function TPasRISCV.THART.StoreEx(const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt64;const aSize:TPasRISCVUInt64):Boolean;
var TranslatedAddress,PartSize:TPasRISCVUInt64;
begin
 result:=false;
 if ((aAddress and PAGE_MASK)+aSize)<=PAGE_SIZE then begin
  TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.DebuggerStore,[TMMU.TAccessFlag.IgnoreMMUProtection,TMMU.TAccessFlag.NoTrap]);
  if TranslatedAddress<>0 then begin
   case aSize of
    3:begin
     if not fBus.StoreEx(TranslatedAddress,(aValue shr 0) and TPasRISCVUInt64($ffff),2) then begin
      exit;
     end;
     if not fBus.StoreEx(TranslatedAddress+2,(aValue shr 16) and TPasRISCVUInt64($ff),1) then begin
      exit;
     end;
    end;
    5:begin
     if not fBus.StoreEx(TranslatedAddress,(aValue shr 0) and TPasRISCVUInt64($ffffffff),4) then begin
      exit;
     end;
     if not fBus.StoreEx(TranslatedAddress+4,(aValue shr 32) and TPasRISCVUInt64($ff),1) then begin
      exit;
     end;
    end;
    6:begin
     if not fBus.StoreEx(TranslatedAddress,(aValue shr 0) and TPasRISCVUInt64($ffffffff),4) then begin
      exit;
     end;
     if not fBus.StoreEx(TranslatedAddress+4,(aValue shr 32) and TPasRISCVUInt64($ffff),2) then begin
      exit;
     end;
    end;
    7:begin
     if not fBus.StoreEx(TranslatedAddress,(aValue shr 0) and TPasRISCVUInt64($ffffffff),4) then begin
      exit;
     end;
     if not fBus.StoreEx(TranslatedAddress+4,(aValue shr 32) and TPasRISCVUInt64($ffff),2) then begin
      exit;
     end;
     if not fBus.StoreEx(TranslatedAddress+6,(aValue shr 48) and TPasRISCVUInt64($ff),1) then begin
      exit;
     end;
    end;
    else begin
     if not fBus.StoreEx(TranslatedAddress,aValue,aSize) then begin
      exit;
     end;
    end;
   end;
   result:=true;
  end;
 end else begin
  PartSize:=PAGE_SIZE-(aAddress and PAGE_MASK);
  if StoreEx(aAddress,aValue and ((TPasRISCVUInt64(1) shl (PartSize shl 3))-1),PartSize) and
     StoreEx(aAddress+PartSize,(aValue shr (PartSize shl 3)) and ((TPasRISCVUInt64(1) shl ((aSize-PartSize) shl 3))-1),aSize-PartSize) then begin
   result:=true;
  end;
 end;
end;

function TPasRISCV.THART.IsCSRENVCFGEnabled(const aMask:TPasRISCVUInt64):Boolean;
var Mask:TPasRISCVUInt64;
begin
 Mask:=aMask;
 if fState.Mode<TPasRISCV.THART.TMode.Machine then begin
  Mask:=Mask and fState.CSR.fData[TCSR.TAddress.MENVCFG];
 end;
 if fState.VirtualMode then begin
  Mask:=Mask and fState.CSR.fData[TCSR.TAddress.HENVCFG];
 end;
 if fState.Mode<TPasRISCV.THART.TMode.Supervisor then begin
  Mask:=Mask and fState.CSR.fData[TCSR.TAddress.SENVCFG];
 end;
 result:=Mask<>0;
end;

class function TPasRISCV.THART.CSROperation(const aOperation:TCSROperation;const aCSR,aRHS:TPasRISCVUInt64):TPasRISCVUInt64;
begin
 case aOperation of
  TCSROperation.Swap:begin
   result:=aRHS;
  end;
  TCSROperation.SetBits:begin
   result:=aCSR or aRHS;
  end;
  TCSROperation.ClearBits:begin
   result:=aCSR and not aRHS;
  end;
  else begin
   result:=aCSR;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerDefault(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue:TPasRISCVUInt64;
begin
 rd:=TRegister((aInstruction shr 7) and $1f);
 CSRValue:=fState.CSR.Load(aCSR);
 fState.CSR.Store(aCSR,CSROperation(aOperation,CSRValue,aRHS));
 {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
  fState.Registers[rd]:=CSRValue;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerDefaultReadOnly(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue:TPasRISCVUInt64;
begin
 rd:=TRegister((aInstruction shr 7) and $1f);
 CSRValue:=fState.CSR.Load(aCSR);
 {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
  fState.Registers[rd]:=CSRValue;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerPrivileged(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  CSRValue:=fState.CSR.Load(aCSR);
  fState.CSR.Store(aCSR,CSROperation(aOperation,CSRValue,aRHS));
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerPrivilegedReadOnly(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  CSRValue:=fState.CSR.Load(aCSR);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerHPrivileged(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue:TPasRISCVUInt64;
begin
 if fState.VirtualMode then begin
  SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
 end else if fState.Mode<TPasRISCV.THART.TMode.Supervisor then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  CSRValue:=fState.CSR.Load(aCSR);
  fState.CSR.Store(aCSR,CSROperation(aOperation,CSRValue,aRHS));
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerHPrivilegedReadOnly(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue:TPasRISCVUInt64;
begin
 if fState.VirtualMode then begin
  SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
 end else if fState.Mode<TPasRISCV.THART.TMode.Supervisor then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  CSRValue:=fState.CSR.Load(aCSR);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerIllegal(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
begin
//writeln(aCSR);
 SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
end;

procedure TPasRISCV.THART.CSRHandlerEnforcedReadOnly(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue,OperationValue:TPasRISCVUInt64;
begin
 rd:=TRegister((aInstruction shr 7) and $1f);
 CSRValue:=fState.CSR.Load(aCSR);
 OperationValue:=CSROperation(aOperation,CSRValue,aRHS);
 if CSRValue<>OperationValue then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerFCSR(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue,OperationValue,FExceptions:TPasRISCVUInt64;
begin
 rd:=TRegister((aInstruction shr 7) and $1f);
 CSRValue:=fState.CSR.Load(aCSR);
 FExceptions:=fState.CSR.fData[THART.TCSR.TAddress.FFLAGS] and TPasRISCVUInt64(TCSR.TFPUExceptionMasks.Mask);
 OperationValue:=CSROperation(aOperation,CSRValue or FExceptions,aRHS);
 fState.CSR.SetFPURM(OperationValue and TPasRISCVUInt64(TCSR.TFloatingPointRoundingModes.Mask));
 fState.CSR.ClearFPUExceptions;
 fState.CSR.SetFPUException(OperationValue and TPasRISCVUInt64(TCSR.TFPUExceptionMasks.Mask));
 fState.CSR.fData[THART.TCSR.TAddress.FCSR]:=OperationValue and $ff;
 {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
  fState.Registers[rd]:=CSRValue and $ff;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerFFLAGS(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue,OperationValue,FExceptions:TPasRISCVUInt64;
begin
 rd:=TRegister((aInstruction shr 7) and $1f);
 CSRValue:=fState.CSR.Load(aCSR);
 FExceptions:=CSRValue and TPasRISCVUInt64(TCSR.TFPUExceptionMasks.Mask);
 OperationValue:=CSROperation(aOperation,FExceptions,aRHS);

 fState.CSR.ClearFPUExceptions;
 fState.CSR.SetFPUException(OperationValue and TPasRISCVUInt64(TCSR.TFPUExceptionMasks.Mask));

 fState.CSR.fData[THART.TCSR.TAddress.FCSR]:=(fState.CSR.fData[THART.TCSR.TAddress.FCSR] and not TPasRISCVUInt64(TCSR.TFPUExceptionMasks.Mask)) or (OperationValue and $ff);

 {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
  fState.Registers[rd]:=CSRValue and TPasRISCVUInt64(TCSR.TFPUExceptionMasks.Mask);
 end;

end;

procedure TPasRISCV.THART.CSRHandlerFRM(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue,OperationValue:TPasRISCVUInt64;
begin

 rd:=TRegister((aInstruction shr 7) and $1f);
 CSRValue:=fState.CSR.fData[THART.TCSR.TAddress.FCSR] shr 5;
 OperationValue:=CSROperation(aOperation,CSRValue,aRHS);

 fState.CSR.ClearFPURM;
 fState.CSR.SetFPURM(OperationValue and TPasRISCVUInt64(TCSR.TFloatingPointRoundingModes.Mask));

 fState.CSR.fData[THART.TCSR.TAddress.FCSR]:=((fState.CSR.fData[THART.TCSR.TAddress.FCSR] and not $e0) or (OperationValue shl 5)) and $ff;

 {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
  fState.Registers[rd]:=CSRValue and TPasRISCVUInt64(TCSR.TFloatingPointRoundingModes.Mask);
 end;

end;

procedure TPasRISCV.THART.CSRHandlerSATP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue:TPasRISCVUInt64;
begin
 if fState.VirtualMode and ((fState.CSR.fData[TCSR.TAddress.HSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.VTVM))<>0) then begin
  // VS-mode with VTVM: VirtualInstruction trap
  SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
 end else if (not fState.VirtualMode) and ((fState.CSR.fData[TCSR.TAddress.MSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.TVM))<>0) then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  CSRValue:=fState.CSR.Load(aCSR);
  fState.CSR.Store(aCSR,CSROperation(aOperation,CSRValue,aRHS));
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
  UpdateMMU;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerSTATUS(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Status,OldStatus,OutStatus,fs,vs,xs,Mask:TPasRISCVUInt64;
begin

 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin

  if aCSR=TCSR.TAddress.MSTATUS then begin
   Mask:=TCSR.TMask.MSTATUS;
  end else begin
   Mask:=TCSR.TMask.SSTATUS;
  end;

  rd:=TRegister((aInstruction shr 7) and $1f);

  Status:=fState.CSR.fData[TCSR.TAddress.MSTATUS];

  OldStatus:=Status;

  fs:=(Status shr 13) and 3;
  vs:=(Status shr 9) and 3;
  if fs<vs then begin
   xs:=vs;
  end else begin
   xs:=fs;
  end;

  Status:=(Status and not (TPasRISCVUInt64(3) shl 15)) or ((xs and 3) shl 15);

  OutStatus:=Status and Mask;

  Status:=(Status and not Mask) or (CSROperation(aOperation,Status,aRHS) and Mask);

  if xs=TCSR.TFS.Dirty then begin
   // XS is dirty, set SD bit
   OutStatus:=OutStatus or TCSR.TMask.TStatus.SD;
  end;

  if Status<>OldStatus then begin
   // Verify UXL and SXL for RV64
   if ((Status shr 32) and 3)<>2 then begin
    Status:=(Status and not (TPasRISCVUInt64(3) shl 32)) or (TPasRISCVUInt64(2) shl 32);
   end;
   if ((Status shr 34) and 3)<>2 then begin
    Status:=(Status and not (TPasRISCVUInt64(3) shl 34)) or (TPasRISCVUInt64(2) shl 34);
   end;
  end;

  if THART.TMode((Status shr 11) and 3)=THART.TMode.Hypervisor then begin
   // Validate MPP
   Status:=(Status and not (TPasRISCVUInt64(3) shl TCSR.TMask.TMSTATUSBit.MPP)) or (TPasRISCVUInt64(THART.TMode.User) shl 11);
  end;

  if ((Status and $a) and not (OldStatus and $a))<>0 then begin
   // MIE/SIE were enabled, check interrupts
   CheckInterrupts;
  end;

  fState.CSR.fData[TCSR.TAddress.MSTATUS]:=Status;

  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=OutStatus;
  end;

 end;

end;

procedure TPasRISCV.THART.CSRHandlerSTIMECMP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else if fState.VirtualMode then begin
  // V=1: sstc predicate - need mcounteren.TM && menvcfg.STCE && hcounteren.TM && henvcfg.STCE
  if ((fState.CSR.fData[TCSR.TAddress.MCOUNTEREN] and TCSR.COUNTEREN_TM)=0) or
     ((fState.CSR.fData[TCSR.TAddress.MENVCFG] and TCSR.ENVCFG_STCE)=0) then begin
   SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
  end else if ((fState.CSR.fData[TCSR.TAddress.HCOUNTEREN] and TCSR.COUNTEREN_TM)=0) or
              ((fState.CSR.fData[TCSR.TAddress.HENVCFG] and TCSR.ENVCFG_STCE)=0) then begin
   SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
  end else if (fState.CSR.fData[TCSR.TAddress.HVICTL] and TCSR.HVICTL_VTI)<>0 then begin
   // hvictl.VTI=1: trap instead of redirect
   SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
  end else begin
   rd:=TRegister((aInstruction shr 7) and $1f);
   CSRValue:=fVSTIMECMP;
   fState.CSR.Store(TCSR.TAddress.VSTIMECMP,CSROperation(aOperation,CSRValue,aRHS));
   if (fMachine.fACLINTDevice.GetTime+fState.CSR.fData[TCSR.TAddress.HTIMEDELTA])>=fVSTIMECMP then begin
    RaiseInterrupt(TInterruptValue.HypervisorTimer);
   end else begin
    ClearInterrupt(TInterruptValue.HypervisorTimer);
   end;
   {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
    fState.Registers[rd]:=CSRValue;
   end;
  end;
 end else begin
  // Non-virtual S/HS/M-mode: sstc predicate - M-mode always allowed, S-mode needs mcounteren.TM && menvcfg.STCE
  if (fState.Mode<TPasRISCV.THART.TMode.Machine) and
     (((fState.CSR.fData[TCSR.TAddress.MCOUNTEREN] and TCSR.COUNTEREN_TM)=0) or
      ((fState.CSR.fData[TCSR.TAddress.MENVCFG] and TCSR.ENVCFG_STCE)=0)) then begin
   SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
  end else begin
   rd:=TRegister((aInstruction shr 7) and $1f);
   CSRValue:=fState.CSR.Load(aCSR);
   fState.CSR.Store(aCSR,CSROperation(aOperation,CSRValue,aRHS));
   if fMachine.fACLINTDevice.GetTime>=fSTIMECMP then begin
    RaiseInterrupt(TInterruptValue.SupervisorTimer);
   end else begin
    ClearInterrupt(TInterruptValue.SupervisorTimer);
   end;
   {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
    fState.Registers[rd]:=CSRValue;
   end;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerVSTIMECMP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    CSRValue:TPasRISCVUInt64;
begin
 if fState.VirtualMode then begin
  // VS-mode cannot directly access VSTIMECMP CSR
  SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
 end else if fState.Mode<TPasRISCV.THART.TMode.Supervisor then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  // HS/M-mode: sstc predicate for VSTIMECMP - M-mode always allowed, HS needs mcounteren.TM && menvcfg.STCE
  if (fState.Mode<TPasRISCV.THART.TMode.Machine) and
     (((fState.CSR.fData[TCSR.TAddress.MCOUNTEREN] and TCSR.COUNTEREN_TM)=0) or
      ((fState.CSR.fData[TCSR.TAddress.MENVCFG] and TCSR.ENVCFG_STCE)=0)) then begin
   SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
  end else begin
   // HS-mode access to VSTIMECMP (hypervisor sets guest timer)
   rd:=TRegister((aInstruction shr 7) and $1f);
   CSRValue:=fVSTIMECMP;
   fState.CSR.Store(TCSR.TAddress.VSTIMECMP,CSROperation(aOperation,CSRValue,aRHS));
   if (fMachine.fACLINTDevice.GetTime+fState.CSR.fData[TCSR.TAddress.HTIMEDELTA])>=fVSTIMECMP then begin
    RaiseInterrupt(TInterruptValue.HypervisorTimer);
   end else begin
    ClearInterrupt(TInterruptValue.HypervisorTimer);
   end;
   {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
    fState.Registers[rd]:=CSRValue;
   end;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerMIE(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Value,CSRValue:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  Value:=fState.CSR.fData[TCSR.TAddress.MIE];
  CSRValue:=CSROperation(aOperation,Value and TCSR.CSR_MEIP_MASK,aRHS) and TCSR.CSR_MEIP_MASK;
  fState.CSR.fData[TCSR.TAddress.MIE]:=(CSRValue and TCSR.CSR_MEIP_MASK) or (Value and not TCSR.CSR_MEIP_MASK);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
  Checkinterrupts;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerSIE(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Value,CSRValue,AliasMask:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else if fState.VirtualMode then begin
  // V=1: sie redirects to vsie (MIE bits filtered by HIDELEG)
  if (fState.CSR.fData[TCSR.TAddress.HVICTL] and TCSR.HVICTL_VTI)<>0 then begin
   SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
  end else begin
   rd:=TRegister((aInstruction shr 7) and $1f);
   AliasMask:=fState.CSR.fData[TCSR.TAddress.HIDELEG] and $222; // VS-level interrupt enable bits
   Value:=fState.CSR.fData[TCSR.TAddress.MIE] and AliasMask;
   CSRValue:=CSROperation(aOperation,Value,aRHS) and AliasMask;
   fState.CSR.fData[TCSR.TAddress.MIE]:=(fState.CSR.fData[TCSR.TAddress.MIE] and not AliasMask) or CSRValue;
   {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
    fState.Registers[rd]:=Value;
   end;
   Checkinterrupts;
  end;
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  Value:=fState.CSR.fData[TCSR.TAddress.MIE];
  CSRValue:=CSROperation(aOperation,Value and TCSR.CSR_SEIP_MASK,aRHS) and TCSR.CSR_SEIP_MASK;
  fState.CSR.fData[TCSR.TAddress.MIE]:=(CSRValue and TCSR.CSR_SEIP_MASK) or (Value and not TCSR.CSR_SEIP_MASK);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
  Checkinterrupts;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerMIP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Value,CSRValue:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  Value:=fState.CSR.fData[TCSR.TAddress.MIP];
  CSRValue:=CSROperation(aOperation,Value and TCSR.CSR_MEIP_MASK,aRHS) and TCSR.CSR_MEIP_MASK;
  fState.CSR.fData[TCSR.TAddress.MIP]:=(CSRValue and TCSR.CSR_MEIP_MASK) or (Value and not TCSR.CSR_MEIP_MASK);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   CSRValue:=CSRValue or (fState.PendingIRQs and TCSR.CSR_MEIP_MASK);
   fState.Registers[rd]:=CSRValue;
  end;
  Checkinterrupts;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerSIP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Value,CSRValue:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else if fState.VirtualMode then begin
  // V=1: sip redirects to vsip (HVIP bits filtered by HIDELEG), only VSSIP writable
  if (fState.CSR.fData[TCSR.TAddress.HVICTL] and TCSR.HVICTL_VTI)<>0 then begin
   SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
  end else begin
   rd:=TRegister((aInstruction shr 7) and $1f);
   // V=1: sip reads (hvip | mip) filtered by hideleg (matching QEMU/Spike)
   Value:=(fState.CSR.fData[TCSR.TAddress.HVIP] or fState.CSR.fData[TCSR.TAddress.MIP]) and fState.CSR.fData[TCSR.TAddress.HIDELEG];
   CSRValue:=CSROperation(aOperation,Value,aRHS) and $4; // Only VSSIP (bit 2) writable
   fState.CSR.fData[TCSR.TAddress.HVIP]:=(fState.CSR.fData[TCSR.TAddress.HVIP] and not TPasRISCVUInt64($4)) or CSRValue;
   {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
    fState.Registers[rd]:=Value;
   end;
   Checkinterrupts;
  end;
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  Value:=fState.CSR.fData[TCSR.TAddress.MIP];
  CSRValue:=CSROperation(aOperation,Value and TCSR.CSR_SEIP_MASK,aRHS) and TCSR.CSR_SEIP_MASK;
  fState.CSR.fData[TCSR.TAddress.MIP]:=(CSRValue and TCSR.CSR_SEIP_MASK) or (Value and not TCSR.CSR_SEIP_MASK);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   CSRValue:=CSRValue or (fState.PendingIRQs and TCSR.CSR_SEIP_MASK);
   fState.Registers[rd]:=CSRValue;
  end;
  Checkinterrupts;
 end;
end;

// ============================================================================
// H-extension CSR handlers
// ============================================================================

procedure TPasRISCV.THART.CSRHandlerHSTATUS(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Value,CSRValue:TPasRISCVUInt64;
begin
 if fState.VirtualMode then begin
  SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
 end else if fState.Mode<TPasRISCV.THART.TMode.Supervisor then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  Value:=fState.CSR.fData[TCSR.TAddress.HSTATUS];
  CSRValue:=CSROperation(aOperation,Value,aRHS);
  // Mask writable bits; force VSXL=2 on read
  CSRValue:=(CSRValue and TCSR.TMask.HSTATUS_MASK) or (TPasRISCVUInt64(2) shl TCSR.TMask.THSTATUSBit.VSXL);
  fState.CSR.fData[TCSR.TAddress.HSTATUS]:=CSRValue;
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=Value or (TPasRISCVUInt64(2) shl TCSR.TMask.THSTATUSBit.VSXL);
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerHIP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Value,CSRValue:TPasRISCVUInt64;
begin
 if fState.VirtualMode then begin
  SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
 end else if fState.Mode<TPasRISCV.THART.TMode.Supervisor then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  // hip reflects VS-level pending interrupts: (hvip | mip) projected through hideleg
  Value:=(fState.CSR.fData[TCSR.TAddress.HVIP] or fState.CSR.fData[TCSR.TAddress.MIP]) and fState.CSR.fData[TCSR.TAddress.HIDELEG];
  // Only VSSIP (bit 2) is writable via hip
  CSRValue:=CSROperation(aOperation,Value,aRHS) and $4;
  fState.CSR.fData[TCSR.TAddress.HVIP]:=(fState.CSR.fData[TCSR.TAddress.HVIP] and not TPasRISCVUInt64($4)) or CSRValue;
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=Value;
  end;
  CheckInterrupts;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerHIE(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Value,CSRValue:TPasRISCVUInt64;
begin
 if fState.VirtualMode then begin
  SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
 end else if fState.Mode<TPasRISCV.THART.TMode.Supervisor then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  Value:=fState.CSR.fData[TCSR.TAddress.HIE];
  CSRValue:=CSROperation(aOperation,Value,aRHS) and $1444;
  fState.CSR.fData[TCSR.TAddress.HIE]:=CSRValue;
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=Value;
  end;
  CheckInterrupts;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerHVIP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Value,CSRValue:TPasRISCVUInt64;
begin
 if fState.VirtualMode then begin
  SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
 end else if fState.Mode<TPasRISCV.THART.TMode.Supervisor then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  Value:=fState.CSR.fData[TCSR.TAddress.HVIP];
  CSRValue:=CSROperation(aOperation,Value,aRHS);
  // Only VS-level interrupt bits (2, 6, 10) are writable
  fState.CSR.fData[TCSR.TAddress.HVIP]:=CSRValue and $444;
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=Value;
  end;
  CheckInterrupts;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerVSCSR(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
// Generic handler for VS-mode CSRs: vstvec, vsscratch, vsepc, vscause, vstval, vsatp
// When V=1, these alias to actual S-CSRs (swap already done). When V=0, they access VS backing store.
var rd:TRegister;
    Value,CSRValue:TPasRISCVUInt64;
begin
 if fState.VirtualMode then begin
  // VS-mode cannot access VS* CSRs directly (they're S-CSRs from VS perspective)
  SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
 end else if fState.Mode<TPasRISCV.THART.TMode.Supervisor then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  Value:=fState.CSR.Load(aCSR);
  CSRValue:=CSROperation(aOperation,Value,aRHS);
  fState.CSR.Store(aCSR,CSRValue);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=Value;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerVSSTATUS(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Value,CSRValue:TPasRISCVUInt64;
begin
 if fState.VirtualMode then begin
  SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
 end else if fState.Mode<TPasRISCV.THART.TMode.Supervisor then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  Value:=fState.CSR.fData[TCSR.TAddress.VSSTATUS];
  CSRValue:=CSROperation(aOperation,Value,aRHS) and TCSR.TMask.SSTATUS;
  // Force UXL=2
  CSRValue:=(CSRValue and not TPasRISCVUInt64($300000000)) or TPasRISCVUInt64($200000000);
  fState.CSR.fData[TCSR.TAddress.VSSTATUS]:=CSRValue;
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=Value;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerVSIP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Value,CSRValue:TPasRISCVUInt64;
begin
 if fState.VirtualMode then begin
  SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
 end else if fState.Mode<TPasRISCV.THART.TMode.Supervisor then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  // vsip shows pending VS-level interrupts: (hvip | mip) filtered by hideleg
  Value:=(fState.CSR.fData[TCSR.TAddress.HVIP] or fState.CSR.fData[TCSR.TAddress.MIP]) and fState.CSR.fData[TCSR.TAddress.HIDELEG];
  // Only VSSIP (bit 2) writable
  CSRValue:=CSROperation(aOperation,Value,aRHS) and $4;
  fState.CSR.fData[TCSR.TAddress.HVIP]:=(fState.CSR.fData[TCSR.TAddress.HVIP] and not TPasRISCVUInt64($4)) or CSRValue;
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=Value;
  end;
  CheckInterrupts;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerVSIE(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Value,CSRValue:TPasRISCVUInt64;
begin
 if fState.VirtualMode then begin
  SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
 end else if fState.Mode<TPasRISCV.THART.TMode.Supervisor then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  // vsie shows enabled VS-level interrupts filtered by hideleg
  Value:=fState.CSR.fData[TCSR.TAddress.HIE] and fState.CSR.fData[TCSR.TAddress.HIDELEG];
  // Only hideleg-delegated bits are writable
  CSRValue:=CSROperation(aOperation,Value,aRHS) and fState.CSR.fData[TCSR.TAddress.HIDELEG];
  fState.CSR.fData[TCSR.TAddress.HIE]:=(fState.CSR.fData[TCSR.TAddress.HIE] and not fState.CSR.fData[TCSR.TAddress.HIDELEG]) or CSRValue;
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=Value;
  end;
  CheckInterrupts;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerHGATP(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    Value,CSRValue,GStageMode:TPasRISCVUInt64;
begin
 if fState.VirtualMode then begin
  SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
 end else if fState.Mode<TPasRISCV.THART.TMode.Supervisor then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else if (fState.Mode=TPasRISCV.THART.TMode.Supervisor) and ((fState.CSR.fData[TCSR.TAddress.MSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.TVM))<>0) then begin
  // TVM=1 in mstatus: hgatp access traps from HS-mode
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  Value:=fState.CSR.fData[TCSR.TAddress.HGATP];
  CSRValue:=CSROperation(aOperation,Value,aRHS);
  // WARL: validate mode field - only Bare(0), Sv39x4(8), Sv48x4(9), Sv57x4(10) are valid
  GStageMode:=(CSRValue shr 60) and $f;
  if not (GStageMode in [0,8,9,10]) then begin
   // Invalid mode: keep old value (QEMU/Spike behavior)
   CSRValue:=Value;
  end;
  fState.CSR.fData[TCSR.TAddress.HGATP]:=CSRValue;
  FlushTLB(true);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=Value;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerMTOPI(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    PendingValue,CSRValue,IRQ:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  PendingValue:=InterruptsPending and TCSR.CSR_MEIP_MASK;
  if PendingValue<>0 then begin
   IRQ:=CLZDWord(PendingValue) xor 31;
  end else begin
   IRQ:=0;
  end;
  CSRValue:=(ord(IRQ<>0) and 1) or (IRQ shl 16);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerSTOPI(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    PendingValue,CSRValue,IRQ:TPasRISCVUInt64;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  // TODO-AIA: For V=1, redirect STOPI access to VSTOPI (guest view) instead of HS STOPI semantics.
  rd:=TRegister((aInstruction shr 7) and $1f);
  PendingValue:=InterruptsPending and TCSR.CSR_SEIP_MASK;
  if PendingValue<>0 then begin
   IRQ:=CLZDWord(PendingValue) xor 31;
  end else begin
   IRQ:=0;
  end;
  CSRValue:=(ord(IRQ<>0) and 1) or (IRQ shl 16);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerMTOPEI(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    IRQ,CSRValue:TPasRISCVUInt64;
    IsWrite:Boolean;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  IsWrite:=(rd<>TRegister.Zero) or (aOperation=TCSROperation.Swap);
  IRQ:=GetAIAIRQ(TPasRISCV.TAIARegFileMode.Machine,IsWrite);
  CSRValue:=IRQ or (IRQ shl 16);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerSTOPEI(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    IRQ,CSRValue:TPasRISCVUInt64;
    IsWrite:Boolean;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  // TODO-AIA: For V=1, redirect STOPEI access to VSTOPEI (guest IMSIC file) instead of HS STOPEI semantics.
  rd:=TRegister((aInstruction shr 7) and $1f);
  IsWrite:=(rd<>TRegister.Zero) or (aOperation=TCSROperation.Swap);
  IRQ:=GetAIAIRQ(TPasRISCV.TAIARegFileMode.Supervisor,IsWrite);
  CSRValue:=IRQ or (IRQ shl 16);
  {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
   fState.Registers[rd]:=CSRValue;
  end;
 end;
end;

class function TPasRISCV.THART.CSRAtomicHelper(const aValue:PPasRISCVUInt32;const aRHS:TPasRISCVUInt64;out aDest:TPasRISCVUInt64;const aOperation:TCSROperation):Boolean;
begin
 case aOperation of
  TCSROperation.Swap:begin
   aDest:=TPasRISCVUInt32(TPasMPInterlocked.Exchange(aValue^,TPasRISCVUInt32(aRHS)));
   result:=true;
  end;
  TCSROperation.SetBits:begin
   if aRHS<>0 then begin
    aDest:=TPasRISCVUInt32(TPasMPInterlocked.ExchangeBitwiseOr(aValue^,TPasRISCVUInt32(aRHS)));
    result:=true;
   end else begin
    aDest:=TPasRISCVUInt32(TPasMPInterlocked.Read(aValue^));
    result:=false;
   end;
  end;
  TCSROperation.ClearBits:begin
   if aRHS<>0 then begin
    aDest:=TPasRISCVUInt32(TPasMPInterlocked.ExchangeBitwiseAnd(aValue^,not TPasRISCVUInt32(aRHS)));
    result:=true;
   end else begin
    aDest:=TPasRISCVUInt32(TPasMPInterlocked.Read(aValue^));
    result:=false;
   end;
  end;
  else begin
   result:=false;
  end;
 end;
end;

function TPasRISCV.THART.CSRAIAHelper(const aMode:TMode;const aAIARegFileMode:TAIARegFileMode;const aValue:PPasRISCVUInt32;const aRHS:TPasRISCVUInt64;out aDest:TPasRISCVUInt64;const aOperation:TCSROperation):Boolean;
begin
 if CSRAtomicHelper(aValue,aRHS,aDest,aOperation) then begin
  UpdateAIAState(aAIARegFileMode);
 end;
 result:=true;
end;

function TPasRISCV.THART.CSRAIAPairHelper(const aMode:TMode;const aAIARegFileMode:TAIARegFileMode;const aReg:TPasRISCVUInt32;const aValue:Pointer;const aRHS:TPasRISCVUInt64;out aDest:TPasRISCVUInt64;const aOperation:TCSROperation):Boolean;
var Top:TPasRISCVUInt64;
begin
 if (aReg and 1)=0 then begin
  if (aReg+1)<TAIARegFile.ARRAY_LENGTH then begin
   CSRAIAHelper(aMode,aAIARegFileMode,@PPasRISCVUInt32Array(aValue)^[aReg],TPasRISCVUInt32(aRHS),aDest,aOperation);
   CSRAIAHelper(aMode,aAIARegFileMode,@PPasRISCVUInt32Array(aValue)^[aReg+1],TPasRISCVUInt32(TPasRISCVUInt64(aRHS shr 32)),Top,aOperation);
   aDest:=aDest or (Top shl 32);
   result:=true;
  end else begin
   result:=false;
  end;
 end else begin
  result:=false;
 end;
end;

procedure TPasRISCV.THART.CSRHandlerIndirect(const aPC,aInstruction,aCSR,aRHS:TPasRISCVUInt64;const aOperation:TCSROperation);
var rd:TRegister;
    OK:Boolean;
    ISelect,CSRValue,Reg:TPasRISCVUInt64;
    Mode:TPasRISCV.THART.TMode;
    AIARegFileMode:TPasRISCV.TAIARegFileMode;
begin
 if fState.Mode<TPasRISCV.THART.TMode((aCSR shr 8) and 3) then begin //if fState.Mode=TPasRISCV.THART.TMode.User then begin
  SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
 end else begin
  rd:=TRegister((aInstruction shr 7) and $1f);
  case aCSR of
   TCSR.TAddress.MIREG:begin
    Mode:=THART.TMode.Machine;
    AIARegFileMode:=TPasRISCV.TAIARegFileMode.Machine;
    ISelect:=fState.CSR.fData[TCSR.TAddress.MISELECT];
   end;
   TCSR.TAddress.SIREG:begin
    Mode:=THART.TMode.Supervisor;
    AIARegFileMode:=TPasRISCV.TAIARegFileMode.Supervisor;
    ISelect:=fState.CSR.fData[TCSR.TAddress.SISELECT];
   end;
   else begin
    Mode:=THART.TMode.Invalid;
    AIARegFileMode:=TPasRISCV.TAIARegFileMode.Machine;
    ISelect:=0;
   end;
  end;
  if Mode<>THART.TMode.Invalid then begin
   OK:=false;
   case ISelect of
    TCSR.CSRI_EIDELIVERY:begin
     if fMachine.fConfiguration.fAIA then begin
      OK:=CSRAIAHelper(Mode,AIARegFileMode,@fAIARegFiles[AIARegFileMode].fEIDelivery,aRHS and 1,CSRValue,aOperation);
      if OK then begin
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=CSRValue;
       end;
      end;
     end;
    end;
    TCSR.CSRI_EITHRESHOLD:begin
     if fMachine.fConfiguration.fAIA then begin
      OK:=CSRAIAHelper(Mode,AIARegFileMode,@fAIARegFiles[AIARegFileMode].fEIThreshold,aRHS,CSRValue,aOperation);
      if OK then begin
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=CSRValue;
       end;
      end;
     end;
    end;
    TCSR.CSRI_MIPRIO_0..TCSR.CSRI_MIPRIO_15:begin
     if fMachine.fConfiguration.fAIA then begin
      CSRValue:=0;
      {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
       fState.Registers[rd]:=CSRValue;
      end;
      OK:=true;
     end;
    end;
    TCSR.CSRI_EIP0..TCSR.CSRI_EIP63:begin
     if fMachine.fConfiguration.fAIA then begin
      Reg:=ISelect-TCSR.CSRI_EIP0;
      OK:=CSRAIAPairHelper(Mode,AIARegFileMode,Reg,@fAIARegFiles[AIARegFileMode].fEIP,aRHS,CSRValue,aOperation);
      if OK then begin
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=CSRValue;
       end;
      end;
     end;
    end;
    TCSR.CSRI_EIE0..TCSR.CSRI_EIE63:begin
     if fMachine.fConfiguration.fAIA then begin
      Reg:=ISelect-TCSR.CSRI_EIE0;
      CSRValue:=aRHS;
      OK:=CSRAIAPairHelper(Mode,AIARegFileMode,Reg,@fAIARegFiles[AIARegFileMode].fEIE,aRHS,CSRValue,aOperation);
      if OK then begin
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=CSRValue;
       end;
      end;
     end;
    end;
    else begin
     OK:=false;
    end;
   end;
   if not OK then begin
    SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
   end;
  end else begin
   SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
  end;
 end;
end;

procedure TPasRISCV.THART.SetFPUExceptions(const aMask:TPasRISCVUInt32=$3f);
var Exceptions:TPasRISCVUInt32;
begin
 Exceptions:=fetestexcept(FE_ALL_EXCEPT);
 if Exceptions<>0 then begin
  Exceptions:=Exceptions and aMask;
{ if (Exceptions and FE_INVALID)<>0 then begin // Invalid
   fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
  end;}
  if (Exceptions and FE_DIVBYZERO)<>0 then begin // Divide by zero
   fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.DivByZero);
  end;
  if (Exceptions and FE_OVERFLOW)<>0 then begin // Overflow
   fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Overflow);
  end;
  if (Exceptions and FE_UNDERFLOW)<>0 then begin // Underflow
   fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Underflow);
  end;
  if (Exceptions and FE_INEXACT)<>0 then begin // Inexact
   fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Inexact);
  end;
  feclearexcept(FE_ALL_EXCEPT);
 end;
end;

procedure TPasRISCV.THART.Breakpoint(const aInstruction:TPasRISCVUInt32);
begin
 if assigned(fMachine.fDebugger) and fMachine.fDebugger.Halt(self,fState.PC,aInstruction) then begin
  SetException(TExceptionValue.DebuggerBreakpoint,aInstruction,fState.PC);
 end else begin
  SetException(TExceptionValue.Breakpoint,aInstruction,fState.PC);
 end;
end;

function TPasRISCV.THART.FetchInstruction(const aAddress:TPasRISCVUInt64;out aInstruction:TPasRISCVUInt32):Boolean;
var VPN,TranslatedAddress:TPasRISCVUInt64;
    DirectAccessTLBEntry:TMMU.PDirectAccessTLBEntry;
begin

 VPN:=aAddress shr PAGE_SHIFT;
 DirectAccessTLBEntry:=@fDirectAccessTLBCache[VPN and TMMU.DIRECT_ACCESS_TLB_MASK];
 if (DirectAccessTLBEntry^.Execute=VPN) and (((aAddress and PAGE_MASK)+3)<PAGE_SIZE) then begin
{$ifdef Use16BitSplittedInstructionFetches}
  aInstruction:=PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryExecute{$endif}+aAddress)))^;
  if (aInstruction and 3)=3 then begin
   aInstruction:=aInstruction or (TPasRISCVUInt32(PPasRISCVUInt16(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryExecute{$endif}+aAddress+2)))^) shl 16);
  end;
{$else}
  aInstruction:=PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt({$ifdef CombinedDirectAccessTLBCache}DirectAccessTLBEntry^.RelativeMemory{$else}DirectAccessTLBEntry^.RelativeMemoryExecute{$endif}+aAddress)))^;
{$endif}
  result:=true;
  exit;
 end;

 TranslatedAddress:=AddressTranslate(aAddress,TMMU.TAccessType.Instruction,[]);
 if fState.ExceptionValue<>TExceptionValue.None then begin
  aInstruction:=0;
  result:=false;
  exit;
 end;

{$ifndef Use16BitSplittedInstructionFetches}
 if ((aAddress and PAGE_MASK)+3)<PAGE_SIZE then begin

  aInstruction:=TPasRISCVUInt32(fBus.Fetch(self,TranslatedAddress,4));

  result:=fState.ExceptionValue=TExceptionValue.None;

 end else{$endif}begin

  aInstruction:=TPasRISCVUInt32(fBus.Fetch(self,TranslatedAddress,2));
  if fState.ExceptionValue<>TExceptionValue.None then begin
   aInstruction:=0;
   result:=false;
   exit;
  end;

  if (aInstruction and 3)=3 then begin

   TranslatedAddress:=AddressTranslate(aAddress+2,TMMU.TAccessType.Instruction,[]);
   if fState.ExceptionValue<>TExceptionValue.None then begin
    aInstruction:=0;
    result:=false;
    exit;
   end;

   aInstruction:=aInstruction or (TPasRISCVUInt32(FBus.Fetch(self,TranslatedAddress,2)) shl 16);

   result:=fState.ExceptionValue=TExceptionValue.None;

  end else begin

   result:=true;

  end;

 end;

end;

function TPasRISCV.THART.GetInstructionSize(const aInstruction:TPasRISCVUInt32):TPasRISCVUInt64;
begin
 if (aInstruction and 3)=3 then begin
  result:=4; // Normal instruction
 end else begin
  result:=2; // Compressed instruction
 end;
end;

{$ifdef fpc}
 {$push}
 {$codealign jump=16}
 {$codealign loop=16}
 {$codealign proc=16}
{$endif}
function TPasRISCV.THART.ExecuteInstruction(const aInstruction:TPasRISCVUInt32):TPasRISCVUInt64;
// This function decodes and executes a single RISC-V instruction by using a simple but effective
// switch-based interpreter. This approach is chosen for its simplicity, portability, and ease of
// maintenance. The function is designed to be easily extensible to support additional instruction
// extensions and customizations. Direct/indirect threaded code, or other advanced techniques, could
// be used for improved performance, but would complicate the code and make it harder to maintain.
// However once JIT compilation is implemented later, the interpreter will be used only for the
// initial warm-up phase and for handling edge cases as well as more complex instructions, while the
// JIT-compiled code will be used for subsequent execution, providing a significant performance boost.
//
// Optimizations for Performance:
//
// - Jump Table Heuristics:
//     The code attempts to improve performance by encouraging the compiler to generate jump tables
//     for the top-level case statement (TryToForceCaseJumpTableOnLevel1) by using several equivalent
//     case values in a row, eg. "$00,$04,$08,$0c,$10,$14,.." instead only "$00" exploiting the fact
//     that the RISC-V instruction encoding uses the lower two bits for to distinguish between
//     compressed 16-bit and normal 32-bit instructions. This can potentially speed up instruction
//     decoding by reducing linear branch evaluations.
//     However, this optimization is compiler-dependent and might not always be effective, and
//     enabling jump tables for deeper case levels (e.g. TryToForceCaseJumpTableOnCompressedLevel2)
//     is currently disabled because it can have a negative impact on the performance at the moment.
//
// - Branch Prediction and Cache Locality:
//     Case statements should be ordered such that the most frequent instructions are placed at the
//     beginning. This improves both branch prediction accuracy and cache locality:
//       - Branch Prediction:
//           Frequent instructions are more likely to be predicted correctly, reducing mispredictions
//           and improving instruction pipeline flow.
//       - Cache Locality:
//           Keeping frequently executed code in the cache minimizes data access latency and improves
//           overall execution speed.
//
// - Early Exits:
//     The function utilizes `exit;` statements whenever possible to terminate execution after handling
//     an instruction. This avoids unnecessary jumps to the function's end, improving code locality and
//     potentially reducing cache misses.
//
// However, the effectiveness of these optimizations can vary depending on the specific CPU architecture,
// compiler version, and optimization settings used. The primary goal of these optimizations is to achieve
// a balance between performance and code maintainability.
{$define TryToForceCaseJumpTableOnLevel1}
{-$define TryToForceCaseJumpTableOnCompressedLevel2}
{-$define TryToForceCaseJumpTableOnLevel2}
var Address,Temporary,Offset{$ifdef UseExtraShAmt},ShAmt{$endif}:TPasRISCVUInt64;
    Immediate:TPasRISCVInt64;
    Ptr:Pointer;
    rd,rs1,rs2:TRegister;
    frd,frs1,frs2,frs3:TFPURegister;
    f32,f32n:TPasRISCVFloat;
    f64,f64n:TPasRISCVDouble;
    HalfFloat:TPasRISCVHalfFloat;
begin

 case {$ifdef TryToForceCaseJumpTableOnLevel1}TPasRISCVUInt8(aInstruction and $7f){$else}aInstruction and 3{$endif} of

  {$ifdef TryToForceCaseJumpTableOnLevel1}
   $00,$04,$08,$0c,$10,$14,$18,$1c,$20,$24,$28,$2c,$30,$34,$38,$3c,
   $40,$44,$48,$4c,$50,$54,$58,$5c,$60,$64,$68,$6c,$70,$74,$78,$7c,
   $80,$84,$88,$8c,$90,$94,$98,$9c,$a0,$a4,$a8,$ac,$b0,$b4,$b8,$bc,
   $c0,$c4,$c8,$cc,$d0,$d4,$d8,$dc,$e0,$e4,$e8,$ec,$f0,$f4,$f8,$fc:
  {$else}
   $00:
  {$endif}begin
   // Compressed quandrant 0
// case TPasRISCVUInt8((aInstruction shr 13) and {$ifdef TryToForceCaseJumpTableOnCompressedLevel2}$ff{$else}7{$endif}) of
   case {$ifdef TryToForceCaseJumpTableOnCompressedLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 13) and 7) of
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
     if aInstruction=0 then begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
      result:=4;
      exit;
     end else begin
      // c.addi4spn
      Immediate:=((aInstruction shr 1) and $3c0) or ((aInstruction shr 7) and $30) or ((aInstruction shr 2) and $08) or ((aInstruction shr 4) and $04);
      if Immediate<>0 then begin
       rd:=TRegister(((aInstruction shr 2) and $7)+8);
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=fState.Registers[TRegister.SP]+TPasRISCVUInt64(Immediate);
       end;
       result:=2;
       exit;
      end else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
       result:=2;
{$ifdef PasRISCVCPUFileDumpDebug}
       halt(0);
{$endif}
       exit;
      end;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
     // c.fld
     frd:=TFPURegister(((aInstruction shr 2) and $7)+8);
     rs1:=TRegister(((aInstruction shr 7) and $7)+8);
     Offset:=((aInstruction shl 1) and $c0) or ((aInstruction shr 7) and $38);
{$ifdef UseSpecializedRegisterLoadStores}
     LoadRegisterF64(frd,fState.Registers[rs1]+Offset);
{$else}
     Temporary:=Load64(fState.Registers[rs1]+Offset);
     if fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None then begin
      fState.FPURegisters[frd].ui64:=Temporary;
      fState.CSR.SetFSDirty;
     end;
{$endif}
//   SetFPUExceptions(FE_ALL_EXCEPT and not FE_INEXACT);
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
     // c.lw
     rd:=TRegister(((aInstruction shr 2) and $7)+8);
     rs1:=TRegister(((aInstruction shr 7) and $7)+8);
     Immediate:=((aInstruction shl 1) and $40) or ((aInstruction shr 7) and $38) or ((aInstruction shr 4) and $04);
{$ifdef UseSpecializedRegisterLoadStores}
     LoadRegisterS32(rd,fState.Registers[rs1]+TPasRISCVUInt64(Immediate));
{$else}
     Temporary:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Load32(fState.Registers[rs1]+TPasRISCVUInt64(Immediate)))));
     if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
      fState.Registers[rd]:=Temporary;
     end;
{$endif}
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
     // c.ld
     rd:=TRegister(((aInstruction shr 2) and $7)+8);
     rs1:=TRegister(((aInstruction shr 7) and $7)+8);
     Offset:=((aInstruction shl 1) and $c0) or ((aInstruction shr 7) and $38);
{$ifdef UseSpecializedRegisterLoadStores}
     LoadRegisterU64(rd,fState.Registers[rs1]+Offset);
{$else}
     Temporary:=Load64(fState.Registers[rs1]+Offset);
     if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
      fState.Registers[rd]:=Temporary;
     end;
{$endif}
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
     // Zcb
     case (aInstruction shr 10) and 7 of
      $0:begin
       // c.lbu (Zcb)
       rs1:=TRegister(((aInstruction shr 7) and $7)+8);
       Offset:=((aInstruction and $20) shr 4) or ((aInstruction and $40) shr 6);
{$ifdef UseSpecializedRegisterLoadStores}
       LoadRegisterU8(TRegister(((aInstruction shr 2) and $7)+8),fState.Registers[rs1]+Offset);
{$else}
       Temporary:=Load8(fState.Registers[rs1]+Offset);
       rd:=TRegister(((aInstruction shr 2) and $7)+8);
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=2;
       exit;
      end;
      $1:begin
       // c.lh/c.lhu (Zcb)
{$ifdef UseSpecializedRegisterLoadStores}
       rd:=TRegister(((aInstruction shr 2) and $7)+8);
{$endif}
       rs1:=TRegister(((aInstruction shr 7) and $7)+8);
       Offset:=(aInstruction and $20) shr 4;
       if (aInstruction and $40)<>0 then begin
        // c.lh (Zcb)
{$ifdef UseSpecializedRegisterLoadStores}
        LoadRegisterS16(rd,fState.Registers[rs1]+Offset);
{$else}
        Temporary:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Load16(fState.Registers[rs1]+Offset))));
{$endif}
       end else begin
        // c.lhu (Zcb)
{$ifdef UseSpecializedRegisterLoadStores}
        LoadRegisterU16(rd,fState.Registers[rs1]+Offset);
{$else}
        Temporary:=Load16(fState.Registers[rs1]+Offset);
{$endif}
       end;
{$ifndef UseSpecializedRegisterLoadStores}
       rd:=TRegister(((aInstruction shr 2) and $7)+8);
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=2;
       exit;
      end;
      $2:begin
       // c.sbu (Zcb)
       rd:=TRegister(((aInstruction shr 2) and $7)+8);
       rs1:=TRegister(((aInstruction shr 7) and $7)+8);
       Offset:=((aInstruction and $20) shr 4) or ((aInstruction and $40) shr 6);
       Store8(fState.Registers[rs1]+Offset,TPasRISCVUInt8(fState.Registers[rd]));
       result:=2;
       exit;
      end;
      $3:begin
       if (aInstruction and $40)=0 then begin
        // c.sh (Zcb)
        rd:=TRegister(((aInstruction shr 2) and $7)+8);
        rs1:=TRegister(((aInstruction shr 7) and $7)+8);
        Offset:=((aInstruction and $20) shr 4) or ((aInstruction and $40) shr 6);
        Store16(fState.Registers[rs1]+Offset,TPasRISCVUInt16(fState.Registers[rd]));
        result:=2;
        exit;
       end else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
        result:=2;
        exit;
       end;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
       result:=2;
       exit;
      end;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
     // c.fsd
     frd:=TFPURegister(((aInstruction shr 2) and $7)+8);
     rs1:=TRegister(((aInstruction shr 7) and $7)+8);
     Offset:=((aInstruction shl 1) and $c0) or ((aInstruction shr 7) and $38);
{$ifdef UseSpecializedRegisterLoadStores}
     StoreRegisterF64(fState.Registers[rs1]+Offset,frd);
{$else}
     Store64(fState.Registers[rs1]+Offset,fState.FPURegisters[frd].ui64);
{$endif}
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
     // c.sw
     rs1:=TRegister(((aInstruction shr 7) and $7)+8);
     rs2:=TRegister(((aInstruction shr 2) and $7)+8);
     Offset:=(((aInstruction shl 1) and $40) or ((aInstruction shr 7) and $38) or ((aInstruction shr 4) and $04));
{$ifdef UseSpecializedRegisterLoadStores}
     StoreRegisterU32(fState.Registers[rs1]+Offset,rs2);
{$else}
     Store32(fState.Registers[rs1]+Offset,fState.Registers[rs2]);
{$endif}
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}else{-$7:}{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
     // c.sd
     rs1:=TRegister(((aInstruction shr 7) and $7)+8);
     rs2:=TRegister(((aInstruction shr 2) and $7)+8);
     Offset:=((aInstruction shl 1) and $c0) or ((aInstruction shr 7) and $38);
{$ifdef UseSpecializedRegisterLoadStores}
     StoreRegisterU64(fState.Registers[rs1]+Offset,rs2);
{$else}
     Store64(fState.Registers[rs1]+Offset,fState.Registers[rs2]);
{$endif}
     result:=2;
     exit;
    end;
   end;
  end;

  {$ifdef TryToForceCaseJumpTableOnLevel1}
   $01,$05,$09,$0d,$11,$15,$19,$1d,$21,$25,$29,$2d,$31,$35,$39,$3d,
   $41,$45,$49,$4d,$51,$55,$59,$5d,$61,$65,$69,$6d,$71,$75,$79,$7d,
   $81,$85,$89,$8d,$91,$95,$99,$9d,$a1,$a5,$a9,$ad,$b1,$b5,$b9,$bd,
   $c1,$c5,$c9,$cd,$d1,$d5,$d9,$dd,$e1,$e5,$e9,$ed,$f1,$f5,$f9,$fd:
  {$else}
   $01:
  {$endif}begin
   // Compressed quandrant 1
// case TPasRISCVUInt8((aInstruction shr 13) and {$ifdef TryToForceCaseJumpTableOnCompressedLevel2}$ff{$else}7{$endif}) of
   case {$ifdef TryToForceCaseJumpTableOnCompressedLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 13) and 7) of
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
     // c.addi
     rd:=TRegister(((aInstruction shr 7) and $1f));
     {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
      Immediate:=SignExtend(((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f),6);
      fState.Registers[rd]:=fState.Registers[rd]+TPasRISCVUInt64(Immediate);
     end;
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
     // c.addiw
     rd:=TRegister(((aInstruction shr 7) and $1f));
     if rd<>TRegister.Zero then begin
      Immediate:=SignExtend(((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f),6);
      fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(fState.Registers[rd]+Immediate)));
      result:=2;
      exit;
     end else begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
      result:=2;
      exit;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
     // c.li
     rd:=TRegister(((aInstruction shr 7) and $1f));
     {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
      Immediate:=SignExtend(((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f),6);
      fState.Registers[rd]:=TPasRISCVUInt64(Immediate);
     end;
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
     case (aInstruction shr 7) and $1f of
      $0:begin
       // c.nop
       result:=2;
       exit;
      end;
      $2:begin
       // c.addi16sp
       Immediate:=SignExtend(((aInstruction shr 3) and $200) or
                             ((aInstruction shr 2) and $10) or
                             ((aInstruction shl 1) and $40) or
                             ((aInstruction shl 4) and $180) or
                             ((aInstruction shl 3) and $20),10);
       if Immediate<>0 then begin
        inc(fState.Registers[TRegister.SP],TPasRISCVUInt64(Immediate));
        result:=2;
        exit;
       end else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
        result:=2;
        exit;
       end;
      end;
      else begin
       // c.lui
       rd:=TRegister((aInstruction shr 7) and $1f);
       Immediate:=SignExtend(((aInstruction shl 5) and $20000) or ((aInstruction shl 10) and $1f000),18);
       if Immediate<>0 then begin
        {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
         fState.Registers[rd]:=TPasRISCVUInt64(Immediate);
        end;
        result:=2;
        exit;
       end else begin
        // Zcmop - c.mop.N (rd is odd, 1..15) => NOP
        if ((ord(rd) and 1)<>0) and (ord(rd)<=15) then begin
         result:=2;
         exit;
        end else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
         result:=2;
         exit;
        end;
       end;
      end;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
     case (aInstruction shr 10) and 3 of
      $0:begin
       // c.srli
       rd:=TRegister(((aInstruction shr 7) and $7)+8);
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        Immediate:=((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f);
        fState.Registers[rd]:=fState.Registers[rd] shr TPasRISCVUInt64(Immediate);
       end;
       result:=2;
       exit;
      end;
      $1:begin
       // c.srai
       rd:=TRegister(((aInstruction shr 7) and $7)+8);
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        Immediate:=((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f);
        fState.Registers[rd]:=SARInt64(fState.Registers[rd],TPasRISCVUInt64(Immediate));
       end;
       result:=2;
       exit;
      end;
      $2:begin
       // c.andi
       rd:=TRegister(((aInstruction shr 7) and $7)+8);
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        Immediate:=SignExtend(((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f),6);
        fState.Registers[rd]:=fState.Registers[rd] and TPasRISCVUInt64(Immediate);
       end;
       result:=2;
       exit;
      end;
      else {-$3:}begin
       if ((aInstruction shr 12) and 1)=0 then begin
        case (aInstruction shr 5) and 3 of
         $0:begin
          // c.sub
          rd:=TRegister(((aInstruction shr 7) and $7)+8);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           rs2:=TRegister(((aInstruction shr 2) and $7)+8);
           fState.Registers[rd]:=fState.Registers[rd]-fState.Registers[rs2];
          end;
          result:=2;
          exit;
         end;
         $1:begin
          // c.xor
          rd:=TRegister(((aInstruction shr 7) and $7)+8);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           rs2:=TRegister(((aInstruction shr 2) and $7)+8);
           fState.Registers[rd]:=fState.Registers[rd] xor fState.Registers[rs2];
          end;
          result:=2;
          exit;
         end;
         $2:begin
          // c.or
          rd:=TRegister(((aInstruction shr 7) and $7)+8);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           rs2:=TRegister(((aInstruction shr 2) and $7)+8);
           fState.Registers[rd]:=fState.Registers[rd] or fState.Registers[rs2];
          end;
          result:=2;
          exit;
         end;
         else {-$3:}begin
          // c.and
          rd:=TRegister(((aInstruction shr 7) and $7)+8);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           rs2:=TRegister(((aInstruction shr 2) and $7)+8);
           fState.Registers[rd]:=fState.Registers[rd] and fState.Registers[rs2];
          end;
          result:=2;
          exit;
         end;
        end;
       end else begin
        case (aInstruction shr 5) and 3 of
         $0:begin
          // c.subw
          rd:=TRegister(((aInstruction shr 7) and $7)+8);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           rs2:=TRegister(((aInstruction shr 2) and $7)+8);
           fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVInt32(fState.Registers[rd])-TPasRISCVInt32(fState.Registers[rs2])));
          end;
          result:=2;
          exit;
         end;
         $1:begin
          // c.addw
          rd:=TRegister(((aInstruction shr 7) and $7)+8);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           rs2:=TRegister(((aInstruction shr 2) and $7)+8);
           fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVInt32(fState.Registers[rd])+TPasRISCVInt32(fState.Registers[rs2])));
          end;
          result:=2;
          exit;
         end;
         $2:begin
          // c.mul (Zcb + M)
          rd:=TRegister(((aInstruction shr 7) and $7)+8);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           rs2:=TRegister(((aInstruction shr 2) and $7)+8);
           fState.Registers[rd]:=fState.Registers[rd]*fState.Registers[rs2];
          end;
          result:=2;
          exit;
         end;
         $3:begin
          case (aInstruction shr 2) and 7 of
           $0:begin
            // c.zext.b (Zcb)
            rd:=TRegister(((aInstruction shr 7) and $7)+8);
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt8(fState.Registers[rd]);
            end;
            result:=2;
            exit;
           end;
           $1:begin
            // c.sext.b (Zcb + Zbb)
            rd:=TRegister(((aInstruction shr 7) and $7)+8);
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(fState.Registers[rd])));
            end;
            result:=2;
            exit;
           end;
           $2:begin
            // c.zext.h (Zcb + Zbb)
            rd:=TRegister(((aInstruction shr 7) and $7)+8);
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt16(fState.Registers[rd]);
            end;
            result:=2;
            exit;
           end;
           $3:begin
            // c.sext.w (Zcb + Zbb)
            rd:=TRegister(((aInstruction shr 7) and $7)+8);
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(fState.Registers[rd])));
            end;
            result:=2;
            exit;
           end;
           $4:begin
            // c.zext.w (Zcb + Zba)
            rd:=TRegister(((aInstruction shr 7) and $7)+8);
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt32(fState.Registers[rd]);
            end;
            result:=2;
            exit;
           end;
           $5:begin
            // c.not (Zcb)
            rd:=TRegister(((aInstruction shr 7) and $7)+8);
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=not fState.Registers[rd];
            end;
            result:=2;
            exit;
           end;
           else begin
            SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
            result:=2;
            exit;
           end;
          end;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
          result:=2;
          exit;
         end;
        end;
       end;
      end;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
     // c.j
     Immediate:=SignExtend(((aInstruction shr 1) and $800) or  //  bit [12] -> [11]
                           ((aInstruction shl 2) and $400) or  //  bit [8] -> [10]
                           ((aInstruction shr 1) and $300) or  //  bits [10:9] -> [9:8]
                           ((aInstruction shl 1) and $80) or   //  bit [6] -> [7]
                           ((aInstruction shr 1) and $40) or   //  bit [7] -> [6]
                           ((aInstruction shl 3) and $20) or   //  bit [2] -> [5]
                           ((aInstruction shr 7) and $10) or   //  bit [11] -> [4]
                           ((aInstruction shr 2) and $0e),12); //  bits [5:3] -> [3:1]
     inc(fState.PC,TPasRISCVUInt64(Immediate)-2);
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
     // c.beqz
     rs1:=TRegister(((aInstruction shr 7) and $7)+8);
     if fState.Registers[rs1]=0 then begin
      Immediate:=SignExtend(((aInstruction shr 4) and $100) or
                            ((aInstruction shl 1) and $c0) or
                            ((aInstruction shl 3) and $20) or
                            ((aInstruction shr 7) and $18) or
                            ((aInstruction shr 2) and $06),9);
      inc(fState.PC,TPasRISCVUInt64(Immediate)-2);
     end;
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}else{-$7:}{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
     // c.bnez
     rs1:=TRegister(((aInstruction shr 7) and $7)+8);
     if fState.Registers[rs1]<>0 then begin
      Immediate:=SignExtend(((aInstruction shr 4) and $100) or
                            ((aInstruction shl 1) and $c0) or
                            ((aInstruction shl 3) and $20) or
                            ((aInstruction shr 7) and $18) or
                            ((aInstruction shr 2) and $06),9);
      inc(fState.PC,TPasRISCVUInt64(Immediate)-2);
     end;
     result:=2;
     exit;
    end;
   end;
  end;

  {$ifdef TryToForceCaseJumpTableOnLevel1}
   $02,$06,$0a,$0e,$12,$16,$1a,$1e,$22,$26,$2a,$2e,$32,$36,$3a,$3e,
   $42,$46,$4a,$4e,$52,$56,$5a,$5e,$62,$66,$6a,$6e,$72,$76,$7a,$7e,
   $82,$86,$8a,$8e,$92,$96,$9a,$9e,$a2,$a6,$aa,$ae,$b2,$b6,$ba,$be,
   $c2,$c6,$ca,$ce,$d2,$d6,$da,$de,$e2,$e6,$ea,$ee,$f2,$f6,$fa,$fe:
  {$else}
   $02:
  {$endif}begin
   // Compressed quandrant 2
// case TPasRISCVUInt8((aInstruction shr 13) and {$ifdef TryToForceCaseJumpTableOnCompressedLevel2}$ff{$else}7{$endif}) of
   case {$ifdef TryToForceCaseJumpTableOnCompressedLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 13) and 7) of
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
     // c.slli
     rd:=TRegister((aInstruction shr 7) and $1f);
     {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
      Immediate:=((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f);
      fState.Registers[rd]:=fState.Registers[rd] shl TPasRISCVUInt64(Immediate);
     end;
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
     // c.fldsp
     if fState.CSR.IsFPUEnabled then begin
      frd:=TFPURegister((aInstruction shr 7) and $1f);
      Offset:=((aInstruction shl 4) and $1c0) or
              ((aInstruction shr 7) and $20) or
              ((aInstruction shr 2) and $18);
{$ifdef UseSpecializedRegisterLoadStores}
      LoadRegisterF64(frd,fState.Registers[TRegister.SP]+Offset);
{$else}
      Temporary:=Load64(fState.Registers[TRegister.SP]+Offset);
      if fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None then begin
       fState.FPURegisters[frd].ui64:=Temporary;
       fState.CSR.SetFSDirty;
      end;
{$endif}
//    SetFPUExceptions(FE_ALL_EXCEPT and not FE_INEXACT);
      result:=2;
      exit;
     end else begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
      result:=2;
      exit;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
     // c.lwsp
     rd:=TRegister((aInstruction shr 7) and $1f);
     if rd<>TRegister.Zero then begin
      Offset:=((aInstruction shl 4) and $c0) or
              ((aInstruction shr 7) and $20) or
              ((aInstruction shr 2) and $1c);
{$ifdef UseSpecializedRegisterLoadStores}
      LoadRegisterS32(rd,fState.Registers[TRegister.SP]+Offset);
{$else}
      Temporary:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Load32(fState.Registers[TRegister.SP]+Offset))));
      if fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None then begin
       fState.Registers[rd]:=Temporary;
      end;
{$endif}
      result:=2;
      exit;
     end else begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
      result:=2;
      exit;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
     // c.ldsp
     rd:=TRegister((aInstruction shr 7) and $1f);
     if rd<>TRegister.Zero then begin
      Offset:=((aInstruction shl 4) and $1c0) or
              ((aInstruction shr 7) and $20) or
              ((aInstruction shr 2) and $18);
{$ifdef UseSpecializedRegisterLoadStores}
      LoadRegisterU64(rd,fState.Registers[TRegister.SP]+Offset);
{$else}
      Temporary:=Load64(fState.Registers[TRegister.SP]+Offset);
      if fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None then begin
       fState.Registers[rd]:=Temporary;
      end;
{$endif}
      result:=2;
      exit;
     end else begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
      result:=2;
      exit;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
     if ((aInstruction shr 12) and 1)=0 then begin
      case (aInstruction shr 2) and $1f of
       $0:begin
        // c.jr
        rs1:=TRegister((aInstruction shr 7) and $1f);
        fState.PC:=fState.Registers[rs1]-2;
        result:=2;
        exit;
       end;
       else begin
        // c.mv
        rd:=TRegister((aInstruction shr 7) and $1f);
        {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
         rs1:=TRegister((aInstruction shr 2) and $1f);
         fState.Registers[rd]:=fState.Registers[rs1];
        end;
        result:=2;
        exit;
       end;
      end;
     end else begin
      if ((aInstruction shr 7) and $1f)<>0 then begin
       case (aInstruction shr 2) and $1f of
        $0:begin
         // c.jalr
         rs1:=TRegister((aInstruction shr 7) and $1f);
         Temporary:=fState.PC+2;
         fState.PC:=fState.Registers[rs1]-2;
         fState.Registers[TRegister.RA]:=Temporary;
         result:=2;
         exit;
        end;
        else begin
         // c.add
         rd:=TRegister((aInstruction shr 7) and $1f);
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          rs1:=TRegister((aInstruction shr 2) and $1f);
          fState.Registers[rd]:=fState.Registers[rd]+fState.Registers[rs1];
         end;
         result:=2;
         exit;
        end;
       end;
      end else begin
       // c.ebreak
       Breakpoint(aInstruction);
       result:=2;
       exit;
      end;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
     // c.fsdsp
     if fState.CSR.IsFPUEnabled then begin
      frs1:=TFPURegister((aInstruction shr 2) and $1f);
      Offset:=(((aInstruction shr 1) and $1c0) or ((aInstruction shr 7) and $38));
{$ifdef UseSpecializedRegisterLoadStores}
      StoreRegisterF64(fState.Registers[TRegister.SP]+Offset,frs1);
{$else}
      Store64(fState.Registers[TRegister.SP]+Offset,fState.FPURegisters[frs1].ui64);
{$endif}
      result:=2;
      exit;
     end else begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction and $ffff,fState.PC);
      result:=2;
      exit;
     end;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
     // c.swsp
     rs1:=TRegister((aInstruction shr 2) and $1f);
     Offset:=(((aInstruction shr 1) and $c0) or ((aInstruction shr 7) and $3c));
{$ifdef UseSpecializedRegisterLoadStores}
     StoreRegisterU32(fState.Registers[TRegister.SP]+Offset,rs1);
{$else}
     Store32(fState.Registers[TRegister.SP]+Offset,fState.Registers[rs1]);
{$endif}
     result:=2;
     exit;
    end;
    {$ifndef TryToForceCaseJumpTableOnCompressedLevel2}else{-$7:}{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
     // c.sdsp
     rs1:=TRegister((aInstruction shr 2) and $1f);
     Offset:=(((aInstruction shr 1) and $1c0) or ((aInstruction shr 7) and $38));
{$ifdef UseSpecializedRegisterLoadStores}
     StoreRegisterU64(fState.Registers[TRegister.SP]+Offset,rs1);
{$else}
     Store64(fState.Registers[TRegister.SP]+Offset,fState.Registers[rs1]);
{$endif}
     result:=2;
     exit;
    end;
   end;
  end;

  {$ifdef TryToForceCaseJumpTableOnLevel1}
{  $03,$07,$0b,$0f,$13,$17,$1b,$1f,$23,$27,$2b,$2f,$33,$37,$3b,$3f,
   $43,$47,$4b,$4f,$53,$57,$5b,$5f,$63,$67,$6b,$6f,$73,$77,$7b,$7f,
   $83,$87,$8b,$8f,$93,$97,$9b,$9f,$a3,$a7,$ab,$af,$b3,$b7,$bb,$bf,
   $c3,$c7,$cb,$cf,$d3,$d7,$db,$df,$e3,$e7,$eb,$ef,$f3,$f7,$fb,$ff:begin}
  {$else}
   else {-$03:}begin

    case aInstruction and $7f of
  {$endif}

    //////////////////////////////////////////////////////////////////////////////
    // Load                                                                     //
    //////////////////////////////////////////////////////////////////////////////
    $03{$ifdef TryToForceCaseJumpTableOnLevel1},$83{$endif}:begin
     // Immediate[11:0] = inst[31:20]
     rd:=TRegister((aInstruction shr 7) and $1f);
     rs1:=TRegister((aInstruction shr 15) and $1f);
     Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction{and TPasRISCVUInt32($fff00000)}))),20);
     Address:=fState.Registers[rs1]+Immediate;
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       // lb
{$ifdef UseSpecializedRegisterLoadStores}
       LoadRegisterS8(rd,Address);
{$else}
       Temporary:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Load8(Address))));
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // lh
{$ifdef UseSpecializedRegisterLoadStores}
       LoadRegisterS16(rd,Address);
{$else}
       Temporary:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Load16(Address))));
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
       // lw
{$ifdef UseSpecializedRegisterLoadStores}
       LoadRegisterS32(rd,Address);
{$else}
       Temporary:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Load32(Address))));
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
       // ld
{$ifdef UseSpecializedRegisterLoadStores}
       LoadRegisterU64(rd,Address);
{$else}
       Temporary:=Load64(Address);
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
       // lbu
{$ifdef UseSpecializedRegisterLoadStores}
       LoadRegisterU8(rd,Address);
{$else}
       Temporary:=Load8(Address);
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
       // lhu
{$ifdef UseSpecializedRegisterLoadStores}
       LoadRegisterU16(rd,Address);
{$else}
       Temporary:=Load16(Address);
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
       // lwu
{$ifdef UseSpecializedRegisterLoadStores}
       LoadRegisterU32(rd,Address);
{$else}
       Temporary:=Load32(Address);
       if (fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None){$ifndef ExplicitEnforceZeroRegister}and (rd<>TRegister.Zero){$endif}then begin
        fState.Registers[rd]:=Temporary;
       end;
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}else{-$7:}{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // Misc. Mem                                                                //
    //////////////////////////////////////////////////////////////////////////////
    $0f{$ifdef TryToForceCaseJumpTableOnLevel1},$8f{$endif}:begin
     // A fence instruction does nothing because this emulator executes an instruction sequentially on a single thread.
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       if aInstruction=TPasRISCVUInt32($0100000f) then begin
        // pause (Zihintpause)
        Sleep(0);
        result:=4;
        exit;
       end else if ((aInstruction and TPasRISCVUInt32($05000000))<>0) and ((aInstruction and TPasRISCVUInt32($00a00000))<>0) then begin
        // StoreLoad fence (SEQ_CST)
        TPasMPMemoryBarrier.ReadDependency;
        TPasMPInterlocked.BitwiseOr(TPasMPUInt64(fState.Bounce.ui64),0);
        result:=4;
        exit;
       end else begin
        // LoadLoad, LoadStore, StoreStore fence (ACQ_REL)
        TPasMPMemoryBarrier.ReadWrite;
        result:=4;
        exit;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // fence.i
       // TODO: JIT flush in the future
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
       // cbo (Zicbom)
       case aInstruction shr 20 of
        $00:begin
         // cbo.inval
         if (((aInstruction shr 7) and 15)=0) and IsCSRENVCFGEnabled(TCSR.ENVCFG_CBIE) then begin
          TPasMPMemoryBarrier.ReadWrite;
          result:=4;
          exit;
         end else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
        $01,$02:begin
         // cbo.clean, cbo.flush
         if (((aInstruction shr 7) and 15)=0) and IsCSRENVCFGEnabled(TCSR.ENVCFG_CBCFE) then begin
          TPasMPMemoryBarrier.ReadWrite;
          result:=4;
          exit;
         end else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
        $04:begin
         // cbo.zero
         if (((aInstruction shr 7) and 15)=0) and IsCSRENVCFGEnabled(TCSR.ENVCFG_CBZE) then begin
          rs1:=TRegister((aInstruction shr 15) and $1f);
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1] and TPasRISCVUInt64($ffffffffffffffc0),64,nil,false);
          if assigned(Ptr) then begin
           FillChar(Ptr^,64,#0);
          end;
          result:=4;
          exit;
         end else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // Imm                                                                      //
    //////////////////////////////////////////////////////////////////////////////
    $13{$ifdef TryToForceCaseJumpTableOnLevel1},$93{$endif}:begin
     // Immediate[11:0] = inst[31:20]
     Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction{and TPasRISCVUInt32($fff00000)}))),20);
     rd:=TRegister((aInstruction shr 7) and $1f);
     rs1:=TRegister((aInstruction shr 15) and $1f);
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       // addi
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=fState.Registers[rs1]+TPasRISCVUInt64(Immediate);
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // slli bseti bclri binvi
       {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}:=(aInstruction shr 20) and $3f;
       case (aInstruction shr 26) shl 1 of
        $00:begin
         // slli
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] shl {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif};
         end;
         result:=4;
         exit;
        end;
        $14:begin
         // bseti (Zbs)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] or (TPasRISCVUInt64(1) shl {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif});
         end;
         result:=4;
         exit;
        end;
        $24:begin
         // bclri (Zbs)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] and not TPasRISCVUInt64(TPasRISCVUInt64(1) shl {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif});
         end;
         result:=4;
         exit;
        end;
        $30:begin
         // Zbb
         case {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif} of
          $00:begin
           // clz (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=CLZQWord(fState.Registers[rs1]);
           end;
           result:=4;
           exit;
          end;
          $01:begin
           // ctz (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=CTZQWord(fState.Registers[rs1]);
           end;
           result:=4;
           exit;
          end;
          $02:begin
           // cpop (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=POPCNTQWord(fState.Registers[rs1]);
           end;
           result:=4;
           exit;
          end;
          $04:begin
           // sext.b (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(TPasRISCVUInt8(fState.Registers[rs1]))));
           end;
           result:=4;
           exit;
          end;
          $05:begin
           // sext.h (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(TPasRISCVUInt16(fState.Registers[rs1]))));
           end;
           result:=4;
           exit;
          end;
          else begin
           SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
           result:=4;
           exit;
          end;
         end;
        end;
        $34:begin
         // binvi (Zbs)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] xor (TPasRISCVUInt64(1) shl {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif});
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
       // slti
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=ord(TPasRISCVInt64(fState.Registers[rs1])<TPasRISCVInt64(Immediate)) and 1;
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
       // sltiu
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=ord(fState.Registers[rs1]<TPasRISCVUInt64(Immediate)) and 1;
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
       // xori
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=fState.Registers[rs1] xor TPasRISCVUInt64(Immediate);
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
       // srli srai bexti orcb.b rev8
       {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}:=(aInstruction shr 20) and $3f;
       case (aInstruction shr 26) shl 1 of
        $00:begin
         // srli
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] shr {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif};
         end;
         result:=4;
         exit;
        end;
        $20:begin
         // srai
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=SARInt64(fState.Registers[rs1],{$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif});
         end;
         result:=4;
         exit;
        end;
        $14:begin
         case {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif} of
          $07:begin
           // orc.b (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=BitwiseOrCombine(fState.Registers[rs1]);
           end;
           result:=4;
           exit;
          end;
          else begin
           SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
           result:=4;
           exit;
          end;
         end;
        end;
        $24:begin
         // bexti (Zbs)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=(fState.Registers[rs1] shr {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}) and 1;
         end;
         result:=4;
         exit;
        end;
        $30:begin
         // rori (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=RORQWord(fState.Registers[rs1],{$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif});
         end;
         result:=4;
         exit;
        end;
        $34:begin
         case {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif} of
          $38:begin
           // rev8 (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=ByteSwap64(fState.Registers[rs1]);
           end;
           result:=4;
           exit;
          end;
          else begin
           SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
           result:=4;
           exit;
          end;
         end;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
       // ori
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=fState.Registers[rs1] or TPasRISCVUInt64(Immediate);
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$7:{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
       // andi
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=fState.Registers[rs1] and TPasRISCVUInt64(Immediate);
       end;
       result:=4;
       exit;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // auipc                                                                    //
    //////////////////////////////////////////////////////////////////////////////
    $17{$ifdef TryToForceCaseJumpTableOnLevel1},$97{$endif}:begin
     // auipc
     rd:=TRegister((aInstruction shr 7) and $1f);
     {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
      Immediate:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($fffff000))));
      fState.Registers[rd]:=fState.PC+TPasRISCVUInt64(Immediate);
     end;
     result:=4;
     exit;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // Imm32                                                                    //
    //////////////////////////////////////////////////////////////////////////////
    $1b{$ifdef TryToForceCaseJumpTableOnLevel1},$9b{$endif}:begin
     rd:=TRegister((aInstruction shr 7) and $1f);
     rs1:=TRegister((aInstruction shr 15) and $1f);
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       // addiw
       Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction{and TPasRISCVUInt32($fff00000)}))),20);
       {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
        fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(fState.Registers[rs1])+Immediate)));
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // slliw slli.uw
       case (aInstruction shr 25) and $7f of
        $00:begin
         // slliw
         {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}:=(aInstruction shr 20) and $1f;
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(fState.Registers[rs1]) shl TPasRISCVUInt64({$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}))));
         end;
         result:=4;
         exit;
        end;
        $04,$05:begin
         // slli.uw
         {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}:=(aInstruction shr 20) and $3f;
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVUInt32(fState.Registers[rs1])) shl TPasRISCVUInt64({$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif});
         end;
         result:=4;
         exit;
        end;
        $30:begin
         case (aInstruction shr 20) and $1f of
          $00:begin
           // clzw (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=CLZDWord(TPasRISCVUInt32(fState.Registers[rs1]));
           end;
           result:=4;
           exit;
          end;
          $01:begin
           // ctzw (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=CTZDWord(TPasRISCVUInt32(fState.Registers[rs1]));
           end;
           result:=4;
           exit;
          end;
          $02:begin
           // cpopw (Zbb)
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=POPCNTDWord(TPasRISCVUInt32(fState.Registers[rs1]));
           end;
           result:=4;
           exit;
          end;
          else begin
           SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
           result:=4;
           exit;
          end;
         end;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
       // srliw sraiw roriw
       {$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}:=(aInstruction shr 20) and $1f;
       case (aInstruction shr 25) and $7f of
        $00:begin
         // srliw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(TPasRISCVUInt32(fState.Registers[rs1]) shr TPasRISCVUInt64({$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}))));
         end;
         result:=4;
         exit;
        end;
        $20:begin
         // sraiw
         Immediate:=(aInstruction shr 20) and $1f;
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=SARLongint(fState.Registers[rs1],TPasRISCVUInt64({$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif}));
         end;
         result:=4;
         exit;
        end;
        $30:begin
         // roriw (Zbb)
         Immediate:=(aInstruction shr 20) and $1f;
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(RORDWord(TPasRISCVUInt32(fState.Registers[rs1]),TPasRISCVUInt32({$ifdef UseExtraShAmt}ShAmt{$else}Immediate{$endif})))));
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // Store                                                                    //
    //////////////////////////////////////////////////////////////////////////////
    $23{$ifdef TryToForceCaseJumpTableOnLevel1},$a3{$endif}:begin
     // Immediate[11:5|4:0] = inst[31:25|11:7]
//   Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($fe000000)))),20) or ((aInstruction shr 7) and $1f);
     Immediate:=SignExtend((((aInstruction shr 25) and $7f) shl 5) or ((aInstruction shr 7) and $1f),12);
     rs1:=TRegister((aInstruction shr 15) and $1f);
     rs2:=TRegister((aInstruction shr 20) and $1f);
     Address:=fState.Registers[rs1]+Immediate;
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       // sb
{$ifdef UseSpecializedRegisterLoadStores}
       StoreRegisterU8(Address,rs2);
{$else}
       Store8(Address,fState.Registers[rs2] and $ff);
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // sh
{$ifdef UseSpecializedRegisterLoadStores}
       StoreRegisterU16(Address,rs2);
{$else}
       Store16(Address,fState.Registers[rs2] and $ffff);
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
       // sw
{$ifdef UseSpecializedRegisterLoadStores}
       StoreRegisterU32(Address,rs2);
{$else}
       Store32(Address,fState.Registers[rs2] and $ffffffff);
{$endif}
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
       // sd
{$ifdef UseSpecializedRegisterLoadStores}
       StoreRegisterU64(Address,rs2);
{$else}
       Store64(Address,fState.Registers[rs2]);
{$endif}
       result:=4;
       exit;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // Op                                                                       //
    //////////////////////////////////////////////////////////////////////////////
    $33{$ifdef TryToForceCaseJumpTableOnLevel1},$b3{$endif}:begin
     // "SLL, SRL, and SRA perform logical left, logical right, and arithmetic right
     // shifts on the value in register rs1 by the shift amount held in register rs2.
     // In RV64I, only the low 6 bits of rs2 are considered for the shift amount."
     rd:=TRegister((aInstruction shr 7) and $1f);
     rs1:=TRegister((aInstruction shr 15) and $1f);
     rs2:=TRegister((aInstruction shr 20) and $1f);
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       // add, sub, sub
       case (aInstruction shr 25) and $7f of
        $00:begin
         // add
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1]+fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // mul
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1]*fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        $20:begin
         // sub
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1]-fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // sll mulh clmul bset bclr rol binv
       case (aInstruction shr 25) and $7f of
        $00:begin
         // sll
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] shl (fState.Registers[rs2] and $3f);
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // mulh
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=MULH(TPasRISCVInt64(fState.Registers[rs1]),TPasRISCVInt64(fState.Registers[rs2]));
         end;
         result:=4;
         exit;
        end;
        $05:begin
         // clmul (Zbc)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=CLMul64(TPasRISCVUInt64(fState.Registers[rs1]),TPasRISCVUInt64(fState.Registers[rs2]));
         end;
         result:=4;
         exit;
        end;
        $14:begin
         // bset (Zbs)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] or (TPasRISCVUInt64(1) shl (fState.Registers[rs2] and $3f));
         end;
         result:=4;
         exit;
        end;
        $24:begin
         // bclr (Zbs)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] and not TPasRISCVUInt64(TPasRISCVUInt64(1) shl (fState.Registers[rs2] and $3f));
         end;
         result:=4;
         exit;
        end;
        $30:begin
         // rol (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=ROLQWord(fState.Registers[rs1],fState.Registers[rs2] and $3f);
         end;
         result:=4;
         exit;
        end;
        $34:begin
         // binv (Zbs)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] xor (TPasRISCVUInt64(1) shl (fState.Registers[rs2] and $3f));
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
       // slt mulhsu clmulr sh1add
       case (aInstruction shr 25) and $7f of
        $00:begin
         // slt
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=ord(TPasRISCVInt64(fState.Registers[rs1])<TPasRISCVInt64(fState.Registers[rs2])) and 1;
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // mulhsu
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=MULHSU(TPasRISCVInt64(fState.Registers[rs1]),fState.Registers[rs2]);
         end;
         result:=4;
         exit;
        end;
        $05:begin
         // clmulr (Zbc)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=CLMulR64(TPasRISCVUInt64(fState.Registers[rs1]),TPasRISCVUInt64(fState.Registers[rs2]));
         end;
         result:=4;
         exit;
        end;
        $10:begin
         // sh1add (Zba)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs2]+(fState.Registers[rs1] shl 1);
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
       // sltu mulhu clmulh
       case (aInstruction shr 25) and $7f of
        $00:begin
         // sltu
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=ord(fState.Registers[rs1]<fState.Registers[rs2]) and 1;
         end;
         result:=4;
         exit;
        end;
        $01:begin
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=MULHU(fState.Registers[rs1],fState.Registers[rs2]);
         end;
         result:=4;
         exit;
        end;
        $05:begin
         // clmulh (Zbc)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=CLMulH64(TPasRISCVUInt64(fState.Registers[rs1]),TPasRISCVUInt64(fState.Registers[rs2]));
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
       // xor div sh2add xnor min
       case (aInstruction shr 25) and $7f of
        $00:begin
         // xor
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] xor fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // div
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if fState.Registers[rs2]=0 then begin
           fState.Registers[rd]:=TPasRISCVUInt64($ffffffffffffffff);
          end else if (TPasRISCVInt64(fState.Registers[rs1])=Low(TPasRISCVInt64)) and (TPasRISCVInt64(fState.Registers[rs2])=-1) then begin
           fState.Registers[rd]:=TPasRISCVInt64(fState.Registers[rs1]);
          end else begin
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(fState.Registers[rs1]) div TPasRISCVInt64(fState.Registers[rs2])));
          end;
         end;
         result:=4;
         exit;
        end;
        $05:begin
         // min (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if TPasRISCVInt64(fState.Registers[rs1])<TPasRISCVInt64(fState.Registers[rs2]) then begin
           fState.Registers[rd]:=fState.Registers[rs1];
          end else begin
           fState.Registers[rd]:=fState.Registers[rs2];
          end;
         end;
         result:=4;
         exit;
        end;
        $10:begin
         // sh2add (Zba)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs2]+(fState.Registers[rs1] shl 2);
         end;
         result:=4;
         exit;
        end;
        $20:begin
         // xnor (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] xor not fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
       // srl divu sra bext minu ror czero.eqz
       case (aInstruction shr 25) and $7f of
        $00:begin
         // srl
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] shr (fState.Registers[rs2] and $3f);
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // divu
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if fState.Registers[rs2]=0 then begin
           fState.Registers[rd]:=TPasRISCVUInt64($ffffffffffffffff);
          end else begin
           fState.Registers[rd]:=fState.Registers[rs1] div fState.Registers[rs2];
          end;
         end;
         result:=4;
         exit;
        end;
        $05:begin
         // minu (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if TPasRISCVUInt64(fState.Registers[rs1])<TPasRISCVUInt64(fState.Registers[rs2]) then begin
           fState.Registers[rd]:=fState.Registers[rs1];
          end else begin
           fState.Registers[rd]:=fState.Registers[rs2];
          end;
         end;
         result:=4;
         exit;
        end;
        $07:begin
         // czero.eqz (Zicond)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if fState.Registers[rs2]<>0 then begin
           fState.Registers[rd]:=fState.Registers[rs1];
          end else begin
           fState.Registers[rd]:=0;
          end;
         end;
         result:=4;
         exit;
        end;
        $20:begin
         // sra
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=SARInt64(fState.Registers[rs1],fState.Registers[rs2] and $3f);
         end;
         result:=4;
         exit;
        end;
        $24:begin
         // bext (Zbs)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=(fState.Registers[rs1] shr (fState.Registers[rs2] and $3f)) and 1;
         end;
         result:=4;
         exit;
        end;
        $30:begin
         // ror (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=RORQWord(fState.Registers[rs1],fState.Registers[rs2] and $3f);
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
       // or rem sh3add orn max
       case (aInstruction shr 25) and $7f of
        $00:begin
         // or
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] or fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // rem
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if fState.Registers[rs2]=0 then begin
           fState.Registers[rd]:=fState.Registers[rs1];
          end else if (TPasRISCVInt64(fState.Registers[rs1])=Low(TPasRISCVInt64)) and (TPasRISCVInt64(fState.Registers[rs2])=-1) then begin
           fState.Registers[rd]:=0;
          end else begin
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(fState.Registers[rs1]) mod TPasRISCVInt64(fState.Registers[rs2])));
          end;
         end;
         result:=4;
         exit;
        end;
        $05:begin
         // max (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if TPasRISCVInt64(fState.Registers[rs1])>TPasRISCVInt64(fState.Registers[rs2]) then begin
           fState.Registers[rd]:=fState.Registers[rs1];
          end else begin
           fState.Registers[rd]:=fState.Registers[rs2];
          end;
         end;
         result:=4;
         exit;
        end;
        $10:begin
         // sh3add (Zba)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs2]+(fState.Registers[rs1] shl 3);
         end;
         result:=4;
         exit;
        end;
        $20:begin
         // orn (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] or not fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$7:{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
       // and remu andn maxu czero.nez
       case (aInstruction shr 25) and $7f of
        $00:begin
         // and
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] and fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // remu
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if fState.Registers[rs2]=0 then begin
           fState.Registers[rd]:=fState.Registers[rs1];
          end else begin
           fState.Registers[rd]:=fState.Registers[rs1] mod fState.Registers[rs2];
          end;
         end;
         result:=4;
         exit;
        end;
        $05:begin
         // maxu (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if TPasRISCVUInt64(fState.Registers[rs1])>TPasRISCVUInt64(fState.Registers[rs2]) then begin
           fState.Registers[rd]:=fState.Registers[rs1];
          end else begin
           fState.Registers[rd]:=fState.Registers[rs2];
          end;
         end;
         result:=4;
         exit;
        end;
        $07:begin
         // czero.nez (Zicond)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if fState.Registers[rs2]<>0 then begin
           fState.Registers[rd]:=0;
          end else begin
           fState.Registers[rd]:=fState.Registers[rs1];
          end;
         end;
         result:=4;
         exit;
        end;
        $20:begin
         // andn (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs1] and not fState.Registers[rs2];
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // lui                                                                      //
    //////////////////////////////////////////////////////////////////////////////
    $37{$ifdef TryToForceCaseJumpTableOnLevel1},$b7{$endif}:begin
     // lui
     rd:=TRegister((aInstruction shr 7) and $1f);
     {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
      Immediate:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($fffff000))));
      fState.Registers[rd]:=TPasRISCVUInt64(Immediate);
     end;
     result:=4;
     exit;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // Op32                                                                     //
    //////////////////////////////////////////////////////////////////////////////
    $3b{$ifdef TryToForceCaseJumpTableOnLevel1},$bb{$endif}:begin
     // "The shift amount is given by rs2[4:0]."
     rd:=TRegister((aInstruction shr 7) and $1f);
     rs1:=TRegister((aInstruction shr 15) and $1f);
     rs2:=TRegister((aInstruction shr 20) and $1f);
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       // addw mulw subw add.uw
       case (aInstruction shr 25) and $7f of
        $00:begin
         // addw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(fState.Registers[rs1])+TPasRISCVUInt32(fState.Registers[rs2])));
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // mulw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(TPasRISCVUInt32(fState.Registers[rs1])*TPasRISCVUInt32(fState.Registers[rs2]))));
         end;
         result:=4;
         exit;
        end;
        $04:begin
         // add.uw (Zba)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs2]+TPasRISCVUInt64(TPasRISCVUInt32(fState.Registers[rs1]));
         end;
         result:=4;
         exit;
        end;
        $20:begin
         // subw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(fState.Registers[rs1])-TPasRISCVUInt32(fState.Registers[rs2])));
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // sllw rolw
       case (aInstruction shr 25) and $7f of
        $00:begin
         // sllw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(TPasRISCVUInt32(fState.Registers[rs1]) shl (fState.Registers[rs2] and $1f))));
         end;
         result:=4;
         exit;
        end;
        $30:begin
         // rolw (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVInt32(ROLDWord(TPasRISCVUInt32(fState.Registers[rs1]),fState.Registers[rs2] and $1f))));
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
       // sh1add.uw
       case (aInstruction shr 25) and $7f of
        $10:begin
         // sh1add.uw (Zba)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs2]+(TPasRISCVUInt64(TPasRISCVUInt32(fState.Registers[rs1])) shl 1);
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
       // divw sha2add.uw
       case (aInstruction shr 25) and $7f of
        $01:begin
         // divw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if TPasRISCVUInt32(fState.Registers[rs2])=0 then begin
           fState.Registers[rd]:=TPasRISCVUInt64($ffffffffffffffff);
          end else if (TPasRISCVInt32(fState.Registers[rs1])=Low(TPasRISCVInt32)) and (TPasRISCVInt32(fState.Registers[rs2])=-1) then begin
           fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(fState.Registers[rs1]));
          end else begin
           fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVInt32(fState.Registers[rs1]) div TPasRISCVInt32(fState.Registers[rs2])));
          end;
         end;
         result:=4;
         exit;
        end;
        $04:begin
         if TPasRISCVUInt64(rs2)=0 then begin
          // zext.h (Zbb)
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVUInt16(fState.Registers[rs1]));
          end;
          result:=4;
          exit;
         end else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
        $10:begin
         // sh2add.uw (Zba)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs2]+(TPasRISCVUInt64(TPasRISCVUInt32(fState.Registers[rs1])) shl 2);
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
       // srlw divuw sraw rorw
       case (aInstruction shr 25) and $7f of
        $00:begin
         // srlw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(TPasRISCVUInt32(fState.Registers[rs1]) shr (fState.Registers[rs2] and $1f)))));
         end;
         result:=4;
         exit;
        end;
        $01:begin
         // divuw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if TPasRISCVUInt32(fState.Registers[rs2])=0 then begin
           fState.Registers[rd]:=TPasRISCVUInt64($ffffffffffffffff);
          end else begin
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(TPasRISCVUInt32(fState.Registers[rs1]) div TPasRISCVUInt32(fState.Registers[rs2])))));
          end;
         end;
         result:=4;
         exit;
        end;
        $20:begin
         // sraw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(SARLongint(TPasRISCVInt32(fState.Registers[rs1]),fState.Registers[rs2] and $1f)));
         end;
         result:=4;
         exit;
        end;
        $30:begin
         // rorw (Zbb)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=TPasRISCVInt64(TPasRISCVInt32(TPasRISCVInt32(RORDWord(TPasRISCVUInt32(fState.Registers[rs1]),fState.Registers[rs2] and $1f))));
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
       // remw sh3add.uw
       case (aInstruction shr 25) and $7f of
        $01:begin
         // remw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if TPasRISCVUInt32(fState.Registers[rs2])=0 then begin
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(fState.Registers[rs1]))));
          end else if (TPasRISCVInt32(fState.Registers[rs1])=Low(TPasRISCVInt32)) and (TPasRISCVInt32(fState.Registers[rs2])=-1) then begin
           fState.Registers[rd]:=0;
          end else begin
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVInt32(fState.Registers[rs1]) mod TPasRISCVInt32(fState.Registers[rs2]))));
          end;
         end;
         result:=4;
         exit;
        end;
        $10:begin
         // sh3add.uw (Zba)
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          fState.Registers[rd]:=fState.Registers[rs2]+(TPasRISCVUInt64(TPasRISCVUInt32(fState.Registers[rs1])) shl 3);
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$7:{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
       // remuw
       case (aInstruction shr 25) and $7f of
        $01:begin
         // remuw
         {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
          if TPasRISCVUInt32(fState.Registers[rs2])=0 then begin
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(fState.Registers[rs1]))));
          end else begin
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(TPasRISCVUInt32(fState.Registers[rs1]) mod TPasRISCVUInt32(fState.Registers[rs2])))));
          end;
         end;
         result:=4;
         exit;
        end;
        else begin
         SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         result:=4;
         exit;
        end;
       end;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // Branch                                                                   //
    //////////////////////////////////////////////////////////////////////////////
    $63{$ifdef TryToForceCaseJumpTableOnLevel1},$e3{$endif}:begin
     // Immediate[12|10:5|4:1|11] = inst[31|30:25|11:8|7]
     rs1:=TRegister((aInstruction shr 15) and $1f);
     rs2:=TRegister((aInstruction shr 20) and $1f);
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       // beq
       if fState.Registers[rs1]=fState.Registers[rs2] then begin
        Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($80000000)))),19) or
                   ((aInstruction and $80) shl 4) or
                   ((aInstruction shr 20) and $7e0) or
                   ((aInstruction shr 7) and $1e);
        inc(fState.PC,Immediate-4);
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // bne
       if fState.Registers[rs1]<>fState.Registers[rs2] then begin
        Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($80000000)))),19) or
                   ((aInstruction and $80) shl 4) or
                   ((aInstruction shr 20) and $7e0) or
                   ((aInstruction shr 7) and $1e);
        inc(fState.PC,Immediate-4);
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
       // blt
       if TPasRISCVInt64(fState.Registers[rs1])<TPasRISCVInt64(fState.Registers[rs2]) then begin
        Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($80000000)))),19) or
                   ((aInstruction and $80) shl 4) or
                   ((aInstruction shr 20) and $7e0) or
                   ((aInstruction shr 7) and $1e);
        inc(fState.PC,Immediate-4);
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
       // bge
       if TPasRISCVInt64(fState.Registers[rs1])>=TPasRISCVInt64(fState.Registers[rs2]) then begin
        Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($80000000)))),19) or
                   ((aInstruction and $80) shl 4) or
                   ((aInstruction shr 20) and $7e0) or
                   ((aInstruction shr 7) and $1e);
        inc(fState.PC,Immediate-4);
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
       // bltu
       if fState.Registers[rs1]<fState.Registers[rs2] then begin
        Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($80000000)))),19) or
                   ((aInstruction and $80) shl 4) or
                   ((aInstruction shr 20) and $7e0) or
                   ((aInstruction shr 7) and $1e);
        inc(fState.PC,Immediate-4);
       end;
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$7:{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
       // bgeu
       if fState.Registers[rs1]>=fState.Registers[rs2] then begin
        Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($80000000)))),19) or
                   ((aInstruction and $80) shl 4) or
                   ((aInstruction shr 20) and $7e0) or
                   ((aInstruction shr 7) and $1e);
        inc(fState.PC,Immediate-4);
       end;
       result:=4;
       exit;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // jalr                                                                     //
    //////////////////////////////////////////////////////////////////////////////
    $67{$ifdef TryToForceCaseJumpTableOnLevel1},$e7{$endif}:begin
     // jalr
     Temporary:=fState.PC+4;
     Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($fff00000)))),20);
     rd:=TRegister((aInstruction shr 7) and $1f);
     rs1:=TRegister((aInstruction shr 15) and $1f);
     fState.PC:=((fState.Registers[rs1]+TPasRISCVUInt64(Immediate)) and TPasRISCVUInt64($fffffffffffffffe))-4;
     {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
      fState.Registers[rd]:=Temporary;
     end;
     result:=4;
     exit;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // jal                                                                      //
    //////////////////////////////////////////////////////////////////////////////
    $6f{$ifdef TryToForceCaseJumpTableOnLevel1},$ef{$endif}:begin
     // jal
     rd:=TRegister((aInstruction shr 7) and $1f);
     {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
      fState.Registers[rd]:=fState.PC+4;
     end;
     Immediate:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(aInstruction and TPasRISCVUInt32($80000000)))),11) or // Immediate[20]
                (aInstruction and $ff000) or // Immediate[19:12]
                ((aInstruction shr 9) and $800) or // Immediate[11]
                ((aInstruction shr 20) and $7fe); // Immediate[10:1]
     inc(fState.PC,TPasRISCVUInt64(Immediate)-4);
     result:=4;
     exit;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // System                                                                   //
    //////////////////////////////////////////////////////////////////////////////
    $73{$ifdef TryToForceCaseJumpTableOnLevel1},$f3{$endif}:begin
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       // Environment call instructions
       case (aInstruction shr 25) and $7f of
        $09:begin
         // SFENCEVMA
         if fState.VirtualMode then begin
          // In VS-mode: check hstatus.VTVM
          if (fState.CSR.fData[TCSR.TAddress.HSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.VTVM))<>0 then begin
           SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
          end else begin
           rs1:=TRegister((aInstruction shr 15) and $1f);
           if rs1<>TRegister.Zero then begin
            FlushTLBPage(true,fState.Registers[rs1]);
           end else begin
            FlushTLB(true);
           end;
           State.LRSC:=false;
          end;
         end else if ((fState.Mode>=THART.TMode.Supervisor) and
                      ((fState.CSR.fData[TCSR.TAddress.MSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.TVM))=0)) or
                     (fState.Mode=THART.TMode.Machine) then begin
          rs1:=TRegister((aInstruction shr 15) and $1f);
          if rs1<>TRegister.Zero then begin
           FlushTLBPage(true,fState.Registers[rs1]);
          end else begin
           FlushTLB(true);
          end;
          State.LRSC:=false;
         end else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end;
         result:=4;
         exit;
        end;
        $0c:begin
         // sinval.vma / sfence.w.inval / sfence.inval.ir (Svinval)
         // sinval.vma treated as sfence.vma; sfence.w.inval/sfence.inval.ir are NOPs
         if fState.VirtualMode then begin
          // In VS-mode: check hstatus.VTVM for sinval.vma
          if (fState.CSR.fData[TCSR.TAddress.HSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.VTVM))<>0 then begin
           SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
          end else begin
           rs1:=TRegister((aInstruction shr 15) and $1f);
           if rs1<>TRegister.Zero then begin
            FlushTLBPage(true,fState.Registers[rs1]);
           end else begin
            FlushTLB(true);
           end;
           State.LRSC:=false;
          end;
         end else if ((fState.Mode>=THART.TMode.Supervisor) and
                      ((fState.CSR.fData[TCSR.TAddress.MSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.TVM))=0)) or
                     (fState.Mode=THART.TMode.Machine) then begin
          rs1:=TRegister((aInstruction shr 15) and $1f);
          if rs1<>TRegister.Zero then begin
           FlushTLBPage(true,fState.Registers[rs1]);
          end else begin
           FlushTLB(true);
          end;
          State.LRSC:=false;
         end else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end;
         result:=4;
         exit;
        end;
        $11:begin
         // HFENCE.VVMA (was HFENCEBVMA)
         if fState.VirtualMode then begin
          SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
         end else if fState.Mode>=THART.TMode.Supervisor then begin
          // Flush TLB for VS-stage entries
          FlushTLB(true);
          fState.LRSC:=false;
         end else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end;
         result:=4;
         exit;
        end;
        $51:begin
         // HFENCE.GVMA
         if fState.VirtualMode then begin
          SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
         end else if fState.Mode<THART.TMode.Supervisor then begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end else if (fState.Mode=THART.TMode.Supervisor) and ((fState.CSR.fData[TCSR.TAddress.MSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.TVM))<>0) then begin
          // TVM=1 in mstatus: HFENCE.GVMA traps from HS-mode
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end else begin
          // Flush TLB for G-stage entries
          FlushTLB(true);
          fState.LRSC:=false;
         end;
         result:=4;
         exit;
        end;
        $16:begin
         // HINVAL.VVMA (Svinval H-extension)
         if fState.VirtualMode then begin
          SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
         end else if fState.Mode>=THART.TMode.Supervisor then begin
          FlushTLB(true);
          fState.LRSC:=false;
         end else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end;
         result:=4;
         exit;
        end;
        $66:begin
         // HINVAL.GVMA (Svinval H-extension)
         if fState.VirtualMode then begin
          SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
         end else if fState.Mode<THART.TMode.Supervisor then begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end else if (fState.Mode=THART.TMode.Supervisor) and ((fState.CSR.fData[TCSR.TAddress.MSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.TVM))<>0) then begin
          // TVM=1 in mstatus: HINVAL.GVMA traps from HS-mode
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end else begin
          FlushTLB(true);
          fState.LRSC:=false;
         end;
         result:=4;
         exit;
        end;
        else begin
         case (aInstruction shr 20) and $1f of
          $00:begin
           // ecall
           case fState.Mode of
            THART.TMode.User:begin
             SetException(TExceptionValue.ECallUMode,fState.PC,fState.PC);
             result:=4;
             exit;
            end;
            THART.TMode.Supervisor:begin
             if fState.VirtualMode then begin
              SetException(TExceptionValue.ECallVSMode,fState.PC,fState.PC);
             end else begin
              SetException(TExceptionValue.ECallSMode,fState.PC,fState.PC);
             end;
             result:=4;
             exit;
            end;
            THART.TMode.Hypervisor:begin
             SetException(TExceptionValue.ECallVSMode,fState.PC,fState.PC);
             result:=4;
             exit;
            end;
            THART.TMode.Machine:begin
             SetException(TExceptionValue.ECallMMode,fState.PC,fState.PC);
             result:=4;
             exit;
            end;
            else begin
             SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
             result:=4;
             exit;
            end;
           end;
          end;
          $01:begin
           // ebreak
           Breakpoint(aInstruction);
           result:=4;
           exit;
          end;
          $02:begin
           // ret
           case (aInstruction shr 25) and $7f of
            $00:begin
             // uret7
             SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
             result:=4;
             exit;
            end;
            $08:begin
             // sret
             if fState.VirtualMode then begin
              // In VS-mode: check hstatus.VTSR
              if (fState.CSR.fData[TCSR.TAddress.HSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.VTSR))<>0 then begin
               SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
               result:=4;
               exit;
              end;
              // VS-mode SRET: return within virtual world
              Temporary:=fState.CSR.fData[TCSR.TAddress.MSTATUS];
              SetMode(THART.TMode((Temporary shr TCSR.TMask.TSSTATUSBit.SPP) and 1));
              // V stays 1
              Temporary:=(Temporary and not (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPP)) or ((ord(THART.TMode.User) and 1) shl TCSR.TMask.TSSTATUSBit.SPP);
              Temporary:=(Temporary and not (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SIE)) or (((Temporary shr TCSR.TMask.TSSTATUSBit.SPIE) and 1) shl TCSR.TMask.TSSTATUSBit.SIE);
              Temporary:=Temporary or (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPIE); // SPIE=1 per spec
              fState.CSR.fData[TCSR.TAddress.MSTATUS]:=Temporary;
              fState.PC:=fState.CSR.fData[TCSR.TAddress.SEPC]-4;
              CheckInterrupts;
              result:=4;
              exit;
             end else if ((fState.Mode>=THART.TMode.Supervisor) and
                          ((fState.CSR.fData[TCSR.TAddress.MSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.TSR))=0)) or
                         (fState.Mode=THART.TMode.Machine) then begin

              // HS-mode SRET (V=0) — QEMU ordering: modify MSTATUS before swap
              Temporary:=fState.CSR.fData[TCSR.TAddress.MSTATUS];

              SetMode(THART.TMode((Temporary shr TCSR.TMask.TSSTATUSBit.SPP) and 1));

              // Set SPP to U (before swap, so this lands in HS-mode backing)
              Temporary:=(Temporary and not (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPP)) or ((ord(THART.TMode.User) and 1) shl TCSR.TMask.TSSTATUSBit.SPP);

              // Set SIE to SPIE (before swap)
              Temporary:=(Temporary and not (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SIE)) or (((Temporary shr TCSR.TMask.TSSTATUSBit.SPIE) and 1) shl TCSR.TMask.TSSTATUSBit.SIE);

              // Set SPIE to 1 (spec requirement)
              Temporary:=Temporary or (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPIE);

              fState.CSR.fData[TCSR.TAddress.MSTATUS]:=Temporary;

              // Check hstatus.SPV: should we return to virtual mode?
              if (fState.CSR.fData[TCSR.TAddress.HSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.SPV))<>0 then begin
               // Return to VS/VU mode: swap HS→VS CSRs
               // Clear SPV first
               fState.CSR.fData[TCSR.TAddress.HSTATUS]:=fState.CSR.fData[TCSR.TAddress.HSTATUS] and not (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.SPV);
               SetVirtualMode(true);
              end;

              // Set PC to CSR.SEPC
              fState.PC:=fState.CSR.fData[TCSR.TAddress.SEPC]-4;

              CheckInterrupts;

              result:=4;
              exit;

             end else begin
              SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
              result:=4;
              exit;
             end;
            end;
            $18:begin
             // mret
             if fState.Mode=THART.TMode.Machine then begin

              Temporary:=fState.CSR.fData[TCSR.TAddress.MSTATUS];

              SetMode(THART.TMode((Temporary shr TCSR.TMask.TMSTATUSBit.MPP) and 3));

              // Clear MPRV when returning to less privileged mode
              if fState.Mode<THART.TMode.Machine then begin
               Temporary:=Temporary and not (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MPRV);
              end;

              // Determine if returning to virtual mode
              fWasVirtual:=(Temporary and (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MPV))<>0;

              // Set MPP to U (before swap, so this lands in M-mode persistent state)
              Temporary:=(Temporary and not (TPasRISCVUInt64(3) shl TCSR.TMask.TMSTATUSBit.MPP)) or ((ord(THART.TMode.User) and 3) shl TCSR.TMask.TMSTATUSBit.MPP);

              // Set MIE to MPIE (before swap)
              Temporary:=(Temporary and not (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MIE)) or (((Temporary shr TCSR.TMask.TMSTATUSBit.MPIE) and 1) shl TCSR.TMask.TMSTATUSBit.MIE);

              // Clear MPV (before swap)
              Temporary:=Temporary and not (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MPV);

              fState.CSR.fData[TCSR.TAddress.MSTATUS]:=Temporary;

              // Check MPV: should we return to virtual mode?
              if fWasVirtual and (fState.Mode<>THART.TMode.Machine) then begin
               SetVirtualMode(true);
              end;

              // Set PC to CSR.MEPC
              fState.PC:=fState.CSR.fData[TCSR.TAddress.MEPC]-4;

              CheckInterrupts;

              result:=4;
              exit;

             end else begin
              SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
              result:=4;
              exit;
             end;
            end;
            else begin
             SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
             result:=4;
             exit;
            end;
           end;
          end;
          $05:begin
           // wfi
           case (aInstruction shr 25) and $7f of
            $08:begin
             // wfi
             if fState.VirtualMode then begin
              // In VS-mode: check hstatus.VTW
              if (fState.CSR.fData[TCSR.TAddress.HSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.VTW))<>0 then begin
               SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
              end else begin
               if InterruptsPending=0 then begin
                SleepUntilNextInterrupt;
               end;
              end;
             end else if ((fState.Mode>=THART.TMode.Supervisor) and
                          ((fState.CSR.fData[TCSR.TAddress.MSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.TW))=0)) or
                         (fState.Mode=THART.TMode.Machine) then begin
              if InterruptsPending=0 then begin
               SleepUntilNextInterrupt;
              end;
             end else begin
              SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
             end;
             result:=4;
             exit;
            end;
            else begin
             SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
             result:=4;
             exit;
            end;
           end;
          end;
          $0d:begin
           // wrs.nto (Zawrs) - Wait on Reservation Set, No Timeout
           // NOP in emulator: no hardware reservation set to poll
           result:=4;
           exit;
          end;
          $1d:begin
           // wrs.sto (Zawrs) - Wait on Reservation Set, Short Timeout
           // NOP in emulator: no hardware reservation set to poll
           result:=4;
           exit;
          end;
         end;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // csrrw
       Address:=aInstruction shr 20;
       rs1:=TRegister((aInstruction shr 15) and $1f);
       fCSRHandlerMap[Address](fState.PC,aInstruction,Address,fState.Registers[rs1],TCSROperation.Swap);
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
       // csrrs
       Address:=aInstruction shr 20;
       rs1:=TRegister((aInstruction shr 15) and $1f);
       fCSRHandlerMap[Address](fState.PC,aInstruction,Address,fState.Registers[rs1],TCSROperation.SetBits);
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
       // csrrc
       Address:=aInstruction shr 20;
       rs1:=TRegister((aInstruction shr 15) and $1f);
       fCSRHandlerMap[Address](fState.PC,aInstruction,Address,fState.Registers[rs1],TCSROperation.ClearBits);
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
       // funct3=4: HLV/HSV (H-extension) and Zimop
       case (aInstruction shr 25) and $7f of
        $30:begin
         // HLV.B (rs2=0) / HLV.BU (rs2=1)
         if fState.VirtualMode then begin
          SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end else if (fState.Mode=THART.TMode.User) and ((fState.CSR.fData[TCSR.TAddress.HSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.HU))=0) then begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end else begin
          rd:=TRegister((aInstruction shr 7) and $1f);
          rs1:=TRegister((aInstruction shr 15) and $1f);
          Address:=ForcedVirtualTranslate(fState.Registers[rs1],TMMU.TAccessType.Load);
          if fState.ExceptionValue<>TExceptionValue.None then begin 
           result:=4; 
           exit; 
          end;
          if ((aInstruction shr 20) and $1f)=0 then begin
           // HLV.B - signed byte
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(TPasRISCVUInt8(fBus.Load(self,Address,1)))));
           end;
          end else begin
           // HLV.BU - unsigned byte
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt8(fBus.Load(self,Address,1));
           end;
          end;
          result:=4;
          exit;
         end;
        end;
        $31:begin
         // HSV.B
         if fState.VirtualMode then begin
          SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end else if (fState.Mode=THART.TMode.User) and ((fState.CSR.fData[TCSR.TAddress.HSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.HU))=0) then begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end else begin
          rs1:=TRegister((aInstruction shr 15) and $1f);
          rs2:=TRegister((aInstruction shr 20) and $1f);
          Address:=ForcedVirtualTranslate(fState.Registers[rs1],TMMU.TAccessType.Store);
          if fState.ExceptionValue<>TExceptionValue.None then begin
           result:=4; 
           exit; 
          end else begin 
           fBus.Store(self,Address,TPasRISCVUInt64(TPasRISCVUInt8(fState.Registers[rs2])),1);
           result:=4;
           exit;
          end; 
         end;
        end;
        $32:begin
         // HLV.H / HLV.HU / HLVX.HU
         if fState.VirtualMode then begin
          SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end else if (fState.Mode=THART.TMode.User) and ((fState.CSR.fData[TCSR.TAddress.HSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.HU))=0) then begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end else begin
          rd:=TRegister((aInstruction shr 7) and $1f);
          rs1:=TRegister((aInstruction shr 15) and $1f);
          // HLVX uses Instruction access type for execute-permission check
          if ((aInstruction shr 20) and $1f)=3 then begin
           Address:=ForcedVirtualTranslate(fState.Registers[rs1],TMMU.TAccessType.Instruction);
          end else begin
           Address:=ForcedVirtualTranslate(fState.Registers[rs1],TMMU.TAccessType.Load);
          end; 
          if fState.ExceptionValue<>TExceptionValue.None then begin 
           result:=4; 
           exit; 
          end;
          case (aInstruction shr 20) and $1f of
           0:begin // HLV.H - signed half
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(TPasRISCVUInt16(fBus.Load(self,Address,2)))));
            end;
           end;
           1:begin // HLV.HU - unsigned half
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt16(fBus.Load(self,Address,2));
            end;
           end;
           3:begin // HLVX.HU - execute-permission unsigned half
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt16(fBus.Load(self,Address,2));
            end;
           end;
           else begin
            SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
           end;
          end;
          result:=4;
          exit;
         end;
        end;
        $33:begin
         // HSV.H
         if fState.VirtualMode then begin
          SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end else if (fState.Mode=THART.TMode.User) and ((fState.CSR.fData[TCSR.TAddress.HSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.HU))=0) then begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end else begin
          rs1:=TRegister((aInstruction shr 15) and $1f);
          rs2:=TRegister((aInstruction shr 20) and $1f);
          Address:=ForcedVirtualTranslate(fState.Registers[rs1],TMMU.TAccessType.Store);
          if fState.ExceptionValue<>TExceptionValue.None then begin 
           result:=4; 
           exit; 
          end;
          fBus.Store(self,Address,TPasRISCVUInt64(TPasRISCVUInt16(fState.Registers[rs2])),2);
          result:=4;
          exit;
         end;
        end;
        $34:begin
         // HLV.W / HLV.WU / HLVX.WU
         if fState.VirtualMode then begin
          SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end else if (fState.Mode=THART.TMode.User) and ((fState.CSR.fData[TCSR.TAddress.HSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.HU))=0) then begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end else begin
          rd:=TRegister((aInstruction shr 7) and $1f);
          rs1:=TRegister((aInstruction shr 15) and $1f);
          // HLVX uses Instruction access type for execute-permission check
          if ((aInstruction shr 20) and $1f)=3 then begin
           Address:=ForcedVirtualTranslate(fState.Registers[rs1],TMMU.TAccessType.Instruction);
          end else begin
           Address:=ForcedVirtualTranslate(fState.Registers[rs1],TMMU.TAccessType.Load);
          end; 
          if fState.ExceptionValue<>TExceptionValue.None then begin 
           result:=4; 
           exit; 
          end;
          case (aInstruction shr 20) and $1f of
           0:begin // HLV.W - signed word
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(fBus.Load(self,Address,4)))));
            end;
           end;
           1:begin // HLV.WU - unsigned word
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt32(fBus.Load(self,Address,4));
            end;
           end;
           3:begin // HLVX.WU - execute-permission unsigned word
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt32(fBus.Load(self,Address,4));
            end;
           end;
           else begin
            SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
           end;
          end;
          result:=4;
          exit;
         end;
        end;
        $35:begin
         // HSV.W
         if fState.VirtualMode then begin
          SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end else if (fState.Mode=THART.TMode.User) and ((fState.CSR.fData[TCSR.TAddress.HSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.HU))=0) then begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end else begin
          rs1:=TRegister((aInstruction shr 15) and $1f);
          rs2:=TRegister((aInstruction shr 20) and $1f);
          Address:=ForcedVirtualTranslate(fState.Registers[rs1],TMMU.TAccessType.Store);
          if fState.ExceptionValue<>TExceptionValue.None then begin 
           result:=4; 
           exit; 
          end;
          fBus.Store(self,Address,TPasRISCVUInt64(TPasRISCVUInt32(fState.Registers[rs2])),4);
          result:=4;
          exit;
         end;
        end;
        $36:begin
         // HLV.D
         if fState.VirtualMode then begin
          SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end else if (fState.Mode=THART.TMode.User) and ((fState.CSR.fData[TCSR.TAddress.HSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.HU))=0) then begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end else begin
          rd:=TRegister((aInstruction shr 7) and $1f);
          rs1:=TRegister((aInstruction shr 15) and $1f);
          Address:=ForcedVirtualTranslate(fState.Registers[rs1],TMMU.TAccessType.Load);
          if fState.ExceptionValue<>TExceptionValue.None then begin
           result:=4;
           exit;
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=fBus.Load(self,Address,8);
          end;
          result:=4;
          exit;
         end;
        end;
        $37:begin
         // HSV.D
         if fState.VirtualMode then begin
          SetException(TExceptionValue.VirtualInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end else if (fState.Mode=THART.TMode.User) and ((fState.CSR.fData[TCSR.TAddress.HSTATUS] and (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.HU))=0) then begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end else begin
          rs1:=TRegister((aInstruction shr 15) and $1f);
          rs2:=TRegister((aInstruction shr 20) and $1f);
          Address:=ForcedVirtualTranslate(fState.Registers[rs1],TMMU.TAccessType.Store);
          if fState.ExceptionValue<>TExceptionValue.None then begin 
           result:=4; 
           exit; 
          end;
          fBus.Store(self,Address,fState.Registers[rs2],8);
          result:=4;
          exit;
         end;
        end;
        else begin
         // Zimop - mop.r.N / mop.rr.N (write 0 to rd)
         if (aInstruction and $b0000000)=$80000000 then begin // bit[31]=1, bits[29:28]=00
          rd:=TRegister((aInstruction shr 7) and $1f);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=0;
          end;
          result:=4;
          exit;
         end else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$5:{$else}$05,$0d,$15,$1d,$25,$2d,$35,$3d,$45,$4d,$55,$5d,$65,$6d,$75,$7d,$85,$8d,$95,$9d,$a5,$ad,$b5,$bd,$c5,$cd,$d5,$dd,$e5,$ed,$f5,$fd:{$endif}begin
       // csrrwi
       Address:=aInstruction shr 20;
       fCSRHandlerMap[Address](fState.PC,aInstruction,Address,(aInstruction shr 15) and $1f,TCSROperation.Swap);
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$6:{$else}$06,$0e,$16,$1e,$26,$2e,$36,$3e,$46,$4e,$56,$5e,$66,$6e,$76,$7e,$86,$8e,$96,$9e,$a6,$ae,$b6,$be,$c6,$ce,$d6,$de,$e6,$ee,$f6,$fe:{$endif}begin
       // csrrsi
       Address:=aInstruction shr 20;
       fCSRHandlerMap[Address](fState.PC,aInstruction,Address,(aInstruction shr 15) and $1f,TCSROperation.SetBits);
       result:=4;
       exit;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$7:{$else}$07,$0f,$17,$1f,$27,$2f,$37,$3f,$47,$4f,$57,$5f,$67,$6f,$77,$7f,$87,$8f,$97,$9f,$a7,$af,$b7,$bf,$c7,$cf,$d7,$df,$e7,$ef,$f7,$ff:{$endif}begin
       // csrrci
       Address:=aInstruction shr 20;
       fCSRHandlerMap[Address](fState.PC,aInstruction,Address,(aInstruction shr 15) and $1f,TCSROperation.ClearBits);
       result:=4;
       exit;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    // FPU

    //////////////////////////////////////////////////////////////////////////////
    // FPU Load                                                                 //
    //////////////////////////////////////////////////////////////////////////////
    $07{$ifdef TryToForceCaseJumpTableOnLevel1},$87{$endif}:begin
     // fl
     if not fState.CSR.IsFPUEnabled then begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
      result:=4;
      exit;
     end else begin
      case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
       {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
        // flw
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        rs1:=TRegister((aInstruction shr 15) and $1f);
        Offset:=TPasRISCVInt64(TPasRISCVInt32(SARLongint(TPasRISCVInt32(aInstruction),20)));
//      Offset:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(aInstruction)),20);
        Address:=fState.Registers[rs1]+TPasRISCVUInt64(Offset);
{$ifdef UseSpecializedRegisterLoadStores}
        LoadRegisterF32(frd,Address);
{$else}
        Temporary:=Load32(Address) or TPasRISCVUInt64($ffffffff00000000);
        if fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None then begin
         fState.FPURegisters[frd].ui64:=Temporary;
         fState.CSR.SetFSDirty;
        end;
{$endif}
        SetFPUExceptions(FE_ALL_EXCEPT and not FE_INEXACT);
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
        // fld
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        rs1:=TRegister((aInstruction shr 15) and $1f);
        Offset:=TPasRISCVInt64(TPasRISCVInt32(SARLongint(TPasRISCVInt32(aInstruction),20)));
//      Offset:=SARInt64(TPasRISCVInt64(TPasRISCVInt32(aInstruction)),20);
        Address:=fState.Registers[rs1]+TPasRISCVUInt64(Offset);
{$ifdef UseSpecializedRegisterLoadStores}
        LoadRegisterF64(frd,Address);
{$else}
        Temporary:=Load64(Address);
        if fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None then begin
         fState.FPURegisters[frd].ui64:=Temporary;
         fState.CSR.SetFSDirty;
        end;
{$endif}
        SetFPUExceptions(FE_ALL_EXCEPT and not FE_INEXACT);
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
        // flh (Zfhmin)
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        rs1:=TRegister((aInstruction shr 15) and $1f);
        Offset:=TPasRISCVInt64(TPasRISCVInt32(SARLongint(TPasRISCVInt32(aInstruction),20)));
        Address:=fState.Registers[rs1]+TPasRISCVUInt64(Offset);
        Temporary:=Load16(Address) or TPasRISCVUInt64($ffffffffffff0000);
        if fState.ExceptionValue=TPasRISCV.THART.TExceptionValue.None then begin
         fState.FPURegisters[frd].ui64:=Temporary;
         fState.CSR.SetFSDirty;
        end;
        SetFPUExceptions(FE_ALL_EXCEPT and not FE_INEXACT);
        result:=4;
        exit;
       end;
       else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
        result:=4;
        exit;
       end;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // FPU Store                                                                //
    //////////////////////////////////////////////////////////////////////////////
    $27{$ifdef TryToForceCaseJumpTableOnLevel1},$a7{$endif}:begin
     // fs
     if not fState.CSR.IsFPUEnabled then begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
      result:=4;
      exit;
     end else begin
      case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
       {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
        // fsw
        rs1:=TRegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        Offset:=SignExtend((((aInstruction shr 25) and $7f) shl 5) or ((aInstruction shr 7) and $1f),12);
        Address:=fState.Registers[rs1]+TPasRISCVUInt64(Offset);
{$ifdef UseSpecializedRegisterLoadStores}
        StoreRegisterF32(Address,frs2);
{$else}
        Store32(Address,fState.FPURegisters[frs2].ui64);
{$endif}
        SetFPUExceptions(FE_ALL_EXCEPT and not FE_INEXACT);
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
        // fsd
        rs1:=TRegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        Offset:=SignExtend((((aInstruction shr 25) and $7f) shl 5) or ((aInstruction shr 7) and $1f),12);
        Address:=fState.Registers[rs1]+TPasRISCVUInt64(Offset);
{$ifdef UseSpecializedRegisterLoadStores}
        StoreRegisterF64(Address,frs2);
{$else}
        Store64(Address,fState.FPURegisters[frs2].ui64);
{$endif}
        SetFPUExceptions(FE_ALL_EXCEPT and not FE_INEXACT);
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
        // fsh (Zfhmin)
        rs1:=TRegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        Offset:=SignExtend((((aInstruction shr 25) and $7f) shl 5) or ((aInstruction shr 7) and $1f),12);
        Address:=fState.Registers[rs1]+TPasRISCVUInt64(Offset);
        Store16(Address,fState.FPURegisters[frs2].ui16);
        SetFPUExceptions(FE_ALL_EXCEPT and not FE_INEXACT);
        result:=4;
        exit;
       end;
       else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
        result:=4;
        exit;
       end;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // FPU Add                                                                  //
    //////////////////////////////////////////////////////////////////////////////
    $43{$ifdef TryToForceCaseJumpTableOnLevel1},$c3{$endif}:begin
     // fmadd
     if not fState.CSR.IsFPUEnabled then begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
      result:=4;
      exit;
     end else begin
      case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction and TPasRISCVUInt32($03000000)) shr 25) of
       {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
        // fmadd.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        fState.FPURegisters[frd].f32:=(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)*ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64))+ReadNormalizedFloatF32(fState.FPURegisters[frs3].ui64);
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        if fState.FPURegisters[frd].ui32=TPasRISCVUInt32($7fc00000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
        // fmadd.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        fState.FPURegisters[frd].f64:=(fState.FPURegisters[frs1].f64*fState.FPURegisters[frs2].f64)+fState.FPURegisters[frs3].f64;
        if fState.FPURegisters[frd].ui64=TPasRISCVUInt64($7ff8000000000000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
        // fmadd.h (Zfh)
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        HalfFloat:=TPasRISCVHalfFloat.FromFloat((ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat*ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).ToFloat)+ReadNormalizedFloatF16(fState.FPURegisters[frs3].ui64).ToFloat);
        fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(HalfFloat.Value) or TPasRISCVUInt64($ffffffffffff0000);
        if HalfFloat.IsNaN then begin
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($ffffffffffff7e00);
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
        result:=4;
        exit;
       end;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // FPU Sub                                                                  //
    //////////////////////////////////////////////////////////////////////////////
    $47{$ifdef TryToForceCaseJumpTableOnLevel1},$c7{$endif}:begin
     // fmsub
     if not fState.CSR.IsFPUEnabled then begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
      result:=4;
      exit;
     end else begin
      case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction and TPasRISCVUInt32($03000000)) shr 25) of
       {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
        // fmsub.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        fState.FPURegisters[frd].f32:=(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)*ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64))-ReadNormalizedFloatF32(fState.FPURegisters[frs3].ui64);
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        if fState.FPURegisters[frd].ui32=TPasRISCVUInt32($7fc00000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
        // fmsub.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        fState.FPURegisters[frd].f64:=(fState.FPURegisters[frs1].f64*fState.FPURegisters[frs2].f64)-fState.FPURegisters[frs3].f64;
        if fState.FPURegisters[frd].ui64=TPasRISCVUInt64($7ff8000000000000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
        // fmsub.h (Zfh)
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        HalfFloat:=TPasRISCVHalfFloat.FromFloat((ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat*ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).ToFloat)-ReadNormalizedFloatF16(fState.FPURegisters[frs3].ui64).ToFloat);
        fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(HalfFloat.Value) or TPasRISCVUInt64($ffffffffffff0000);
        if HalfFloat.IsNaN then begin
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($ffffffffffff7e00);
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
        result:=4;
        exit;
       end;
      end;
     end;
    end;

{$if defined(PasRISCVCPUDebug)}
    $7f:begin
     // Custom instruction
     case (aInstruction shr 8) and $ff of
      $00:begin
      end;
      $01:begin
{$if defined(PasRISCVCPUDumpDebug)}
       DumpDebug:=true;
{$ifend}
      end;
      $02:begin
{$if defined(PasRISCVCPUDebug)}
       DumpDebug:=false;
{$ifend}
      end;
      $03:begin
      end;
      else begin
      end;
     end;
     result:=4;
     exit;
    end;
{$ifend}

    //////////////////////////////////////////////////////////////////////////////
    // FPU NAdd                                                                 //
    //////////////////////////////////////////////////////////////////////////////
    $4b{$ifdef TryToForceCaseJumpTableOnLevel1},$cb{$endif}:begin
     // fnmadd
     if not fState.CSR.IsFPUEnabled then begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
      result:=4;
      exit;
     end else begin
      case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction and TPasRISCVUInt32($03000000)) shr 25) of
       {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
        // fnmadd.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        fState.FPURegisters[frd].f32:=((-ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64))*ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64))+ReadNormalizedFloatF32(fState.FPURegisters[frs3].ui64);
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        if fState.FPURegisters[frd].ui32=TPasRISCVUInt32($7fc00000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
        // fnmadd.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        fState.FPURegisters[frd].f64:=((-fState.FPURegisters[frs1].f64)*fState.FPURegisters[frs2].f64)+fState.FPURegisters[frs3].f64;
        if fState.FPURegisters[frd].ui64=TPasRISCVUInt64($7ff8000000000000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
        // fnmadd.h (Zfh)
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        HalfFloat:=TPasRISCVHalfFloat.FromFloat(((-ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat)*ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).ToFloat)+ReadNormalizedFloatF16(fState.FPURegisters[frs3].ui64).ToFloat);
        fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(HalfFloat.Value) or TPasRISCVUInt64($ffffffffffff0000);
        if HalfFloat.IsNaN then begin
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($ffffffffffff7e00);
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
        result:=4;
        exit;
       end;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // FPU NSub                                                                 //
    //////////////////////////////////////////////////////////////////////////////
    $4f{$ifdef TryToForceCaseJumpTableOnLevel1},$cf{$endif}:begin
     // fnmsub
     if not fState.CSR.IsFPUEnabled then begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
      result:=4;
      exit;
     end else begin
      case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction and TPasRISCVUInt32($03000000)) shr 25) of
       {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
        // fnmsub.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        fState.FPURegisters[frd].f32:=((-ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64))*ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64))-ReadNormalizedFloatF32(fState.FPURegisters[frs3].ui64);
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        if fState.FPURegisters[frd].ui32=TPasRISCVUInt32($7fc00000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
        // fnmsub.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        fState.FPURegisters[frd].f64:=((-fState.FPURegisters[frs1].f64)*fState.FPURegisters[frs2].f64)-fState.FPURegisters[frs3].f64;
        if fState.FPURegisters[frd].ui64=TPasRISCVUInt64($7ff8000000000000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
        // fnmsub.h (Zfh)
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        frs3:=TFPURegister((aInstruction shr 27) and $1f);
        HalfFloat:=TPasRISCVHalfFloat.FromFloat(((-ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat)*ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).ToFloat)-ReadNormalizedFloatF16(fState.FPURegisters[frs3].ui64).ToFloat);
        fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(HalfFloat.Value) or TPasRISCVUInt64($ffffffffffff0000);
        if HalfFloat.IsNaN then begin
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($ffffffffffff7e00);
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
        result:=4;
        exit;
       end;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // FPU Op                                                                   //
    //////////////////////////////////////////////////////////////////////////////
    $53{$ifdef TryToForceCaseJumpTableOnLevel1},$d3{$endif}:begin
     // fother
     if not fState.CSR.IsFPUEnabled then begin
      SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
      result:=4;
      exit;
     end else begin
      case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 25) and $7f) of
       {$ifndef TryToForceCaseJumpTableOnLevel2}$00:{$else}$00,$80:{$endif}begin
        // fadd.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        if IsFloat32Infinite(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) and IsFloat32Infinite(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
         fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000);
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end else begin
         fState.FPURegisters[frd].f32:=ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)+ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64);
         if fState.FPURegisters[frd].ui32=TPasRISCVUInt32($7fc00000) then begin // Canonical NaN
          fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
         end;
        end;
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$01:{$else}$01,$81:{$endif}begin
        // fadd.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        if IsFloat64Infinite(fState.FPURegisters[frs1].f64) and IsFloat64Infinite(fState.FPURegisters[frs2].f64) then begin
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000);
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end else begin
         fState.FPURegisters[frd].f64:=fState.FPURegisters[frs1].f64+fState.FPURegisters[frs2].f64;
         if fState.FPURegisters[frd].ui64=TPasRISCVUInt64($7ff8000000000000) then begin // Canonical NaN
          fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
         end;
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$02:{$else}$02,$82:{$endif}begin
        // fadd.h (Zfh)
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        HalfFloat:=TPasRISCVHalfFloat.FromFloat(ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat+ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).ToFloat);
        if HalfFloat.IsNaN then begin
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($ffffffffffff7e00);
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end else begin
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(HalfFloat.Value) or TPasRISCVUInt64($ffffffffffff0000);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$04:{$else}$04,$84:{$endif}begin
        // fsub.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        if IsFloat32Infinite(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) and IsFloat32Infinite(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
         fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000);
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end else begin
         fState.FPURegisters[frd].f32:=ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)-ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64);
         if fState.FPURegisters[frd].ui32=TPasRISCVUInt32($7fc00000) then begin // Canonical NaN
          fState.FPURegisters[frd].f32:=TPasRISCVUInt32($7fc00000);
          fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
         end;
        end;
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$05:{$else}$05,$85:{$endif}begin
        // fsub.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        if IsFloat64Infinite(fState.FPURegisters[frs1].f64) and IsFloat64Infinite(fState.FPURegisters[frs2].f64) then begin
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000);
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end else begin
         fState.FPURegisters[frd].f64:=fState.FPURegisters[frs1].f64-fState.FPURegisters[frs2].f64;
         if fState.FPURegisters[frd].ui64=TPasRISCVUInt64($7ff8000000000000) then begin // Canonical NaN
          fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
         end;
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$06:{$else}$06,$86:{$endif}begin
        // fsub.h (Zfh)
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        HalfFloat:=TPasRISCVHalfFloat.FromFloat(ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat-ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).ToFloat);
        if HalfFloat.IsNaN then begin
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($ffffffffffff7e00);
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end else begin
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(HalfFloat.Value) or TPasRISCVUInt64($ffffffffffff0000);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$08:{$else}$08,$88:{$endif}begin
        // fmul.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        fState.FPURegisters[frd].f32:=ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)*ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64);
        if fState.FPURegisters[frd].ui32=TPasRISCVUInt32($7fc00000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$09:{$else}$09,$89:{$endif}begin
        // fmul.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        fState.FPURegisters[frd].f64:=fState.FPURegisters[frs1].f64*fState.FPURegisters[frs2].f64;
        if fState.FPURegisters[frd].ui64=TPasRISCVUInt64($7ff8000000000000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$0a:{$else}$0a,$8a:{$endif}begin
        // fmul.h (Zfh)
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        HalfFloat:=TPasRISCVHalfFloat.FromFloat(ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat*ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).ToFloat);
        if HalfFloat.IsNaN then begin
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($ffffffffffff7e00);
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end else begin
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(HalfFloat.Value) or TPasRISCVUInt64($ffffffffffff0000);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$0c:{$else}$0c,$8c:{$endif}begin
        // fdiv.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        fState.FPURegisters[frd].f32:=ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)/ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64);
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        if fState.FPURegisters[frd].ui32=TPasRISCVUInt32($7fc00000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$0d:{$else}$0d,$8d:{$endif}begin
        // fdiv.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        fState.FPURegisters[frd].f64:=fState.FPURegisters[frs1].f64/fState.FPURegisters[frs2].f64;
        if fState.FPURegisters[frd].ui64=TPasRISCVUInt64($7ff8000000000000) then begin // Canonical NaN
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$0e:{$else}$0e,$8e:{$endif}begin
        // fdiv.h (Zfh)
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        frs2:=TFPURegister((aInstruction shr 20) and $1f);
        HalfFloat:=TPasRISCVHalfFloat.FromFloat(ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat/ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).ToFloat);
        if HalfFloat.IsNaN then begin
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($ffffffffffff7e00);
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
        end else begin
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(HalfFloat.Value) or TPasRISCVUInt64($ffffffffffff0000);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$10:{$else}$10,$90:{$endif}begin
        // fsngl.s
        case (aInstruction shr 12) and 7 of
         $0:begin
          // fsgnl.s
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          fState.FPURegisters[frd].ui64:=((ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64) and TPasRISCVUInt32($7fffffff)) or (ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64) and TPasRISCVUInt32($80000000))) or TPasRISCVUInt64($ffffffff00000000);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $1:begin
          // fsgnjn.s
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          fState.FPURegisters[frd].ui64:=((ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64) and TPasRISCVUInt32($7fffffff)) or ((not ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64)) and TPasRISCVUInt32($80000000))) or TPasRISCVUInt64($ffffffff00000000);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $2:begin
          // fsgnjx.s
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          fState.FPURegisters[frd].ui64:=((ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64) and TPasRISCVUInt32($7fffffff)) or ((ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64) xor ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64)) and TPasRISCVUInt32($80000000))) or TPasRISCVUInt64($ffffffff00000000);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$11:{$else}$11,$91:{$endif}begin
        // fsngl.d
        case (aInstruction shr 12) and 7 of
         $0:begin
          // fsgnl.d
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          fState.FPURegisters[frd].ui64:=(fState.FPURegisters[frs1].ui64 and TPasRISCVUInt64($7fffffffffffffff)) or (fState.FPURegisters[frs2].ui64 and TPasRISCVUInt64($8000000000000000));
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $1:begin
          // fsgnjn.d
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          fState.FPURegisters[frd].ui64:=(fState.FPURegisters[frs1].ui64 and TPasRISCVUInt64($7fffffffffffffff)) or ((not fState.FPURegisters[frs2].ui64) and TPasRISCVUInt64($8000000000000000));
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $2:begin
          // fsgnjx.d
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          fState.FPURegisters[frd].ui64:=(fState.FPURegisters[frs1].ui64 and TPasRISCVUInt64($7fffffffffffffff)) or ((fState.FPURegisters[frs1].ui64 xor fState.FPURegisters[frs2].ui64) and TPasRISCVUInt64($8000000000000000));
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$12:{$else}$12,$92:{$endif}begin
        // fsgnj.h (Zfh)
        case (aInstruction shr 12) and 7 of
         $0:begin
          // fsgnj.h
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          fState.FPURegisters[frd].ui64:=((ReadNormalizedFloatUI16(fState.FPURegisters[frs1].ui64) and TPasRISCVUInt16($7fff)) or (ReadNormalizedFloatUI16(fState.FPURegisters[frs2].ui64) and TPasRISCVUInt16($8000))) or TPasRISCVUInt64($ffffffffffff0000);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $1:begin
          // fsgnjn.h
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          fState.FPURegisters[frd].ui64:=((ReadNormalizedFloatUI16(fState.FPURegisters[frs1].ui64) and TPasRISCVUInt16($7fff)) or ((not ReadNormalizedFloatUI16(fState.FPURegisters[frs2].ui64)) and TPasRISCVUInt16($8000))) or TPasRISCVUInt64($ffffffffffff0000);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $2:begin
          // fsgnjx.h
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          fState.FPURegisters[frd].ui64:=((ReadNormalizedFloatUI16(fState.FPURegisters[frs1].ui64) and TPasRISCVUInt16($7fff)) or ((ReadNormalizedFloatUI16(fState.FPURegisters[frs1].ui64) xor ReadNormalizedFloatUI16(fState.FPURegisters[frs2].ui64)) and TPasRISCVUInt16($8000))) or TPasRISCVUInt64($ffffffffffff0000);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$14:{$else}$14,$94:{$endif}begin
        // fminmax.s
        case (aInstruction shr 12) and 7 of
         $0:begin
          // fmin.s
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) or IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) then begin
           if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
            fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000); // Canonical NaN
           end else begin
            fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
           end;
          end else begin
           if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
            fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
           end else begin
            if ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)<ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64) then begin
             fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
            end else if ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)>ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64) then begin
             fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
            end else begin
             if (ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64) and $80000000)<>0 then begin
              fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
             end else begin
              fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
             end;
            end;
           end;
           fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $1:begin
          // fmax.s
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) or IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) then begin
           if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
            fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000); // Canonical NaN
           end else begin
            fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
           end;
          end else begin
           if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
            fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
           end else begin
            if ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)>ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64) then begin
             fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
            end else if ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)<ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64) then begin
             fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
            end else begin
             if (ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64) and $80000000)<>0 then begin
              fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
             end else begin
              fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
             end;
            end;
           end;
           fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $2:begin
          // fminm.s (Zfa) - IEEE 754-2019 minimum: NaN if either operand is NaN
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) or IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) or IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
           fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000); // Canonical NaN
          end else begin
           if ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)<ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64) then begin
            fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
           end else if ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)>ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64) then begin
            fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
           end else begin
            if (ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64) and $80000000)<>0 then begin
             fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
            end else begin
             fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
            end;
           end;
          end;
          fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $3:begin
          // fmaxm.s (Zfa) - IEEE 754-2019 maximum: NaN if either operand is NaN
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) or IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) or IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
           fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000); // Canonical NaN
          end else begin
           if ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)>ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64) then begin
            fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
           end else if ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)<ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64) then begin
            fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
           end else begin
            if (ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64) and $80000000)<>0 then begin
             fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs2].ui64);
            end else begin
             fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
            end;
           end;
          end;
          fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$15:{$else}$15,$95:{$endif}begin
        // fminmax.d
        case (aInstruction shr 12) and 7 of
         $0:begin
          // fmin.d
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat64SignalingNaN(fState.FPURegisters[frs1].f64) or IsFloat64SignalingNaN(fState.FPURegisters[frs2].f64) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          if IsFloat64NaN(fState.FPURegisters[frs1].f64) then begin
           if IsFloat64NaN(fState.FPURegisters[frs2].f64) then begin
            fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000); // Canonical NaN
           end else begin
            fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs2].ui64;
           end;
          end else begin
           if IsFloat64NaN(fState.FPURegisters[frs2].f64) then begin
            fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs1].ui64;
           end else begin
            if fState.FPURegisters[frs1].f64<fState.FPURegisters[frs2].f64 then begin
             fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs1].ui64;
            end else if fState.FPURegisters[frs1].f64>fState.FPURegisters[frs2].f64 then begin
             fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs2].ui64;
            end else begin
             if (fState.FPURegisters[frs1].ui64 and TPasRISCVUInt64($8000000000000000))<>0 then begin
              fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs1].ui64;
             end else begin
              fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs2].ui64;
             end;
            end;
           end;
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $1:begin
          // fmax.d
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat64SignalingNaN(fState.FPURegisters[frs1].f64) or IsFloat64SignalingNaN(fState.FPURegisters[frs2].f64) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          if IsFloat64NaN(fState.FPURegisters[frs1].f64) then begin
           if IsFloat64NaN(fState.FPURegisters[frs2].f64) then begin
            fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000); // Canonical NaN
           end else begin
            fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs2].ui64;
           end;
          end else begin
           if IsFloat64NaN(fState.FPURegisters[frs2].f64) then begin
            fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs1].ui64;
           end else begin
            if fState.FPURegisters[frs1].f64>fState.FPURegisters[frs2].f64 then begin
             fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs1].ui64;
            end else if fState.FPURegisters[frs1].f64<fState.FPURegisters[frs2].f64 then begin
             fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs2].ui64;
            end else begin
             if (fState.FPURegisters[frs1].ui64 and TPasRISCVUInt64($8000000000000000))<>0 then begin
              fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs2].ui64;
             end else begin
              fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs1].ui64;
             end;
            end;
           end;
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $2:begin
          // fminm.d (Zfa) - IEEE 754-2019 minimum: NaN if either operand is NaN
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat64SignalingNaN(fState.FPURegisters[frs1].f64) or IsFloat64SignalingNaN(fState.FPURegisters[frs2].f64) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          if IsFloat64NaN(fState.FPURegisters[frs1].f64) or IsFloat64NaN(fState.FPURegisters[frs2].f64) then begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000); // Canonical NaN
          end else begin
           if fState.FPURegisters[frs1].f64<fState.FPURegisters[frs2].f64 then begin
            fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs1].ui64;
           end else if fState.FPURegisters[frs1].f64>fState.FPURegisters[frs2].f64 then begin
            fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs2].ui64;
           end else begin
            if (fState.FPURegisters[frs1].ui64 and TPasRISCVUInt64($8000000000000000))<>0 then begin
             fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs1].ui64;
            end else begin
             fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs2].ui64;
            end;
           end;
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $3:begin
          // fmaxm.d (Zfa) - IEEE 754-2019 maximum: NaN if either operand is NaN
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat64SignalingNaN(fState.FPURegisters[frs1].f64) or IsFloat64SignalingNaN(fState.FPURegisters[frs2].f64) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          if IsFloat64NaN(fState.FPURegisters[frs1].f64) or IsFloat64NaN(fState.FPURegisters[frs2].f64) then begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000); // Canonical NaN
          end else begin
           if fState.FPURegisters[frs1].f64>fState.FPURegisters[frs2].f64 then begin
            fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs1].ui64;
           end else if fState.FPURegisters[frs1].f64<fState.FPURegisters[frs2].f64 then begin
            fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs2].ui64;
           end else begin
            if (fState.FPURegisters[frs1].ui64 and TPasRISCVUInt64($8000000000000000))<>0 then begin
             fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs2].ui64;
            end else begin
             fState.FPURegisters[frd].ui64:=fState.FPURegisters[frs1].ui64;
            end;
           end;
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$16:{$else}$16,$96:{$endif}begin
        // fminmax.h (Zfh)
        case (aInstruction shr 12) and 7 of
         $0:begin
          // fmin.h
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).IsNaN or ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).IsNaN then begin
           if ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).IsNaN and ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).IsNaN then begin
            fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($ffffffffffff7e00);
           end else if ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).IsNaN then begin
            fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(ReadNormalizedFloatUI16(fState.FPURegisters[frs2].ui64)) or TPasRISCVUInt64($ffffffffffff0000);
           end else begin
            fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(ReadNormalizedFloatUI16(fState.FPURegisters[frs1].ui64)) or TPasRISCVUInt64($ffffffffffff0000);
           end;
          end else if ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat<ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).ToFloat then begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(ReadNormalizedFloatUI16(fState.FPURegisters[frs1].ui64)) or TPasRISCVUInt64($ffffffffffff0000);
          end else begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(ReadNormalizedFloatUI16(fState.FPURegisters[frs2].ui64)) or TPasRISCVUInt64($ffffffffffff0000);
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $1:begin
          // fmax.h
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).IsNaN or ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).IsNaN then begin
           if ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).IsNaN and ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).IsNaN then begin
            fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($ffffffffffff7e00);
           end else if ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).IsNaN then begin
            fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(ReadNormalizedFloatUI16(fState.FPURegisters[frs2].ui64)) or TPasRISCVUInt64($ffffffffffff0000);
           end else begin
            fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(ReadNormalizedFloatUI16(fState.FPURegisters[frs1].ui64)) or TPasRISCVUInt64($ffffffffffff0000);
           end;
          end else if ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat>ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).ToFloat then begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(ReadNormalizedFloatUI16(fState.FPURegisters[frs1].ui64)) or TPasRISCVUInt64($ffffffffffff0000);
          end else begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(ReadNormalizedFloatUI16(fState.FPURegisters[frs2].ui64)) or TPasRISCVUInt64($ffffffffffff0000);
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $2:begin
          // fminm.h (Zfa) - IEEE 754-2019 minimum
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).IsNaN or ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).IsNaN then begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($ffffffffffff7e00);
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end else if ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat<ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).ToFloat then begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(ReadNormalizedFloatUI16(fState.FPURegisters[frs1].ui64)) or TPasRISCVUInt64($ffffffffffff0000);
          end else begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(ReadNormalizedFloatUI16(fState.FPURegisters[frs2].ui64)) or TPasRISCVUInt64($ffffffffffff0000);
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $3:begin
          // fmaxm.h (Zfa) - IEEE 754-2019 maximum
          frd:=TFPURegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).IsNaN or ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).IsNaN then begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($ffffffffffff7e00);
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end else if ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat>ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).ToFloat then begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(ReadNormalizedFloatUI16(fState.FPURegisters[frs1].ui64)) or TPasRISCVUInt64($ffffffffffff0000);
          end else begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(ReadNormalizedFloatUI16(fState.FPURegisters[frs2].ui64)) or TPasRISCVUInt64($ffffffffffff0000);
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$20:{$else}$20,$a0:{$endif}begin
        // fcvt.s.d / fround.s / froundnx.s (Zfa)
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        case (aInstruction shr 20) and $1f of
         $01:begin
          // fcvt.s.d
          if IsFloat64NaN(fState.FPURegisters[frs1].f64) then begin
           fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000); // Canonical NaN
          end else begin
           fState.FPURegisters[frd].f32:=fState.FPURegisters[frs1].f64;
          end;
          fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $04:begin
          // fround.s (Zfa)
          f32:=ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64);
          if IsFloat32NaN(f32) then begin
           fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000); // Canonical NaN
           if IsFloat32SignalingNaN(f32) then begin
            fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           end;
          end else if IsFloat32Infinite(f32) then begin
           fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
          end else if (ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64) and $7f800000)>=TPasRISCVUInt32($4b000000) then begin
           // |value| >= 2^23, already an integer
           fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
          end else begin
           Immediate:=(aInstruction shr 12) and 7;
           if Immediate=TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundDynamic) then begin
            Immediate:=fState.CSR.fData[TCSR.TAddress.FRM] and TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.Mask);
           end;
           case Immediate of
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundToNearestEven):begin
             f32n:=RoundToNearestTiesToEven32(f32);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundToZero):begin
             f32n:=Trunc(f32);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundDown):begin
             f32n:=Floor(f32);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundUp):begin
             f32n:=Ceil(f32);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundNearestMaxMagnitude):begin
             f32n:=RoundToNearestTiesToMaxMagnitude32(f32);
            end;
            else begin
             SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
             result:=4;
             exit;
            end;
           end;
           if f32n<>f32 then begin
            fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Inexact);
           end;
           fState.FPURegisters[frd].f32:=f32n;
          end;
          fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $05:begin
          // froundnx.s (Zfa)
          f32:=ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64);
          if IsFloat32NaN(f32) then begin
           fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000); // Canonical NaN
           if IsFloat32SignalingNaN(f32) then begin
            fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           end;
          end else if IsFloat32Infinite(f32) then begin
           fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
          end else if (ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64) and $7f800000)>=TPasRISCVUInt32($4b000000) then begin
           // |value| >= 2^23, already an integer
           fState.FPURegisters[frd].ui32:=ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64);
          end else begin
           Immediate:=(aInstruction shr 12) and 7;
           if Immediate=TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundDynamic) then begin
            Immediate:=fState.CSR.fData[TCSR.TAddress.FRM] and TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.Mask);
           end;
           case Immediate of
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundToNearestEven):begin
             f32n:=RoundToNearestTiesToEven32(f32);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundToZero):begin
             f32n:=Trunc(f32);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundDown):begin
             f32n:=Floor(f32);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundUp):begin
             f32n:=Ceil(f32);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundNearestMaxMagnitude):begin
             f32n:=RoundToNearestTiesToMaxMagnitude32(f32);
            end;
            else begin
             SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
             result:=4;
             exit;
            end;
           end;
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Inexact);
           fState.FPURegisters[frd].f32:=f32n;
          end;
          fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $02:begin
          // fcvt.s.h (Zfhmin)
          HalfFloat:=ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64);
          if HalfFloat.IsNaN then begin
           fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000); // Canonical NaN
          end else begin
           fState.FPURegisters[frd].f32:=HalfFloat.ToFloat;
          end;
          fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $06:begin
          // fcvt.s.bf16 (Zfbfmin)
          // BFloat16 is upper 16 bits of float32, so just shift left by 16
          Temporary:=TPasRISCVUInt64(ReadNormalizedFloatUI16(fState.FPURegisters[frs1].ui64));
          fState.FPURegisters[frd].ui32:=TPasRISCVUInt32(Temporary shl 16);
          if IsFloat32NaN(fState.FPURegisters[frd].f32) then begin
           fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000); // Canonical NaN
          end;
          fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$21:{$else}$21,$a1:{$endif}begin
        // fcvt.d.s / fround.d / froundnx.d (Zfa)
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        case (aInstruction shr 20) and $1f of
         $00:begin
          // fcvt.d.s
          if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) then begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000); // Canonical NaN
          end else begin
           fState.FPURegisters[frd].f64:=ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64);
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $04:begin
          // fround.d (Zfa)
          f64:=fState.FPURegisters[frs1].f64;
          if IsFloat64NaN(f64) then begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000); // Canonical NaN
           if IsFloat64SignalingNaN(f64) then begin
            fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           end;
          end else if IsFloat64Infinite(f64) then begin
           fState.FPURegisters[frd].f64:=f64;
          end else if (fState.FPURegisters[frs1].ui64 and $7ff0000000000000)>=TPasRISCVUInt64($4330000000000000) then begin
           // |value| >= 2^52, already an integer
           fState.FPURegisters[frd].f64:=f64;
          end else begin
           Immediate:=(aInstruction shr 12) and 7;
           if Immediate=TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundDynamic) then begin
            Immediate:=fState.CSR.fData[TCSR.TAddress.FRM] and TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.Mask);
           end;
           case Immediate of
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundToNearestEven):begin
             f64n:=RoundToNearestTiesToEven64(f64);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundToZero):begin
             f64n:=Trunc(f64);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundDown):begin
             f64n:=Floor(f64);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundUp):begin
             f64n:=Ceil(f64);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundNearestMaxMagnitude):begin
             f64n:=RoundToNearestTiesToMaxMagnitude64(f64);
            end;
            else begin
             SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
             result:=4;
             exit;
            end;
           end;
           if f64n<>f64 then begin
            fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Inexact);
           end;
           fState.FPURegisters[frd].f64:=f64n;
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $05:begin
          // froundnx.d (Zfa)
          f64:=fState.FPURegisters[frs1].f64;
          if IsFloat64NaN(f64) then begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000); // Canonical NaN
           if IsFloat64SignalingNaN(f64) then begin
            fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           end;
          end else if IsFloat64Infinite(f64) then begin
           fState.FPURegisters[frd].f64:=f64;
          end else if (fState.FPURegisters[frs1].ui64 and $7ff0000000000000)>=TPasRISCVUInt64($4330000000000000) then begin
           // |value| >= 2^52, already an integer
           fState.FPURegisters[frd].f64:=f64;
          end else begin
           Immediate:=(aInstruction shr 12) and 7;
           if Immediate=TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundDynamic) then begin
            Immediate:=fState.CSR.fData[TCSR.TAddress.FRM] and TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.Mask);
           end;
           case Immediate of
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundToNearestEven):begin
             f64n:=RoundToNearestTiesToEven64(f64);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundToZero):begin
             f64n:=Trunc(f64);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundDown):begin
             f64n:=Floor(f64);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundUp):begin
             f64n:=Ceil(f64);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundNearestMaxMagnitude):begin
             f64n:=RoundToNearestTiesToMaxMagnitude64(f64);
            end;
            else begin
             SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
             result:=4;
             exit;
            end;
           end;
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Inexact);
           fState.FPURegisters[frd].f64:=f64n;
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $02:begin
          // fcvt.d.h (Zfhmin)
          HalfFloat:=ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64);
          if HalfFloat.IsNaN then begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000); // Canonical NaN
          end else begin
           fState.FPURegisters[frd].f64:=HalfFloat.ToFloat;
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$22:{$else}$22,$a2:{$endif}begin
        // fcvt.h.s / fcvt.h.d (Zfhmin) / fcvt.bf16.s (Zfbfmin)
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        case (aInstruction shr 20) and $1f of
         $00:begin
          // fcvt.h.s (Zfhmin)
          f32:=ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64);
          if IsFloat32NaN(f32) then begin
           fState.FPURegisters[frd].ui16:=TPasRISCVUInt16($7e00); // Canonical f16 NaN
          end else begin
           HalfFloat:=TPasRISCVHalfFloat.FromFloat(f32);
           fState.FPURegisters[frd].ui16:=HalfFloat.Value;
          end;
          fState.FPURegisters[frd].ui64:=fState.FPURegisters[frd].ui64 or TPasRISCVUInt64($ffffffffffff0000);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $01:begin
          // fcvt.h.d (Zfhmin)
          f64:=fState.FPURegisters[frs1].f64;
          if IsFloat64NaN(f64) then begin
           fState.FPURegisters[frd].ui16:=TPasRISCVUInt16($7e00); // Canonical f16 NaN
          end else begin
           HalfFloat:=TPasRISCVHalfFloat.FromFloat(f64);
           fState.FPURegisters[frd].ui16:=HalfFloat.Value;
          end;
          fState.FPURegisters[frd].ui64:=fState.FPURegisters[frd].ui64 or TPasRISCVUInt64($ffffffffffff0000);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $04:begin
          // fround.h (Zfa)
          HalfFloat:=ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64);
          if HalfFloat.IsNaN then begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($ffffffffffff7e00);
          end else if HalfFloat.IsInfinity then begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(ReadNormalizedFloatUI16(fState.FPURegisters[frs1].ui64)) or TPasRISCVUInt64($ffffffffffff0000);
          end else begin
           f32:=HalfFloat.ToFloat;
           Immediate:=(aInstruction shr 12) and 7;
           if Immediate=TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundDynamic) then begin
            Immediate:=fState.CSR.fData[TCSR.TAddress.FRM] and TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.Mask);
           end;
           case Immediate of
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundToNearestEven):begin
             f32n:=RoundToNearestTiesToEven32(f32);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundToZero):begin
             f32n:=Trunc(f32);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundDown):begin
             f32n:=Floor(f32);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundUp):begin
             f32n:=Ceil(f32);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundNearestMaxMagnitude):begin
             f32n:=RoundToNearestTiesToMaxMagnitude32(f32);
            end;
            else begin
             SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
             result:=4;
             exit;
            end;
           end;
           HalfFloat:=TPasRISCVHalfFloat.FromFloat(f32n);
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(HalfFloat.Value) or TPasRISCVUInt64($ffffffffffff0000);
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $05:begin
          // froundnx.h (Zfa)
          HalfFloat:=ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64);
          if HalfFloat.IsNaN then begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($ffffffffffff7e00);
          end else if HalfFloat.IsInfinity then begin
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(ReadNormalizedFloatUI16(fState.FPURegisters[frs1].ui64)) or TPasRISCVUInt64($ffffffffffff0000);
          end else begin
           f32:=HalfFloat.ToFloat;
           Immediate:=(aInstruction shr 12) and 7;
           if Immediate=TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundDynamic) then begin
            Immediate:=fState.CSR.fData[TCSR.TAddress.FRM] and TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.Mask);
           end;
           case Immediate of
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundToNearestEven):begin
             f32n:=RoundToNearestTiesToEven32(f32);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundToZero):begin
             f32n:=Trunc(f32);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundDown):begin
             f32n:=Floor(f32);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundUp):begin
             f32n:=Ceil(f32);
            end;
            TPasRISCVInt64(TCSR.TFloatingPointRoundingModes.RoundNearestMaxMagnitude):begin
             f32n:=RoundToNearestTiesToMaxMagnitude32(f32);
            end;
            else begin
             SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
             result:=4;
             exit;
            end;
           end;
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Inexact);
           HalfFloat:=TPasRISCVHalfFloat.FromFloat(f32n);
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(HalfFloat.Value) or TPasRISCVUInt64($ffffffffffff0000);
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $08:begin
          // fcvt.bf16.s (Zfbfmin)
          // BFloat16 = upper 16 bits of float32 (with rounding)
          f32:=ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64);
          if IsFloat32NaN(f32) then begin
           fState.FPURegisters[frd].ui16:=TPasRISCVUInt16($7fc0); // Canonical bf16 NaN
          end else begin
           Temporary:=TPasRISCVUInt64(ReadNormalizedFloatUI32(fState.FPURegisters[frs1].ui64));
           // Round to nearest even: add rounding bias
           Temporary:=Temporary+TPasRISCVUInt64($00007fff)+TPasRISCVUInt64((Temporary shr 16) and 1);
           fState.FPURegisters[frd].ui16:=TPasRISCVUInt16(Temporary shr 16);
          end;
          fState.FPURegisters[frd].ui64:=fState.FPURegisters[frd].ui64 or TPasRISCVUInt64($ffffffffffff0000);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$2c:{$else}$2c,$ac:{$endif}begin
        // fsqrt.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        if ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)<0.0 then begin
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
         fState.FPURegisters[frd].ui32:=TPasRISCVUInt32($7fc00000); // Canonical NaN
        end else begin
         fState.FPURegisters[frd].f32:=sqrt(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64));
        end;
        fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$2d:{$else}$2d,$ad:{$endif}begin
        // fsqrt.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        if fState.FPURegisters[frs1].f64<0.0 then begin
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000); // Canonical NaN
        end else begin
         fState.FPURegisters[frd].f64:=sqrt(fState.FPURegisters[frs1].f64);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$2e:{$else}$2e,$ae:{$endif}begin
        // fsqrt.h (Zfh)
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        HalfFloat:=ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64);
        if HalfFloat.ToFloat<0.0 then begin
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($ffffffffffff7e00); // Canonical f16 NaN
        end else begin
         HalfFloat:=TPasRISCVHalfFloat.FromFloat(sqrt(HalfFloat.ToFloat));
         fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(HalfFloat.Value) or TPasRISCVUInt64($ffffffffffff0000);
        end;
        SetFPUExceptions;
        fState.CSR.SetFSDirty;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$50:{$else}$50,$d0:{$endif}begin
        // fc.s
        case (aInstruction shr 12) and 7 of
         $0:begin
          // fle.s
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) or IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)<=ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         $1:begin
          // flt.s
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) or IsFloat32NaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)<ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         $2:begin
          // feq.s
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) or IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)=ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         $4:begin
          // fleq.s (Zfa) - quiet LE: Invalid only for sNaN
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) or IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)<=ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         $5:begin
          // fltq.s (Zfa) - quiet LT: Invalid only for sNaN
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)) or IsFloat32SignalingNaN(ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64)<ReadNormalizedFloatF32(fState.FPURegisters[frs2].ui64)) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$51:{$else}$51,$d1:{$endif}begin
        // fc.d
        case (aInstruction shr 12) and 7 of
         $0:begin
          // fle.d
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat64NaN(fState.FPURegisters[frs1].f64) or IsFloat64NaN(fState.FPURegisters[frs2].f64) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(fState.FPURegisters[frs1].f64<=fState.FPURegisters[frs2].f64) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         $1:begin
          // flt.d
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat64NaN(fState.FPURegisters[frs1].f64) or IsFloat64NaN(fState.FPURegisters[frs2].f64) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(fState.FPURegisters[frs1].f64<fState.FPURegisters[frs2].f64) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         $2:begin
          // feq.d
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat64SignalingNaN(fState.FPURegisters[frs1].f64) or IsFloat64SignalingNaN(fState.FPURegisters[frs2].f64) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(fState.FPURegisters[frs1].f64=fState.FPURegisters[frs2].f64) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         $4:begin
          // fleq.d (Zfa) - quiet LE: Invalid only for sNaN
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat64SignalingNaN(fState.FPURegisters[frs1].f64) or IsFloat64SignalingNaN(fState.FPURegisters[frs2].f64) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(fState.FPURegisters[frs1].f64<=fState.FPURegisters[frs2].f64) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         $5:begin
          // fltq.d (Zfa) - quiet LT: Invalid only for sNaN
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if IsFloat64SignalingNaN(fState.FPURegisters[frs1].f64) or IsFloat64SignalingNaN(fState.FPURegisters[frs2].f64) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(fState.FPURegisters[frs1].f64<fState.FPURegisters[frs2].f64) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$52:{$else}$52,$d2:{$endif}begin
        // fc.h (Zfh)
        case (aInstruction shr 12) and 7 of
         $0:begin
          // fle.h
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).IsNaN or ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).IsNaN then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat<=ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).ToFloat) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         $1:begin
          // flt.h
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).IsNaN or ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).IsNaN then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat<ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).ToFloat) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         $2:begin
          // feq.h
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          if ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).IsNaN or ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).IsNaN then begin
           // feq signals Invalid only for sNaN (simplified: skip sNaN check for f16)
          end;
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat=ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).ToFloat) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         $4:begin
          // fleq.h (Zfa) - quiet LE: Invalid only for sNaN
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat<=ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).ToFloat) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         $5:begin
          // fltq.h (Zfa) - quiet LT: Invalid only for sNaN
          rd:=TRegister((aInstruction shr 7) and $1f);
          frs1:=TFPURegister((aInstruction shr 15) and $1f);
          frs2:=TFPURegister((aInstruction shr 20) and $1f);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           fState.Registers[rd]:=ord(ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat<ReadNormalizedFloatF16(fState.FPURegisters[frs2].ui64).ToFloat) and 1;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$60:{$else}$60,$e0:{$endif}begin
        // fcvt.w.s
        rd:=TRegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        f32:=ReadNormalizedFloatF32(fState.FPURegisters[frs1].ui64);
        Immediate:=(aInstruction shr 12) and 7;
        if Immediate=TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundDynamic) then begin
         Immediate:=fState.CSR.fData[TCSR.TAddress.FRM] and TPasRISCVUInt64(TCSR.TFloatingPointRoundingModes.Mask);
        end;
        case Immediate of
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundToNearestEven):begin
          f32n:=RoundToNearestTiesToEven32(f32);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundToZero):begin
          f32n:=Trunc(f32);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundDown):begin
          f32n:=Floor(f32);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundUp):begin
          f32n:=Ceil(f32);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundNearestMaxMagnitude):begin
          f32n:=RoundToNearestTiesToMaxMagnitude32(f32);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundDynamic):begin
          f32n:=Round(f32);
         end;
         else begin
          // Rounding mode values of 5 & 6 are illegal
          f32n:=f32;
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
        if f32n<>f32 then begin
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Inexact);
        end;
        case (aInstruction shr 20) and $1f of
         $00:begin
          // fcvt0
          if IsFloat32NaNOrInfinite(f32) or (f32n<Low(TPasRISCVInt32)) or (f32n>High(TPasRISCVInt32)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           if IsFloat32NaN(f32) or not IsFloat32Negative(f32) then begin
            fState.Registers[rd]:=TPasRISCVUInt32($000000007fffffff);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64($ffffffff80000000);
           end;
          end else {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           if IsFloat32NaN(f32) then begin
            if IsFloat32Negative(f32) then begin
             fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(-High(TPasRISCVInt32)));
            end else begin
             fState.Registers[rd]:=High(TPasRISCVInt32);
            end;
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(trunc(f32n))));
           end;
          end;
         end;
         $01:begin
          // fcvt1
          if IsFloat32NaNOrInfinite(f32) or (f32n<Low(TPasRISCVUInt32)) or (f32n>High(TPasRISCVUInt32)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           if IsFloat32NaN(f32) or not IsFloat32Negative(f32) then begin
            fState.Registers[rd]:=TPasRISCVUInt64($ffffffffffffffff);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64($0000000000000000);
           end;
          end else {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           if IsFloat32NaN(f32) then begin
            fState.Registers[rd]:=High(TPasRISCVUInt32);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(trunc(f32n)))));
           end;
          end;
         end;
         $02:begin
          // fcvt2
          if IsFloat32NaNOrInfinite(f32) or (f32n<=-9223372036854775808.0) or (f32n>=9223372036854775807.0) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           if IsFloat32NaN(f32) or not IsFloat32Negative(f32) then begin
            fState.Registers[rd]:=TPasRISCVUInt64($7fffffffffffffff);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64($8000000000000000);
           end;
          end else {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           if IsFloat32NaN(f32) then begin
            if IsFloat32Negative(f32) then begin
             fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(-High(TPasRISCVInt64)));
            end else begin
             fState.Registers[rd]:=High(TPasRISCVInt64);
            end;
           end else begin
            fState.Registers[rd]:=trunc(f32n);
           end;
          end;
         end;
         $03:begin
          // fcvt3
          if IsFloat32NaNOrInfinite(f32) or (f32n<0.0) or (f32n>=18446744073709551615.0) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           if IsFloat32NaN(f32) or not IsFloat32Negative(f32) then begin
            fState.Registers[rd]:=TPasRISCVUInt64($ffffffffffffffff);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64($0000000000000000);
           end;
          end else {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           if IsFloat32NaN(f32) then begin
            fState.Registers[rd]:=High(TPasRISCVUInt64);
           end else begin
            fState.Registers[rd]:=trunc(f32n);
           end;
          end;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end;
        end;
        SetFPUExceptions;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$61:{$else}$61,$e1:{$endif}begin
        // fcvt.w.d
        rd:=TRegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        f64:=fState.FPURegisters[frs1].f64;
        Immediate:=(aInstruction shr 12) and 7;
        if Immediate=TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundDynamic) then begin
         Immediate:=fState.CSR.fData[TCSR.TAddress.FRM] and TPasRISCVUInt64(TCSR.TFloatingPointRoundingModes.Mask);
        end;
        case Immediate of
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundToNearestEven):begin
          f64n:=RoundToNearestTiesToEven64(f64);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundToZero):begin
          f64n:=Trunc(f64);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundDown):begin
          f64n:=Floor(f64);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundUp):begin
          f64n:=Ceil(f64);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundNearestMaxMagnitude):begin
          f64n:=RoundToNearestTiesToMaxMagnitude64(f64);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundDynamic):begin
          f64n:=Round(f64);
         end;
         else begin
          // Rounding mode values of 5 & 6 are illegal
          f64n:=f64;
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
        if f64n<>f64 then begin
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Inexact);
        end;
        case (aInstruction shr 20) and $1f of
         $00:begin
          // fcvt0
          if IsFloat64NaNOrInfinite(f64) or (f64n<Low(TPasRISCVInt32)) or (f64n>High(TPasRISCVInt32)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           if IsFloat64NaN(f64) or not IsFloat64Negative(f64) then begin
            fState.Registers[rd]:=TPasRISCVUInt32($000000007fffffff);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64($ffffffff80000000);
           end;
          end else {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           if IsFloat64NaN(f64) then begin
            if IsFloat64Negative(f64) then begin
             fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(-High(TPasRISCVInt32)));
            end else begin
             fState.Registers[rd]:=High(TPasRISCVInt32);
            end;
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(trunc(f64n))));
           end;
          end;
         end;
         $01:begin
          // fcvt1
          if IsFloat64NaNOrInfinite(f64) or (f64n<Low(TPasRISCVUInt32)) or (f64n>High(TPasRISCVUInt32)) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           if IsFloat64NaN(f64) or not IsFloat64Negative(f64) then begin
            fState.Registers[rd]:=TPasRISCVUInt64($ffffffffffffffff);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64($0000000000000000);
           end;
          end else {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           if IsFloat64NaN(f64) then begin
            fState.Registers[rd]:=High(TPasRISCVUInt32);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(trunc(f64n)))));
           end;
          end;
         end;
         $02:begin
          // fcvt2
          if IsFloat64NaNOrInfinite(f64) or (f64n<=-9223372036854775808.0) or (f64n>=9223372036854775807.0) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           if IsFloat64NaN(f64) or not IsFloat64Negative(f64) then begin
            fState.Registers[rd]:=TPasRISCVUInt64($7fffffffffffffff);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64($8000000000000000);
           end;
          end else {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           if IsFloat64NaN(f64) then begin
            if IsFloat64Negative(f64) then begin
             fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(-High(TPasRISCVInt64)));
            end else begin
             fState.Registers[rd]:=High(TPasRISCVInt64);
            end;
           end else begin
            fState.Registers[rd]:=trunc(f64n);
           end;
          end;
         end;
         $03:begin
          // fcvt3
          if IsFloat64NaNOrInfinite(f64) or (f64n<0.0) or (f64n>=18446744073709551615.0) then begin
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           if IsFloat64NaN(f64) or not IsFloat64Negative(f64) then begin
            fState.Registers[rd]:=TPasRISCVUInt64($ffffffffffffffff);
           end else begin
            fState.Registers[rd]:=TPasRISCVUInt64($0000000000000000);
           end;
          end else {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           if IsFloat64NaN(f64) then begin
            fState.Registers[rd]:=High(TPasRISCVUInt64);
           end else begin
            fState.Registers[rd]:=trunc(f64n);
           end;
          end;
         end;
         $08:begin
          // fcvtmod.w.d (Zfa): JavaScript-style f64 to i32, modular truncation
          // rm field must be $01 (RTZ)
          if ((aInstruction shr 12) and 7)<>$1 then begin
           SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
           result:=4;
           exit;
          end;
          // Bit-level extraction for modular truncation to avoid Int64 overflow
          Temporary:=fState.FPURegisters[frs1].ui64;
          // Check for NaN/Inf (exponent all ones)
          if (Temporary and $7ff0000000000000)=$7ff0000000000000 then begin
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=0;
           end;
          end else begin
           Address:=(Temporary shr 52) and $7ff; // biased exponent
           if Address<1023 then begin
            // |value| < 1, truncates to 0
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=0;
            end;
           end else begin
            Address:=Address-1023; // unbiased exponent, >= 0
            Offset:=(Temporary and $fffffffffffff) or TPasRISCVUInt64($10000000000000); // 53-bit mantissa with implicit 1
            if Address>=84 then begin
             // Mantissa shifted completely past 32 bits
             {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
              fState.Registers[rd]:=0;
             end;
            end else begin
             if Address>=52 then begin
              Offset:=Offset shl (Address-52);
             end else begin
              Offset:=Offset shr (52-Address);
             end;
             if (Temporary shr 63)<>0 then begin
              Offset:=TPasRISCVUInt64(-TPasRISCVInt64(Offset));
             end;
             {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
              fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Offset and $ffffffff)));
             end;
            end;
           end;
          end;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end;
        end;
        SetFPUExceptions;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$62:{$else}$62,$e2:{$endif}begin
        // fcvt.{w,wu,l,lu}.h (Zfh)
        rd:=TRegister((aInstruction shr 7) and $1f);
        frs1:=TFPURegister((aInstruction shr 15) and $1f);
        f32:=ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64).ToFloat;
        Immediate:=(aInstruction shr 12) and 7;
        if Immediate=TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundDynamic) then begin
         Immediate:=fState.CSR.fData[TCSR.TAddress.FRM] and TPasRISCVUInt64(TCSR.TFloatingPointRoundingModes.Mask);
        end;
        case Immediate of
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundToNearestEven):begin
          f32n:=RoundToNearestTiesToEven32(f32);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundToZero):begin
          f32n:=Trunc(f32);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundDown):begin
          f32n:=Floor(f32);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundUp):begin
          f32n:=Ceil(f32);
         end;
         TPasRISCVUInt32(TCSR.TFloatingPointRoundingModes.RoundNearestMaxMagnitude):begin
          f32n:=RoundToNearestTiesToMaxMagnitude32(f32);
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
        if f32n<>f32 then begin
         fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Inexact);
        end;
        case (aInstruction shr 20) and $1f of
         0:begin
          // fcvt.w.h
          if IsFloat32NaN(f32) then begin
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32($7fffffff)));
           end;
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end else begin
           if f32n>TPasRISCVFloat(TPasRISCVInt32($7fffffff)) then begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32($7fffffff)));
            fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           end else if f32n<TPasRISCVFloat(TPasRISCVInt32($80000000)) then begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32($80000000)));
            fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           end else begin
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Trunc(f32n))));
            end;
           end;
          end;
         end;
         1:begin
          // fcvt.wu.h
          if IsFloat32NaN(f32) then begin
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32($ffffffff)));
           end;
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end else begin
           if f32n>=TPasRISCVFloat(TPasRISCVUInt32($ffffffff))+1.0 then begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32($ffffffff)));
            fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           end else if f32n<0 then begin
            fState.Registers[rd]:=0;
            fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           end else begin
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(TPasRISCVUInt32(Trunc(f32n)))));
            end;
           end;
          end;
         end;
         2:begin
          // fcvt.l.h
          if IsFloat32NaN(f32) then begin
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64($7fffffffffffffff);
           end;
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end else begin
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(Trunc(f32n)));
           end;
          end;
         end;
         3:begin
          // fcvt.lu.h
          if IsFloat32NaN(f32) then begin
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64($ffffffffffffffff);
           end;
           fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
          end else begin
           if f32n<0 then begin
            fState.Registers[rd]:=0;
            fState.CSR.SetFPUException(TCSR.TFPUExceptionMasks.Invalid);
           end else begin
            {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
             fState.Registers[rd]:=TPasRISCVUInt64(Trunc(f32n));
            end;
           end;
          end;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end;
        end;
        SetFPUExceptions;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$68:{$else}$68,$e8:{$endif}begin
        // fcvtsdw.s
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        rs1:=TRegister((aInstruction shr 15) and $1f);
        case (aInstruction shr 20) and $1f of
         0:begin
          // fcvt0
          fState.FPURegisters[frd].f32:=TPasRISCVInt32(fState.Registers[rs1]);
          fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
         end;
         1:begin
          // fcvt1
          fState.FPURegisters[frd].f32:=TPasRISCVUInt32(fState.Registers[rs1]);
          fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
         end;
         2:begin
          // fcvt2
          fState.FPURegisters[frd].f32:=TPasRISCVInt64(fState.Registers[rs1]);
          fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
         end;
         3:begin
          // fcvt3
          fState.FPURegisters[frd].f32:=TPasRISCVUInt64(fState.Registers[rs1]);
          fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end;
        end;
        SetFPUExceptions;
        if fState.ExceptionValue<>TExceptionValue.IllegalInstruction then begin
         fState.CSR.SetFSDirty;
        end;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$69:{$else}$69,$e9:{$endif}begin
        // fcvtdw.d
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        rs1:=TRegister((aInstruction shr 15) and $1f);
        case (aInstruction shr 20) and $1f of
         0:begin
          // fcvt0
          fState.FPURegisters[frd].f64:=TPasRISCVInt32(fState.Registers[rs1]);
         end;
         1:begin
          // fcvt1
          fState.FPURegisters[frd].f64:=TPasRISCVUInt32(fState.Registers[rs1]);
         end;
         2:begin
          // fcvt2
          fState.FPURegisters[frd].f64:=TPasRISCVInt64(fState.Registers[rs1]);
         end;
         3:begin
          // fcvt3
          fState.FPURegisters[frd].f64:=TPasRISCVUInt64(fState.Registers[rs1]);
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end;
        end;
        SetFPUExceptions;
        if fState.ExceptionValue<>TExceptionValue.IllegalInstruction then begin
         fState.CSR.SetFSDirty;
        end;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$6a:{$else}$6a,$ea:{$endif}begin
        // fcvt.h.{w,wu,l,lu} (Zfh)
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        rs1:=TRegister((aInstruction shr 15) and $1f);
        case (aInstruction shr 20) and $1f of
         0:begin
          // fcvt.h.w
          HalfFloat:=TPasRISCVHalfFloat.FromFloat(TPasRISCVFloat(TPasRISCVInt32(fState.Registers[rs1])));
          fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(HalfFloat.Value) or TPasRISCVUInt64($ffffffffffff0000);
         end;
         1:begin
          // fcvt.h.wu
          HalfFloat:=TPasRISCVHalfFloat.FromFloat(TPasRISCVFloat(TPasRISCVUInt32(fState.Registers[rs1])));
          fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(HalfFloat.Value) or TPasRISCVUInt64($ffffffffffff0000);
         end;
         2:begin
          // fcvt.h.l
          HalfFloat:=TPasRISCVHalfFloat.FromFloat(TPasRISCVFloat(TPasRISCVInt64(fState.Registers[rs1])));
          fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(HalfFloat.Value) or TPasRISCVUInt64($ffffffffffff0000);
         end;
         3:begin
          // fcvt.h.lu
          HalfFloat:=TPasRISCVHalfFloat.FromFloat(TPasRISCVFloat(TPasRISCVUInt64(fState.Registers[rs1])));
          fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(HalfFloat.Value) or TPasRISCVUInt64($ffffffffffff0000);
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
         end;
        end;
        SetFPUExceptions;
        if fState.ExceptionValue<>TExceptionValue.IllegalInstruction then begin
         fState.CSR.SetFSDirty;
        end;
        result:=4;
        exit;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$70:{$else}$70,$f0:{$endif}begin
        // fmvxw
        case (aInstruction shr 12) and 7 of
         0:begin
          // fmvxw.s
          rd:=TRegister((aInstruction shr 7) and $1f);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           frs1:=TFPURegister((aInstruction shr 15) and $1f);
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(fState.FPURegisters[frs1].ui32)));
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         1:begin
          // fclass.s
          rd:=TRegister((aInstruction shr 7) and $1f);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           frs1:=TFPURegister((aInstruction shr 15) and $1f);
           f32:=fState.FPURegisters[frs1].f32;
           case Float32Classify(f32) of
            TPasRISCVFPType.Infinite:begin
             if IsFloat32Negative(f32) then begin
              fState.Registers[rd]:=TFClass.NEG_INF;
             end else begin
              fState.Registers[rd]:=TFClass.POS_INF;
             end;
            end;
            TPasRISCVFPType.QuietNaN:begin
             fState.Registers[rd]:=TFClass.NAN_QUIET;
            end;
            TPasRISCVFPType.SignalingNaN:begin
             fState.Registers[rd]:=TFClass.NAN_SIG;
            end;
            TPasRISCVFPType.Normal:begin
             if IsFloat32Negative(f32) then begin
              fState.Registers[rd]:=TFClass.NEG_NORMAL;
             end else begin
              fState.Registers[rd]:=TFClass.POS_NORMAL;
             end;
            end;
            TPasRISCVFPType.SubNormal:begin
             if IsFloat32Negative(f32) then begin
              fState.Registers[rd]:=TFClass.NEG_SUBNORMAL;
             end else begin
              fState.Registers[rd]:=TFClass.POS_SUBNORMAL;
             end;
            end;
            TPasRISCVFPType.Zero:begin
             if IsFloat32Negative(f32) then begin
              fState.Registers[rd]:=TFClass.NEG_ZERO;
             end else begin
              fState.Registers[rd]:=TFClass.POS_ZERO;
             end;
            end;
            else begin
             fState.Registers[rd]:=0;
            end;
           end;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$71:{$else}$71,$f1:{$endif}begin
        // fmvxd
        case (aInstruction shr 12) and 7 of
         0:begin
          // fmvxd.d
          rd:=TRegister((aInstruction shr 7) and $1f);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           frs1:=TFPURegister((aInstruction shr 15) and $1f);
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(fState.FPURegisters[frs1].ui64));
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         1:begin
          // fclass.d
          rd:=TRegister((aInstruction shr 7) and $1f);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           frs1:=TFPURegister((aInstruction shr 15) and $1f);
           f64:=fState.FPURegisters[frs1].f64;
           case Float64Classify(f64) of
            TPasRISCVFPType.Infinite:begin
             if IsFloat64Negative(f64) then begin
              fState.Registers[rd]:=TFClass.NEG_INF;
             end else begin
              fState.Registers[rd]:=TFClass.POS_INF;
             end;
            end;
            TPasRISCVFPType.QuietNaN:begin
             fState.Registers[rd]:=TFClass.NAN_QUIET;
            end;
            TPasRISCVFPType.SignalingNaN:begin
             fState.Registers[rd]:=TFClass.NAN_SIG;
            end;
            TPasRISCVFPType.Normal:begin
             if IsFloat64Negative(f64) then begin
              fState.Registers[rd]:=TFClass.NEG_NORMAL;
             end else begin
              fState.Registers[rd]:=TFClass.POS_NORMAL;
             end;
            end;
            TPasRISCVFPType.SubNormal:begin
             if IsFloat64Negative(f64) then begin
              fState.Registers[rd]:=TFClass.NEG_SUBNORMAL;
             end else begin
              fState.Registers[rd]:=TFClass.POS_SUBNORMAL;
             end;
            end;
            TPasRISCVFPType.Zero:begin
             if IsFloat64Negative(f64) then begin
              fState.Registers[rd]:=TFClass.NEG_ZERO;
             end else begin
              fState.Registers[rd]:=TFClass.POS_ZERO;
             end;
            end;
            else begin
             fState.Registers[rd]:=0;
            end;
           end;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$72:{$else}$72,$f2:{$endif}begin
        // fmv.x.h / fclass.h (Zfh)
        case (aInstruction shr 12) and 7 of
         0:begin
          // fmv.x.h
          rd:=TRegister((aInstruction shr 7) and $1f);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           frs1:=TFPURegister((aInstruction shr 15) and $1f);
           fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(fState.FPURegisters[frs1].ui16)));
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         1:begin
          // fclass.h (Zfh)
          rd:=TRegister((aInstruction shr 7) and $1f);
          {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
           frs1:=TFPURegister((aInstruction shr 15) and $1f);
           HalfFloat:=ReadNormalizedFloatF16(fState.FPURegisters[frs1].ui64);
           Temporary:=TPasRISCVUInt64(HalfFloat.Value);
           // f16 layout: sign[15], exp[14:10], frac[9:0]
           if (Temporary and $7c00)=$7c00 then begin
            // exponent all ones
            if (Temporary and $03ff)<>0 then begin
             // NaN
             if (Temporary and $0200)<>0 then begin
              fState.Registers[rd]:=TFClass.NAN_QUIET;
             end else begin
              fState.Registers[rd]:=TFClass.NAN_SIG;
             end;
            end else begin
             // infinity
             if (Temporary and $8000)<>0 then begin
              fState.Registers[rd]:=TFClass.NEG_INF;
             end else begin
              fState.Registers[rd]:=TFClass.POS_INF;
             end;
            end;
           end else if (Temporary and $7c00)=0 then begin
            // exponent zero
            if (Temporary and $03ff)=0 then begin
             // zero
             if (Temporary and $8000)<>0 then begin
              fState.Registers[rd]:=TFClass.NEG_ZERO;
             end else begin
              fState.Registers[rd]:=TFClass.POS_ZERO;
             end;
            end else begin
             // subnormal
             if (Temporary and $8000)<>0 then begin
              fState.Registers[rd]:=TFClass.NEG_SUBNORMAL;
             end else begin
              fState.Registers[rd]:=TFClass.POS_SUBNORMAL;
             end;
            end;
           end else begin
            // normal
            if (Temporary and $8000)<>0 then begin
             fState.Registers[rd]:=TFClass.NEG_NORMAL;
            end else begin
             fState.Registers[rd]:=TFClass.POS_NORMAL;
            end;
           end;
          end;
          SetFPUExceptions;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$78:{$else}$78,$f8:{$endif}begin
        // fmvwx / fli.s (Zfa)
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        case (aInstruction shr 20) and $1f of
         $00:begin
          // fmv.w.x
          rs1:=TRegister((aInstruction shr 15) and $1f);
          fState.FPURegisters[frd].ui64:=fState.Registers[rs1] or TPasRISCVUInt64($ffffffff00000000);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $01:begin
          // fli.s (Zfa): load floating-point immediate from table
          fState.FPURegisters[frd].ui32:=PasRISCVFLITable[(aInstruction shr 15) and $1f];
          fState.FPURegisters[frd].NaNBoxUI32:=TPasRISCVUInt64($ffffffff);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$79:{$else}$79,$f9:{$endif}begin
        // fmvdx / fli.d (Zfa)
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        case (aInstruction shr 20) and $1f of
         $00:begin
          // fmv.d.x
          rs1:=TRegister((aInstruction shr 15) and $1f);
          fState.FPURegisters[frd].ui64:=fState.Registers[rs1];
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $01:begin
          // fli.d (Zfa): load floating-point immediate from table
          Immediate:=(aInstruction shr 15) and $1f;
          if Immediate=1 then begin
           // Minimum positive normal for f64 (differs from f32)
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($0010000000000000);
          end else if Immediate=31 then begin
           // Canonical NaN for f64
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7ff8000000000000);
          end else begin
           // Convert f32 bit pattern from table to f64
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(PasRISCVFLITable[Immediate]) or TPasRISCVUInt64($ffffffff00000000);
           fState.FPURegisters[frd].f64:=ReadNormalizedFloatF32(fState.FPURegisters[frd].ui64);
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       {$ifndef TryToForceCaseJumpTableOnLevel2}$7a:{$else}$7a,$fa:{$endif}begin
        // fmv.h.x / fli.h (Zfh + Zfa)
        frd:=TFPURegister((aInstruction shr 7) and $1f);
        case (aInstruction shr 20) and $1f of
         $00:begin
          // fmv.h.x
          rs1:=TRegister((aInstruction shr 15) and $1f);
          fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(fState.Registers[rs1] and $ffff) or TPasRISCVUInt64($ffffffffffff0000);
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         $01:begin
          // fli.h (Zfa): load floating-point immediate from table
          Immediate:=(aInstruction shr 15) and $1f;
          if Immediate=1 then begin
           // Minimum positive normal for f16: 2^(-14) = $0400
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($0400) or TPasRISCVUInt64($ffffffffffff0000);
          end else if Immediate=31 then begin
           // Canonical NaN for f16
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64($7e00) or TPasRISCVUInt64($ffffffffffff0000);
          end else begin
           // Convert from f32 FLI table to f16 via f32 intermediate
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(PasRISCVFLITable[Immediate]) or TPasRISCVUInt64($ffffffff00000000);
           HalfFloat:=TPasRISCVHalfFloat.FromFloat(fState.FPURegisters[frd].f32);
           fState.FPURegisters[frd].ui64:=TPasRISCVUInt64(HalfFloat.Value) or TPasRISCVUInt64($ffffffffffff0000);
          end;
          SetFPUExceptions;
          fState.CSR.SetFSDirty;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
       else begin
        SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
        result:=4;
        exit;
       end;
      end;
     end;
    end;

    //////////////////////////////////////////////////////////////////////////////
    // AMO                                                                      //
    //////////////////////////////////////////////////////////////////////////////
    $2f{$ifdef TryToForceCaseJumpTableOnLevel1},$af{$endif}:begin
     // RV64A: "A" standard extension for atomic instructions
     // Alignment check first, before any memory translation or LRSC check.
     // This is spec-compliant (RISC-V allows either order) and matches RVVM's
     // approach and QEMU's implementation in the legacy code path. It's more
     // efficient as it avoids unnecessary TLB lookups for misaligned addresses.
     case {$ifdef TryToForceCaseJumpTableOnLevel2}TPasRISCVUInt8{$endif}((aInstruction shr 12) and 7) of
      {$ifndef TryToForceCaseJumpTableOnLevel2}$0:{$else}$00,$08,$10,$18,$20,$28,$30,$38,$40,$48,$50,$58,$60,$68,$70,$78,$80,$88,$90,$98,$a0,$a8,$b0,$b8,$c0,$c8,$d0,$d8,$e0,$e8,$f0,$f8:{$endif}begin
       // amob (Zabha: Byte atomics)
       // No alignment check needed for byte operations
       rd:=TRegister((aInstruction shr 7) and $1f);
       rs1:=TRegister((aInstruction shr 15) and $1f);
       rs2:=TRegister((aInstruction shr 20) and $1f);
       begin
{$if defined(cpu386) or defined(cpux86_64)}
        // Native 8-bit atomics (x86/x86_64)
        Ptr:=MemoryPointerTranslate(fState.Registers[rs1],1,@fState.Bounce.ui8,false);
        if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
         case ((aInstruction shr 25) and $7c) shr 2 of
          $00:begin
           // amoadd.b (Zabha)
           Immediate:=TPasRISCVInt64(TPasMPInterlocked.Add(PPasMPUInt8(Ptr)^,TPasMPUInt8(fState.Registers[rs2])));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui8 then begin
            RMWCommit(fState.Registers[rs1],1,@fState.Bounce.ui8);
           end;
           result:=4;
           exit;
          end;
          $01:begin
           // amoswap.b (Zabha)
           Immediate:=TPasRISCVInt64(TPasMPInterlocked.Exchange(PPasMPUInt8(Ptr)^,TPasMPUInt8(fState.Registers[rs2])));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui8 then begin
            RMWCommit(fState.Registers[rs1],1,@fState.Bounce.ui8);
           end;
           result:=4;
           exit;
          end;
          $04:begin
           // amoxor.b (Zabha)
           Immediate:=TPasRISCVInt64(TPasMPInterlocked.ExchangeBitwiseXor(PPasMPUInt8(Ptr)^,TPasMPUInt8(fState.Registers[rs2])));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui8 then begin
            RMWCommit(fState.Registers[rs1],1,@fState.Bounce.ui8);
           end;
           result:=4;
           exit;
          end;
          $05:begin
           // amocas.b (Zabha+Zacas)
           Immediate:=TPasRISCVInt64(TPasMPInterlocked.CompareExchange(PPasMPUInt8(Ptr)^,TPasMPUInt8(fState.Registers[rs2]),TPasMPUInt8(fState.Registers[rd])));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui8 then begin
            RMWCommit(fState.Registers[rs1],1,@fState.Bounce.ui8);
           end;
           result:=4;
           exit;
          end;
          $08:begin
           // amoor.b (Zabha)
           Immediate:=TPasRISCVInt64(TPasMPInterlocked.ExchangeBitwiseOr(PPasMPUInt8(Ptr)^,TPasMPUInt8(fState.Registers[rs2])));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui8 then begin
            RMWCommit(fState.Registers[rs1],1,@fState.Bounce.ui8);
           end;
           result:=4;
           exit;
          end;
          $0c:begin
           // amoand.b (Zabha)
           Immediate:=TPasRISCVInt64(TPasMPInterlocked.ExchangeBitwiseAnd(PPasMPUInt8(Ptr)^,TPasMPUInt8(fState.Registers[rs2])));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui8 then begin
            RMWCommit(fState.Registers[rs1],1,@fState.Bounce.ui8);
           end;
           result:=4;
           exit;
          end;
          $10:begin
           // amomin.b (Zabha)
           repeat
            Temporary:=TPasRISCVUInt64(TPasMPInterlocked.Read(PPasMPUInt8(Ptr)^));
            if TPasRISCVInt8(Temporary)<=TPasRISCVInt8(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt8(Ptr)^,TPasMPUInt8(Temporary),TPasMPUInt8(Temporary))=TPasMPUInt8(Temporary) then break;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt8(Ptr)^,TPasMPUInt8(fState.Registers[rs2]),TPasMPUInt8(Temporary))=TPasMPUInt8(Temporary) then break;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui8 then begin
            RMWCommit(fState.Registers[rs1],1,@fState.Bounce.ui8);
           end;
           result:=4;
           exit;
          end;
          $14:begin
           // amomax.b (Zabha)
           repeat
            Temporary:=TPasRISCVUInt64(TPasMPInterlocked.Read(PPasMPUInt8(Ptr)^));
            if TPasRISCVInt8(Temporary)>=TPasRISCVInt8(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt8(Ptr)^,TPasMPUInt8(Temporary),TPasMPUInt8(Temporary))=TPasMPUInt8(Temporary) then break;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt8(Ptr)^,TPasMPUInt8(fState.Registers[rs2]),TPasMPUInt8(Temporary))=TPasMPUInt8(Temporary) then break;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui8 then begin
            RMWCommit(fState.Registers[rs1],1,@fState.Bounce.ui8);
           end;
           result:=4;
           exit;
          end;
          $18:begin
           // amominu.b (Zabha)
           repeat
            Temporary:=TPasRISCVUInt64(TPasMPInterlocked.Read(PPasMPUInt8(Ptr)^));
            if TPasRISCVUInt8(Temporary)<=TPasRISCVUInt8(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt8(Ptr)^,TPasMPUInt8(Temporary),TPasMPUInt8(Temporary))=TPasMPUInt8(Temporary) then break;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt8(Ptr)^,TPasMPUInt8(fState.Registers[rs2]),TPasMPUInt8(Temporary))=TPasMPUInt8(Temporary) then break;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui8 then begin
            RMWCommit(fState.Registers[rs1],1,@fState.Bounce.ui8);
           end;
           result:=4;
           exit;
          end;
          $1c:begin
           // amomaxu.b (Zabha)
           repeat
            Temporary:=TPasRISCVUInt64(TPasMPInterlocked.Read(PPasMPUInt8(Ptr)^));
            if TPasRISCVUInt8(Temporary)>=TPasRISCVUInt8(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt8(Ptr)^,TPasMPUInt8(Temporary),TPasMPUInt8(Temporary))=TPasMPUInt8(Temporary) then break;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt8(Ptr)^,TPasMPUInt8(fState.Registers[rs2]),TPasMPUInt8(Temporary))=TPasMPUInt8(Temporary) then break;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui8 then begin
            RMWCommit(fState.Registers[rs1],1,@fState.Bounce.ui8);
           end;
           result:=4;
           exit;
          end;
          else begin
           SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
           result:=4;
           exit;
          end;
         end;
        end;
{$else}
        // 32-bit CAS loop fallback (non-x86 platforms)
        Address:=fState.Registers[rs1] and TPasRISCVUInt64(not TPasRISCVUInt64(3));
        Offset:=TPasRISCVUInt64((fState.Registers[rs1] and 3) shl 3); // bit shift for byte position
        Ptr:=MemoryPointerTranslate(Address,4,@fState.Bounce.ui32,false);
        if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
         case ((aInstruction shr 25) and $7c) shr 2 of
          $00:begin
           // amoadd.b (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt8(Temporary shr Offset));
           until TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt8(TPasRISCVUInt8(Immediate)+TPasRISCVUInt8(fState.Registers[rs2]))) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary);
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $01:begin
           // amoswap.b (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt8(Temporary shr Offset));
           until TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt8(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary);
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $04:begin
           // amoxor.b (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt8(Temporary shr Offset));
           until TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt8(Immediate) xor TPasRISCVUInt8(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary);
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $05:begin
           // amocas.b (Zabha+Zacas)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt8(Temporary shr Offset));
            if TPasRISCVUInt8(Immediate)=TPasRISCVUInt8(fState.Registers[rd]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt8(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(Temporary),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $08:begin
           // amoor.b (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt8(Temporary shr Offset));
           until TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt8(Immediate) or TPasRISCVUInt8(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary);
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $0c:begin
           // amoand.b (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt8(Temporary shr Offset));
           until TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt8(Immediate) and TPasRISCVUInt8(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary);
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $10:begin
           // amomin.b (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt8(Temporary shr Offset));
            if TPasRISCVInt8(Immediate)<=TPasRISCVInt8(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(Temporary),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then break;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt8(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then break;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $14:begin
           // amomax.b (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt8(Temporary shr Offset));
            if TPasRISCVInt8(Immediate)>=TPasRISCVInt8(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(Temporary),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then break;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt8(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then break;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $18:begin
           // amominu.b (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt8(Temporary shr Offset));
            if TPasRISCVUInt8(Immediate)<=TPasRISCVUInt8(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(Temporary),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then break;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt8(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then break;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $1c:begin
           // amomaxu.b (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt8(Temporary shr Offset));
            if TPasRISCVUInt8(Immediate)>=TPasRISCVUInt8(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(Temporary),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then break;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt8(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then break;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt8(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          else begin
           SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
           result:=4;
           exit;
          end;
         end;
        end;
{$ifend}
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$1:{$else}$01,$09,$11,$19,$21,$29,$31,$39,$41,$49,$51,$59,$61,$69,$71,$79,$81,$89,$91,$99,$a1,$a9,$b1,$b9,$c1,$c9,$d1,$d9,$e1,$e9,$f1,$f9:{$endif}begin
       // amoh (Zabha: Halfword atomics)
       rd:=TRegister((aInstruction shr 7) and $1f);
       rs1:=TRegister((aInstruction shr 15) and $1f);
       rs2:=TRegister((aInstruction shr 20) and $1f);
       if (fState.Registers[rs1] and 1)<>0 then begin
        SetException(TExceptionValue.StoreAddressMisaligned,fState.Registers[rs1],fState.PC);
        result:=4;
        exit;
       end else begin
{$if defined(cpu386) or defined(cpux86_64)}
        // Native 16-bit atomics (x86/x86_64)
        Ptr:=MemoryPointerTranslate(fState.Registers[rs1],2,@fState.Bounce.ui16,false);
        if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
         case ((aInstruction shr 25) and $7c) shr 2 of
          $00:begin
           // amoadd.h (Zabha)
           Immediate:=TPasRISCVInt64(TPasMPInterlocked.Add(PPasMPUInt16(Ptr)^,TPasMPUInt16(fState.Registers[rs2])));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui16 then begin
            RMWCommit(fState.Registers[rs1],2,@fState.Bounce.ui16);
           end;
           result:=4;
           exit;
          end;
          $01:begin
           // amoswap.h (Zabha)
           Immediate:=TPasRISCVInt64(TPasMPInterlocked.Exchange(PPasMPUInt16(Ptr)^,TPasMPUInt16(fState.Registers[rs2])));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui16 then begin
            RMWCommit(fState.Registers[rs1],2,@fState.Bounce.ui16);
           end;
           result:=4;
           exit;
          end;
          $04:begin
           // amoxor.h (Zabha)
           Immediate:=TPasRISCVInt64(TPasMPInterlocked.ExchangeBitwiseXor(PPasMPUInt16(Ptr)^,TPasMPUInt16(fState.Registers[rs2])));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui16 then begin
            RMWCommit(fState.Registers[rs1],2,@fState.Bounce.ui16);
           end;
           result:=4;
           exit;
          end;
          $05:begin
           // amocas.h (Zabha+Zacas)
           Immediate:=TPasRISCVInt64(TPasMPInterlocked.CompareExchange(PPasMPUInt16(Ptr)^,TPasMPUInt16(fState.Registers[rs2]),TPasMPUInt16(fState.Registers[rd])));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui16 then begin
            RMWCommit(fState.Registers[rs1],2,@fState.Bounce.ui16);
           end;
           result:=4;
           exit;
          end;
          $08:begin
           // amoor.h (Zabha)
           Immediate:=TPasRISCVInt64(TPasMPInterlocked.ExchangeBitwiseOr(PPasMPUInt16(Ptr)^,TPasMPUInt16(fState.Registers[rs2])));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui16 then begin
            RMWCommit(fState.Registers[rs1],2,@fState.Bounce.ui16);
           end;
           result:=4;
           exit;
          end;
          $0c:begin
           // amoand.h (Zabha)
           Immediate:=TPasRISCVInt64(TPasMPInterlocked.ExchangeBitwiseAnd(PPasMPUInt16(Ptr)^,TPasMPUInt16(fState.Registers[rs2])));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui16 then begin
            RMWCommit(fState.Registers[rs1],2,@fState.Bounce.ui16);
           end;
           result:=4;
           exit;
          end;
          $10:begin
           // amomin.h (Zabha)
           repeat
            Temporary:=TPasRISCVUInt64(TPasMPInterlocked.Read(PPasMPUInt16(Ptr)^));
            if TPasRISCVInt16(Temporary)<=TPasRISCVInt16(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt16(Ptr)^,TPasMPUInt16(Temporary),TPasMPUInt16(Temporary))=TPasMPUInt16(Temporary) then break;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt16(Ptr)^,TPasMPUInt16(fState.Registers[rs2]),TPasMPUInt16(Temporary))=TPasMPUInt16(Temporary) then break;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui16 then begin
            RMWCommit(fState.Registers[rs1],2,@fState.Bounce.ui16);
           end;
           result:=4;
           exit;
          end;
          $14:begin
           // amomax.h (Zabha)
           repeat
            Temporary:=TPasRISCVUInt64(TPasMPInterlocked.Read(PPasMPUInt16(Ptr)^));
            if TPasRISCVInt16(Temporary)>=TPasRISCVInt16(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt16(Ptr)^,TPasMPUInt16(Temporary),TPasMPUInt16(Temporary))=TPasMPUInt16(Temporary) then break;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt16(Ptr)^,TPasMPUInt16(fState.Registers[rs2]),TPasMPUInt16(Temporary))=TPasMPUInt16(Temporary) then break;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui16 then begin
            RMWCommit(fState.Registers[rs1],2,@fState.Bounce.ui16);
           end;
           result:=4;
           exit;
          end;
          $18:begin
           // amominu.h (Zabha)
           repeat
            Temporary:=TPasRISCVUInt64(TPasMPInterlocked.Read(PPasMPUInt16(Ptr)^));
            if TPasRISCVUInt16(Temporary)<=TPasRISCVUInt16(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt16(Ptr)^,TPasMPUInt16(Temporary),TPasMPUInt16(Temporary))=TPasMPUInt16(Temporary) then break;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt16(Ptr)^,TPasMPUInt16(fState.Registers[rs2]),TPasMPUInt16(Temporary))=TPasMPUInt16(Temporary) then break;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui16 then begin
            RMWCommit(fState.Registers[rs1],2,@fState.Bounce.ui16);
           end;
           result:=4;
           exit;
          end;
          $1c:begin
           // amomaxu.h (Zabha)
           repeat
            Temporary:=TPasRISCVUInt64(TPasMPInterlocked.Read(PPasMPUInt16(Ptr)^));
            if TPasRISCVUInt16(Temporary)>=TPasRISCVUInt16(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt16(Ptr)^,TPasMPUInt16(Temporary),TPasMPUInt16(Temporary))=TPasMPUInt16(Temporary) then break;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt16(Ptr)^,TPasMPUInt16(fState.Registers[rs2]),TPasMPUInt16(Temporary))=TPasMPUInt16(Temporary) then break;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui16 then begin
            RMWCommit(fState.Registers[rs1],2,@fState.Bounce.ui16);
           end;
           result:=4;
           exit;
          end;
          else begin
           SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
           result:=4;
           exit;
          end;
         end;
        end;
{$else}
        // 32-bit CAS loop fallback (non-x86 platforms)
        Address:=fState.Registers[rs1] and TPasRISCVUInt64(not TPasRISCVUInt64(3));
        Offset:=TPasRISCVUInt64((fState.Registers[rs1] and 2) shl 3); // bit shift for halfword position (0 or 16)
        Ptr:=MemoryPointerTranslate(Address,4,@fState.Bounce.ui32,false);
        if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
         case ((aInstruction shr 25) and $7c) shr 2 of
          $00:begin
           // amoadd.h (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt16(Temporary shr Offset));
           until TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ffff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt16(TPasRISCVUInt16(Immediate)+TPasRISCVUInt16(fState.Registers[rs2]))) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary);
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $01:begin
           // amoswap.h (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt16(Temporary shr Offset));
           until TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ffff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt16(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary);
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $04:begin
           // amoxor.h (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt16(Temporary shr Offset));
           until TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ffff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt16(Immediate) xor TPasRISCVUInt16(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary);
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $05:begin
           // amocas.h (Zabha+Zacas)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt16(Temporary shr Offset));
            if TPasRISCVUInt16(Immediate)=TPasRISCVUInt16(fState.Registers[rd]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ffff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt16(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(Temporary),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $08:begin
           // amoor.h (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt16(Temporary shr Offset));
           until TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ffff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt16(Immediate) or TPasRISCVUInt16(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary);
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $0c:begin
           // amoand.h (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt16(Temporary shr Offset));
           until TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ffff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt16(Immediate) and TPasRISCVUInt16(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary);
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $10:begin
           // amomin.h (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt16(Temporary shr Offset));
            if TPasRISCVInt16(Immediate)<=TPasRISCVInt16(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(Temporary),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then break;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ffff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt16(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then break;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $14:begin
           // amomax.h (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt16(Temporary shr Offset));
            if TPasRISCVInt16(Immediate)>=TPasRISCVInt16(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(Temporary),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then break;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ffff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt16(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then break;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $18:begin
           // amominu.h (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt16(Temporary shr Offset));
            if TPasRISCVUInt16(Immediate)<=TPasRISCVUInt16(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(Temporary),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then break;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ffff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt16(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then break;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          $1c:begin
           // amomaxu.h (Zabha)
           repeat
            Temporary:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
            Immediate:=TPasRISCVInt64(TPasRISCVUInt16(Temporary shr Offset));
            if TPasRISCVUInt16(Immediate)>=TPasRISCVUInt16(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(Temporary),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then break;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32((Temporary and (not (TPasRISCVUInt64($ffff) shl Offset))) or (TPasRISCVUInt64(TPasRISCVUInt16(fState.Registers[rs2])) shl Offset)),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then break;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt16(Immediate)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(Address,4,@fState.Bounce.ui32);
           end;
           result:=4;
           exit;
          end;
          else begin
           SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
           result:=4;
           exit;
          end;
         end;
        end;
{$ifend}
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$2:{$else}$02,$0a,$12,$1a,$22,$2a,$32,$3a,$42,$4a,$52,$5a,$62,$6a,$72,$7a,$82,$8a,$92,$9a,$a2,$aa,$b2,$ba,$c2,$ca,$d2,$da,$e2,$ea,$f2,$fa:{$endif}begin
       // amow
       rd:=TRegister((aInstruction shr 7) and $1f);
       rs1:=TRegister((aInstruction shr 15) and $1f);
       rs2:=TRegister((aInstruction shr 20) and $1f);
       if (fState.Registers[rs1] and 3)<>0 then begin
        SetException(TExceptionValue.StoreAddressMisaligned,fState.Registers[rs1],fState.PC);
        result:=4;
        exit;
       end else begin
        case ((aInstruction shr 25) and $7c) shr 2 of
         $00:begin
          // amoadd.w
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.Add(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $01:begin
          // amoswap.w
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.Exchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $02:begin
          // lr.w
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,true);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           fState.LRSC:=true;
           fState.LRSCCycle:=fState.Cycle;
           fState.LRSCAddress:=fState.Registers[rs1];
           fState.LRSCCAS:=TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^);
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(fState.LRSCCAS)));
           end;
          end;
          result:=4;
          exit;
         end;
         $03:begin
          // sc.w
          // QEMU checks LRSC address match first, then memory translation.
          // While RVVM does memory translation first, then checks LRSC state.
          // We follow QEMU here for better compatibility, since RVVM's
          // approach may lead to unnecessary page faults when the reservation
          // address doesn't match, which is inefficient in some scenarios.
          if fState.LRSC and
             ((fMachine.fLRSCMaximumCycles=0) or 
              ((fState.Cycle-fState.LRSCCycle)<fMachine.fLRSCMaximumCycles)) and
             (fState.LRSCAddress=fState.Registers[rs1]) then begin 
           Ptr:=MemoryPointerTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
           if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
            if (TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]),TPasMPUInt32(fState.LRSCCAS))=TPasMPUInt32(fState.LRSCCAS)) then begin
             {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
              fState.Registers[rd]:=0;
             end;
             if Ptr=@fState.Bounce.ui32 then begin
              RMWCommit(fState.Registers[rs1],4,@fState.Bounce.ui32);
             end;
            end else begin
             {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
              fState.Registers[rd]:=1;
             end;
            end;
           end;
          end else begin
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=1;
           end;
          end;
          fState.LRSC:=false;
          result:=4;
          exit;
         end;
         $04:begin
          // amoxor.w
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.ExchangeBitwiseXor(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $05:begin
          // amocas.w (Zacas)
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPUInt32(TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]),TPasMPUInt32(fState.Registers[rd])));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $08:begin
          // amoor.w
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.ExchangeBitwiseOr(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $0c:begin
          // amoand.w
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.ExchangeBitwiseAnd(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $10:begin
          // amomin.w
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           repeat
            Temporary:=TPasMPUInt64(TPasMPInt64(TPasMPInt32(TPasMPInterlocked.Read(PPasMPInt32(Ptr)^))));
            if TPasMPInt32(Temporary)<TPasMPInt32(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPInt32(Ptr)^,TPasMPInt32(Temporary),TPasMPInt32(Temporary))=TPasMPInt32(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPInt32(Ptr)^,TPasMPInt32(fState.Registers[rs2]),TPasMPInt32(Temporary))=TPasMPInt32(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $14:begin
          // amomax.w
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           repeat
            Temporary:=TPasMPUInt64(TPasMPInt64(TPasMPInt32(TPasMPInterlocked.Read(PPasMPInt32(Ptr)^))));
            if TPasMPInt32(Temporary)>TPasMPInt32(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPInt32(Ptr)^,TPasMPInt32(Temporary),TPasMPInt32(Temporary))=TPasMPInt32(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPInt32(Ptr)^,TPasMPInt32(fState.Registers[rs2]),TPasMPInt32(Temporary))=TPasMPInt32(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $18:begin
          // amominu.w
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           repeat
            Temporary:=TPasMPUInt64(TPasMPUInt32(TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^)));
            if TPasMPUInt32(Temporary)<TPasMPUInt32(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(Temporary),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         $1c:begin
          // amomaxu.w
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],4,@fState.Bounce.ui32,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           repeat
            Temporary:=TPasMPUInt64(TPasMPUInt32(TPasMPInterlocked.Read(PPasMPUInt32(Ptr)^)));
            if TPasMPUInt32(Temporary)>TPasMPUInt32(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(Temporary),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt32(Ptr)^,TPasMPUInt32(fState.Registers[rs2]),TPasMPUInt32(Temporary))=TPasMPUInt32(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt32(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui32 then begin
            RMWCommit(fState.Registers[rs1],4,@fState.Bounce.ui32);
           end;
          end;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
      end;
      {$ifndef TryToForceCaseJumpTableOnLevel2}$3:{$else}$03,$0b,$13,$1b,$23,$2b,$33,$3b,$43,$4b,$53,$5b,$63,$6b,$73,$7b,$83,$8b,$93,$9b,$a3,$ab,$b3,$bb,$c3,$cb,$d3,$db,$e3,$eb,$f3,$fb:{$endif}begin
       // amod
       rd:=TRegister((aInstruction shr 7) and $1f);
       rs1:=TRegister((aInstruction shr 15) and $1f);
       rs2:=TRegister((aInstruction shr 20) and $1f);
       if (fState.Registers[rs1] and 7)<>0 then begin
        SetException(TExceptionValue.StoreAddressMisaligned,fState.Registers[rs1],fState.PC);
        result:=4;
        exit;
       end else begin
        case ((aInstruction shr 25) and $7c) shr 2 of
         $00:begin
          // amoadd.d
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.Add(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWCommit(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $01:begin
          // amoswap.d
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.Exchange(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWCommit(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $02:begin
          // lr.d
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,true);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           fState.LRSC:=true;
           fState.LRSCCycle:=fState.Cycle;
           fState.LRSCAddress:=fState.Registers[rs1];
           fState.LRSCCAS:=TPasMPInterlocked.Read(PPasMPUInt64(Ptr)^);
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(fState.LRSCCAS)));
           end;
          end;
          result:=4;
          exit;
         end;
         $03:begin
          // sc.d
          // QEMU checks LRSC address match first, then memory translation.
          // While RVVM does memory translation first, then checks LRSC state.
          // We follow QEMU here for better compatibility, since RVVM's
          // approach may lead to unnecessary page faults when the reservation
          // address doesn't match, which is inefficient in some scenarios.
          if fState.LRSC and
             ((fMachine.fLRSCMaximumCycles=0) or 
              ((fState.Cycle-fState.LRSCCycle)<fMachine.fLRSCMaximumCycles)) and
             (fState.LRSCAddress=fState.Registers[rs1]) then begin 
           Ptr:=MemoryPointerTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
           if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
            if (TPasMPInterlocked.CompareExchange(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]),TPasMPUInt64(fState.LRSCCAS))=TPasMPUInt64(fState.LRSCCAS)) then begin
             {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
              fState.Registers[rd]:=0;
             end;
             if Ptr=@fState.Bounce.ui64 then begin
              RMWCommit(fState.Registers[rs1],8,@fState.Bounce.ui64);
             end;
            end else begin
             {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
              fState.Registers[rd]:=1;
             end;
            end;
           end;
          end else begin
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=1;
           end;
          end;
          fState.LRSC:=false;
          result:=4;
          exit;
         end;
         $04:begin
          // amoxor.d
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.ExchangeBitwiseXor(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWCommit(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $05:begin
          // amocas.d (Zacas)
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPUInt64(TPasMPInterlocked.CompareExchange(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]),TPasMPUInt64(fState.Registers[rd])));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=Temporary;
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWCommit(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $08:begin
          // amoor.d
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.ExchangeBitwiseOr(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWCommit(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $0c:begin
          // amoand.d
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           Temporary:=TPasMPInterlocked.ExchangeBitwiseAnd(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]));
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWCommit(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $10:begin
          // amomin.d
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           repeat
            Temporary:=TPasMPUInt64(TPasMPInt64(TPasMPInt64(TPasMPInterlocked.Read(PPasMPInt64(Ptr)^))));
            if TPasMPInt64(Temporary)<TPasMPInt64(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPInt64(Ptr)^,TPasMPInt64(Temporary),TPasMPInt64(Temporary))=TPasMPInt64(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPInt64(Ptr)^,TPasMPInt64(fState.Registers[rs2]),TPasMPInt64(Temporary))=TPasMPInt64(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWCommit(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $14:begin
          // amomax.d
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           repeat
            Temporary:=TPasMPUInt64(TPasMPInt64(TPasMPInt64(TPasMPInterlocked.Read(PPasMPInt64(Ptr)^))));
            if TPasMPInt64(Temporary)>TPasMPInt64(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPInt64(Ptr)^,TPasMPInt64(Temporary),TPasMPInt64(Temporary))=TPasMPInt64(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPInt64(Ptr)^,TPasMPInt64(fState.Registers[rs2]),TPasMPInt64(Temporary))=TPasMPInt64(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWCommit(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $18:begin
          // amominu.d
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           repeat
            Temporary:=TPasMPUInt64(TPasMPUInt64(TPasMPInterlocked.Read(PPasMPUInt64(Ptr)^)));
            if TPasMPUInt64(Temporary)<TPasMPUInt64(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt64(Ptr)^,TPasMPUInt64(Temporary),TPasMPUInt64(Temporary))=TPasMPUInt64(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]),TPasMPUInt64(Temporary))=TPasMPUInt64(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWCommit(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         $1c:begin
          // amomaxu.d
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],8,@fState.Bounce.ui64,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           repeat
            Temporary:=TPasMPUInt64(TPasMPUInt64(TPasMPInterlocked.Read(PPasMPUInt64(Ptr)^)));
            if TPasMPUInt64(Temporary)>TPasMPUInt64(fState.Registers[rs2]) then begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt64(Ptr)^,TPasMPUInt64(Temporary),TPasMPUInt64(Temporary))=TPasMPUInt64(Temporary) then begin
              break;
             end;
            end else begin
             if TPasMPInterlocked.CompareExchange(PPasMPUInt64(Ptr)^,TPasMPUInt64(fState.Registers[rs2]),TPasMPUInt64(Temporary))=TPasMPUInt64(Temporary) then begin
              break;
             end;
            end;
           until false;
           {$ifndef ExplicitEnforceZeroRegister}if rd<>TRegister.Zero then{$endif}begin
            fState.Registers[rd]:=TPasRISCVUInt64(TPasRISCVInt64(TPasRISCVInt64(Temporary)));
           end;
           if Ptr=@fState.Bounce.ui64 then begin
            RMWCommit(fState.Registers[rs1],8,@fState.Bounce.ui64);
           end;
          end;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
      end;
     {$ifndef TryToForceCaseJumpTableOnLevel2}$4:{$else}$04,$0c,$14,$1c,$24,$2c,$34,$3c,$44,$4c,$54,$5c,$64,$6c,$74,$7c,$84,$8c,$94,$9c,$a4,$ac,$b4,$bc,$c4,$cc,$d4,$dc,$e4,$ec,$f4,$fc:{$endif}begin
       // amoq
       rd:=TRegister((aInstruction shr 7) and $1f);
       rs1:=TRegister((aInstruction shr 15) and $1f);
       rs2:=TRegister((aInstruction shr 20) and $1f);
       if (fState.Registers[rs1] and 15)<>0 then begin
        SetException(TExceptionValue.StoreAddressMisaligned,fState.Registers[rs1],fState.PC);
        result:=4;
        exit;
       end else begin
        case ((aInstruction shr 25) and $7c) shr 2 of
         $05:begin
          // amocas.q (Zacas)
          Ptr:=MemoryPointerTranslate(fState.Registers[rs1],16,@fState.Bounce.ui128,false);
          if assigned(Ptr) and (fState.ExceptionValue=TExceptionValue.None) then begin
           fState.CAS128OldValue.Lo:=TPasMPUInt64(fState.Registers[rd]);
           fState.CAS128OldValue.Hi:=TPasMPUInt64(fState.Registers[TRegister((TPasRISCVUInt32(rd)+1) and $1f)]);
           fState.CAS128NewValue.Lo:=TPasMPUInt64(fState.Registers[rs2]);
           fState.CAS128NewValue.Hi:=TPasMPUInt64(fState.Registers[TRegister((TPasRISCVUInt32(rs2)+1) and $1f)]);
           fState.CAS128Result:=TPasMPInterlocked.CompareExchange(PPasMPInt128Record(Ptr)^,fState.CAS128NewValue,fState.CAS128OldValue);
           if rd<>TRegister.Zero then begin
            fState.Registers[rd]:=fState.CAS128Result.Lo;
            if TRegister((TPasRISCVUInt32(rd)+1) and $1f)<>TRegister.Zero then begin
             fState.Registers[TRegister((TPasRISCVUInt32(rd)+1) and $1f)]:=fState.CAS128Result.Hi;
            end;
           end;
           if Ptr=@fState.Bounce.ui128 then begin
            RMWCommit(fState.Registers[rs1],16,@fState.Bounce.ui128);
           end;
          end;
          result:=4;
          exit;
         end;
         else begin
          SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
          result:=4;
          exit;
         end;
        end;
       end;
      end;
      else begin
       SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
       result:=4;
       exit;
      end;
     end;
    end;

    else begin
     SetException(TExceptionValue.IllegalInstruction,aInstruction,fState.PC);
     result:=4;
     exit;
    end;

{$ifndef TryToForceCaseJumpTableOnLevel1}
   end;

  end;
{$endif}

 end;

end;
{$ifdef fpc}{$pop}{$endif}

function TPasRISCV.THART.InterruptsRaised:TPasRISCVUInt64;
begin
 result:=TPasMPInterlocked.Read(fState.PendingIRQs);
end;

function TPasRISCV.THART.InterruptsPending:TPasRISCVUInt64;
begin
 // Include HVIP as active interrupt source (QEMU/Spike treat hvip as alias into pending bits)
 result:=(TPasMPInterlocked.Read(fState.PendingIRQs) or fState.CSR.fData[TCSR.TAddress.MIP] or fState.CSR.fData[TCSR.TAddress.HVIP]) and fState.CSR.fData[TCSR.TAddress.MIE];
end;

function TPasRISCV.THART.InterruptsNotPending:TPasRISCVUInt64;
begin
 result:=(not (TPasMPInterlocked.Read(fState.PendingIRQs) or fState.CSR.fData[TCSR.TAddress.MIP] or fState.CSR.fData[TCSR.TAddress.HVIP])) and fState.CSR.fData[TCSR.TAddress.MIE];
end;

procedure TPasRISCV.THART.ClearInterrupt(const aInterruptValue:TPasRISCV.THART.TInterruptValue);
var Mask:TPasRISCVUInt64;
begin
 Mask:=TPasRISCVUInt64(1) shl TPasRISCVUInt64(aInterruptValue);
 TPasMPInterlocked.BitwiseAnd(fState.PendingIRQs,TPasRISCVUInt64(not TPasRISCVUInt64(Mask)));
//TPasMPInterlocked.BitwiseAnd(fState.CSR.fData[TCSR.TAddress.MIP],TPasRISCVUInt64(not TPasRISCVUInt64(Mask)));
end;

procedure TPasRISCV.THART.RaiseInterrupt(const aInterruptValue:TPasRISCV.THART.TInterruptValue);
var Mask:TPasRISCVUInt64;
begin
 Mask:=TPasRISCVUInt64(1) shl TPasRISCVUInt64(aInterruptValue);
 if (TPasMPInterlocked.ExchangeBitwiseOr(fState.PendingIRQs,Mask) and Mask)=0 then begin
  fMachine.fWakeUpConditionVariableLock.Acquire;
  try
   TPasMPInterlocked.BitwiseOr(fMachine.fRunState,fMachine.fAllHARTMask);
   fMachine.fWakeUpConditionVariable.Broadcast;
  finally
   fMachine.fWakeUpConditionVariableLock.Release;
  end;
 end;
end;

function TPasRISCV.THART.SetInterrupt(const aInterruptValue:TPasRISCV.THART.TInterruptValue):Boolean;
var Mask:TPasRISCVUInt64;
begin
 Mask:=TPasRISCVUInt64(1) shl TPasRISCVUInt64(aInterruptValue);
 result:=(TPasMPInterlocked.ExchangeBitwiseOr(fState.PendingIRQs,Mask) and Mask)=0;
end;

procedure TPasRISCV.THART.SendAIAIRQ(const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aIRQ:TPasRISCVUInt32);
var AIARegFile:TPasRISCV.THART.TAIARegFile;
    MSIP:THART.TInterruptValue;
    Threshold,Reg,Value,EIE,Previous:TPasRISCVUInt32;
begin
 AIARegFile:=fAIARegFiles[aAIARegFileMode];
 if assigned(AIARegFile) and (aIRQ>0) and (aIRQ<TPasRISCV.THART.TAIARegFile.IRQ_LIMIT) then begin
  TPasMPMemoryBarrier.ReadDependency;
  if AIARegFile.fEIDelivery<>0 then begin
   TPasMPMemoryBarrier.ReadDependency;
   Threshold:=AIARegFile.fEIThreshold-1;
   case aAIARegFileMode of
    TPasRISCV.TAIARegFileMode.Machine:begin
     MSIP:=THART.TInterruptValue.MachineExternal;
    end;
    TPasRISCV.TAIARegFileMode.Supervisor:begin
     MSIP:=THART.TInterruptValue.SupervisorExternal;
    end;
    else begin
     MSIP:=THART.TInterruptValue.None;
    end;
   end;
   Reg:=aIRQ shr 5;
   Value:=TPasRISCVUInt32(1) shl (aIRQ and $1f);
   TPasMPMemoryBarrier.ReadDependency;
   EIE:=AIARegFile.fEIE[Reg];
   Previous:=TPasMPInterlocked.ExchangeBitwiseOr(AIARegFile.fEIP[Reg],Value);
   if (aIRQ<Threshold) and ((Value and EIE)<>0) and ((Value and Previous)=0) then begin
    RaiseInterrupt(MSIP);
   end;
  end;
 end;
end;

function TPasRISCV.THART.UpdateAIAInternal(const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aUpdate,aClaim:Boolean):TPasRISCVUInt32;
var AIARegFile:TPasRISCV.THART.TAIARegFile;
    MSIP:THART.TInterruptValue;
    Threshold,EIE,EIP,Bits,Bit,IRQ,Mask:TPasRISCVUInt32;
    Index:TPasRISCVInt32;
begin
 result:=0;
 AIARegFile:=fAIARegFiles[aAIARegFileMode];
 if assigned(AIARegFile) then begin
  TPasMPMemoryBarrier.ReadDependency;
  Threshold:=AIARegFile.fEIThreshold-1;
  case aAIARegFileMode of
   TPasRISCV.TAIARegFileMode.Machine:begin
    MSIP:=THART.TInterruptValue.MachineExternal;
   end;
   TPasRISCV.TAIARegFileMode.Supervisor:begin
    MSIP:=THART.TInterruptValue.SupervisorExternal;
   end;
   else begin
    MSIP:=THART.TInterruptValue.None;
   end;
  end;
  if aUpdate then begin
   ClearInterrupt(MSIP);
  end;
  TPasMPMemoryBarrier.ReadDependency;
  if AIARegFile.fEIDelivery<>0 then begin
   for Index:=0 to TPasRISCV.THART.TAIARegFile.ARRAY_LENGTH-1 do begin
    TPasMPMemoryBarrier.ReadDependency;
    EIE:=AIARegFile.fEIE[Index];
    TPasMPMemoryBarrier.ReadDependency;
    EIP:=AIARegFile.fEIP[Index];
    Bits:=EIE and EIP;
    if Bits<>0 then begin
     if result<>0 then begin
      RaiseInterrupt(MSIP);
      exit;
     end else begin
      Bit:=CLZDWord(Bits) xor 31;
      IRQ:=(Index shl 5) or Bit;
      Mask:=not (TPasRISCVUInt32(1) shl Bit);
      if IRQ<Threshold then begin
       result:=IRQ;
       if aClaim then begin
        Bits:=Bits and Mask;
        TPasMPInterlocked.BitwiseAnd(AIARegFile.fEIP[Index],Mask);
       end;
       if aUpdate then begin
        if Bits<>0 then begin
         RaiseInterrupt(MSIP);
         exit;
        end;
       end else begin
        exit;
       end;
      end;
     end;
    end;
   end;
  end;
 end;
end;

function TPasRISCV.THART.UpdateAIAState(const aAIARegFileMode:TPasRISCV.TAIARegFileMode):TPasRISCVUInt32;
begin
 result:=UpdateAIAInternal(aAIARegFileMode,true,false);
end;

function TPasRISCV.THART.GetAIAIRQ(const aAIARegFileMode:TPasRISCV.TAIARegFileMode;const aClaim:Boolean):TPasRISCVUInt32;
begin
 result:=UpdateAIAInternal(aAIARegFileMode,true,aClaim);
end;

procedure TPasRISCV.THART.HandleInterrupts;
var PC,Status,HStatus,PendingIRQs,IRQs,IDELEG,HIDELEG_Val:TPasRISCVUInt64;
    Mode,Privilege:THART.TMode;
    InterruptValue:TPasRISCV.THART.TInterruptValue;
    WasVirtual,DelegateToVS:Boolean;
begin

 PendingIRQs:=InterruptsPending;

 if PendingIRQs<>0 then begin

  WasVirtual:=fState.VirtualMode;
  DelegateToVS:=false;

  Privilege:=TMode.Machine;
  IDELEG:=fState.CSR.fData[TCSR.TAddress.MIDELEG];
  IRQs:=PendingIRQs and not IDELEG;
  PendingIRQs:=PendingIRQs and IDELEG;

  if IRQs=0 then begin

   // All remaining interrupts are delegated from M to S/HS
   Privilege:=TMode.Supervisor;
{  IDELEG:=fState.CSR.fData[TCSR.TAddress.SIDELEG];
   IRQs:=PendingIRQs and not IDELEG;
   PendingIRQs:=PendingIRQs and IDELEG;}

   // No TMode.User here, since User-level interrupts are optional for implementation were part of the
   // "n" extension that has been removed from the RISC-V specs.
{  if IRQs=0 then begin
    Privilege:=TMode.User;
   end;}

   // If in virtual mode, check hideleg for further delegation M→HS→VS
   if WasVirtual then begin
    HIDELEG_Val:=fState.CSR.fData[TCSR.TAddress.HIDELEG];
    IRQs:=PendingIRQs and not HIDELEG_Val;
    if IRQs=0 then begin
     // All delegated to VS
     IRQs:=PendingIRQs;
     DelegateToVS:=true;
    end;
   end else begin
    IRQs:=PendingIRQs;
   end;
  end;

  Mode:=fState.Mode;
  if Mode>Privilege then begin
   exit;
  end else if ((fState.Mode=Privilege) and (((TPasRISCVUInt32(1) shl TPasRISCVUInt32(Mode)) and fState.CSR.fData[TCSR.TAddress.MSTATUS])=0)) then begin
   exit;
  end else if IRQs<>0 then begin

   PC:=fState.PC;

   InterruptValue:=TInterruptValue(TPasMPMath.BitScanReverse64(IRQs));

   case Privilege of

    TMode.Machine:begin

     if WasVirtual then begin
      SetVirtualMode(false);
     end;
     SetMode(THART.TMode.Machine);

     fState.PC:=(fState.CSR.fData[TCSR.TAddress.MTVEC] and TPasRISCVUInt64($fffffffffffffffc))+TPasRISCVUInt64(ord(fState.CSR.fData[TCSR.TAddress.MTVEC] and 1)*TPasRISCVUInt64(InterruptValue)*4);

     fState.CSR.fData[TCSR.TAddress.MEPC]:=PC and TPasRISCVUInt64($fffffffffffffffe);

     fState.CSR.fData[TCSR.TAddress.MCAUSE]:=(TPasRISCVUInt64(1) shl 63) or TPasRISCVUInt64(InterruptValue);

     fState.CSR.fData[TCSR.TAddress.MTVAL]:=0;

     // H-extension: clear MTVAL2 and MTINST for M-mode interrupt traps
     fState.CSR.fData[TCSR.TAddress.MTVAL2]:=0;
     fState.CSR.fData[TCSR.TAddress.MTINST]:=0;

     Status:=fState.CSR.fData[TCSR.TAddress.MSTATUS];
     Status:=(Status and not ((TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MPIE) or (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MIE))) or (((Status shr TCSR.TMask.TMSTATUSBit.MIE) and 1) shl TCSR.TMask.TMSTATUSBit.MPIE);
     Status:=(Status and not (TPasRISCVUInt64(3) shl 11)) or (TPasRISCVUInt64(TPasRISCVUInt64(Mode) and 3) shl 11);
     // Set MPV
     if WasVirtual then begin
      Status:=Status or (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MPV);
     end else begin
      Status:=Status and not (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MPV);
     end;
     fState.CSR.fData[TCSR.TAddress.MSTATUS]:=Status;

    end;

    TMode.Supervisor:begin

     if DelegateToVS then begin
      // Trap to VS-mode (V stays 1, S-CSRs already contain VS values)
      SetMode(THART.TMode.Supervisor);

      fState.PC:=(fState.CSR.fData[TCSR.TAddress.STVEC] and TPasRISCVUInt64($fffffffffffffffc))+TPasRISCVUInt64(ord(fState.CSR.fData[TCSR.TAddress.STVEC] and 1)*TPasRISCVUInt64(InterruptValue)*4);
      fState.CSR.fData[TCSR.TAddress.SEPC]:=PC and TPasRISCVUInt64($fffffffffffffffe);
      fState.CSR.fData[TCSR.TAddress.SCAUSE]:=(TPasRISCVUInt64(1) shl 63) or TPasRISCVUInt64(InterruptValue);
      fState.CSR.fData[TCSR.TAddress.STVAL]:=0;

      Status:=fState.CSR.fData[TCSR.TAddress.MSTATUS];
      Status:=(Status and not ((TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPIE) or (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SIE))) or (((Status shr TCSR.TMask.TSSTATUSBit.SIE) and 1) shl TCSR.TMask.TSSTATUSBit.SPIE);
      Status:=(Status and not (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPP)) or ((TPasRISCVUInt32(Mode) and 1) shl TCSR.TMask.TSSTATUSBit.SPP);
      fState.CSR.fData[TCSR.TAddress.MSTATUS]:=Status;

     end else begin
      // Trap to HS-mode
      if WasVirtual then begin
       SetVirtualMode(false);
       HStatus:=fState.CSR.fData[TCSR.TAddress.HSTATUS];
       HStatus:=(HStatus and not (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.SPV)) or (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.SPV);
       HStatus:=(HStatus and not (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.SPVP)) or ((TPasRISCVUInt64(Mode) and 1) shl TCSR.TMask.THSTATUSBit.SPVP);
       fState.CSR.fData[TCSR.TAddress.HSTATUS]:=HStatus;
      end;

      SetMode(THART.TMode.Supervisor);

      fState.PC:=(fState.CSR.fData[TCSR.TAddress.STVEC] and TPasRISCVUInt64($fffffffffffffffc))+TPasRISCVUInt64(ord(fState.CSR.fData[TCSR.TAddress.STVEC] and 1)*TPasRISCVUInt64(InterruptValue)*4);

      fState.CSR.fData[TCSR.TAddress.SEPC]:=PC and TPasRISCVUInt64($fffffffffffffffe);

      fState.CSR.fData[TCSR.TAddress.SCAUSE]:=(TPasRISCVUInt64(1) shl 63) or TPasRISCVUInt64(InterruptValue);

      fState.CSR.fData[TCSR.TAddress.STVAL]:=0;

      Status:=fState.CSR.fData[TCSR.TAddress.MSTATUS];
      Status:=(Status and not ((TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPIE) or (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SIE))) or (((Status shr TCSR.TMask.TSSTATUSBit.SIE) and 1) shl TCSR.TMask.TSSTATUSBit.SPIE);
      Status:=(Status and not (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPP)) or ((TPasRISCVUInt32(Mode) and 1) shl TCSR.TMask.TSSTATUSBit.SPP);
      fState.CSR.fData[TCSR.TAddress.MSTATUS]:=Status;

     end;

    end;

    else begin
    end;

   end;

  end;

 end;

end;

procedure TPasRISCV.THART.SwapHypervisorRegs;
var MStatus,SavedMStatus:TPasRISCVUInt64;
    Temp:TPasRISCVUInt64;
begin
 // Swap S-mode CSRs between HS-mode and VS-mode backing store.
 // Called on every V transition (enter/exit virtualized mode).
 // This follows the QEMU approach: actual swapping using separate backing fields.
 MStatus:=fState.CSR.fData[TCSR.TAddress.MSTATUS];

 if fState.VirtualMode then begin
  // V=1 → V=0: save VS state, restore HS state
  // Save current (VS) mstatus bits to vsstatus
  fState.CSR.fData[TCSR.TAddress.VSSTATUS]:=MStatus and TCSR.TMask.MSTATUS_SWAP_MASK;
  // Restore HS mstatus bits
  fState.CSR.fData[TCSR.TAddress.MSTATUS]:=(MStatus and not TCSR.TMask.MSTATUS_SWAP_MASK) or fState.HSMode_MSTATUS;

  // Swap stvec
  Temp:=fState.CSR.fData[TCSR.TAddress.STVEC];
  fState.CSR.fData[TCSR.TAddress.STVEC]:=fState.HSMode_STVEC;
  fState.CSR.fData[TCSR.TAddress.VSTVEC]:=Temp;

  // Swap sscratch
  Temp:=fState.CSR.fData[TCSR.TAddress.SSCRATCH];
  fState.CSR.fData[TCSR.TAddress.SSCRATCH]:=fState.HSMode_SSCRATCH;
  fState.CSR.fData[TCSR.TAddress.VSSCRATCH]:=Temp;

  // Swap sepc
  Temp:=fState.CSR.fData[TCSR.TAddress.SEPC];
  fState.CSR.fData[TCSR.TAddress.SEPC]:=fState.HSMode_SEPC;
  fState.CSR.fData[TCSR.TAddress.VSEPC]:=Temp;

  // Swap scause
  Temp:=fState.CSR.fData[TCSR.TAddress.SCAUSE];
  fState.CSR.fData[TCSR.TAddress.SCAUSE]:=fState.HSMode_SCAUSE;
  fState.CSR.fData[TCSR.TAddress.VSCAUSE]:=Temp;

  // Swap stval
  Temp:=fState.CSR.fData[TCSR.TAddress.STVAL];
  fState.CSR.fData[TCSR.TAddress.STVAL]:=fState.HSMode_STVAL;
  fState.CSR.fData[TCSR.TAddress.VSTVAL]:=Temp;

  // Swap satp
  Temp:=fState.CSR.fData[TCSR.TAddress.SATP];
  fState.CSR.fData[TCSR.TAddress.SATP]:=fState.HSMode_SATP;
  fState.CSR.fData[TCSR.TAddress.VSATP]:=Temp;

 end else begin
  // V=0 → V=1: save HS state, restore VS state
  // Save current (HS) mstatus bits to HSMode backing store
  fState.HSMode_MSTATUS:=MStatus and TCSR.TMask.MSTATUS_SWAP_MASK;
  // Restore VS mstatus bits
  fState.CSR.fData[TCSR.TAddress.MSTATUS]:=(MStatus and not TCSR.TMask.MSTATUS_SWAP_MASK) or fState.CSR.fData[TCSR.TAddress.VSSTATUS];

  // Swap stvec
  fState.HSMode_STVEC:=fState.CSR.fData[TCSR.TAddress.STVEC];
  fState.CSR.fData[TCSR.TAddress.STVEC]:=fState.CSR.fData[TCSR.TAddress.VSTVEC];

  // Swap sscratch
  fState.HSMode_SSCRATCH:=fState.CSR.fData[TCSR.TAddress.SSCRATCH];
  fState.CSR.fData[TCSR.TAddress.SSCRATCH]:=fState.CSR.fData[TCSR.TAddress.VSSCRATCH];

  // Swap sepc
  fState.HSMode_SEPC:=fState.CSR.fData[TCSR.TAddress.SEPC];
  fState.CSR.fData[TCSR.TAddress.SEPC]:=fState.CSR.fData[TCSR.TAddress.VSEPC];

  // Swap scause
  fState.HSMode_SCAUSE:=fState.CSR.fData[TCSR.TAddress.SCAUSE];
  fState.CSR.fData[TCSR.TAddress.SCAUSE]:=fState.CSR.fData[TCSR.TAddress.VSCAUSE];

  // Swap stval
  fState.HSMode_STVAL:=fState.CSR.fData[TCSR.TAddress.STVAL];
  fState.CSR.fData[TCSR.TAddress.STVAL]:=fState.CSR.fData[TCSR.TAddress.VSTVAL];

  // Swap satp (HS satp ↔ vsatp)
  fState.HSMode_SATP:=fState.CSR.fData[TCSR.TAddress.SATP];
  fState.CSR.fData[TCSR.TAddress.SATP]:=fState.CSR.fData[TCSR.TAddress.VSATP];

 end;
end;

procedure TPasRISCV.THART.SetVirtualMode(const aEnabled:Boolean);
begin
 if fState.VirtualMode<>aEnabled then begin
  SwapHypervisorRegs;
  fState.VirtualMode:=aEnabled;
  FlushTLB(true);
  UpdateMMU;
 end;
end;

procedure TPasRISCV.THART.ExecuteException;
var Status,ExceptionBit,HStatus:TPasRISCVUInt64;
    Mode,Privilege:THART.TMode;
    WasVirtual,DelegateToVS:Boolean;
begin

 if fState.ExceptionValue=TExceptionValue.DebuggerBreakpoint then begin
  fState.ExceptionValue:=TExceptionValue.None;
  fState.PC:=fState.ExceptionPC;
  exit;
 end;

 // Clear any pending LR/SC reservation on trap entry, as recommended by the RISC-V Privileged
 // Specification (Volume II, Section 3.1.6). While the spec uses "may" rather than "must",
 // all production implementations (QEMU, hardware) and operating systems (Linux, BSD) expect
 // that exceptions/traps invalidate LR/SC reservations. This prevents spurious SC success
 // after page faults, interrupts, or context switches that occur between LR and SC.
 // Note: This is more conservative than QEMU, which only clears reservations on privilege
 // mode changes (in riscv_cpu_set_mode). We clear on every trap entry to ensure correctness
 // even for traps that don't change the privilege mode (e.g., page fault in S-mode handled
 // by S-mode). The SetMode() function also clears reservations on mode change for consistency.
 fState.LRSC:=false;

 // No TMode.User here, since User-level interrupts are optional for implementation were part of the
 // "n" extension that has been removed from the RISC-V specs.

 Mode:=fState.Mode;
 WasVirtual:=fState.VirtualMode;
 ExceptionBit:=TPasRISCVUInt64(1) shl TPasRISCVUInt32(fState.ExceptionValue);

 // Determine target privilege level
 // Step 1: Check if delegated M→S via medeleg
 if (THART.TMode.Machine>Mode) and ((fState.CSR.fData[TCSR.TAddress.MEDELEG] and ExceptionBit)<>0) then begin
//if (THART.TMode.Hypervisor>Mode) and ((fState.CSR.fData[TCSR.TAddress.HEDELEG] and ExceptionBit)<>0) then begin
  // Delegated to S-mode
  Privilege:=THART.TMode.Supervisor;
  // Step 2: If virtual mode, check if further delegated HS→VS via hedeleg
  DelegateToVS:=WasVirtual and ((fState.CSR.fData[TCSR.TAddress.HEDELEG] and ExceptionBit)<>0);
 end else begin
  Privilege:=THART.TMode.Machine;
 end;

 case Privilege of

  THART.TMode.Supervisor:begin

   if DelegateToVS then begin
    // Trap to VS-mode: S-CSRs already contain VS values (no swap needed)
    // Mode and VirtualMode stay as-is for VS
    SetMode(THART.TMode.Supervisor);
    // V remains 1

    fState.PC:=(fState.CSR.fData[TCSR.TAddress.STVEC] and TPasRISCVUInt64($fffffffffffffffc))+((fState.CSR.fData[TCSR.TAddress.STVEC] and 1)*(TPasRISCVUInt32(fState.ExceptionValue) shl 2));
    fState.CSR.fData[TCSR.TAddress.SEPC]:=fState.ExceptionPC and TPasRISCVUInt64($fffffffffffffffe);
    fState.CSR.fData[TCSR.TAddress.SCAUSE]:=TPasRISCVUInt32(fState.ExceptionValue);
    fState.CSR.fData[TCSR.TAddress.STVAL]:=fState.ExceptionData;

    Status:=fState.CSR.fData[TCSR.TAddress.MSTATUS];
    Status:=(Status and not ((TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPIE) or (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SIE))) or (((Status shr TCSR.TMask.TSSTATUSBit.SIE) and 1) shl TCSR.TMask.TSSTATUSBit.SPIE);
    Status:=(Status and not (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPP)) or ((TPasRISCVUInt32(Mode) and 1) shl TCSR.TMask.TSSTATUSBit.SPP);
    fState.CSR.fData[TCSR.TAddress.MSTATUS]:=Status;

   end else begin
    // Trap to HS-mode
    if WasVirtual then begin
     // Coming from virtual mode: swap VS→HS CSRs, set hstatus.SPV/SPVP
     SetVirtualMode(false);
     HStatus:=fState.CSR.fData[TCSR.TAddress.HSTATUS];
     HStatus:=(HStatus and not (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.SPV)) or (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.SPV); // SPV=1
     HStatus:=(HStatus and not (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.SPVP)) or ((TPasRISCVUInt64(Mode) and 1) shl TCSR.TMask.THSTATUSBit.SPVP); // SPVP=prev priv
     // GVA: set if this was a guest-page-fault or virtual instruction fault
     if (fState.ExceptionValue=TExceptionValue.InstructionGuestPageFault) or
        (fState.ExceptionValue=TExceptionValue.LoadGuestPageFault) or
        (fState.ExceptionValue=TExceptionValue.StoreGuestPageFault) or
        (fState.ExceptionValue=TExceptionValue.VirtualInstruction) then begin
      HStatus:=HStatus or (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.GVA);
     end else begin
      HStatus:=HStatus and not (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.GVA);
     end;
     fState.CSR.fData[TCSR.TAddress.HSTATUS]:=HStatus;
    end else begin
     // Coming from HS/U mode: clear hstatus.SPV
     HStatus:=fState.CSR.fData[TCSR.TAddress.HSTATUS];
     HStatus:=HStatus and not (TPasRISCVUInt64(1) shl TCSR.TMask.THSTATUSBit.SPV);
     fState.CSR.fData[TCSR.TAddress.HSTATUS]:=HStatus;
    end;

    SetMode(THART.TMode.Supervisor);

    fState.PC:=(fState.CSR.fData[TCSR.TAddress.STVEC] and TPasRISCVUInt64($fffffffffffffffc))+((fState.CSR.fData[TCSR.TAddress.STVEC] and 1)*(TPasRISCVUInt32(fState.ExceptionValue) shl 2));
    fState.CSR.fData[TCSR.TAddress.SEPC]:=fState.ExceptionPC and TPasRISCVUInt64($fffffffffffffffe);
    fState.CSR.fData[TCSR.TAddress.SCAUSE]:=TPasRISCVUInt32(fState.ExceptionValue);
    fState.CSR.fData[TCSR.TAddress.STVAL]:=fState.ExceptionData;

    Status:=fState.CSR.fData[TCSR.TAddress.MSTATUS];
    Status:=(Status and not ((TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPIE) or (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SIE))) or (((Status shr TCSR.TMask.TSSTATUSBit.SIE) and 1) shl TCSR.TMask.TSSTATUSBit.SPIE);
    Status:=(Status and not (TPasRISCVUInt64(1) shl TCSR.TMask.TSSTATUSBit.SPP)) or ((TPasRISCVUInt32(Mode) and 1) shl TCSR.TMask.TSSTATUSBit.SPP);
    fState.CSR.fData[TCSR.TAddress.MSTATUS]:=Status;
   end;

  end;

  else {THART.TMode.Machine:}begin

   // Trap to M-mode: set MPV to previous virtual state
   SetVirtualMode(false);
   SetMode(THART.TMode.Machine);

   fState.PC:=(fState.CSR.fData[TCSR.TAddress.MTVEC] and TPasRISCVUInt64($fffffffffffffffc))+((fState.CSR.fData[TCSR.TAddress.MTVEC] and 1)*(TPasRISCVUInt32(fState.ExceptionValue) shl 2));

   fState.CSR.fData[TCSR.TAddress.MEPC]:=fState.ExceptionPC and TPasRISCVUInt64($fffffffffffffffe);

   fState.CSR.fData[TCSR.TAddress.MCAUSE]:=TPasRISCVUInt32(fState.ExceptionValue);

   fState.CSR.fData[TCSR.TAddress.MTVAL]:=fState.ExceptionData;

   // H-extension: MTVAL2 and MTINST for M-mode traps
   if (fState.ExceptionValue=TExceptionValue.InstructionGuestPageFault) or
      (fState.ExceptionValue=TExceptionValue.LoadGuestPageFault) or
      (fState.ExceptionValue=TExceptionValue.StoreGuestPageFault) then begin
    fState.CSR.fData[TCSR.TAddress.MTVAL2]:=fState.CSR.fData[TCSR.TAddress.HTVAL];
    fState.CSR.fData[TCSR.TAddress.MTINST]:=fState.CSR.fData[TCSR.TAddress.HTINST];
   end else begin
    fState.CSR.fData[TCSR.TAddress.MTVAL2]:=0;
    fState.CSR.fData[TCSR.TAddress.MTINST]:=0;
   end;

   Status:=fState.CSR.fData[TCSR.TAddress.MSTATUS];
   Status:=(Status and not ((TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MPIE) or (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MIE))) or (((Status shr TCSR.TMask.TMSTATUSBit.MIE) and 1) shl TCSR.TMask.TMSTATUSBit.MPIE);
   Status:=(Status and not (TPasRISCVUInt64(3) shl 11)) or (TPasRISCVUInt64(TPasRISCVUInt64(Mode) and 3) shl 11);
   // Set MPV to indicate whether we came from virtual mode
   if WasVirtual then begin
    Status:=Status or (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MPV);
   end else begin
    Status:=Status and not (TPasRISCVUInt64(1) shl TCSR.TMask.TMSTATUSBit.MPV);
   end;
   fState.CSR.fData[TCSR.TAddress.MSTATUS]:=Status;

  end;

 end;

 ClearException;

end;

procedure TPasRISCV.THART.SleepUntilNextInterrupt;
var SleepDuration,CurrentSleepDuration,WaitForDuration,
    Time,TimeA,TimeB,ActiveTimers,MTIMECMP,STIMECMP,SleepThreshold,
    Remaining,Difference:TPasRISCVUInt64;
    DoInterrupt:Boolean;
begin

 fState.Sleep:=true;

 if (InterruptsPending and (TPasRISCV.THART.TInterruptValueMasks.MachineTimer or TPasRISCV.THART.TInterruptValueMasks.SupervisorTimer or TPasRISCV.THART.TInterruptValueMasks.HypervisorTimer))=0 then begin

  ActiveTimers:=fState.CSR.fData[TPasRISCV.THART.TCSR.TAddress.MIE] and (TPasRISCV.THART.TInterruptValueMasks.MachineTimer or TPasRISCV.THART.TInterruptValueMasks.SupervisorTimer or TPasRISCV.THART.TInterruptValueMasks.HypervisorTimer);

  if ActiveTimers<>0 then begin

   Time:=fACLINTDevice.GetTime;

   SleepDuration:=TPasRISCVUInt64($ffffffffffffffff);

   MTIMECMP:=fMTIMECMP;
   if (MTIMECMP<>TPasRISCVUInt64($ffffffffffffffff)) and
      ((ActiveTimers and TPasRISCV.THART.TInterruptValueMasks.MachineTimer)<>0) and
      (Time<MTIMECMP) then begin
    CurrentSleepDuration:=TPasRISCVInt64(MTIMECMP)-TPasRISCVInt64(Time);
    if CurrentSleepDuration<SleepDuration then begin
     SleepDuration:=CurrentSleepDuration;
    end;
   end;

   STIMECMP:=fSTIMECMP;
   if (STIMECMP<>TPasRISCVUInt64($ffffffffffffffff)) and
      ((ActiveTimers and TPasRISCV.THART.TInterruptValueMasks.SupervisorTimer)<>0) and
      (Time<STIMECMP) then begin
    CurrentSleepDuration:=TPasRISCVInt64(STIMECMP)-TPasRISCVInt64(Time);
    if CurrentSleepDuration<SleepDuration then begin
     SleepDuration:=CurrentSleepDuration;
    end;
   end;

   if (fVSTIMECMP<>TPasRISCVUInt64($ffffffffffffffff)) and
      ((ActiveTimers and TPasRISCV.THART.TInterruptValueMasks.HypervisorTimer)<>0) and
      ((Time+fState.CSR.fData[TCSR.TAddress.HTIMEDELTA])<fVSTIMECMP) then begin
    CurrentSleepDuration:=TPasRISCVInt64(fVSTIMECMP)-TPasRISCVInt64(Time+fState.CSR.fData[TCSR.TAddress.HTIMEDELTA]);
    if CurrentSleepDuration<SleepDuration then begin
     SleepDuration:=CurrentSleepDuration;
    end;
   end;

   if (SleepDuration>0) and (SleepDuration<>TPasRISCVUInt64($ffffffffffffffff)) then begin

    if SleepDuration>(60*CLOCK_FREQUENCY) then begin
     SleepDuration:=60*CLOCK_FREQUENCY;
    end;

    SleepThreshold:=GlobalSleepThreshold;
    if GlobalSleepGranularity<>0 then begin
     inc(SleepThreshold,SleepDuration div 6);
    end;

    Remaining:=SleepDuration;

    TimeA:=Time;

    if Remaining>SleepThreshold then begin

     fMachine.fWakeUpConditionVariableLock.Acquire;
     try
      while (Remaining>SleepThreshold) and ((TPasMPInterlocked.Read(fMachine.fRunState) and (fHARTMask or TPasRISCVUInt32(RUNSTATE_GLOBAL_MASK)))=RUNSTATE_RUNNING) do begin
       WaitForDuration:=ConvertScale(Remaining-SleepThreshold,CLOCK_FREQUENCY,1000);
       if WaitForDuration>0 then begin
        fMachine.fWakeUpConditionVariable.Wait(fMachine.fWakeUpConditionVariableLock,WaitForDuration);
       end;
       TimeB:=fACLINTDevice.GetTime;
       Difference:=TimeB-TimeA;
       if Remaining>Difference then begin
        dec(Remaining,Difference);
       end else begin
        Remaining:=0;
       end;
       TimeA:=TimeB;
      end;
     finally
      fMachine.fWakeUpConditionVariableLock.Release;
     end;

     TimeB:=fACLINTDevice.GetTime;
     Difference:=TimeB-TimeA;
     if Remaining>Difference then begin
      dec(Remaining,Difference);
     end else begin
      Remaining:=0;
     end;
     TimeA:=TimeB;

    end;

    while (Remaining>0) and ((TPasMPInterlocked.Read(fMachine.fRunState) and (fHARTMask or TPasRISCVUInt32(RUNSTATE_GLOBAL_MASK)))=RUNSTATE_RUNNING) do begin
     TimeB:=fACLINTDevice.GetTime;
     Difference:=TimeB-TimeA;
     if Remaining>Difference then begin
      dec(Remaining,Difference);
     end else begin
      Remaining:=0;
     end;
     TimeA:=TimeB;
    end;

    Time:=fACLINTDevice.GetTime;

   end;

   DoInterrupt:=false;

   if ((ActiveTimers and TPasRISCV.THART.TInterruptValueMasks.MachineTimer)<>0) and (Time>=fMTIMECMP) then begin
    if SetInterrupt(TPasRISCV.THART.TInterruptValue.MachineTimer) then begin
     DoInterrupt:=true;
    end;
   end;

   if ((ActiveTimers and TPasRISCV.THART.TInterruptValueMasks.SupervisorTimer)<>0) and (Time>=STIMECMP) then begin
    if SetInterrupt(TPasRISCV.THART.TInterruptValue.SupervisorTimer) then begin
     DoInterrupt:=true;
    end;
   end;

   if DoInterrupt then begin
    fMachine.InterruptAndWakeUp;
   end;

  end;

 end;

 fState.Sleep:=false;

end;

procedure TPasRISCV.THART.SleepPause;
begin
 fMachine.fWakeUpConditionVariableLock.Acquire;
 try
  fMachine.fWakeUpConditionVariable.Wait(fMachine.fWakeUpConditionVariableLock,10);
 finally
  fMachine.fWakeUpConditionVariableLock.Release;
 end;
end;

procedure TPasRISCV.THART.CheckTimers;
var Interrupts,Time:TPasRISCVUInt64;
    DoInterrupt:Boolean;
begin
 Interrupts:=InterruptsNotPending and (TPasRISCV.THART.TInterruptValueMasks.MachineTimer or TPasRISCV.THART.TInterruptValueMasks.SupervisorTimer or TPasRISCV.THART.TInterruptValueMasks.HypervisorTimer);
 if Interrupts<>0 then begin
  Time:=fACLINTDevice.GetTime;
  DoInterrupt:=false;
  if ((Interrupts and TPasRISCV.THART.TInterruptValueMasks.MachineTimer)<>0) and (Time>=fMTIMECMP) then begin
   if SetInterrupt(TPasRISCV.THART.TInterruptValue.MachineTimer) then begin
    DoInterrupt:=true;
   end;
  end;
  if ((Interrupts and TPasRISCV.THART.TInterruptValueMasks.SupervisorTimer)<>0) and (Time>=fSTIMECMP) then begin
   if SetInterrupt(TPasRISCV.THART.TInterruptValue.SupervisorTimer) then begin
    DoInterrupt:=true;
   end;
  end;
  if ((Interrupts and TPasRISCV.THART.TInterruptValueMasks.HypervisorTimer)<>0) and ((Time+fState.CSR.fData[TCSR.TAddress.HTIMEDELTA])>=fVSTIMECMP) then begin
   if SetInterrupt(TPasRISCV.THART.TInterruptValue.HypervisorTimer) then begin
    DoInterrupt:=true;
   end;
  end;
  if DoInterrupt then begin
   fMachine.InterruptAndWakeUp;
  end;
 end;
end;

procedure TPasRISCV.THART.CheckInterrupts;
var Interrupts:TPasRISCVUInt64;
begin
 Interrupts:=InterruptsPending;
 if Interrupts<>0 then begin
  fMachine.InterruptAndWakeUp;
 end;
end;

{$if defined(PasRISCVCPUFileDumpDebug)}
var DumpFile:^Text=nil;
{$ifend}

procedure TPasRISCV.THART.Execute;
type PDirectAccessTLBEntry=TMMU.PDirectAccessTLBEntry;
var Instruction:TPasRISCVUInt32;
    InstructionAddress,PageAddress:TPasRISCVUInt64;
    InstructionPointer:TPasRISCVPtrUInt;
    RunState:PPasRISCVUInt32;
begin

 RunState:=@fMachine.fRunState;

 repeat

  if (fMachine.fFlushTLBHARTMask and fHARTMask)<>0 then begin
   FlushTLB(false);
   TPasMPInterlocked.BitwiseAnd(fMachine.fFlushTLBHARTMask,TPasMPUInt32(not TPasMPUInt32(fHARTMask)));
  end;

  {$if defined(PasRISCVCPUDebug)}if not IgnoreInterrupts then{$ifend}begin
   CheckTimers;
  end;

  if fState.ExceptionValue<>TExceptionValue.None then begin
   ExecuteException;
  end else begin
   {$if defined(PasRISCVCPUDebug)}if not IgnoreInterrupts then{$ifend}begin
    HandleInterrupts;
   end;
  end;

  InstructionPointer:=0;
  Instruction:=0;
  PageAddress:=TPasRISCVUInt64($7fffffffffffffff);

  repeat

   inc(fState.Cycle);

   InstructionAddress:=fState.PC;

   if TPasRISCVUInt64(InstructionAddress-PageAddress)<TPasRISCVUInt64($ffd) then begin

    Instruction:=PPasRISCVUInt32(Pointer(TPasRISCVPtrUInt(InstructionPointer+InstructionAddress)))^;

   end else if FetchInstruction(InstructionAddress,Instruction) then begin

    PDirectAccessTLBEntry(InstructionPointer):=@fDirectAccessTLBCache[(InstructionAddress shr PAGE_SHIFT) and TMMU.DIRECT_ACCESS_TLB_MASK];
    PageAddress:=PDirectAccessTLBEntry(InstructionPointer)^.Execute shl PAGE_SHIFT;
    InstructionPointer:={$ifdef CombinedDirectAccessTLBCache}PDirectAccessTLBEntry(InstructionPointer)^.RelativeMemory{$else}PDirectAccessTLBEntry(InstructionPointer)^.RelativeMemoryExecute{$endif};

   end else begin

    break;

   end;

{$if defined(PasRISCVCPUDumpDebug)}
   if DumpDebug then begin
    write('PC=',LowerCase(IntToHex(fState.PC,16)),' ');
    if (Instruction and 3)=3 then begin
     write('Inst=',LowerCase(IntToHex(Instruction,8)),' ');
    end else begin
     write('Inst=',LowerCase(IntToHex(Instruction and $ffff,4)),' ');
    end;
    writeln;
   end;
{$ifend}

{$if defined(PasRISCVCPUFileDumpDebug)}
   begin
    if not assigned(DumpFile) then begin
     New(DumpFile);
     Assign(DumpFile^,'pasriscv_trace.txt');
     Rewrite(DumpFile^);
    end;
    write(DumpFile^,'PC=',LowerCase(IntToHex(fState.PC,16)),' ');
    if (Instruction and 3)=3 then begin
     write(DumpFile^,'Inst=',LowerCase(IntToHex(Instruction,8)),' ');
    end else begin
     write(DumpFile^,'Inst=',LowerCase(IntToHex(Instruction and $ffff,4)),' ');
    end;
    writeln(DumpFile^);
    Flush(DumpFile^);
  end;
{$ifend}

   inc(fState.PC,ExecuteInstruction(Instruction));

  until ((RunState^ and (fHARTMask or TPasRISCVUInt32(RUNSTATE_GLOBAL_MASK)))<>RUNSTATE_RUNNING) or
        ((fState.Cycle and TPasRISCVUInt32($ffff))=0);

  TPasMPInterlocked.BitwiseAnd(RunState^,TPasRISCVUInt32(TPasRISCVUInt32(not TPasRISCVUInt32(fHARTMask)) or TPasRISCVUInt32(RUNSTATE_GLOBAL_MASK)));

  // Clear LR/SC reservation after a certain number of cycles to prevent, what some real RISC-V SoCs are
  // known to do, i.e. holding on to reservations indefinitely in case of busy-wait loops.
  if fState.LRSC and (fMachine.fLRSCMaximumCycles>0) and ((fState.Cycle-fState.LRSCCycle)>=fMachine.fLRSCMaximumCycles) then begin
   fState.LRSC:=false;
  end;

(*{$if defined(PasRISCVCPUDebug)}if not IgnoreInterrupts then{$ifend}begin
   CheckInterrupts;
  end;*)

  if fState.ExceptionValue<>TExceptionValue.None then begin
   ExecuteException;
  end;

 until (RunState^ and (RUNSTATE_POWEROFF or RUNSTATE_REBOOT or RUNSTATE_SINGLESTEP or RUNSTATE_PAUSED or RUNSTATE_PAUSING))<>0;

end;

procedure TPasRISCV.THART.ThreadProc;
var HARTActive:Boolean;
begin

 while not fExecutionThread.Terminated do begin

  fMachine.fHARTWakeUpConditionVariableLock.Acquire;
  try
   repeat
    HARTActive:=(TPasMPInterlocked.Read(TPasMPUInt32(fMachine.fHARTActiveMask)) and fHARTMask)<>0;
    if HARTActive or fExecutionThread.Terminated then begin
     break;
    end else begin
     fMachine.fHARTWakeUpConditionVariable.Wait(fMachine.fHARTWakeUpConditionVariableLock);
    end;
   until false;
  finally
   fMachine.fHARTWakeUpConditionVariableLock.Release;
  end;

  if fExecutionThread.Terminated then begin
   break;
  end else begin

   if HARTActive then begin

    fMachine.fHARTStatusChangeConditionVariableLock.Acquire;
    try
     TPasMPInterlocked.BitwiseOr(TPasMPUInt32(fMachine.fHARTRunningMask),TPasMPUInt32(fHARTMask));
     fMachine.fHARTStatusChangeConditionVariable.Broadcast;
    finally
     fMachine.fHARTStatusChangeConditionVariableLock.Release;
    end;

//  Sleep(fHARTID*10);

    Execute;

    fMachine.fHARTStatusChangeConditionVariableLock.Acquire;
    try
     TPasMPInterlocked.BitwiseAnd(TPasMPUInt32(fMachine.fHARTActiveMask),not TPasMPUInt32(fHARTMask));
     TPasMPInterlocked.BitwiseAnd(TPasMPUInt32(fMachine.fHARTRunningMask),not TPasMPUInt32(fHARTMask));
     fMachine.fHARTStatusChangeConditionVariable.Broadcast;
    finally
     fMachine.fHARTStatusChangeConditionVariableLock.Release;
    end;

   end else begin
    TPasMP.Yield;
   end;

  end;

 end;

 fMachine.fHARTStatusChangeConditionVariableLock.Acquire;
 try
  TPasMPInterlocked.BitwiseAnd(TPasMPUInt32(fMachine.fHARTActiveMask),not TPasMPUInt32(fHARTMask));
  TPasMPInterlocked.BitwiseAnd(TPasMPUInt32(fMachine.fHARTRunningMask),not TPasMPUInt32(fHARTMask));
  fMachine.fHARTStatusChangeConditionVariable.Broadcast;
 finally
  fMachine.fHARTStatusChangeConditionVariableLock.Release;
 end;

end;

procedure TPasRISCV.THART.DumpRegisters;
var Register:TRegister;
    FPURegister:TFPURegister;
    s:string;
begin
 WriteLn('Registers:');
 WriteLn;
 for Register:=Low(TRegister) to High(TRegister) do begin
  WriteLn(TInstructionSetArchitecture.RegisterABINames[Register]+': 0x'+LowerCase(IntToHex(fState.Registers[Register],8)));
 end;
 WriteLn('Float registers:');
 for FPURegister:=Low(TFPURegister) to High(TFPURegister) do begin
  s:=FloatToStr(fState.FPURegisters[FPURegister].f64);
  WriteLn(TInstructionSetArchitecture.FPURegisterABINames[FPURegister]+': '+s+' ('+LowerCase(IntToHex(fState.FPURegisters[FPURegister].ui64,8))+')');
 end;
 WriteLn('pc: 0x'+LowerCase(IntToHex(fState.PC,8)));
 if fState.Sleep then begin
  WriteLn('wfi: true');
 end else begin
  WriteLn('wfi: false');
 end;
 WriteLn;
 WriteLn;
end;

{ TPasRISCV.TDisassembler }

constructor TPasRISCV.TDisassembler.Create(const aMachine:TPasRISCV);
begin
 inherited Create;
 fMachine:=aMachine;
 fInstructionSet:=TPasRISCV.TInstructionSetArchitecture.Create(aMachine);
 fOptions.Style:=TStyle.ABI;
 fOptions.Flags:=[TFlag.HexImmediate,TFlag.CSRNames];
end;

destructor TPasRISCV.TDisassembler.Destroy;
begin
 FreeAndNil(fInstructionSet);
 inherited Destroy;
end;

function TPasRISCV.TDisassembler.GetRegisterName(const aRegister:TRegister):TPasRISCVUTF8String;
begin
 case fOptions.Style of
  TStyle.ABI:begin
   result:=TInstructionSetArchitecture.RegisterABINames[aRegister];
  end;
  TStyle.Raw:begin
   result:=TInstructionSetArchitecture.RegisterRawNames[aRegister];
  end;
  else begin
   result:=TInstructionSetArchitecture.RegisterABINames[aRegister];
  end;
 end;
end;

function TPasRISCV.TDisassembler.GetFPURegisterName(const aRegister:TFPURegister):TPasRISCVUTF8String;
begin
 case fOptions.Style of
  TStyle.ABI:begin
   result:=TInstructionSetArchitecture.FPURegisterABINames[aRegister];
  end;
  TStyle.Raw:begin
   result:=TInstructionSetArchitecture.FPURegisterRawNames[aRegister];
  end;
  else begin
   result:=TInstructionSetArchitecture.FPURegisterABINames[aRegister];
  end;
 end;
end;

function TPasRISCV.TDisassembler.FormatImmediate(const aValue:TPasRISCVInt64):TPasRISCVUTF8String;
var AbsoluteValue:TPasRISCVUInt64;
begin
 if TFlag.HexImmediate in fOptions.Flags then begin
  if aValue<0 then begin
   AbsoluteValue:=TPasRISCVUInt64(-aValue);
   result:='-0x'+LowerCase(IntToHex(AbsoluteValue,1));
  end else begin
   result:='0x'+LowerCase(IntToHex(TPasRISCVUInt64(aValue),1));
  end;
 end else begin
  result:=IntToStr(aValue);
 end;
end;

function TPasRISCV.TDisassembler.FormatUnsignedImmediate(const aValue:TPasRISCVUInt64):TPasRISCVUTF8String;
begin
 if TFlag.HexImmediate in fOptions.Flags then begin
  result:='0x'+LowerCase(IntToHex(aValue,1));
 end else begin
  result:=IntToStr(TPasRISCVInt64(aValue));
 end;
end;

function TPasRISCV.TDisassembler.FormatCSR(const aValue:TPasRISCVUInt32):TPasRISCVUTF8String;
var CSRName:TPasRISCVUTF8String;
begin
 CSRName:='';
 if TFlag.CSRNames in fOptions.Flags then begin
  case aValue of
   THART.TCSR.TAddress.USTATUS:begin
    CSRName:='ustatus';
   end;
   THART.TCSR.TAddress.FFLAGS:begin
    CSRName:='fflags';
   end;
   THART.TCSR.TAddress.FRM:begin
    CSRName:='frm';
   end;
   THART.TCSR.TAddress.FCSR:begin
    CSRName:='fcsr';
   end;
   THART.TCSR.TAddress.UVEC:begin
    CSRName:='uvec';
   end;
   THART.TCSR.TAddress.SEED:begin
    CSRName:='seed';
   end;
   THART.TCSR.TAddress.UEPC:begin
    CSRName:='uepc';
   end;
   THART.TCSR.TAddress.UCAUSE:begin
    CSRName:='ucause';
   end;
   THART.TCSR.TAddress.UTVAL:begin
    CSRName:='utval';
   end;
   THART.TCSR.TAddress.SSTATUS:begin
    CSRName:='sstatus';
   end;
   THART.TCSR.TAddress.SEDELEG:begin
    CSRName:='sedeleg';
   end;
   THART.TCSR.TAddress.SIDELEG:begin
    CSRName:='sideleg';
   end;
   THART.TCSR.TAddress.SIE:begin
    CSRName:='sie';
   end;
   THART.TCSR.TAddress.STVEC:begin
    CSRName:='stvec';
   end;
   THART.TCSR.TAddress.SCOUNTEREN:begin
    CSRName:='scounteren';
   end;
   THART.TCSR.TAddress.SENVCFG:begin
    CSRName:='senvcfg';
   end;
   THART.TCSR.TAddress.SSCRATCH:begin
    CSRName:='sscratch';
   end;
   THART.TCSR.TAddress.SEPC:begin
    CSRName:='sepc';
   end;
   THART.TCSR.TAddress.SCAUSE:begin
    CSRName:='scause';
   end;
   THART.TCSR.TAddress.STVAL:begin
    CSRName:='stval';
   end;
   THART.TCSR.TAddress.SIP:begin
    CSRName:='sip';
   end;
   THART.TCSR.TAddress.STIMECMP:begin
    CSRName:='stimecmp';
   end;
   THART.TCSR.TAddress.SISELECT:begin
    CSRName:='siselect';
   end;
   THART.TCSR.TAddress.SIREG:begin
    CSRName:='sireg';
   end;
   THART.TCSR.TAddress.SIREG2:begin
    CSRName:='sireg2';
   end;
   THART.TCSR.TAddress.SIREG3:begin
    CSRName:='sireg3';
   end;
   THART.TCSR.TAddress.SIREG4:begin
    CSRName:='sireg4';
   end;
   THART.TCSR.TAddress.SIREG5:begin
    CSRName:='sireg5';
   end;
   THART.TCSR.TAddress.SIREG6:begin
    CSRName:='sireg6';
   end;
   THART.TCSR.TAddress.SIREG7:begin
    CSRName:='sireg7';
   end;
   THART.TCSR.TAddress.STOPEI:begin
    CSRName:='stopei';
   end;
   THART.TCSR.TAddress.STIMECMPH:begin
    CSRName:='stimecmph';
   end;
   THART.TCSR.TAddress.SATP:begin
    CSRName:='satp';
   end;
   THART.TCSR.TAddress.MSTATUS:begin
    CSRName:='mstatus';
   end;
   THART.TCSR.TAddress.MISA:begin
    CSRName:='misa';
   end;
   THART.TCSR.TAddress.MEDELEG:begin
    CSRName:='medeleg';
   end;
   THART.TCSR.TAddress.MIDELEG:begin
    CSRName:='mideleg';
   end;
   THART.TCSR.TAddress.MIE:begin
    CSRName:='mie';
   end;
   THART.TCSR.TAddress.MTVEC:begin
    CSRName:='mtvec';
   end;
   THART.TCSR.TAddress.MCOUNTEREN:begin
    CSRName:='mcounteren';
   end;
   THART.TCSR.TAddress.MENVCFG:begin
    CSRName:='menvcfg';
   end;
   THART.TCSR.TAddress.MSTATUSH:begin
    CSRName:='mstatush';
   end;
   THART.TCSR.TAddress.MEDELEGH:begin
    CSRName:='medelegh';
   end;
   THART.TCSR.TAddress.MENVCFGH:begin
    CSRName:='menvcfgh';
   end;
   THART.TCSR.TAddress.MCOUNTINHIBIT:begin
    CSRName:='mcountinhibit';
   end;
   THART.TCSR.TAddress.MSCRATCH:begin
    CSRName:='mscratch';
   end;
   THART.TCSR.TAddress.MEPC:begin
    CSRName:='mepc';
   end;
   THART.TCSR.TAddress.MCAUSE:begin
    CSRName:='mcause';
   end;
   THART.TCSR.TAddress.MTVAL:begin
    CSRName:='mtval';
   end;
   THART.TCSR.TAddress.MIP:begin
    CSRName:='mip';
   end;
   THART.TCSR.TAddress.MISELECT:begin
    CSRName:='miselect';
   end;
   THART.TCSR.TAddress.MIREG:begin
    CSRName:='mireg';
   end;
   THART.TCSR.TAddress.MIREG2:begin
    CSRName:='mireg2';
   end;
   THART.TCSR.TAddress.MIREG3:begin
    CSRName:='mireg3';
   end;
   THART.TCSR.TAddress.MIREG4:begin
    CSRName:='mireg4';
   end;
   THART.TCSR.TAddress.MIREG5:begin
    CSRName:='mireg5';
   end;
   THART.TCSR.TAddress.MIREG6:begin
    CSRName:='mireg6';
   end;
   THART.TCSR.TAddress.MIREG7:begin
    CSRName:='mireg7';
   end;
   THART.TCSR.TAddress.MTOPEI:begin
    CSRName:='mtopei';
   end;
   THART.TCSR.TAddress.MNSCRATCH:begin
    CSRName:='mnscratch';
   end;
   THART.TCSR.TAddress.MNEPC:begin
    CSRName:='mnepc';
   end;
   THART.TCSR.TAddress.MNCAUSE:begin
    CSRName:='mncause';
   end;
   THART.TCSR.TAddress.MNSTATUS:begin
    CSRName:='mnstatus';
   end;
   THART.TCSR.TAddress.MSECCFG:begin
    CSRName:='mseccfg';
   end;
   THART.TCSR.TAddress.MSECCFGH:begin
    CSRName:='mseccfgh';
   end;
   THART.TCSR.TAddress.TSELECT:begin
    CSRName:='tselect';
   end;
   THART.TCSR.TAddress.TDATA1:begin
    CSRName:='tdata1';
   end;
   THART.TCSR.TAddress.TDATA2:begin
    CSRName:='tdata2';
   end;
   THART.TCSR.TAddress.TINFO:begin
    CSRName:='tinfo';
   end;
   THART.TCSR.TAddress.DCSR:begin
    CSRName:='dcsr';
   end;
   THART.TCSR.TAddress.DPC:begin
    CSRName:='dpc';
   end;
   THART.TCSR.TAddress.DSCRATCH0:begin
    CSRName:='dscratch0';
   end;
   THART.TCSR.TAddress.DSCRATCH2:begin
    CSRName:='dscratch2';
   end;
   THART.TCSR.TAddress.MCYCLE:begin
    CSRName:='mcycle';
   end;
   THART.TCSR.TAddress.MCYCLEH:begin
    CSRName:='mcycleh';
   end;
   THART.TCSR.TAddress.MINSTRET:begin
    CSRName:='minstret';
   end;
   THART.TCSR.TAddress.MINSTRETH:begin
    CSRName:='minstreth';
   end;
   THART.TCSR.TAddress.CYCLE:begin
    CSRName:='cycle';
   end;
   THART.TCSR.TAddress.CYCLEH:begin
    CSRName:='cycleh';
   end;
   THART.TCSR.TAddress.INSTRET:begin
    CSRName:='instret';
   end;
   THART.TCSR.TAddress.INSTRETH:begin
    CSRName:='instreth';
   end;
   THART.TCSR.TAddress.TIME:begin
    CSRName:='time';
   end;
   THART.TCSR.TAddress.TIMEMS:begin
    CSRName:='timems';
   end;
   THART.TCSR.TAddress.TIMEH:begin
    CSRName:='timeh';
   end;
   THART.TCSR.TAddress.STOPI:begin
    CSRName:='stopi';
   end;
   THART.TCSR.TAddress.MVENDORID:begin
    CSRName:='mvendorid';
   end;
   THART.TCSR.TAddress.MARCHID:begin
    CSRName:='marchid';
   end;
   THART.TCSR.TAddress.MIMPID:begin
    CSRName:='mimpid';
   end;
   THART.TCSR.TAddress.MHARTID:begin
    CSRName:='mhartid';
   end;
   THART.TCSR.TAddress.MCONFIGPTR:begin
    CSRName:='mconfigptr';
   end;
   THART.TCSR.TAddress.MTOPI:begin
    CSRName:='mtopi';
   end;
   else begin
    CSRName:='';
   end;
  end;
 end;
 if length(CSRName)>0 then begin
  result:=CSRName;
 end else begin
  if TFlag.HexImmediate in fOptions.Flags then begin
   result:='0x'+LowerCase(IntToHex(aValue,1));
  end else begin
   result:=IntToStr(aValue);
  end;
 end;
end;

function TPasRISCV.TDisassembler.FormatFenceFlags(const aValue:TPasRISCVUInt32):TPasRISCVUTF8String;
begin
 result:='';
 if (aValue and 8)<>0 then begin
  result:=result+'i';
 end;
 if (aValue and 4)<>0 then begin
  result:=result+'o';
 end;
 if (aValue and 2)<>0 then begin
  result:=result+'r';
 end;
 if (aValue and 1)<>0 then begin
  result:=result+'w';
 end;
 if length(result)=0 then begin
  result:='0';
 end;
end;

function TPasRISCV.TDisassembler.FormatRoundingMode(const aValue:TPasRISCVUInt32):TPasRISCVUTF8String;
begin
 case aValue and 7 of
  0:begin
   result:='rne';
  end;
  1:begin
   result:='rtz';
  end;
  2:begin
   result:='rdn';
  end;
  3:begin
   result:='rup';
  end;
  4:begin
   result:='rmm';
  end;
  7:begin
   result:='dyn';
  end;
  else begin
   result:='rm'+IntToStr(aValue and 7);
  end;
 end;
end;

function TPasRISCV.TDisassembler.FormatInstruction32(const aAddress:TPasRISCVUInt64;
                                                     const aInstruction:TPasRISCVUInt32;
                                                     const aDefinition:TInstructionSetArchitecture.TInstruction):TPasRISCVUTF8String;
var Mnemonic,Operand:TPasRISCVUTF8String;
    rd,rs1,rs2,rs3:TRegister;
    frd,frs1,frs2,frs3:TFPURegister;
    Immediate:TPasRISCVInt64;
    UnsignedImmediate:TPasRISCVUInt64;
    TargetAddress:TPasRISCVUInt64;
    Shamt:TPasRISCVUInt64;
    Pred,Succ:TPasRISCVUInt32;
    CSRValue,RMValue:TPasRISCVUInt32;
    Suffix:TPasRISCVUTF8String;
begin
 Mnemonic:=aDefinition.Mnemonic;
 if TFlag.UppercaseMnemonic in fOptions.Flags then begin
  Mnemonic:=UpperCase(Mnemonic);
 end;
 rd:=TRegister((aInstruction shr 7) and $1f);
 rs1:=TRegister((aInstruction shr 15) and $1f);
 rs2:=TRegister((aInstruction shr 20) and $1f);
 rs3:=TRegister((aInstruction shr 27) and $1f);
 frd:=TFPURegister((aInstruction shr 7) and $1f);
 frs1:=TFPURegister((aInstruction shr 15) and $1f);
 frs2:=TFPURegister((aInstruction shr 20) and $1f);
 frs3:=TFPURegister((aInstruction shr 27) and $1f);
 case aDefinition.Format of
  TInstructionSetArchitecture.TInstructionFormat.None:begin
   result:=Mnemonic;
  end;
  TInstructionSetArchitecture.TInstructionFormat.R:begin
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+GetRegisterName(rs1)+', '+GetRegisterName(rs2);
  end;
  TInstructionSetArchitecture.TInstructionFormat.RUnary:begin
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+GetRegisterName(rs1);
  end;
  TInstructionSetArchitecture.TInstructionFormat.I:begin
   Immediate:=SignExtend(aInstruction shr 20,12);
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+GetRegisterName(rs1)+', '+FormatImmediate(Immediate);
  end;
  TInstructionSetArchitecture.TInstructionFormat.IShift:begin
   Shamt:=(aInstruction shr 20) and $3f;
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+GetRegisterName(rs1)+', '+FormatUnsignedImmediate(Shamt);
  end;
  TInstructionSetArchitecture.TInstructionFormat.IShiftW:begin
   Shamt:=(aInstruction shr 20) and $1f;
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+GetRegisterName(rs1)+', '+FormatUnsignedImmediate(Shamt);
  end;
  TInstructionSetArchitecture.TInstructionFormat.Load:begin
   Immediate:=SignExtend(aInstruction shr 20,12);
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+FormatImmediate(Immediate)+'('+GetRegisterName(rs1)+')';
  end;
  TInstructionSetArchitecture.TInstructionFormat.Store:begin
   Immediate:=SignExtend(((aInstruction shr 25) shl 5) or ((aInstruction shr 7) and $1f),12);
   result:=Mnemonic+' '+GetRegisterName(rs2)+', '+FormatImmediate(Immediate)+'('+GetRegisterName(rs1)+')';
  end;
  TInstructionSetArchitecture.TInstructionFormat.Branch:begin
   Immediate:=SignExtend(((aInstruction shr 19) and $1000) or
                         ((aInstruction shr 20) and $7e0) or
                         ((aInstruction shr 7) and $1e) or
                         ((aInstruction shl 4) and $800),13);
   if TFlag.AbsoluteTargets in fOptions.Flags then begin
    TargetAddress:=aAddress+TPasRISCVUInt64(Immediate);
    result:=Mnemonic+' '+GetRegisterName(rs1)+', '+GetRegisterName(rs2)+', '+FormatUnsignedImmediate(TargetAddress);
   end else begin
    result:=Mnemonic+' '+GetRegisterName(rs1)+', '+GetRegisterName(rs2)+', '+FormatImmediate(Immediate);
   end;
  end;
  TInstructionSetArchitecture.TInstructionFormat.U:begin
   Immediate:=TPasRISCVInt64(TPasRISCVInt32(aInstruction and TPasRISCVUInt32($fffff000)));
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+FormatImmediate(Immediate);
  end;
  TInstructionSetArchitecture.TInstructionFormat.J:begin
   Immediate:=SignExtend(((aInstruction shr 11) and $100000) or
                         (aInstruction and $ff000) or
                         ((aInstruction shr 9) and $800) or
                         ((aInstruction shr 20) and $7fe),21);
   if TFlag.AbsoluteTargets in fOptions.Flags then begin
    TargetAddress:=aAddress+TPasRISCVUInt64(Immediate);
    result:=Mnemonic+' '+GetRegisterName(rd)+', '+FormatUnsignedImmediate(TargetAddress);
   end else begin
    result:=Mnemonic+' '+GetRegisterName(rd)+', '+FormatImmediate(Immediate);
   end;
  end;
  TInstructionSetArchitecture.TInstructionFormat.Jalr:begin
   Immediate:=SignExtend(aInstruction shr 20,12);
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+GetRegisterName(rs1)+', '+FormatImmediate(Immediate);
  end;
  TInstructionSetArchitecture.TInstructionFormat.Fence:begin
   Pred:=(aInstruction shr 24) and $f;
   Succ:=(aInstruction shr 20) and $f;
   result:=Mnemonic+' '+FormatFenceFlags(Pred)+', '+FormatFenceFlags(Succ);
  end;
  TInstructionSetArchitecture.TInstructionFormat.Cbo:begin
   result:=Mnemonic+' '+GetRegisterName(rs1);
  end;
  TInstructionSetArchitecture.TInstructionFormat.Prefetch:begin
   Immediate:=SignExtend(aInstruction shr 25,7);
   result:=Mnemonic+' '+FormatImmediate(Immediate shl 5)+'('+GetRegisterName(rs1)+')';
  end;
  TInstructionSetArchitecture.TInstructionFormat.CSR:begin
   CSRValue:=(aInstruction shr 20) and $fff;
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+FormatCSR(CSRValue)+', '+GetRegisterName(rs1);
  end;
  TInstructionSetArchitecture.TInstructionFormat.CSRImm:begin
   CSRValue:=(aInstruction shr 20) and $fff;
   UnsignedImmediate:=(aInstruction shr 15) and $1f;
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+FormatCSR(CSRValue)+', '+FormatUnsignedImmediate(UnsignedImmediate);
  end;
  TInstructionSetArchitecture.TInstructionFormat.SFence:begin
   result:=Mnemonic+' '+GetRegisterName(rs1)+', '+GetRegisterName(rs2);
  end;
  TInstructionSetArchitecture.TInstructionFormat.HLV:begin
   // HLV.x rd, (rs1)
   result:=Mnemonic+' '+GetRegisterName(rd)+', ('+GetRegisterName(rs1)+')';
  end;
  TInstructionSetArchitecture.TInstructionFormat.HSV:begin
   // HSV.x rs2, (rs1)
   result:=Mnemonic+' '+GetRegisterName(rs2)+', ('+GetRegisterName(rs1)+')';
  end;
  TInstructionSetArchitecture.TInstructionFormat.AMO:begin
   Suffix:='';
   if (aInstruction and TPasRISCVUInt32($04000000))<>0 then begin
    Suffix:=Suffix+'.aq';
   end;
   if (aInstruction and TPasRISCVUInt32($02000000))<>0 then begin
    Suffix:=Suffix+'.rl';
   end;
   result:=Mnemonic+Suffix+' '+GetRegisterName(rd)+', '+GetRegisterName(rs2)+', ('+GetRegisterName(rs1)+')';
  end;
  TInstructionSetArchitecture.TInstructionFormat.LR:begin
   Suffix:='';
   if (aInstruction and TPasRISCVUInt32($04000000))<>0 then begin
    Suffix:=Suffix+'.aq';
   end;
   if (aInstruction and TPasRISCVUInt32($02000000))<>0 then begin
    Suffix:=Suffix+'.rl';
   end;
   result:=Mnemonic+Suffix+' '+GetRegisterName(rd)+', ('+GetRegisterName(rs1)+')';
  end;
  TInstructionSetArchitecture.TInstructionFormat.SC:begin
   Suffix:='';
   if (aInstruction and TPasRISCVUInt32($04000000))<>0 then begin
    Suffix:=Suffix+'.aq';
   end;
   if (aInstruction and TPasRISCVUInt32($02000000))<>0 then begin
    Suffix:=Suffix+'.rl';
   end;
   result:=Mnemonic+Suffix+' '+GetRegisterName(rd)+', '+GetRegisterName(rs2)+', ('+GetRegisterName(rs1)+')';
  end;
  TInstructionSetArchitecture.TInstructionFormat.FLoad:begin
   Immediate:=SignExtend(aInstruction shr 20,12);
   result:=Mnemonic+' '+GetFPURegisterName(frd)+', '+FormatImmediate(Immediate)+'('+GetRegisterName(rs1)+')';
  end;
  TInstructionSetArchitecture.TInstructionFormat.FStore:begin
   Immediate:=SignExtend(((aInstruction shr 25) shl 5) or ((aInstruction shr 7) and $1f),12);
   result:=Mnemonic+' '+GetFPURegisterName(frs2)+', '+FormatImmediate(Immediate)+'('+GetRegisterName(rs1)+')';
  end;
  TInstructionSetArchitecture.TInstructionFormat.FMA:begin
   RMValue:=(aInstruction shr 12) and 7;
   Operand:=FormatRoundingMode(RMValue);
   result:=Mnemonic+' '+GetFPURegisterName(frd)+', '+GetFPURegisterName(frs1)+', '+GetFPURegisterName(frs2)+', '+GetFPURegisterName(frs3)+', '+Operand;
  end;
  TInstructionSetArchitecture.TInstructionFormat.FPBinaryRM:begin
   RMValue:=(aInstruction shr 12) and 7;
   Operand:=FormatRoundingMode(RMValue);
   result:=Mnemonic+' '+GetFPURegisterName(frd)+', '+GetFPURegisterName(frs1)+', '+GetFPURegisterName(frs2)+', '+Operand;
  end;
  TInstructionSetArchitecture.TInstructionFormat.FPBinary:begin
   result:=Mnemonic+' '+GetFPURegisterName(frd)+', '+GetFPURegisterName(frs1)+', '+GetFPURegisterName(frs2);
  end;
  TInstructionSetArchitecture.TInstructionFormat.FPUnaryRM:begin
   RMValue:=(aInstruction shr 12) and 7;
   Operand:=FormatRoundingMode(RMValue);
   result:=Mnemonic+' '+GetFPURegisterName(frd)+', '+GetFPURegisterName(frs1)+', '+Operand;
  end;
  TInstructionSetArchitecture.TInstructionFormat.FPCompare:begin
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+GetFPURegisterName(frs1)+', '+GetFPURegisterName(frs2);
  end;
  TInstructionSetArchitecture.TInstructionFormat.FPClass:begin
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+GetFPURegisterName(frs1);
  end;
  TInstructionSetArchitecture.TInstructionFormat.FPCvtIntFromFP:begin
   RMValue:=(aInstruction shr 12) and 7;
   Operand:=FormatRoundingMode(RMValue);
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+GetFPURegisterName(frs1)+', '+Operand;
  end;
  TInstructionSetArchitecture.TInstructionFormat.FPCvtFPFromInt:begin
   RMValue:=(aInstruction shr 12) and 7;
   Operand:=FormatRoundingMode(RMValue);
   result:=Mnemonic+' '+GetFPURegisterName(frd)+', '+GetRegisterName(rs1)+', '+Operand;
  end;
  TInstructionSetArchitecture.TInstructionFormat.FPCvtFP:begin
   RMValue:=(aInstruction shr 12) and 7;
   Operand:=FormatRoundingMode(RMValue);
   result:=Mnemonic+' '+GetFPURegisterName(frd)+', '+GetFPURegisterName(frs1)+', '+Operand;
  end;
  TInstructionSetArchitecture.TInstructionFormat.FPMoveToInt:begin
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+GetFPURegisterName(frs1);
  end;
  TInstructionSetArchitecture.TInstructionFormat.FPMoveFromInt:begin
   result:=Mnemonic+' '+GetFPURegisterName(frd)+', '+GetRegisterName(rs1);
  end;
  TInstructionSetArchitecture.TInstructionFormat.FPLoadImm:begin
   Immediate:=(aInstruction shr 15) and $1f;
   case Immediate of
    0:begin
     Operand:='-1.0';
    end;
    1:begin
     Operand:='min';
    end;
    2:begin
     Operand:='1.52587890625e-05';
    end;
    3:begin
     Operand:='3.0517578125e-05';
    end;
    4:begin
     Operand:='3.90625e-03';
    end;
    5:begin
     Operand:='7.8125e-03';
    end;
    6:begin
     Operand:='0.0625';
    end;
    7:begin
     Operand:='0.125';
    end;
    8:begin
     Operand:='0.25';
    end;
    9:begin
     Operand:='0.3125';
    end;
    10:begin
     Operand:='0.375';
    end;
    11:begin
     Operand:='0.4375';
    end;
    12:begin
     Operand:='0.5';
    end;
    13:begin
     Operand:='0.625';
    end;
    14:begin
     Operand:='0.75';
    end;
    15:begin
     Operand:='0.875';
    end;
    16:begin
     Operand:='1.0';
    end;
    17:begin
     Operand:='1.25';
    end;
    18:begin
     Operand:='1.5';
    end;
    19:begin
     Operand:='1.75';
    end;
    20:begin
     Operand:='2.0';
    end;
    21:begin
     Operand:='2.5';
    end;
    22:begin
     Operand:='3.0';
    end;
    23:begin
     Operand:='4.0';
    end;
    24:begin
     Operand:='8.0';
    end;
    25:begin
     Operand:='16.0';
    end;
    26:begin
     Operand:='128.0';
    end;
    27:begin
     Operand:='256.0';
    end;
    28:begin
     Operand:='32768.0';
    end;
    29:begin
     Operand:='65536.0';
    end;
    30:begin
     Operand:='inf';
    end;
    31:begin
     Operand:='nan';
    end;
    else begin
     Operand:='?';
    end;
   end;
   result:=Mnemonic+' '+GetFPURegisterName(frd)+', '+Operand;
  end;
  else begin
   result:=Mnemonic;
  end;
 end;
end;

function TPasRISCV.TDisassembler.FormatInstruction16(const aAddress:TPasRISCVUInt64;
                                                     const aInstruction:TPasRISCVUInt32;
                                                     const aDefinition:TInstructionSetArchitecture.TCompressedInstruction):TPasRISCVUTF8String;
var Mnemonic:TPasRISCVUTF8String;
    rd,rs2:TRegister;
    rdPrimeHigh,rdPrimeLow,rs2PrimeLow:TRegister;
    Immediate:TPasRISCVInt64;
    Offset:TPasRISCVUInt64;
    TargetAddress:TPasRISCVUInt64;
    DataRegisterName:TPasRISCVUTF8String;
    DataRegisterKind:TInstructionSetArchitecture.TRegisterKind;
 function FormatDataRegister(const aRegister:TRegister;const aKind:TInstructionSetArchitecture.TRegisterKind):TPasRISCVUTF8String;
 var FRegister:TFPURegister;
 begin
  if aKind=TInstructionSetArchitecture.TRegisterKind.Float then begin
   FRegister:=TFPURegister(aRegister);
   result:=GetFPURegisterName(FRegister);
  end else begin
   result:=GetRegisterName(aRegister);
  end;
 end;
begin
 Mnemonic:=aDefinition.Mnemonic;
 if TFlag.UppercaseMnemonic in fOptions.Flags then begin
  Mnemonic:=UpperCase(Mnemonic);
 end;
 rd:=TRegister((aInstruction shr 7) and $1f);
 rs2:=TRegister((aInstruction shr 2) and $1f);
 rdPrimeHigh:=TRegister(((aInstruction shr 7) and $7)+8);
 rdPrimeLow:=TRegister(((aInstruction shr 2) and $7)+8);
 rs2PrimeLow:=rdPrimeLow;
 DataRegisterKind:=aDefinition.DataRegisterKind;
 case aDefinition.Format of
  TInstructionSetArchitecture.TCompressedFormat.None:begin
   result:=Mnemonic;
  end;
  TInstructionSetArchitecture.TCompressedFormat.CI:begin
   Immediate:=SignExtend(((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f),6);
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+FormatImmediate(Immediate);
  end;
  TInstructionSetArchitecture.TCompressedFormat.CIPrime:begin
   Immediate:=SignExtend(((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f),6);
   result:=Mnemonic+' '+GetRegisterName(rdPrimeHigh)+', '+FormatImmediate(Immediate);
  end;
  TInstructionSetArchitecture.TCompressedFormat.CIShift:begin
   Offset:=((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f);
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+FormatUnsignedImmediate(Offset);
  end;
  TInstructionSetArchitecture.TCompressedFormat.CIShiftPrime:begin
   Offset:=((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1f);
   result:=Mnemonic+' '+GetRegisterName(rdPrimeHigh)+', '+FormatUnsignedImmediate(Offset);
  end;
  TInstructionSetArchitecture.TCompressedFormat.CIAddi16sp:begin
   Immediate:=SignExtend(((aInstruction shr 3) and $200) or
                         ((aInstruction shr 2) and $10) or
                         ((aInstruction shl 1) and $40) or
                         ((aInstruction shl 4) and $180) or
                         ((aInstruction shl 3) and $20),10);
   if TFlag.ExplicitSP in fOptions.Flags then begin
    result:=Mnemonic+' '+GetRegisterName(TRegister.SP)+', '+FormatImmediate(Immediate);
   end else begin
    result:=Mnemonic+' '+FormatImmediate(Immediate);
   end;
  end;
  TInstructionSetArchitecture.TCompressedFormat.CILui:begin
   Immediate:=SignExtend(((aInstruction shl 5) and $20000) or ((aInstruction shl 10) and $1f000),18);
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+FormatImmediate(Immediate);
  end;
  TInstructionSetArchitecture.TCompressedFormat.CIW:begin
   Offset:=((aInstruction shr 1) and $3c0) or ((aInstruction shr 7) and $30) or ((aInstruction shr 2) and $08) or ((aInstruction shr 4) and $04);
   if TFlag.ExplicitSP in fOptions.Flags then begin
    result:=Mnemonic+' '+GetRegisterName(rdPrimeLow)+', '+GetRegisterName(TRegister.SP)+', '+FormatUnsignedImmediate(Offset);
   end else begin
    result:=Mnemonic+' '+GetRegisterName(rdPrimeLow)+', '+FormatUnsignedImmediate(Offset);
   end;
  end;
  TInstructionSetArchitecture.TCompressedFormat.CLW:begin
   Offset:=((aInstruction shl 1) and $40) or ((aInstruction shr 7) and $38) or ((aInstruction shr 4) and $04);
   DataRegisterName:=FormatDataRegister(rdPrimeLow,DataRegisterKind);
   result:=Mnemonic+' '+DataRegisterName+', '+FormatUnsignedImmediate(Offset)+'('+GetRegisterName(rdPrimeHigh)+')';
  end;
  TInstructionSetArchitecture.TCompressedFormat.CLD:begin
   Offset:=((aInstruction shl 1) and $c0) or ((aInstruction shr 7) and $38);
   DataRegisterName:=FormatDataRegister(rdPrimeLow,DataRegisterKind);
   result:=Mnemonic+' '+DataRegisterName+', '+FormatUnsignedImmediate(Offset)+'('+GetRegisterName(rdPrimeHigh)+')';
  end;
  TInstructionSetArchitecture.TCompressedFormat.CSW:begin
   Offset:=((aInstruction shl 1) and $40) or ((aInstruction shr 7) and $38) or ((aInstruction shr 4) and $04);
   DataRegisterName:=FormatDataRegister(rs2PrimeLow,DataRegisterKind);
   result:=Mnemonic+' '+DataRegisterName+', '+FormatUnsignedImmediate(Offset)+'('+GetRegisterName(rdPrimeHigh)+')';
  end;
  TInstructionSetArchitecture.TCompressedFormat.CSD:begin
   Offset:=((aInstruction shl 1) and $c0) or ((aInstruction shr 7) and $38);
   DataRegisterName:=FormatDataRegister(rs2PrimeLow,DataRegisterKind);
   result:=Mnemonic+' '+DataRegisterName+', '+FormatUnsignedImmediate(Offset)+'('+GetRegisterName(rdPrimeHigh)+')';
  end;
  TInstructionSetArchitecture.TCompressedFormat.CJ:begin
   Immediate:=SignExtend(((aInstruction shr 1) and $800) or
                         ((aInstruction shl 2) and $400) or
                         ((aInstruction shr 1) and $300) or
                         ((aInstruction shl 1) and $80) or
                         ((aInstruction shr 1) and $40) or
                         ((aInstruction shl 3) and $20) or
                         ((aInstruction shr 7) and $10) or
                         ((aInstruction shr 2) and $0e),12);
   if TFlag.AbsoluteTargets in fOptions.Flags then begin
    TargetAddress:=aAddress+TPasRISCVUInt64(Immediate);
    result:=Mnemonic+' '+FormatUnsignedImmediate(TargetAddress);
   end else begin
    result:=Mnemonic+' '+FormatImmediate(Immediate);
   end;
  end;
  TInstructionSetArchitecture.TCompressedFormat.CB:begin
   Immediate:=SignExtend(((aInstruction shr 4) and $100) or
                         ((aInstruction shl 1) and $c0) or
                         ((aInstruction shl 3) and $20) or
                         ((aInstruction shr 7) and $18) or
                         ((aInstruction shr 2) and $06),9);
   if TFlag.AbsoluteTargets in fOptions.Flags then begin
    TargetAddress:=aAddress+TPasRISCVUInt64(Immediate);
    result:=Mnemonic+' '+GetRegisterName(rdPrimeHigh)+', '+FormatUnsignedImmediate(TargetAddress);
   end else begin
    result:=Mnemonic+' '+GetRegisterName(rdPrimeHigh)+', '+FormatImmediate(Immediate);
   end;
  end;
  TInstructionSetArchitecture.TCompressedFormat.CR:begin
   result:=Mnemonic+' '+GetRegisterName(rd)+', '+GetRegisterName(rs2);
  end;
  TInstructionSetArchitecture.TCompressedFormat.CA:begin
   result:=Mnemonic+' '+GetRegisterName(rdPrimeHigh)+', '+GetRegisterName(rs2PrimeLow);
  end;
  TInstructionSetArchitecture.TCompressedFormat.RDPrime:begin
   result:=Mnemonic+' '+GetRegisterName(rdPrimeHigh);
  end;
  TInstructionSetArchitecture.TCompressedFormat.CLWSP:begin
   Offset:=((aInstruction shl 4) and $c0) or ((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $1c);
   DataRegisterName:=FormatDataRegister(rd,DataRegisterKind);
   result:=Mnemonic+' '+DataRegisterName+', '+FormatUnsignedImmediate(Offset)+'('+GetRegisterName(TRegister.SP)+')';
  end;
  TInstructionSetArchitecture.TCompressedFormat.CLDSP:begin
   Offset:=((aInstruction shl 4) and $1c0) or ((aInstruction shr 7) and $20) or ((aInstruction shr 2) and $18);
   DataRegisterName:=FormatDataRegister(rd,DataRegisterKind);
   result:=Mnemonic+' '+DataRegisterName+', '+FormatUnsignedImmediate(Offset)+'('+GetRegisterName(TRegister.SP)+')';
  end;
  TInstructionSetArchitecture.TCompressedFormat.CSWSP:begin
   Offset:=((aInstruction shr 1) and $c0) or ((aInstruction shr 7) and $3c);
   DataRegisterName:=FormatDataRegister(rs2,DataRegisterKind);
   result:=Mnemonic+' '+DataRegisterName+', '+FormatUnsignedImmediate(Offset)+'('+GetRegisterName(TRegister.SP)+')';
  end;
  TInstructionSetArchitecture.TCompressedFormat.CSDSP:begin
   Offset:=((aInstruction shr 1) and $1c0) or ((aInstruction shr 7) and $38);
   DataRegisterName:=FormatDataRegister(rs2,DataRegisterKind);
   result:=Mnemonic+' '+DataRegisterName+', '+FormatUnsignedImmediate(Offset)+'('+GetRegisterName(TRegister.SP)+')';
  end;
  TInstructionSetArchitecture.TCompressedFormat.CJR:begin
   result:=Mnemonic+' '+GetRegisterName(rd);
  end;
  TInstructionSetArchitecture.TCompressedFormat.ZcbLbu:begin
   Offset:=((aInstruction and $20) shr 4) or ((aInstruction and $40) shr 6);
   DataRegisterName:=FormatDataRegister(rdPrimeLow,DataRegisterKind);
   result:=Mnemonic+' '+DataRegisterName+', '+FormatUnsignedImmediate(Offset)+'('+GetRegisterName(rdPrimeHigh)+')';
  end;
  TInstructionSetArchitecture.TCompressedFormat.ZcbLh:begin
   Offset:=(aInstruction and $20) shr 4;
   DataRegisterName:=FormatDataRegister(rdPrimeLow,DataRegisterKind);
   result:=Mnemonic+' '+DataRegisterName+', '+FormatUnsignedImmediate(Offset)+'('+GetRegisterName(rdPrimeHigh)+')';
  end;
  TInstructionSetArchitecture.TCompressedFormat.ZcbLhu:begin
   Offset:=(aInstruction and $20) shr 4;
   DataRegisterName:=FormatDataRegister(rdPrimeLow,DataRegisterKind);
   result:=Mnemonic+' '+DataRegisterName+', '+FormatUnsignedImmediate(Offset)+'('+GetRegisterName(rdPrimeHigh)+')';
  end;
  TInstructionSetArchitecture.TCompressedFormat.ZcbSbu:begin
   Offset:=((aInstruction and $20) shr 4) or ((aInstruction and $40) shr 6);
   DataRegisterName:=FormatDataRegister(rs2PrimeLow,DataRegisterKind);
   result:=Mnemonic+' '+DataRegisterName+', '+FormatUnsignedImmediate(Offset)+'('+GetRegisterName(rdPrimeHigh)+')';
  end;
  TInstructionSetArchitecture.TCompressedFormat.ZcbSh:begin
   Offset:=((aInstruction and $20) shr 4) or ((aInstruction and $40) shr 6);
   DataRegisterName:=FormatDataRegister(rs2PrimeLow,DataRegisterKind);
   result:=Mnemonic+' '+DataRegisterName+', '+FormatUnsignedImmediate(Offset)+'('+GetRegisterName(rdPrimeHigh)+')';
  end;
  else begin
   result:=Mnemonic;
  end;
 end;
end;

function TPasRISCV.TDisassembler.DisassembleInstruction(const aAddress:TPasRISCVUInt64;const aInstruction:TPasRISCVUInt32):TPasRISCVUTF8String;
var InstructionDefinition:TInstructionSetArchitecture.TInstruction;
    CompressedInstructionDefinition:TInstructionSetArchitecture.TCompressedInstruction;
begin
 if (aInstruction and 3)=3 then begin
  if fInstructionSet.FindInstruction32(aInstruction,InstructionDefinition) then begin
   result:=FormatInstruction32(aAddress,aInstruction,InstructionDefinition);
  end else begin
   result:='.word 0x'+LowerCase(IntToHex(aInstruction,8));
  end;
 end else begin
  if fInstructionSet.FindInstruction16(aInstruction and $ffff,CompressedInstructionDefinition) then begin
   result:=FormatInstruction16(aAddress,aInstruction and $ffff,CompressedInstructionDefinition);
  end else begin
   result:='.half 0x'+LowerCase(IntToHex(aInstruction and $ffff,4));
  end;
 end;
end;

{ TPasRISCV.TDebugger.TClientThread }

constructor TPasRISCV.TDebugger.TClientThread.Create(const aDebugger:TDebugger;const aSocket:TRNLSocket;const aAddress:TRNLAddress);
begin
 fDebugger:=aDebugger;
 fSocket:=aSocket;
 fAddress:=aAddress;
 fHART:=nil;
 fRecvSize:=0;
 fSendBufferString:='';
 fEvent:=TRNLNetworkEvent.Create;
 if fDebugger.fMachine.fCountHARTs>0 then begin
  fHART:=fDebugger.fMachine.fHARTs[0];
 end else begin
  fHART:=nil;
 end;
 inherited Create(false);
end;

destructor TPasRISCV.TDebugger.TClientThread.Destroy;
begin
 Shutdown;
 fSendBufferString:='';
 inherited Destroy;
end;

procedure TPasRISCV.TDebugger.TClientThread.AfterConstruction;
var Index:TPasRISCVSizeInt;
begin

 inherited AfterConstruction;

 // Add the client thread to the list
 if assigned(fDebugger) and assigned(fDebugger.fLock) then begin
  fDebugger.fLock.Acquire;
  try
   Index:=fDebugger.fCountClientThreads;
   inc(fDebugger.fCountClientThreads);
   if length(fDebugger.fClientThreads)<fDebugger.fCountClientThreads then begin
    SetLength(fDebugger.fClientThreads,fDebugger.fCountClientThreads+((fDebugger.fCountClientThreads+1) shr 1));
   end;
   fDebugger.fClientThreads[Index]:=self;
  finally
   fDebugger.fLock.Release;
  end;
 end;

end;

procedure TPasRISCV.TDebugger.TClientThread.BeforeDestruction;
var Index:TPasRISCVSizeInt;
begin

 if assigned(fDebugger) and assigned(fDebugger.fLock) then begin

  // Close the socket
  if fSocket<>RNL_SOCKET_NULL then begin
   try
    fDebugger.fRNLNetwork.SocketShutdown(fSocket);
    fDebugger.fRNLNetwork.SocketDestroy(fSocket);
   finally
    fSocket:=RNL_SOCKET_NULL;
   end;
  end;

  // Remove the client thread from the list
  fDebugger.fLock.Acquire;
  try
   for Index:=0 to fDebugger.fCountClientThreads-1 do begin
    if fDebugger.fClientThreads[Index]=self then begin
     if (Index+1)<fDebugger.fCountClientThreads then begin
      fDebugger.fClientThreads[Index]:=fDebugger.fClientThreads[fDebugger.fCountClientThreads-1];
     end;
     dec(fDebugger.fCountClientThreads);
     break;
    end;
   end;
  finally
   fDebugger.fLock.Release;
  end;

  if assigned(fDebugger.fClientsInvertedSemaphore) then begin
   fDebugger.fClientsInvertedSemaphore.Release;
  end;

 end;

 inherited BeforeDestruction;

end;

procedure TPasRISCV.TDebugger.TClientThread.Shutdown;
begin
 if not Finished then begin
  Terminate;
  fEvent.SetEvent;
  WaitFor;
 end;
end;

class function TPasRISCV.TDebugger.TClientThread.Hexify(const aNibble:TPasRISCVUInt8):TPasRISCVRawByteChar;
begin
 if aNibble<10 then begin
  result:=TPasRISCVRawByteChar(TPasRISCVUInt8(aNibble+$30));
 end else if aNibble<16 then begin
  result:=TPasRISCVRawByteChar(TPasRISCVUInt8(aNibble+$57));
 end else begin
  result:='?';
 end;
end;

class function TPasRISCV.TDebugger.TClientThread.ByteToHex(const aValue:TPasRISCVUInt8):TPasRISCVRawByteString;
begin
 result:=Hexify((aValue shr 4) and $f)+Hexify(aValue and $f);
end;

class function TPasRISCV.TDebugger.TClientThread.LittleEndianBytesToHex(const aData:Pointer;const aBytes:TPasRISCVSizeInt):TPasRISCVRawByteString;
var Index:TPasRISCVSizeInt;
    p:PPasRISCVUInt8;
begin
 result:='';
 p:=aData;
 for Index:=0 to aBytes-1 do begin
  result:=result+ByteToHex(p^);
  inc(p);
 end;
end;

class function TPasRISCV.TDebugger.TClientThread.LittleEndianValueToHex(const aValue:TPasRISCVUInt64;const aBytes:TPasRISCVSizeInt):TPasRISCVRawByteString;
var Index:TPasRISCVSizeInt;
    p:TPasRISCVUInt8;
begin
 result:='';
 for Index:=0 to aBytes-1 do begin
  p:=TPasRISCVUInt8((aValue shr (Index shl 3)) and $ff);
  result:=result+ByteToHex(p);
 end;
end;

class function TPasRISCV.TDebugger.TClientThread.HexNibble(const aDigit:TPasRISCVRawByteChar):TPasRISCVUInt8;
begin
 case aDigit of
  '0'..'9':begin
   result:=TPasRISCVUInt8(aDigit)-$30;
  end;
  'a'..'f':begin
   result:=TPasRISCVUInt8(aDigit)-$57;
  end;
  'A'..'F':begin
   result:=TPasRISCVUInt8(aDigit)-$37;
  end;
  else begin
   result:=0;
  end;
 end;
end;

class function TPasRISCV.TDebugger.TClientThread.HexToByte(const aString:TPasRISCVRawByteString;var aStringPosition:TPasRISCVSizeInt):TPasRISCVUInt8;
begin
 result:=0;
 if aStringPosition<=length(aString) then begin
  result:=result or HexNibble(aString[aStringPosition]);
  inc(aStringPosition);
 end;
 if aStringPosition<=length(aString) then begin
  result:=(result shl 4) or HexNibble(aString[aStringPosition]);
  inc(aStringPosition);
 end;
end;

class procedure TPasRISCV.TDebugger.TClientThread.HexToLittleEndianBytes(const aData:Pointer;const aString:TPasRISCVRawByteString;var aStringPosition:TPasRISCVSizeInt;const aBytes:TPasRISCVSizeInt);
var Index:TPasRISCVSizeInt;
    p:PPasRISCVUInt8;
begin
 p:=aData;
 for Index:=0 to aBytes-1 do begin
  p^:=HexToByte(aString,aStringPosition);
  inc(p);
 end;
end;

class function TPasRISCV.TDebugger.TClientThread.HexToLittleEndianValue(const aString:TPasRISCVRawByteString;var aStringPosition:TPasRISCVSizeInt;const aBytes:TPasRISCVSizeInt):TPasRISCVUInt64;
var Index:TPasRISCVSizeInt;
begin
 result:=0;
 for Index:=0 to aBytes-1 do begin
  result:=result or (TPasRISCVUInt64(HexToByte(aString,aStringPosition)) shl (Index shl 3));
 end;
end;

procedure TPasRISCV.TDebugger.TClientThread.Send(const aData:TPasRISCVRawByteString);
var BytesSent,Count:TPasRISCVSizeInt;
begin
 writeln('< ',aData);
 if length(aData)>0 then begin
  BytesSent:=0;
  while BytesSent<length(aData) do begin
   Count:=fDebugger.fRNLNetwork.Send(fSocket,@fAddress,aData[BytesSent+1],length(aData)-BytesSent,RNL_IPV4);
   if Count>0 then begin
    inc(BytesSent,Count);
   end;
  end;
 end;
 writeln('!');
end;

procedure TPasRISCV.TDebugger.TClientThread.ReplyACK;
begin
 Send('+');
end;

procedure TPasRISCV.TDebugger.TClientThread.ReplyNAK;
begin
 Send('-');
end;

procedure TPasRISCV.TDebugger.TClientThread.ResendReply;
begin
 Send(fSendBufferString);
end;

procedure TPasRISCV.TDebugger.TClientThread.SendBufferAppend(const aString:TPasRISCVRawByteString);
begin
 fSendBufferString:=fSendBufferString+aString;
end;

procedure TPasRISCV.TDebugger.TClientThread.ReplyString(const aString:TPasRISCVRawByteString);
var Index:TPasRISCVSizeInt;
    Checksum:TPasRISCVUInt8;
begin
 Checksum:=0;
 for Index:=1 to length(aString) do begin
  Checksum:=Checksum+TPasRISCVUInt8(aString[Index]);
 end;
 fSendBufferString:='$'+aString+'#'+LittleEndianBytesToHex(@Checksum,1);
 ResendReply;
end;

procedure TPasRISCV.TDebugger.TClientThread.ReplyConsole(const aString:TPasRISCVRawByteString);
var Index:TPasRISCVSizeInt;
    HexString:TPasRISCVRawByteString;
begin
 HexString:='';
 for Index:=1 to length(aString) do begin
  HexString:=HexString+ByteToHex(TPasRISCVUInt8(aString[Index]));
 end;
 ReplyString('O'+HexString);
end;

function TPasRISCV.TDebugger.TClientThread.DecodeHexString(const aHex:TPasRISCVRawByteString;out aDecoded:TPasRISCVRawByteString):Boolean;
var Index:TPasRISCVSizeInt;
    ByteValue:TPasRISCVUInt8;
begin
 aDecoded:='';
 if (length(aHex) and 1)<>0 then begin
  result:=false;
  exit;
 end;
 Index:=1;
 while Index<=length(aHex) do begin
  ByteValue:=HexToByte(aHex,Index);
  aDecoded:=aDecoded+TPasRISCVRawByteChar(ByteValue);
 end;
 result:=true;
end;

procedure TPasRISCV.TDebugger.TClientThread.MonitorOutput(const aString:TPasRISCVRawByteString);
begin
 if (length(aString)>0) and ((aString[length(aString)]=#10) or (aString[length(aString)]=#13)) then begin
  ReplyConsole(aString);
 end else begin
  ReplyConsole(aString+#10);
 end;
end;

procedure TPasRISCV.TDebugger.TClientThread.MonitorError(const aString:TPasRISCVRawByteString);
begin
 MonitorOutput(aString);
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessMonitorCommand(const aCommand:TPasRISCVRawByteString);
begin
 if assigned(fDebugger) then begin
  fDebugger.ProcessCommand(aCommand,MonitorOutput,MonitorError);
 end;
end;

procedure TPasRISCV.TDebugger.TClientThread.ConsumeBytes(const aBytes:TPasRISCVSizeInt);
var Amount:TPasRISCVSizeInt;
begin
 if fRecvSize>0 then begin
  if aBytes>fRecvSize then begin
   Amount:=fRecvSize;
  end else begin
   Amount:=aBytes;
  end;
  dec(fRecvSize,Amount);
  Move(fRecvBuffer[Amount],fRecvBuffer[0],fRecvSize);
 end;
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessStep;
begin
 fDebugger.SingleStep;
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessContinue;
begin
 fDebugger.Continue_;
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessMemory(const aPacketString:TPasRISCVRawByteString;const aWrite:Boolean);
var Index,Size,ToDo,Remain,Len:TPasRISCVSizeInt;
    MemoryAddress,MemorySize,Value:TPasRISCVUInt64;
    ByteData:array[0..7] of TPasRISCVUInt8;
    s:TPasRISCVRawByteString;
begin

 Index:=2;

 MemoryAddress:=StrToUIntBase(aPacketString,Index,Size,16);
 if (Index>length(aPacketString)) or (aPacketString[Index]<>TPasRISCVRawByteChar(',')) then begin
  ReplyNAK;
  exit;
 end else begin
  inc(Index);
 end;

 Size:=0;
 MemorySize:=StrToUIntBase(aPacketString,Index,Size,16);
 if Size=0 then begin
  ReplyNAK;
  exit;
 end;

 case aPacketString[1] of
  'm':begin
   // Read memory
   if assigned(fHART) then begin
    Remain:=MemorySize;
    s:='';
    while Remain>0 do begin
     if Remain>8 then begin
      ToDo:=8;
     end else begin
      ToDo:=Remain;
     end;
     case ToDo of
      1:begin
       if fHART.LoadEx(MemoryAddress,Value,1) then begin
        ByteData[0]:=Value;
        inc(MemoryAddress);
       end else begin
        break;
       end;
      end;
      2:begin
       if fHART.LoadEx(MemoryAddress,Value,2) then begin
        PPASRISCVUInt16(Pointer(@ByteData[0]))^:=Value;
        inc(MemoryAddress,2);
       end else begin
        break;
       end;
      end;
      3:begin
       if fHART.LoadEx(MemoryAddress,Value,2) then begin
        PPASRISCVUInt16(Pointer(@ByteData[0]))^:=Value;
        inc(MemoryAddress,2);
       end else begin
        break;
       end;
       if fHART.LoadEx(MemoryAddress,Value,1) then begin
        ByteData[2]:=Value;
        inc(MemoryAddress);
       end else begin
        break;
       end;
      end;
      4:begin
       if fHART.LoadEx(MemoryAddress,Value,4) then begin
        PPASRISCVUInt32(Pointer(@ByteData[0]))^:=Value;
        inc(MemoryAddress,4);
       end else begin
        break;
       end;
      end;
      5:begin
       if fHART.LoadEx(MemoryAddress,Value,4) then begin
        PPASRISCVUInt32(Pointer(@ByteData[0]))^:=Value;
        inc(MemoryAddress,4);
       end else begin
        break;
       end;
       if fHART.LoadEx(MemoryAddress,Value,1) then begin
        ByteData[4]:=Value;
        inc(MemoryAddress);
       end else begin
        break;
       end;
      end;
      6:begin
       if fHART.LoadEx(MemoryAddress,Value,4) then begin
        PPASRISCVUInt32(Pointer(@ByteData[0]))^:=Value;
        inc(MemoryAddress,4);
       end else begin
        break;
       end;
       if fHART.LoadEx(MemoryAddress,Value,2) then begin
        PPASRISCVUInt16(Pointer(@ByteData[4]))^:=Value;
        inc(MemoryAddress,2);
       end else begin
        break;
       end;
      end;
      7:begin
       if fHART.LoadEx(MemoryAddress,Value,4) then begin
        PPASRISCVUInt32(Pointer(@ByteData[0]))^:=Value;
        inc(MemoryAddress,4);
       end else begin
        break;
       end;
       if fHART.LoadEx(MemoryAddress,Value,2) then begin
        PPASRISCVUInt16(Pointer(@ByteData[4]))^:=Value;
        inc(MemoryAddress,2);
       end else begin
        break;
       end;
       if fHART.LoadEx(MemoryAddress,Value,1) then begin
        ByteData[6]:=Value;
        inc(MemoryAddress);
       end else begin
        break;
       end;
      end;
      8:begin
       if fHART.LoadEx(MemoryAddress,Value,8) then begin
        PPASRISCVUInt64(Pointer(@ByteData[0]))^:=Value;
        inc(MemoryAddress,8);
       end else begin
        break;
       end;
      end;
      else begin
       break;
      end;
     end;
     s:=s+LittleEndianBytesToHex(@ByteData[0],ToDo);
     dec(Remain,ToDo);
    end;
    if Remain=0 then begin
     ReplyString(s);
    end else begin
     ReplyString('E00');
    end;
   end else begin
    ReplyString('E00');
   end;
  end;
  'M':begin
   // Write memory
   if (Index>length(aPacketString)) or (aPacketString[Index]<>TPasRISCVRawByteChar(':')) then begin
    ReplyNAK;
    exit;
   end else begin
    inc(Index);
   end;
   if assigned(fHART) then begin
    Remain:=MemorySize;
    Len:=length(aPacketString);
    while (Remain>0) and (((Index+(Remain shl 1))-1)<=Len) do begin
     if Remain>8 then begin
      ToDo:=8;
     end else begin
      ToDo:=Remain;
     end;
     case ToDo of
      1:begin
       ByteData[0]:=HexToByte(aPacketString,Index);
       if fHART.StoreEx(MemoryAddress,ByteData[0],1) then begin
        inc(MemoryAddress);
       end else begin
        break;
       end;
      end;
      2:begin
       ByteData[0]:=HexToByte(aPacketString,Index);
       ByteData[1]:=HexToByte(aPacketString,Index);
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt16(@ByteData[0])^,2) then begin
        inc(MemoryAddress,2);
       end else begin
        break;
       end;
      end;
      3:begin
       ByteData[0]:=HexToByte(aPacketString,Index);
       ByteData[1]:=HexToByte(aPacketString,Index);
       ByteData[2]:=HexToByte(aPacketString,Index);
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt16(@ByteData[0])^,2) then begin
        inc(MemoryAddress,2);
       end else begin
        break;
       end;
       if fHART.StoreEx(MemoryAddress,ByteData[2],1) then begin
        inc(MemoryAddress);
       end else begin
        break;
       end;
      end;
      4:begin
       ByteData[0]:=HexToByte(aPacketString,Index);
       ByteData[1]:=HexToByte(aPacketString,Index);
       ByteData[2]:=HexToByte(aPacketString,Index);
       ByteData[3]:=HexToByte(aPacketString,Index);
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt32(@ByteData[0])^,4) then begin
        inc(MemoryAddress,4);
       end else begin
        break;
       end;
      end;
      5:begin
       ByteData[0]:=HexToByte(aPacketString,Index);
       ByteData[1]:=HexToByte(aPacketString,Index);
       ByteData[2]:=HexToByte(aPacketString,Index);
       ByteData[3]:=HexToByte(aPacketString,Index);
       ByteData[4]:=HexToByte(aPacketString,Index);
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt32(@ByteData[0])^,4) then begin
        inc(MemoryAddress,4);
       end else begin
        break;
       end;
       if fHART.StoreEx(MemoryAddress,ByteData[4],1) then begin
        inc(MemoryAddress);
       end else begin
        break;
       end;
      end;
      6:begin
       ByteData[0]:=HexToByte(aPacketString,Index);
       ByteData[1]:=HexToByte(aPacketString,Index);
       ByteData[2]:=HexToByte(aPacketString,Index);
       ByteData[3]:=HexToByte(aPacketString,Index);
       ByteData[4]:=HexToByte(aPacketString,Index);
       ByteData[5]:=HexToByte(aPacketString,Index);
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt32(@ByteData[0])^,4) then begin
        inc(MemoryAddress,4);
       end else begin
        break;
       end;
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt16(@ByteData[4])^,2) then begin
        inc(MemoryAddress,2);
       end else begin
        break;
       end;
      end;
      7:begin
       ByteData[0]:=HexToByte(aPacketString,Index);
       ByteData[1]:=HexToByte(aPacketString,Index);
       ByteData[2]:=HexToByte(aPacketString,Index);
       ByteData[3]:=HexToByte(aPacketString,Index);
       ByteData[4]:=HexToByte(aPacketString,Index);
       ByteData[5]:=HexToByte(aPacketString,Index);
       ByteData[6]:=HexToByte(aPacketString,Index);
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt32(@ByteData[0])^,4) then begin
        inc(MemoryAddress,4);
       end else begin
        break;
       end;
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt16(@ByteData[4])^,2) then begin
        inc(MemoryAddress,2);
       end else begin
        break;
       end;
       if fHART.StoreEx(MemoryAddress,ByteData[6],1) then begin
        inc(MemoryAddress);
       end else begin
        break;
       end;
      end;
      8:begin
       ByteData[0]:=HexToByte(aPacketString,Index);
       ByteData[1]:=HexToByte(aPacketString,Index);
       ByteData[2]:=HexToByte(aPacketString,Index);
       ByteData[3]:=HexToByte(aPacketString,Index);
       ByteData[4]:=HexToByte(aPacketString,Index);
       ByteData[5]:=HexToByte(aPacketString,Index);
       ByteData[6]:=HexToByte(aPacketString,Index);
       ByteData[7]:=HexToByte(aPacketString,Index);
       if fHART.StoreEx(MemoryAddress,PPASRISCVUInt64(@ByteData[0])^,8) then begin
        inc(MemoryAddress,8);
       end else begin
        break;
       end;
      end;
      else begin
       break;
      end;
     end;
     dec(Remain,ToDo);
    end;
    if Remain=0 then begin
     ReplyString('OK');
    end else begin
     ReplyString('E00');
    end;
   end else begin
    ReplyString('E00');
   end;
  end;
  else begin
   ReplyString('');
  end;
 end;
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessReadRegisters;
var s:TPasRISCVRawByteString;
    Register:TRegister;
begin
 if assigned(fHART) then begin
  s:='';
  for Register:=TRegister(0) to TRegister(31) do begin
   s:=s+LittleEndianValueToHex(fHART.fState.Registers[Register],8);
  end;
  s:=s+LittleEndianValueToHex(fHART.fState.PC,8);
  ReplyString(s);
 end else begin
  ReplyString('E.Invalid CPU');
 end;
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessWriteRegisters(const aPacketString:TPasRISCVRawByteString);
var StringPosition:TPasRISCVSizeInt;
    Register:TRegister;
begin
 if assigned(fHART) then begin
  StringPosition:=1;
  for Register:=TRegister(0) to TRegister(31) do begin
   if (StringPosition+16)<=length(aPacketString) then begin
    fHART.fState.Registers[Register]:=HexToLittleEndianValue(aPacketString,StringPosition,8);
   end else begin
    break;
   end;
  end;
  if (StringPosition+16)<=length(aPacketString) then begin
   fHART.fState.PC:=HexToLittleEndianValue(aPacketString,StringPosition,8);
  end;
 end;
 ReplyString('OK');
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessSetThread(const aPacketString:TPasRISCVRawByteString);
var ThreadID,Position,Size:TPasRISCVSizeInt;
begin
 if length(aPacketString)>=2 then begin
  Position:=2;
  if (Position<=length(aPacketString)) and (aPacketString[Position]='g') then begin
   inc(Position);
   ThreadID:=StrToUIntBase(aPacketString,Position,Size,16);
   if ThreadID<fDebugger.fMachine.fCountHARTs then begin
    fHART:=fDebugger.fMachine.fHARTs[ThreadID];
   end else begin
    fHART:=nil;
   end;
  end;
 end;
 ReplyString('OK');
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessHaltReason;
begin
 ReplyString('S05');
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessQuery(const aPacketString:TPasRISCVRawByteString);
var HARTIndex,Index:TPasRISCVSizeInt;
    QueryCommand,QueryPayload,Feature,s,CommandHex,Command:TPasRISCVRawByteString;
begin
 QueryCommand:='';
 QueryPayload:='';
 if (length(aPacketString)>=6) and (Copy(aPacketString,2,5)='Rcmd,') then begin
  CommandHex:=Copy(aPacketString,7,length(aPacketString)-6);
  if DecodeHexString(CommandHex,Command) then begin
   ProcessMonitorCommand(Command);
   ReplyString('OK');
  end else begin
   ReplyString('E00');
  end;
  exit;
 end;
 if length(aPacketString)>=2 then begin
  for Index:=2 to length(aPacketString) do begin
   if aPacketString[Index]=TPasRISCVRawByteChar(':') then begin
    QueryCommand:=Copy(aPacketString,2,Index-2);
    QueryPayload:=Copy(aPacketString,Index+1,length(aPacketString)-Index);
    break;
   end;
  end;
 end;
 if QueryCommand='Supported' then begin
  s:='PacketSize=1024';
  Index:=1;
  while Index<=length(QueryPayload) do begin
   Feature:='';
   while (Index<=length(QueryPayload)) and (QueryPayload[Index]<>';') do begin
    Feature:=Feature+QueryPayload[Index];
    inc(Index);
   end;
   if (Index<=length(QueryPayload)) and (QueryPayload[Index]=';') then begin
    inc(Index);
   end;
  {if Feature='qXfer:features:read+' then begin
    if length(s)>0 then begin
     s:=s+';';
    end;
    s:=s+'qXfer:features:read+';
   end else if Feature='multiprocess+' then begin
    if length(s)>0 then begin
     s:=s+';';
    end;
    s:=s+'multiprocess+';
   end else}if Feature='swbreak+' then begin
    if length(s)>0 then begin
     s:=s+';';
    end;
    s:=s+'swbreak+';
{  end else if Feature='vContSupported+' then begin
    if length(s)>0 then begin
     s:=s+';';
    end;
    s:=s+'vContSupported+';}
   end else if (length(Feature)>1) and (Feature[length(Feature)]='+') then begin
    if length(s)>0 then begin
     s:=s+';';
    end;
    s:=s+copy(Feature,1,length(Feature)-1)+'-';
   end;
  end;
  ReplyString(s);
 end else if QueryCommand='fThreadInfo' then begin
  s:='m';
  for HARTIndex:=0 to fDebugger.fMachine.fCountHARTs-1 do begin
   s:=s+IntToStr(HARTIndex);
   if (HARTIndex+1)<fDebugger.fMachine.fCountHARTs then begin
    s:=s+',';
   end;
  end;
  ReplyString(s);
 end else if QueryCommand='sThreadInfo' then begin
  ReplyString('l');
{end else if QueryCommand='Attached' then begin
  ReplyString('1');}
 end else begin
  ReplyString('');
 end;
end;

procedure TPasRISCV.TDebugger.TClientThread.ProcessReset;
begin
 fDebugger.Reset;
 ReplyString('OK');
end;

procedure TPasRISCV.TDebugger.TClientThread.HandlePacket(const aPacketString:TPasRISCVRawByteString);
begin
 if length(aPacketString)>0 then begin
  fDebugger.Pause;
  case TPasRISCVUInt8(aPacketString[1]) of
   TPasRISCVUInt8(TPasRISCVRawByteChar('s')):begin
    // Step
    ProcessStep;
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('c')):begin
    // Continue
    ProcessContinue;
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('m')):begin
    // Read memory
    ProcessMemory(aPacketString,false);
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('M')):begin
    // Write memory
    ProcessMemory(aPacketString,true);
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('g')):begin
    // Read registers
    ProcessReadRegisters;
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('G')):begin
    // Write registers
    ProcessWriteRegisters(aPacketString);
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('T')):begin
    // Thread status
    ReplyString('OK');
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('H')):begin
    // Set thread
    ProcessSetThread(aPacketString);
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('?')):begin
    // Halt reason
    ProcessHaltReason;
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('q')):begin
    // Query
    ProcessQuery(aPacketString);
   end;
   TPasRISCVUInt8(TPasRISCVRawByteChar('r')):begin
    // Reset
    ProcessReset;
   end;
   else begin
    ReplyString('');
   end;
  end;
 end;
end;

function TPasRISCV.TDebugger.TClientThread.ParsePacket:Boolean;
var Index:TPasRISCVSizeInt;
    PacketString:TPasRISCVRawByteString;
begin

 // Process the packet
 for Index:=0 to fRecvSize-1 do begin
  if (fRecvBuffer[Index]=TPasRISCVUInt8(AnsiChar('#'))) and ((Index+3)<=fRecvSize) then begin
   ReplyACK;
   PacketString:='';
   SetLength(PacketString,Index-1);
   Move(fRecvBuffer[1],PacketString[1],Index-1);
   try
 // writeln('> $'+PacketString+'#'+Chr(fRecvBuffer[Index+1])+Chr(fRecvBuffer[Index+2]));
    HandlePacket(PacketString);
   finally
    PacketString:='';
   end;
   ConsumeBytes(Index+3);
   result:=true;
   exit;
  end;
 end;

 if fRecvSize>=GDB_MAX_PACKET_SIZE then begin
  // Buffer overflow
  WriteLn('GDBStub Buffer overflow');
  ReplyNAK;
  ConsumeBytes(fRecvSize);
 end;

 result:=false;
end;

procedure TPasRISCV.TDebugger.TClientThread.Execute;
var Conditions:TRNLSocketWaitConditions;
    Ret:TPasRISCVSizeInt;
begin
 NameThreadForDebugging('TPasRISCV.TDebugger.TClientThread');
 while not (Terminated or fDebugger.fTerminated) do begin
  Conditions:=[TRNLSocketWaitCondition.RNL_SOCKET_WAIT_CONDITION_IO_RECEIVE,
               TRNLSocketWaitCondition.RNL_SOCKET_WAIT_CONDITION_SERVICE_INTERRUPT];
  fDebugger.fRNLNetwork.SocketWait([fSocket],Conditions,10,fDebugger.fRNLNetworkEvent);
  if Terminated or fDebugger.fTerminated then begin
   break;
  end else begin
   if TRNLSocketWaitCondition.RNL_SOCKET_WAIT_CONDITION_IO_RECEIVE in Conditions then begin
    if fRecvSize<SizeOf(TPacketBuffer) then begin
     Ret:=fDebugger.fRNLNetwork.Receive(fSocket,@fAddress,fRecvBuffer[fRecvSize],SizeOf(TPacketBuffer)-fRecvSize,RNL_IPV4);
     if Ret>0 then begin
      writeln('> ',Copy(PAnsiChar(@fRecvBuffer[fRecvSize]),0,Ret));
     end;
    end else begin
     Ret:=0;
    end;
    if Ret>=0 then begin
     inc(fRecvSize,Ret);
     while fRecvSize>0 do begin
      case fRecvBuffer[0] of
       TPasRISCVUInt8(AnsiChar('$')):begin
        // Packet
        if not ParsePacket then begin
         // Incomplete packet, wait for more data, so break the loop
         break;
        end;
       end;
       TPasRISCVUInt8(AnsiChar('+')):begin
        // ACK
//      writeln('> +');
        ConsumeBytes(1);
       end;
       TPasRISCVUInt8(AnsiChar('-')):begin
        // NAK
//      writeln('> -');
        ResendReply;
        ConsumeBytes(1);
       end;
       $03:begin
//      writeln('> 0x3');
        fDebugger.Interrupt;
        ConsumeBytes(1);
       end;
       else begin
//      writeln('GDBStub Desync');
        ReplyNAK;
        ConsumeBytes(1);
       end;
      end;
     end;
    end else begin
//   writeln('GDBStub error');
     break;
    end;
   end;
  end;
 end;
end;

{ TPasRISCV.TDebugger.TServerThread }

constructor TPasRISCV.TDebugger.TServerThread.Create(const aDebugger:TDebugger);
begin
 fDebugger:=aDebugger;
 inherited Create(false);
end;

destructor TPasRISCV.TDebugger.TServerThread.Destroy;
begin
 Shutdown;
 inherited Destroy;
end;

procedure TPasRISCV.TDebugger.TServerThread.Shutdown;
begin
 if not Finished then begin
  Terminate;
  fDebugger.fRNLNetworkEvent.SetEvent;
  WaitFor;
 end;
end;

procedure TPasRISCV.TDebugger.TServerThread.Execute;
var ClientSocket:TRNLSocket;
    ClientThread:TClientThread;
    Conditions:TRNLSocketWaitConditions;
    ClientAddress:TRNLAddress;
    Count:TPasMPInt32;
begin
 NameThreadForDebugging('TPasRISCV.TDebugger.TServerThread');
 fListenSocket:=fDebugger.fRNLNetwork.SocketCreate(TRNLSocketType.RNL_SOCKET_TYPE_STREAM,RNL_IPV4);
 if fListenSocket<>RNL_SOCKET_NULL then begin
  try
   try
    fDebugger.fRNLNetwork.SocketSetOption(fListenSocket,RNL_SOCKET_OPTION_NONBLOCK,1);
    fDebugger.fRNLNetwork.SocketSetOption(fListenSocket,RNL_SOCKET_OPTION_REUSEADDR,1);
 ///fDebugger.fRNLNetwork.SocketSetOption(fListenSocket,RNL_SOCKET_OPTION_IPV6_V6ONLY,0);
    if fDebugger.fRNLNetwork.SocketBind(fListenSocket,@fDebugger.fServerAddress,RNL_IPV4) then begin
     try
      if fDebugger.fRNLNetwork.SocketListen(fListenSocket,64) then begin
       while not Terminated do begin
        Conditions:=[TRNLSocketWaitCondition.RNL_SOCKET_WAIT_CONDITION_IO_RECEIVE,
                     TRNLSocketWaitCondition.RNL_SOCKET_WAIT_CONDITION_IO_SEND,
                     TRNLSocketWaitCondition.RNL_SOCKET_WAIT_CONDITION_SERVICE_INTERRUPT];
        // Special IFDEF case for Windows, because WSACloseEvent (in TRNLRealNetwork.EmulatePoll)
        // seems to be close the to accepting socket, so here fRNLNetworkEvent will be not used, so
        // that TRNLRealNetwork.SocketWait uses then the native select-API without this issue,
        // but with a lower timeout value as a compensation, for less time lag at the server
        // shutdown process.
        fDebugger.fRNLNetwork.SocketWait([fListenSocket],Conditions,{$ifdef Windows}10,nil{$else}100,fDebugger.fRNLNetworkEvent{$endif});
        if Terminated then begin
         break;
        end else begin
         if ([TRNLSocketWaitCondition.RNL_SOCKET_WAIT_CONDITION_IO_RECEIVE,
              TRNLSocketWaitCondition.RNL_SOCKET_WAIT_CONDITION_IO_SEND]*Conditions)<>[] then begin
          repeat
           ClientSocket:=fDebugger.fRNLNetwork.SocketAccept(fListenSocket,@ClientAddress,RNL_IPV4);
           if ClientSocket=RNL_SOCKET_NULL then begin
            break;
           end else begin
            Count:=0;
            if (fDebugger.fClientsInvertedSemaphore.Acquire(1,Count)=1) and (Count>=0) then begin
             TClientThread.Create(fDebugger,ClientSocket,ClientAddress);
            end else begin
             try
              fDebugger.fRNLNetwork.SocketShutdown(ClientSocket);
             finally
              fDebugger.fRNLNetwork.SocketDestroy(ClientSocket);
             end;
            end;
           end;
           break;
          until Terminated;
          if Terminated then begin
           break;
          end;
         end;
        end;
       end;
      end;
     finally
      fDebugger.fRNLNetwork.SocketShutdown(fListenSocket);
     end;
    end;
   finally
    fDebugger.fRNLNetwork.SocketDestroy(fListenSocket);
   end;
  finally
  end;
 end;
end;

{ TPasRISCV.TDebugger.TLocalThread }

constructor TPasRISCV.TDebugger.TLocalThread.Create(const aDebugger:TDebugger);
begin
 fDebugger:=aDebugger;
 inherited Create(false);
end;

destructor TPasRISCV.TDebugger.TLocalThread.Destroy;
begin
 Shutdown;
 inherited Destroy;
end;

procedure TPasRISCV.TDebugger.TLocalThread.Shutdown;
begin
 if not Finished then begin
  Terminate;
  WaitFor;
 end;
end;

procedure TPasRISCV.TDebugger.TLocalThread.Execute;
var ContinueLoop:Boolean;
begin
 NameThreadForDebugging('TPasRISCV.TDebugger.TLocalThread');
 ContinueLoop:=true;
 while ContinueLoop and not (Terminated or fDebugger.fTerminated) do begin
  ContinueLoop:=fDebugger.PollLocal;
  if ContinueLoop and (TDebugger.TOption.LocalInputPolling in fDebugger.fOptions) then begin
   Sleep(1);
  end;
 end;
end;

{ TPasRISCV.TDebugger }

constructor TPasRISCV.TDebugger.Create(const aMachine:TPasRISCV;const aPort:TPasRISCVUInt16;const aOptions:TOptions);
var DefaultBreakpoint:TBreakpoint;
begin
 inherited Create;
 fMachine:=aMachine;
 if ([TOption.GDBServer,TOption.LocalDebugger]*aOptions)<>[] then begin
  fOptions:=aOptions;
 end else begin
  fOptions:=[TOption.GDBServer];
 end;
 fOnInput:=nil;
 fOnOutput:=nil;
 fOnStopped:=nil;
 fOnResumed:=nil;
 fOnStepDone:=nil;
 fOnReset:=nil;
 fOnShutdown:=nil;
 fOnError:=nil;
 if TOption.LocalCLI in fOptions then begin
  fOnInput:=DefaultOnInput;
  fOnOutput:=DefaultOnOutput;
 end;
 if TOption.GDBServer in fOptions then begin
  fRNLInstance:=TRNLInstance.Create;
  fRNLNetwork:=TRNLRealNetwork.Create(fRNLInstance);
  fRNLNetworkEvent:=TRNLNetworkEvent.Create;
  fClientsInvertedSemaphore:=TPasMPInvertedSemaphore.Create(0,$7ffffffe);
  fServerAddress:=TRNLAddress.CreateFromString('0.0.0.0:'+IntToStr(aPort));
 end else begin
  fRNLInstance:=nil;
  fRNLNetwork:=nil;
  fRNLNetworkEvent:=nil;
  fClientsInvertedSemaphore:=nil;
  fServerAddress:=TRNLAddress.CreateFromString('0.0.0.0:0');
 end;
 fLock:=TPasMPCriticalSection.Create;
 fBreakpointsLock:=TPasMPCriticalSection.Create;
 fClientThreads:=nil;
 fCountClientThreads:=0;
 fServerThread:=nil;
 fLocalThread:=nil;
 fLocalCommandQueue:=TLocalCommandQueue.Create;
 fLocalHARTIndex:=0;
 fLastHaltHART:=nil;
 fLastHaltPC:=0; 
 fLastHaltCycle:=High(TPasRISCVUInt64);
 fLastHaltInstruction:=0;
 FillChar(DefaultBreakpoint,SizeOf(TBreakpoint),#0);
 fBreakpoints:=TBreakpointMap.Create(DefaultBreakpoint);
 fDisassembler:=TDisassembler.Create(fMachine);
//fSWBreakState:=SWBREAK_NONE;
 fSuppressNotifyPaused:=0;
 fTerminated:=false;
end;

destructor TPasRISCV.TDebugger.Destroy;
begin
 Stop;
 FreeAndNil(fLocalCommandQueue);
 FreeAndNil(fBreakpoints);
 FreeAndNil(fDisassembler);
 FreeAndNil(fBreakpointsLock);
 FreeAndNil(fLock);
 FreeAndNil(fRNLNetworkEvent);
 FreeAndNil(fRNLNetwork);
 FreeAndNil(fRNLInstance);
 FreeAndNil(fClientsInvertedSemaphore);
 inherited Destroy;
end;

procedure TPasRISCV.TDebugger.Output(const aString:TPasRISCVRawByteString);
begin
 if assigned(fOnOutput) then begin
  fOnOutput(aString);
 end;
end;

procedure TPasRISCV.TDebugger.OutputError(const aString:TPasRISCVRawByteString);
begin
 if assigned(fOnError) then begin
  fOnError(aString);
 end else begin
  Output(aString);
 end;
end;

function TPasRISCV.TDebugger.DefaultOnInput(var aString:TPasRISCVRawByteString):Boolean;
begin
 Write('(debugger) ');
 ReadLn(aString);
 result:=true;
{if not Eof then begin
  ReadLn(aString);
  result:=true;
 end else begin
  aString:='';
  result:=false;
 end;}
end;

procedure TPasRISCV.TDebugger.DefaultOnOutput(const aString:TPasRISCVRawByteString);
begin
 WriteLn(aString);
end;

function TPasRISCV.TDebugger.GetHARTByIndex(const aIndex:TPasRISCVUInt64):THART;
begin
 if assigned(fMachine) and (aIndex<fMachine.fCountHARTs) then begin
  result:=fMachine.fHARTs[aIndex];
 end else begin
  result:=nil;
 end;
end;

function TPasRISCV.TDebugger.GetLocalHART:THART;
begin
 result:=GetHARTByIndex(fLocalHARTIndex);
 if not assigned(result) then begin
  result:=GetHARTByIndex(0);
 end;
end;

procedure TPasRISCV.TDebugger.SetLocalHARTIndex(const aIndex:TPasRISCVUInt64);
begin
 if assigned(fMachine) and (aIndex<fMachine.fCountHARTs) then begin
  fLocalHARTIndex:=aIndex;
 end else begin
  fLocalHARTIndex:=0;
 end;
end;

class function TPasRISCV.TDebugger.HexNibble(const aDigit:TPasRISCVRawByteChar;out aValue:TPasRISCVUInt8):Boolean;
begin
 case aDigit of
  '0'..'9':begin
   aValue:=TPasRISCVUInt8(aDigit)-TPasRISCVUInt8(TPasRISCVRawByteChar('0'));
   result:=true;
  end;
  'a'..'f':begin
   aValue:=TPasRISCVUInt8(aDigit)-TPasRISCVUInt8(TPasRISCVRawByteChar('a'))+10;
   result:=true;
  end;
  'A'..'F':begin
   aValue:=TPasRISCVUInt8(aDigit)-TPasRISCVUInt8(TPasRISCVRawByteChar('A'))+10;
   result:=true;
  end;
  else begin
   aValue:=0;
   result:=false;
  end;
 end;
end;

class function TPasRISCV.TDebugger.ByteToHex(const aValue:TPasRISCVUInt8):TPasRISCVRawByteString;
const HexChars:array[0..15] of TPasRISCVRawByteChar=('0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f');
begin
 result:=HexChars[(aValue shr 4) and $f]+HexChars[aValue and $f];
end;

function TPasRISCV.TDebugger.ParseUInt64(const aToken:TPasRISCVRawByteString;out aValue:TPasRISCVUInt64):Boolean;
var Index:TPasRISCVSizeInt;
    Base:TPasRISCVUInt64;
    Digit:TPasRISCVUInt8;
    DigitValue:TPasRISCVUInt64;
begin
 result:=false;
 aValue:=0;
 Base:=10;
 Index:=1;
 if length(aToken)=0 then begin
  exit;
 end;
 if aToken[Index]=TPasRISCVRawByteChar('$') then begin
  Base:=16;
  inc(Index);
 end else if (length(aToken)>=2) and (aToken[Index]=TPasRISCVRawByteChar('0')) then begin
  case aToken[Index+1] of
   'x','X':begin
    Base:=16;
    inc(Index,2);
   end;
   'o','O':begin
    Base:=8;
    inc(Index,2);
   end;
   'b','B':begin
    Base:=2;
    inc(Index,2);
   end;
   else begin
   end;
  end;
 end;
 if Index>length(aToken) then begin
  exit;
 end;
 while Index<=length(aToken) do begin
  case aToken[Index] of
   '0'..'9':begin
    Digit:=TPasRISCVUInt8(aToken[Index])-TPasRISCVUInt8(TPasRISCVRawByteChar('0'));
   end;
   'a'..'f':begin
    Digit:=TPasRISCVUInt8(aToken[Index])-TPasRISCVUInt8(TPasRISCVRawByteChar('a'))+10;
   end;
   'A'..'F':begin
    Digit:=TPasRISCVUInt8(aToken[Index])-TPasRISCVUInt8(TPasRISCVRawByteChar('A'))+10;
   end;
   else begin
    exit;
   end;
  end;
  DigitValue:=Digit;
  if DigitValue>=Base then begin
   exit;
  end;
  aValue:=(aValue*Base)+DigitValue;
  inc(Index);
 end;
 result:=true;
end;

function TPasRISCV.TDebugger.ParseAddressToken(const aHART:THART;const aToken:TPasRISCVRawByteString;out aValue:TPasRISCVUInt64):Boolean;
var Register_:TRegister;
    TokenLower:TPasRISCVRawByteString;
begin
 result:=false;
 aValue:=0;
 if length(aToken)=0 then begin
  exit;
 end;
 if ParseUInt64(aToken,aValue) then begin
  result:=true;
  exit;
 end;
 if not assigned(aHART) then begin
  exit;
 end;
 TokenLower:=LowerCase(aToken);
 if TokenLower='pc' then begin
  aValue:=aHART.fState.PC;
  result:=true;
  exit;
 end else if TokenLower='fp' then begin
  aValue:=aHART.fState.Registers[TRegister.S0];
  result:=true;
  exit;
 end;
 for Register_:=Low(TRegister) to High(TRegister) do begin
  if (TokenLower=LowerCase(TInstructionSetArchitecture.RegisterRawNames[Register_])) or
     (TokenLower=LowerCase(TInstructionSetArchitecture.RegisterABINames[Register_])) then begin
   aValue:=aHART.fState.Registers[Register_];
   result:=true;
   exit;
  end;
 end;
end;

function TPasRISCV.TDebugger.FormatFPURegisterValue(const aValue:TFPURegisterValue):TPasRISCVRawByteString;
begin
 if (aValue.ui64 shr 32)=TPasRISCVUInt64($ffffffff) then begin
  result:='f32='+FloatToStr(aValue.f32);
 end else begin
  result:='f64='+FloatToStr(aValue.f64);
 end;
 result:=result+' (0x'+LowerCase(IntToHex(aValue.ui64,16))+')';
end;

function TPasRISCV.TDebugger.NextToken(const aLine:TPasRISCVRawByteString;var aIndex:TPasRISCVSizeInt):TPasRISCVRawByteString;
var Start:TPasRISCVSizeInt;
begin
 result:='';
 while (aIndex<=length(aLine)) and (aLine[aIndex]<=TPasRISCVRawByteChar(' ')) do begin
  inc(aIndex);
 end;
 Start:=aIndex;
 while (aIndex<=length(aLine)) and (aLine[aIndex]>TPasRISCVRawByteChar(' ')) do begin
  inc(aIndex);
 end;
 if Start<=length(aLine) then begin
  result:=Copy(aLine,Start,aIndex-Start);
 end;
end;

function TPasRISCV.TDebugger.ReadMemoryByte(const aHART:THART;const aAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt8):Boolean;
var Value:TPasRISCVUInt64;
begin
 if assigned(aHART) and aHART.LoadEx(aAddress,Value,1) then begin
  aValue:=TPasRISCVUInt8(Value and $ff);
  result:=true;
 end else begin
  aValue:=0;
  result:=false;
 end;
end;

function TPasRISCV.TDebugger.WriteMemoryByte(const aHART:THART;const aAddress:TPasRISCVUInt64;const aValue:TPasRISCVUInt8):Boolean;
begin
 if assigned(aHART) and aHART.StoreEx(aAddress,aValue,1) then begin
  result:=true;
 end else begin
  result:=false;
 end;
end;

function TPasRISCV.TDebugger.ReadInstruction(const aHART:THART;const aAddress:TPasRISCVUInt64;out aInstruction:TPasRISCVUInt32;out aSize:TPasRISCVUInt64):Boolean;
var Value:TPasRISCVUInt64;
begin
 if assigned(aHART) and aHART.LoadEx(aAddress,Value,2) then begin
  aInstruction:=TPasRISCVUInt32(Value and $ffff);
  if (aInstruction and 3)=3 then begin
   if aHART.LoadEx(aAddress,Value,4) then begin
    aInstruction:=TPasRISCVUInt32(Value and $ffffffff);
    aSize:=4;
    result:=true;
   end else begin
    aInstruction:=0;
    aSize:=0;
    result:=false;
   end;
  end else begin
   aSize:=2;
   result:=true;
  end;
 end else begin
  aInstruction:=0;
  aSize:=0;
  result:=false;
 end;
end;

procedure TPasRISCV.TDebugger.DumpRegisters(const aHART:THART);
begin
 DumpRegistersTo(aHART,Output,OutputError);
end;

procedure TPasRISCV.TDebugger.DumpRegistersTo(const aHART:THART;const aOnOutput:TOnOutput;const aOnError:TOnError);
type TStringLines=array of TPasRISCVRawByteString;
var Count:TPasRISCVSizeInt;
    Register_:TRegister;
    FPURegister:TFPURegister;
    s,r:TPasRISCVRawByteString;
    StringLines:TStringLines;
 procedure Emit(const aString:TPasRISCVRawByteString);
 begin
  if assigned(aOnOutput) then begin
   aOnOutput(aString);
  end;
 end;
 procedure EmitError(const aString:TPasRISCVRawByteString);
 begin
  if assigned(aOnError) then begin
   aOnError(aString);
  end else begin
   Emit(aString);
  end;
 end;
 procedure EmitLines(var aCount:TPasRISCVSizeInt);
 var Index,MaxLength,Rows,ColumnWidth,Columns,Row,Column,ItemIndex,PadCount,PadIndex:TPasRISCVSizeInt;
 begin
  MaxLength:=1;
  for Index:=0 to aCount-1 do begin
   MaxLength:=Max(MaxLength,Length(StringLines[Index])+3);
  end;
  ColumnWidth:=80;
  Columns:=ColumnWidth div MaxLength;
  if Columns<1 then begin
   Columns:=1;
  end else if Columns>aCount then begin
   Columns:=aCount;
  end;
  Rows:=((aCount+Columns)-1) div Columns;
  for Row:=0 to Rows-1 do begin
   s:='';
   for Column:=0 to Columns-1 do begin
    ItemIndex:=(Row*Columns)+Column;
    if ItemIndex<aCount then begin
     r:=StringLines[ItemIndex];
     if (Column<Columns-1) and (Length(r)<MaxLength) then begin
      PadCount:=MaxLength-Length(r);
      for PadIndex:=1 to PadCount do begin
       r:=r+' ';
      end;
     end;
     s:=s+r;
    end else begin
     break;
    end;
   end;
   Emit(s);
  end;
 end;
begin
 if not assigned(aHART) then begin
  EmitError('E.Invalid CPU');
  exit;
 end;
 StringLines:=nil;
 try
  Emit('HART #'+IntToStr(aHART.fHARTID)+': ');
  Emit('Registers:');
  SetLength(StringLines,Max((Ord(High(TRegister))-Ord(Low(TRegister)))+1,(Ord(High(TFPURegister))-Ord(Low(TFPURegister)))+1)+1);
  Count:=0;
  for Register_:=Low(TRegister) to High(TRegister) do begin
   r:=TInstructionSetArchitecture.RegisterABINames[Register_];
   while length(r)<5 do begin
    r:=' '+r;
   end;
   StringLines[Count]:=r+': 0x'+LowerCase(IntToHex(aHART.fState.Registers[Register_],16));
   inc(Count);
  end;
  StringLines[Count]:='   pc: 0x'+LowerCase(IntToHex(aHART.fState.PC,16));
  inc(Count);
  EmitLines(Count);
  Emit('FPU Registers:');
  Count:=0;
  for FPURegister:=Low(TFPURegister) to High(TFPURegister) do begin
   r:=TInstructionSetArchitecture.FPURegisterABINames[FPURegister];
   while length(r)<5 do begin
    r:=' '+r;
   end;
   s:=FormatFPURegisterValue(aHART.fState.FPURegisters[FPURegister]);
   StringLines[Count]:=r+': '+s;
   inc(Count);
  end;
  EmitLines(Count);
  if aHART.fState.Sleep then begin
   Emit('wfi: true');
  end else begin
   Emit('wfi: false');
  end;
 finally
  StringLines:=nil;
 end;
end;

procedure TPasRISCV.TDebugger.DumpMemory(const aHART:THART;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
begin
 DumpMemoryTo(aHART,aAddress,aSize,Output,OutputError);
end;

procedure TPasRISCV.TDebugger.DumpMemoryTo(const aHART:THART;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aOnOutput:TOnOutput;const aOnError:TOnError);
var Offset,LineBytes:TPasRISCVUInt64;
    Index:TPasRISCVSizeInt;
    ByteValue:TPasRISCVUInt8;
    LineHex,LineASCII,Line:TPasRISCVRawByteString;
    LineAddress:TPasRISCVUInt64;
 procedure Emit(const aString:TPasRISCVRawByteString);
 begin
  if assigned(aOnOutput) then begin
   aOnOutput(aString);
  end;
 end;
 procedure EmitError(const aString:TPasRISCVRawByteString);
 begin
  if assigned(aOnError) then begin
   aOnError(aString);
  end else begin
   Emit(aString);
  end;
 end;
begin
 if not assigned(aHART) then begin
  EmitError('E.Invalid CPU');
  exit;
 end;
 Offset:=0;
 while Offset<aSize do begin
  LineAddress:=aAddress+Offset;
  LineBytes:=aSize-Offset;
  if LineBytes>16 then begin
   LineBytes:=16;
  end;
  LineHex:='';
  LineASCII:='';
  for Index:=0 to LineBytes-1 do begin
   if ReadMemoryByte(aHART,LineAddress+TPasRISCVUInt64(Index),ByteValue) then begin
    LineHex:=LineHex+ByteToHex(ByteValue)+' ';
    if (ByteValue>=32) and (ByteValue<127) then begin
     LineASCII:=LineASCII+TPasRISCVRawByteChar(ByteValue);
    end else begin
     LineASCII:=LineASCII+'.';
    end;
   end else begin
    EmitError('E00');
    exit;
   end;
  end;
  for Index:=LineBytes to 15 do begin
   LineHex:=LineHex+'   ';
  end;
  Line:=LowerCase(IntToHex(LineAddress,16))+': '+LineHex+' '+LineASCII;
  Emit(Line);
  inc(Offset,LineBytes);
 end;
end;

procedure TPasRISCV.TDebugger.DumpStack(const aHART:THART;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64);
begin
 DumpStackTo(aHART,aAddress,aSize,Output,OutputError);
end;

procedure TPasRISCV.TDebugger.DumpStackTo(const aHART:THART;const aAddress:TPasRISCVUInt64;const aSize:TPasRISCVUInt64;const aOnOutput:TOnOutput;const aOnError:TOnError);
var SP,FP:TPasRISCVUInt64;
 procedure Emit(const aString:TPasRISCVRawByteString);
 begin
  if assigned(aOnOutput) then begin
   aOnOutput(aString);
  end;
 end;
 procedure EmitError(const aString:TPasRISCVRawByteString);
 begin
  if assigned(aOnError) then begin
   aOnError(aString);
  end else begin
   Emit(aString);
  end;
 end;
begin
 if not assigned(aHART) then begin
  EmitError('E.Invalid CPU');
  exit;
 end;
 SP:=aHART.fState.Registers[TRegister.SP];
 FP:=aHART.fState.Registers[TRegister.S0];
 Emit('stack @ 0x'+LowerCase(IntToHex(aAddress,16))+
      ' (sp=0x'+LowerCase(IntToHex(SP,16))+
      ' fp=0x'+LowerCase(IntToHex(FP,16))+')');
 DumpMemoryTo(aHART,aAddress,aSize,aOnOutput,aOnError);
end;

procedure TPasRISCV.TDebugger.DumpDisassembler(const aHART:THART;const aAddress:TPasRISCVUInt64;const aCount:TPasRISCVUInt64);
begin
 DumpDisassemblerTo(aHART,aAddress,aCount,Output,OutputError);
end;

procedure TPasRISCV.TDebugger.DumpDisassemblerTo(const aHART:THART;const aAddress:TPasRISCVUInt64;const aCount:TPasRISCVUInt64;const aOnOutput:TOnOutput;const aOnError:TOnError);
var Index:TPasRISCVUInt64;
    Address:TPasRISCVUInt64;
    Instruction:TPasRISCVUInt32;
    Size:TPasRISCVUInt64;
    HexValue:TPasRISCVRawByteString;
    Line:TPasRISCVRawByteString;
 procedure Emit(const aString:TPasRISCVRawByteString);
 begin
  if assigned(aOnOutput) then begin
   aOnOutput(aString);
  end;
 end;
 procedure EmitError(const aString:TPasRISCVRawByteString);
 begin
  if assigned(aOnError) then begin
   aOnError(aString);
  end else begin
   Emit(aString);
  end;
 end;
begin
 if not assigned(aHART) then begin
  EmitError('E.Invalid CPU');
  exit;
 end;
 Address:=aAddress;
 for Index:=0 to aCount-1 do begin
  if ReadInstruction(aHART,Address,Instruction,Size) then begin
   if Size=2 then begin
    HexValue:='    '+LowerCase(IntToHex(Instruction and $ffff,4));
   end else begin
    HexValue:=LowerCase(IntToHex(Instruction,8));
   end;
   Line:=LowerCase(IntToHex(Address,16))+': '+HexValue+' '+TPasRISCVRawByteString(fDisassembler.DisassembleInstruction(Address,Instruction));
   Emit(Line);
   inc(Address,Size);
  end else begin
   EmitError('E00');
   exit;
  end;
 end;
end;

procedure TPasRISCV.TDebugger.DumpBacktrace(const aHART:THART;const aMaxDepth:TPasRISCVUInt64);
begin
 DumpBacktraceTo(aHART,aMaxDepth,Output,OutputError);
end;

procedure TPasRISCV.TDebugger.DumpBacktraceTo(const aHART:THART;const aMaxDepth:TPasRISCVUInt64;const aOnOutput:TOnOutput;const aOnError:TOnError);
var Depth:TPasRISCVUInt64;
    FP,NextFP,RA:TPasRISCVUInt64;
    Line:TPasRISCVRawByteString;
 procedure Emit(const aString:TPasRISCVRawByteString);
 begin
  if assigned(aOnOutput) then begin
   aOnOutput(aString);
  end;
 end;
 procedure EmitError(const aString:TPasRISCVRawByteString);
 begin
  if assigned(aOnError) then begin
   aOnError(aString);
  end else begin
   Emit(aString);
  end;
 end;
 function ReadUInt64(const aAddress:TPasRISCVUInt64;out aValue:TPasRISCVUInt64):Boolean;
 begin
  if assigned(aHART) then begin
   result:=aHART.LoadEx(aAddress,aValue,8);
  end else begin
   aValue:=0;
   result:=false;
  end;
 end;
begin
 if not assigned(aHART) then begin
  EmitError('E.Invalid CPU');
  exit;
 end;
 FP:=aHART.fState.Registers[TRegister.S0];
 if FP=0 then begin
  Emit('bt: no frame pointer');
  exit;
 end;
 Emit('bt: fp=0x'+LowerCase(IntToHex(FP,16))+' pc=0x'+LowerCase(IntToHex(aHART.fState.PC,16)));
 Depth:=0;
 while Depth<aMaxDepth do begin
  // Best-effort frame chain: [fp]=prev_fp, [fp+8]=ra.
  if not ReadUInt64(FP,NextFP) then begin
   EmitError('bt: failed to read fp @ 0x'+LowerCase(IntToHex(FP,16)));
   exit;
  end;
  if not ReadUInt64(FP+8,RA) then begin
   EmitError('bt: failed to read ra @ 0x'+LowerCase(IntToHex(FP+8,16)));
   exit;
  end;
  Line:='#'+IntToStr(Depth)+' fp=0x'+LowerCase(IntToHex(FP,16))+' ra=0x'+LowerCase(IntToHex(RA,16));
  Emit(Line);
  if (NextFP=0) or (NextFP<=FP) then begin
   break;
  end;
  FP:=NextFP;
  inc(Depth);
 end;
end;

procedure TPasRISCV.TDebugger.ListBreakpoints;
var Entity:TBreakpointMap.TEntity;
    Count:TPasRISCVSizeInt;
begin
 Count:=0;
 fBreakpointsLock.Acquire;
 try
  for Entity in fBreakpoints.Entities do begin
   if Entity.State=TBreakpointMap.TEntity.Used then begin
    inc(Count);
    if Entity.Value.Enabled then begin
     Output('b '+LowerCase(IntToHex(Entity.Value.Address,16)));
    end else begin
     Output('b '+LowerCase(IntToHex(Entity.Value.Address,16))+' (disabled)');
    end;
   end;
  end;
 finally
  fBreakpointsLock.Release;
 end;
 if Count=0 then begin
  Output('no breakpoints');
 end;
end;

function TPasRISCV.TDebugger.AddBreakpoint(const aHART:THART;const aAddress:TPasRISCVUInt64):Boolean;
var Breakpoint:TBreakpoint;
    Instruction:TPasRISCVUInt32;
    Size:TPasRISCVUInt64;
    Index:TPasRISCVSizeInt;
begin
 result:=false;
 if not assigned(aHART) then begin
  OutputError('E.Invalid CPU');
  exit;
 end;
 fBreakpointsLock.Acquire;
 try
  if fBreakpoints.TryGet(aAddress,Breakpoint) then begin
   if Breakpoint.Enabled then begin
    Output('breakpoint already exists');
    result:=true;
   end else begin
    if EnableBreakpoint(aHART,aAddress) then begin
     Output('breakpoint enabled');
     result:=true;
    end else begin
     OutputError('E00');
    end;
   end;
   exit;
  end;
 finally
  fBreakpointsLock.Release;
 end;
 if ReadInstruction(aHART,aAddress,Instruction,Size) then begin
  FillChar(Breakpoint,SizeOf(TBreakpoint),#0);
  Breakpoint.Address:=aAddress;
  Breakpoint.Size:=Size;
  for Index:=0 to TPasRISCVSizeInt(Size)-1 do begin
   if ReadMemoryByte(aHART,aAddress+TPasRISCVUInt64(Index),Breakpoint.Original[Index]) then begin
   end else begin
    OutputError('E00');
    exit;
   end;
  end;
  Breakpoint.Enabled:=false;
  fBreakpointsLock.Acquire;
  try
   fBreakpoints.Add(aAddress,Breakpoint);
  finally
   fBreakpointsLock.Release;
  end;
  if EnableBreakpoint(aHART,aAddress) then begin
   Output('breakpoint set');
   result:=true;
  end else begin
   OutputError('E00');
  end;
 end else begin
  OutputError('E00');
 end;
end;

function TPasRISCV.TDebugger.RemoveBreakpoint(const aHART:THART;const aAddress:TPasRISCVUInt64):Boolean;
begin
 result:=false;
 if not assigned(aHART) then begin
  OutputError('E.Invalid CPU');
  exit;
 end;
 if DisableBreakpoint(aHART,aAddress) then begin
  fBreakpointsLock.Acquire;
  try
   if fBreakpoints.Delete(aAddress) then begin
    Output('breakpoint removed');
    result:=true;
   end else begin
    OutputError('E00');
   end;
  finally
   fBreakpointsLock.Release;
  end;
 end else begin
  OutputError('E00');
 end;
end;

procedure TPasRISCV.TDebugger.ClearBreakpoints;
var Entity:TBreakpointMap.TEntity;
    HART:THART;
    Index:TPasRISCVSizeInt;
begin
 HART:=GetLocalHART;
 fBreakpointsLock.Acquire;
 try
  for Entity in fBreakpoints.Entities do begin
   if Entity.State=TBreakpointMap.TEntity.Used then begin
    if Entity.Value.Enabled then begin
     for Index:=0 to TPasRISCVSizeInt(Entity.Value.Size)-1 do begin
      if not WriteMemoryByte(HART,Entity.Value.Address+TPasRISCVUInt64(Index),Entity.Value.Original[Index]) then begin
       OutputError('E00');
       exit;
      end;
     end;
    end;
   end;
  end;
  fBreakpoints.Clear;
 finally
  fBreakpointsLock.Release;
 end;
 Output('breakpoints cleared');
end;

function TPasRISCV.TDebugger.EnableBreakpoint(const aHART:THART;const aAddress:TPasRISCVUInt64):Boolean;
var Breakpoint:TBreakpoint;
    Value:TPasRISCVUInt64;
begin
 result:=false;
 if not assigned(aHART) then begin
  exit;
 end;
 fBreakpointsLock.Acquire;
 try
  if fBreakpoints.TryGet(aAddress,Breakpoint) then begin
   if Breakpoint.Enabled then begin
    result:=true;
   end else begin
    if Breakpoint.Size=2 then begin
     Value:=TPasRISCVUInt64($9002);
    end else begin
     Value:=TPasRISCVUInt64($00100073);
    end;
    if aHART.StoreEx(aAddress,Value,Breakpoint.Size) then begin
     Breakpoint.Enabled:=true;
     fBreakpoints.EntityValues[aAddress]:=Breakpoint;
     result:=true;
    end;
   end;
  end;
 finally
  fBreakpointsLock.Release;
 end;
end;

function TPasRISCV.TDebugger.DisableBreakpoint(const aHART:THART;const aAddress:TPasRISCVUInt64):Boolean;
var Breakpoint:TBreakpoint;
    Index:TPasRISCVSizeInt;
begin
 result:=false;
 if not assigned(aHART) then begin
  exit;
 end;
 fBreakpointsLock.Acquire;
 try
  if fBreakpoints.TryGet(aAddress,Breakpoint) then begin
   if not Breakpoint.Enabled then begin
    result:=true;
   end else begin
    for Index:=0 to TPasRISCVSizeInt(Breakpoint.Size)-1 do begin
     if not WriteMemoryByte(aHART,aAddress+TPasRISCVUInt64(Index),Breakpoint.Original[Index]) then begin
      exit;
     end;
    end;
    Breakpoint.Enabled:=false;
    fBreakpoints.EntityValues[aAddress]:=Breakpoint;
    result:=true;
   end;
  end;
 finally
  fBreakpointsLock.Release;
 end;
end;

function TPasRISCV.TDebugger.StepOverBreakpointsIfNeeded(const aSuppressNotify:Boolean):Boolean;
var HART:THART;
    Breakpoint:TBreakpoint;
    PC:TPasRISCVUInt64;
    HasBreakpoint:Boolean;
begin
 result:=false;
 HART:=GetLocalHART;
 if not assigned(HART) then begin
  exit;
 end;
 PC:=HART.fState.PC;
 HasBreakpoint:=false;
 fBreakpointsLock.Acquire;
 try
  if fBreakpoints.TryGet(PC,Breakpoint) then begin
   HasBreakpoint:=Breakpoint.Enabled;
  end;
 finally
  fBreakpointsLock.Release;
 end;
 if HasBreakpoint then begin
  if DisableBreakpoint(HART,PC) then begin
   if aSuppressNotify then begin
    TPasMPInterlocked.Increment(fSuppressNotifyPaused);
   end;
   try
    fMachine.SingleStep(true);
   finally
    if aSuppressNotify then begin
     TPasMPInterlocked.Decrement(fSuppressNotifyPaused);
    end;
   end;
   EnableBreakpoint(HART,PC);
   result:=true;
  end;
 end;
end;

function TPasRISCV.TDebugger.ProcessCommand(const aLine:TPasRISCVRawByteString;const aOnOutput:TOnOutput;const aOnError:TOnError):Boolean;
var Index:TPasRISCVSizeInt;
    Command,Token,Token2:TPasRISCVRawByteString;
    Address,Size,Count:TPasRISCVUInt64;
    HART:THART;
    Register_:TRegister;
    FPURegister:TFPURegister;
    TokenLower:TPasRISCVRawByteString;
    Found:Boolean;
    HexString:TPasRISCVRawByteString;
    HexIndex:TPasRISCVSizeInt;
    ByteHigh,ByteLow:TPasRISCVUInt8;
 procedure Emit(const aString:TPasRISCVRawByteString);
 begin
  if assigned(aOnOutput) then begin
   aOnOutput(aString);
  end;
 end;
 procedure EmitError(const aString:TPasRISCVRawByteString);
 begin
  if assigned(aOnError) then begin
   aOnError(aString);
  end else begin
   Emit(aString);
  end;
 end;
begin
 result:=true;
 Index:=1;
 Command:=LowerCase(NextToken(aLine,Index));
 if length(Command)=0 then begin
  exit;
 end;
 if (Command='quit') or (Command='q') then begin
  result:=false;
  exit;
 end else if (Command='help') or (Command='?') then begin
  Emit('commands: regs (r), print, mem (m), memw (mw), stack (st), backtrace (bt), step (s), stepi (si), cont (c), pause (p), hart (h), disasm (d), break (b), reboot, shutdown, quit (q)');
  exit;
 end;
 if (Command='cont') or (Command='c') then begin
  Continue_;
  exit;
 end else if (Command='pause') or (Command='p') then begin
  Interrupt;
  exit;
 end;
 Pause;
 HART:=GetLocalHART;
 if (Command='regs') or (Command='r') then begin
  DumpRegistersTo(HART,aOnOutput,aOnError);
 end else if Command='print' then begin
  if not assigned(HART) then begin
   EmitError('E.Invalid CPU');
   exit;
  end;
  Token:=NextToken(aLine,Index);
  if length(Token)=0 then begin
   EmitError('E.Missing register');
   exit;
  end;
  while length(Token)>0 do begin
   TokenLower:=LowerCase(Token);
   Found:=false;
   if TokenLower='pc' then begin
    Emit('pc: 0x'+LowerCase(IntToHex(HART.fState.PC,16)));
    Found:=true;
   end else if TokenLower='fp' then begin
    Emit('fp: 0x'+LowerCase(IntToHex(HART.fState.Registers[TRegister.S0],16)));
    Found:=true;
   end else begin
    for Register_:=Low(TRegister) to High(TRegister) do begin
     if (TokenLower=LowerCase(TInstructionSetArchitecture.RegisterRawNames[Register_])) or
        (TokenLower=LowerCase(TInstructionSetArchitecture.RegisterABINames[Register_])) then begin
      Emit(TInstructionSetArchitecture.RegisterABINames[Register_]+': 0x'+LowerCase(IntToHex(HART.fState.Registers[Register_],16)));
      Found:=true;
      break;
     end;
    end;
   end;
   if not Found then begin
    for FPURegister:=Low(TFPURegister) to High(TFPURegister) do begin
     if (TokenLower=LowerCase(TInstructionSetArchitecture.FPURegisterRawNames[FPURegister])) or
        (TokenLower=LowerCase(TInstructionSetArchitecture.FPURegisterABINames[FPURegister])) then begin
      Emit(TInstructionSetArchitecture.FPURegisterABINames[FPURegister]+': '+FormatFPURegisterValue(HART.fState.FPURegisters[FPURegister]));
      Found:=true;
      break;
     end;
    end;
   end;
   if not Found then begin
    EmitError('E.Invalid register');
    exit;
   end;
   Token:=NextToken(aLine,Index);
  end;
 end else if (Command='mem') or (Command='m') then begin
  Token:=NextToken(aLine,Index);
  if ParseAddressToken(HART,Token,Address) then begin
   Token:=NextToken(aLine,Index);
   if ParseUInt64(Token,Size) then begin
    DumpMemoryTo(HART,Address,Size,aOnOutput,aOnError);
   end else begin
    EmitError('E.Invalid size');
   end;
  end else begin
   EmitError('E.Invalid address');
  end;
 end else if (Command='memw') or (Command='mw') then begin
  Token:=NextToken(aLine,Index);
  if ParseAddressToken(HART,Token,Address) then begin
   HexString:=NextToken(aLine,Index);
   if (length(HexString)>=2) and (HexString[1]='0') and ((HexString[2]='x') or (HexString[2]='X')) then begin
    HexString:=Copy(HexString,3,length(HexString)-2);
   end;
   if (length(HexString)>0) and ((length(HexString) and 1)=0) then begin
    HexIndex:=1;
    while HexIndex<length(HexString) do begin
     if HexNibble(HexString[HexIndex],ByteHigh) and HexNibble(HexString[HexIndex+1],ByteLow) then begin
      if WriteMemoryByte(HART,Address,TPasRISCVUInt8((ByteHigh shl 4) or ByteLow)) then begin
       inc(Address);
       inc(HexIndex,2);
      end else begin
       EmitError('E00');
       exit;
      end;
     end else begin
      EmitError('E.Invalid hex');
      exit;
     end;
    end;
    Emit('ok');
   end else begin
    EmitError('E.Invalid hex');
   end;
  end else begin
   EmitError('E.Invalid address');
  end;
 end else if (Command='stack') or (Command='st') then begin
  if not assigned(HART) then begin
   EmitError('E.Invalid CPU');
   exit;
  end;
  Address:=HART.fState.Registers[TRegister.SP];
  Size:=128;
  Token:=NextToken(aLine,Index);
  if length(Token)>0 then begin
   Token2:=NextToken(aLine,Index);
   if length(Token2)>0 then begin
    if ParseAddressToken(HART,Token,Address) then begin
     if ParseUInt64(Token2,Size) then begin
      DumpStackTo(HART,Address,Size,aOnOutput,aOnError);
     end else begin
      EmitError('E.Invalid size');
     end;
    end else begin
     EmitError('E.Invalid address');
    end;
   end else begin
    if ParseUInt64(Token,Size) then begin
     DumpStackTo(HART,Address,Size,aOnOutput,aOnError);
    end else if ParseAddressToken(HART,Token,Address) then begin
     DumpStackTo(HART,Address,Size,aOnOutput,aOnError);
    end else begin
     EmitError('E.Invalid argument');
    end;
   end;
  end else begin
   DumpStackTo(HART,Address,Size,aOnOutput,aOnError);
  end;
 end else if (Command='backtrace') or (Command='bt') then begin
  if not assigned(HART) then begin
   EmitError('E.Invalid CPU');
   exit;
  end;
  Count:=16;
  Token:=NextToken(aLine,Index);
  if length(Token)>0 then begin
   if ParseUInt64(Token,Count) then begin
    DumpBacktraceTo(HART,Count,aOnOutput,aOnError);
   end else begin
    EmitError('E.Invalid depth');
   end;
  end else begin
   DumpBacktraceTo(HART,Count,aOnOutput,aOnError);
  end;
 end else if (Command='step') or (Command='s') or (Command='stepi') or (Command='si') then begin
  SingleStep(true);
 end else if (Command='disasm') or (Command='d') then begin
  Token:=NextToken(aLine,Index);
  if length(Token)>0 then begin
   if ParseAddressToken(HART,Token,Address) then begin
    Token:=NextToken(aLine,Index);
    if ParseUInt64(Token,Count) then begin
     DumpDisassemblerTo(HART,Address,Count,aOnOutput,aOnError);
    end else begin
     DumpDisassemblerTo(HART,Address,16,aOnOutput,aOnError);
    end;
   end else begin
    EmitError('E.Invalid address');
   end;
  end else begin
   if assigned(HART) then begin
    DumpDisassemblerTo(HART,HART.fState.PC,16,aOnOutput,aOnError);
   end else begin
    EmitError('E.Invalid CPU');
   end;
  end;
 end else if (Command='hart') or (Command='h') then begin
  Token:=NextToken(aLine,Index);
  if length(Token)=0 then begin
   if assigned(HART) then begin
    Emit('hart '+IntToStr(HART.fHARTID)+'');
   end else begin
    Emit('hart '+IntToStr(fLocalHARTIndex));
   end;
  end else if ParseUInt64(Token,Address) then begin
   if assigned(fMachine) and (Address<fMachine.fCountHARTs) then begin
    SetLocalHARTIndex(Address);
    HART:=GetLocalHART;
    if assigned(HART) then begin
     Emit('hart '+IntToStr(HART.fHARTID)+'');
    end else begin
     Emit('hart '+IntToStr(fLocalHARTIndex));
    end;
   end else begin
    EmitError('E.Invalid HART');
   end;
  end else begin
   EmitError('E.Invalid HART');
  end;
 end else if (Command='break') or (Command='b') then begin
  Token:=NextToken(aLine,Index);
  Token:=LowerCase(Token);
  if length(Token)=0 then begin
   ListBreakpoints;
  end else if Token='list' then begin
   ListBreakpoints;
  end else if Token='clear' then begin
   ClearBreakpoints;
  end else if Token='-' then begin
   Token:=NextToken(aLine,Index);
   if ParseUInt64(Token,Address) then begin
    RemoveBreakpoint(HART,Address);
   end else begin
    EmitError('E.Invalid address');
   end;
  end else begin
   if ParseUInt64(Token,Address) then begin
    AddBreakpoint(HART,Address);
   end else begin
    EmitError('E.Invalid address');
   end;
  end;
 end else if Command='reboot' then begin
  Reset;
 end else if Command='shutdown' then begin
  if assigned(fMachine) then begin
   fMachine.PowerOff;
   if assigned(fOnShutdown) then begin
    fOnShutdown;
   end;
  end;
  result:=false;
 end else begin
  EmitError('E.Unknown command');
 end;
end;

function TPasRISCV.TDebugger.ProcessLocalCommand(const aLine:TPasRISCVRawByteString):Boolean;
begin
 result:=ProcessCommand(aLine,Output,OutputError);
end;

procedure TPasRISCV.TDebugger.Interrupt;
var ClientIndex:TPasRISCVSizeInt;
    ClientThread:TClientThread;
    HART:THART;
begin
 fMachine.Pause(true);
 fLock.Acquire;
 try
  for ClientIndex:=0 to fCountClientThreads-1 do begin
   ClientThread:=fClientThreads[ClientIndex];
   if assigned(ClientThread) then begin
    ClientThread.ProcessHaltReason;
   end;
  end;
 finally
  fLock.Release;
 end;
 if (TOption.LocalDebugger in fOptions) and assigned(fOnStopped) then begin
  HART:=GetLocalHART;
  if assigned(HART) then begin
   fOnStopped('interrupt',HART.fHARTID,HART.fState.PC);
  end;
 end;
end;

procedure TPasRISCV.TDebugger.NotifyPaused;
var ClientIndex:TPasRISCVSizeInt;
    ClientThread:TClientThread;
    HART:THART;
    Reason:TPasRISCVRawByteString;
    Breakpoint:TBreakpoint;
begin
 if TPasMPInterlocked.Read(fSuppressNotifyPaused)<>0 then begin
  exit;
 end;
 fLock.Acquire;
 try
{if TPasMPInterlocked.CompareExchange(fSWBreakState,SWBREAK_ACTIVE,SWBREAK_TRIGGERED)=SWBREAK_TRIGGERED then begin
  end;}
  for ClientIndex:=0 to fCountClientThreads-1 do begin
   ClientThread:=fClientThreads[ClientIndex];
   if assigned(ClientThread) then begin
    ClientThread.ProcessHaltReason;
   end;
  end;
 finally
  fLock.Release;
 end;
 if (TOption.LocalDebugger in fOptions) and assigned(fOnStopped) then begin
  HART:=GetLocalHART;
  if assigned(HART) then begin
   Reason:='paused';
   fBreakpointsLock.Acquire;
   try
    if fBreakpoints.TryGet(HART.fState.PC,Breakpoint) and Breakpoint.Enabled then begin
     Reason:='breakpoint';
    end;
   finally
    fBreakpointsLock.Release;
   end;
   fOnStopped(Reason,HART.fHARTID,HART.fState.PC);
  end;
 end;
end;

function TPasRISCV.TDebugger.Halt(const aHART:THART;const aPC:TPasRISCVUInt64;const aInstruction:TPasRISCVUInt32):Boolean;
var OK:Boolean;
    Breakpoint:TBreakpoint;
begin

{$ifdef PasRISCVStepDebugOutput}
 WriteLn('DBG Debugger.Halt enter at PC 0x'+LowerCase(IntToHex(aPC,16)));
{$endif}

 fLock.Acquire;
 try
  if (fCountClientThreads>0) or (TOption.LocalDebugger in fOptions) then begin
   OK:=true;
   if TOption.LocalDebugger in fOptions then begin
    fBreakpointsLock.Acquire;
    try
     if not (fBreakpoints.TryGet(aPC,Breakpoint) and Breakpoint.Enabled) then begin
      OK:=false;
     end;
    finally
     fBreakpointsLock.Release;
    end;
   end;
   if (not OK) or (assigned(aHART) and (fLastHaltHART=aHART) and (fLastHaltPC=aPC) and (fLastHaltCycle<=(aHART.fState.Cycle))) then begin
    fLastHaltHART:=nil;
    fLastHaltPC:=0;
    fLastHaltCycle:=High(TPasRISCVUInt64);
    fLastHaltInstruction:=0;
    result:=false;
   end else begin
    fLastHaltHART:=aHART;
    fLastHaltPC:=aPC;
    fLastHaltCycle:=aHART.fState.Cycle;
    fLastHaltInstruction:=aInstruction;
    result:=fMachine.QueuePause(false);//TPasMPInterlocked.CompareExchange(fSWBreakState,SWBREAK_TRIGGERED,SWBREAK_NONE)=SWBREAK_NONE;
   end;
  end else begin
   fLastHaltHART:=aHART;
   fLastHaltPC:=aPC;
   fLastHaltCycle:=aHART.fState.Cycle;
   fLastHaltInstruction:=aInstruction;
   result:=false;
  end;
 finally
  fLock.Release;
 end;

{$ifdef PasRISCVStepDebugOutput}
 WriteLn('DBG Debugger.Halt exit result='+IntToStr(Ord(result)));
{$endif}

end;

procedure TPasRISCV.TDebugger.Pause;
begin
 fMachine.Pause(true);
{if TPasMPInterlocked.CompareExchange(fSWBreakState,SWBREAK_PAUSED,SWBREAK_ACTIVE)=SWBREAK_ACTIVE then begin
 end;}
end;

procedure TPasRISCV.TDebugger.SingleStep(const aWaitUntilDone:Boolean=false);
var DidStep:Boolean;
begin
//fSWBreakState:=SWBREAK_NONE;
 DidStep:=StepOverBreakpointsIfNeeded(false);
 if not DidStep then begin
  fMachine.SingleStep(aWaitUntilDone);
 end;
 if aWaitUntilDone and (TOption.LocalDebugger in fOptions) and assigned(fOnStepDone) then begin
  fOnStepDone;
 end;
end;

procedure TPasRISCV.TDebugger.Continue_;
{var DidStep:Boolean;
    HART:THART;
    HaltPC,HaltCycle,InstructionSize:TPasRISCVUInt64;
    HaltInstruction:TPasRISCVUInt32;}
begin
//fSWBreakState:=SWBREAK_NONE;
 StepOverBreakpointsIfNeeded(true);
{DidStep:=StepOverBreakpointsIfNeeded(true);
 if not DidStep then begin
  fLock.Acquire;
  try
   HART:=fLastHaltHART;
   HaltPC:=fLastHaltPC;
   HaltCycle:=fLastHaltCycle;
   HaltInstruction:=fLastHaltInstruction;
   fLastHaltHART:=nil;
   fLastHaltPC:=0;
   fLastHaltCycle:=High(TPasRISCVUInt64);
   fLastHaltInstruction:=0;
  finally
   fLock.Release;
  end;
  if assigned(HART) and (HART.fState.PC=HaltPC) and (HaltCycle<=(HART.fState.Cycle+1)) then begin
   if (HaltInstruction=TPasRISCVUInt32($00100073)) or (HaltInstruction=TPasRISCVUInt32($9002)) then begin
    InstructionSize:=HART.GetInstructionSize(HaltInstruction);
    if InstructionSize>0 then begin
     HART.fState.PC:=HART.fState.PC+InstructionSize;
    end;
   end;
  end;
 end;}
 fMachine.Resume(true);
 if (TOption.LocalDebugger in fOptions) and assigned(fOnResumed) then begin
  fOnResumed;
 end;
end;

procedure TPasRISCV.TDebugger.Reset;
begin
 fMachine.Resume(false);
 TPasMPInterlocked.BitwiseOr(fMachine.fRunState,TPasMPUInt32(RUNSTATE_REBOOT));
 fMachine.Interrupt;
 fMachine.WakeUp;
 if (TOption.LocalDebugger in fOptions) and assigned(fOnReset) then begin
  fOnReset;
 end;
end;

procedure TPasRISCV.TDebugger.Start;
begin
 if TOption.LocalCLI in fOptions then begin
  if not assigned(fOnInput) then begin
   fOnInput:=DefaultOnInput;
  end;
  if not assigned(fOnOutput) then begin
   fOnOutput:=DefaultOnOutput;
  end;
 end;
 if (TOption.GDBServer in fOptions) and not assigned(fServerThread) then begin
  fServerThread:=TServerThread.Create(self);
 end;
 if (TOption.LocalCLI in fOptions) and (TOption.LocalThreaded in fOptions) and not assigned(fLocalThread) then begin
  fLocalThread:=TLocalThread.Create(self);
 end;
end;

procedure TPasRISCV.TDebugger.Stop;
var //ClientIndex:TPasRISCVSizeInt;
    ClientThread:TClientThread;
begin

 if assigned(fServerThread) or assigned(fLocalThread) then begin

  fTerminated:=true;

  if assigned(fLocalThread) then begin
   try
    fLocalThread.Shutdown;
   finally
    FreeAndNil(fLocalThread);
   end;
  end;

  if assigned(fServerThread) then begin

   // Shutdown server thread first, so that no new clients can connect anymore while we are shutting down
   try
    fServerThread.Shutdown;
   finally
    FreeAndNil(fServerThread);
   end;

   // Shutdown all client threads, after the server thread has been shut down
   fLock.Acquire;
   try

    while fCountClientThreads>0 do begin

     dec(fCountClientThreads);

     ClientThread:=fClientThreads[fCountClientThreads];
     if assigned(ClientThread) then begin

      // Unlock the client thread list lock before shutting down the client thread, so that the client thread can remove itself from the list
      fLock.Release;
      try
       try
        ClientThread.Shutdown;
       finally
        FreeAndNil(ClientThread);
       end;
      finally
       fLock.Acquire;
      end;

     end;
    end;

   finally
    fLock.Release;
   end;

  end;

 end;

end;

function TPasRISCV.TDebugger.PollLocal:Boolean;
var Line:TPasRISCVRawByteString;
begin
 if not (TOption.LocalCLI in fOptions) then begin
  result:=false;
  exit;
 end;
 if fTerminated then begin
  result:=false;
  exit;
 end;
 if assigned(fLocalCommandQueue) and fLocalCommandQueue.TryDequeue(Line) then begin
  result:=ProcessLocalCommand(Line);
  exit;
 end;
 if assigned(fOnInput) then begin
  if fOnInput(Line) then begin
   result:=ProcessLocalCommand(Line);
  end else begin
   if TOption.LocalInputPolling in fOptions then begin
    result:=true;
   end else begin
    result:=false;
   end;
  end;
 end else begin
  if TOption.LocalInputPolling in fOptions then begin
   result:=true;
  end else begin
   result:=false;
  end;
 end;
end;

procedure TPasRISCV.TDebugger.EnqueueLocalCommand(const aCommand:TPasRISCVRawByteString);
begin
 if assigned(fLocalCommandQueue) then begin
  fLocalCommandQueue.Enqueue(aCommand);
 end;
end;

{ TPasRISCV.TConfiguration }

constructor TPasRISCV.TConfiguration.Create;
begin
 inherited Create;

 fDebugger:=false;
 fDebuggerLocal:=false;
 fDebuggerPort:=1234;

 fCountHARTs:=1;

 fBootArguments:='root=/dev/mem rw earlyprintk console=$LINUXUART$ console=tty0 earlycon=sbi';

 fBootMemoryBase:=TPasRISCVUInt64($00000000);
 fBootMemorySize:=TPasRISCVUInt64(65536);

 fMemoryBase:=TPasRISCVUInt64($80000000);
 fMemorySize:=TPasRISCVUInt64(256) shl 20;

 fCLINTBase:=TPasRISCV.TACLINTDevice.DefaultBaseAddress;
 fCLINTSize:=TPasRISCV.TACLINTDevice.DefaultSize;

 fIMSICMachineBase:=TPasRISCV.TIMSICDevice.DefaultBaseAddressMachine;
 fIMSICMachineSizePerHART:=TPasRISCV.TIMSICDevice.DefaultSizePerHART;

 fIMSICSupervisorBase:=TPasRISCV.TIMSICDevice.DefaultBaseAddressSupervisor;
 fIMSICSupervisorSizePerHART:=TPasRISCV.TIMSICDevice.DefaultSizePerHART;

 fAPLICMachineBase:=TPasRISCV.TAPLICDevice.DefaultDomainBaseAddressMachine;
 fAPLICMachineSize:=TPasRISCV.TAPLICDevice.DefaultDomainSize;

 fAPLICSupervisorBase:=TPasRISCV.TAPLICDevice.DefaultDomainBaseAddressSupervisor;
 fAPLICSupervisorSize:=TPasRISCV.TAPLICDevice.DefaultDomainSize;

 fPLICBase:=TPasRISCV.TPLICDevice.DefaultBaseAddress;
 fPLICSize:=TPasRISCV.TPLICDevice.DefaultSize;

 fSYSCONBase:=TPasRISCV.TSYSCONDevice.DefaultBaseAddress;
 fSYSCONSize:=TPasRISCV.TSYSCONDevice.DefaultSize;

 fUARTBase:=TPasRISCV.TUARTDevice.DefaultBaseAddress;
 fUARTSize:=TPasRISCV.TUARTDevice.DefaultSize;
 fUARTIRQ:=TPasRISCV.TUARTDevice.DefaultIRQ;

 fVirtIOBlockBase:=TPasRISCV.TVirtIOBlockDevice.DefaultBaseAddress;
 fVirtIOBlockSize:=TPasRISCV.TVirtIOBlockDevice.DefaultSize;
 fVirtIOBlockIRQ:=TPasRISCV.TVirtIOBlockDevice.DefaultIRQ;

 fDS1742Base:=TPasRISCV.TDS1742Device.DefaultBaseAddress;
 fDS1742Size:=TPasRISCV.TDS1742Device.DefaultSize;

 fGoldfishRTCBase:=TPasRISCV.TGoldfishRTCDevice.DefaultBaseAddress;
 fGoldfishRTCSize:=TPasRISCV.TGoldfishRTCDevice.DefaultSize;
 fGoldfishRTCIRQ:=TPasRISCV.TGoldfishRTCDevice.DefaultIRQ;

 fRTCMode:=TRTCMode.Goldfish;

 fFrameBufferBase:=TPasRISCVUInt64($28000000)-TSimpleFBDevice.FrameBufferAddress;
 fFrameBufferWidth:=640;
 fFrameBufferHeight:=400;
 fFrameBufferBytesPerPixel:=4;
 fFrameBufferStride:=fFrameBufferWidth*fFrameBufferBytesPerPixel;
 fFrameBufferSize:=fFrameBufferWidth*fFrameBufferHeight*fFrameBufferBytesPerPixel;
 fFrameBufferFormat:=0;

 fSharedMemoryBase:=TPasRISCV.TSharedMemoryDevice.DefaultBaseAddress;
 fSharedMemorySize:=TPasRISCV.TSharedMemoryDevice.DefaultSize;
 fSharedMemoryIRQ:=TPasRISCV.TSharedMemoryDevice.DefaultIRQ;

 fRawKeyboardBase:=TPasRISCV.TRawKeyboardDevice.DefaultBaseAddress;
 fRawKeyboardSize:=TPasRISCV.TRawKeyboardDevice.DefaultSize;

 fI2CMode:=TI2CMode.DesignWare;

 fOpenCoresI2CBase:=TPasRISCV.TI2CDevice.DefaultBaseAddress;
 fOpenCoresI2CSize:=TPasRISCV.TOpenCoresI2CDevice.DefaultSize;

 fDesignWareI2CBase:=TPasRISCV.TI2CDevice.DefaultBaseAddress;
 fDesignWareI2CSize:=TPasRISCV.TDesignWareI2CDevice.DefaultSize;

 fPS2KeyboardBase:=TPasRISCV.TPS2KeyboardDevice.DefaultBaseAddress;
 fPS2KeyboardSize:=TPasRISCV.TPS2KeyboardDevice.DefaultSize;
 fPS2KeyboardIRQ:=TPasRISCV.TPS2KeyboardDevice.DefaultIRQ;

 fPS2MouseBase:=TPasRISCV.TPS2MouseDevice.DefaultBaseAddress;
 fPS2MouseSize:=TPasRISCV.TPS2MouseDevice.DefaultSize;
 fPS2MouseIRQ:=TPasRISCV.TPS2MouseDevice.DefaultIRQ;

 fVirtIOInputKeyboardBase:=TPasRISCV.TVirtIOInputKeyboardDevice.DefaultBaseAddress;
 fVirtIOInputKeyboardSize:=TPasRISCV.TVirtIOInputKeyboardDevice.DefaultSize;
 fVirtIOInputKeyboardIRQ:=TPasRISCV.TVirtIOInputKeyboardDevice.DefaultIRQ;

 fVirtIOInputMouseBase:=TPasRISCV.TVirtIOInputMouseDevice.DefaultBaseAddress;
 fVirtIOInputMouseSize:=TPasRISCV.TVirtIOInputMouseDevice.DefaultSize;
 fVirtIOInputMouseIRQ:=TPasRISCV.TVirtIOInputMouseDevice.DefaultIRQ;

 fVirtIOSoundBase:=TPasRISCV.TVirtIOSoundDevice.DefaultBaseAddress;
 fVirtIOSoundSize:=TPasRISCV.TVirtIOSoundDevice.DefaultSize;
 fVirtIOSoundIRQ:=TPasRISCV.TVirtIOSoundDevice.DefaultIRQ;

 fVirtIO9PBase:=TPasRISCV.TVirtIO9PDevice.DefaultBaseAddress;
 fVirtIO9PSize:=TPasRISCV.TVirtIO9PDevice.DefaultSize;
 fVirtIO9PIRQ:=TPasRISCV.TVirtIO9PDevice.DefaultIRQ;

 fVirtIONetBase:=TPasRISCV.TVirtIONetDevice.DefaultBaseAddress;
 fVirtIONetSize:=TPasRISCV.TVirtIONetDevice.DefaultSize;
 fVirtIONetIRQ:=TPasRISCV.TVirtIONetDevice.DefaultIRQ;

 fVirtIORandomGeneratorBase:=TPasRISCV.TVirtIORandomGeneratorDevice.DefaultBaseAddress;
 fVirtIORandomGeneratorSize:=TPasRISCV.TVirtIORandomGeneratorDevice.DefaultSize;
 fVirtIORandomGeneratorIRQ:=TPasRISCV.TVirtIORandomGeneratorDevice.DefaultIRQ;

 fVirtIOGPUBase:=TPasRISCV.TVirtIOGPUDevice.DefaultBaseAddress;
 fVirtIOGPUSize:=TPasRISCV.TVirtIOGPUDevice.DefaultSize;
 fVirtIOGPUIRQ:=TPasRISCV.TVirtIOGPUDevice.DefaultIRQ;

 fVirtIOVSockBase:=TPasRISCV.TVirtIOVSockDevice.DefaultBaseAddress;
 fVirtIOVSockSize:=TPasRISCV.TVirtIOVSockDevice.DefaultSize;
 fVirtIOVSockIRQ:=TPasRISCV.TVirtIOVSockDevice.DefaultIRQ;
 fVirtIOVSockGuestCID:=TPasRISCV.TVirtIOVSockDevice.DefaultGuestCID;

 fVirtIORTCBase:=TPasRISCV.TVirtIORTCDevice.DefaultBaseAddress;
 fVirtIORTCSize:=TPasRISCV.TVirtIORTCDevice.DefaultSize;
 fVirtIORTCIRQ:=TPasRISCV.TVirtIORTCDevice.DefaultIRQ;

 fBIOS:=TMemoryStream.Create;

 fKernel:=TMemoryStream.Create;

 fINITRD:=TMemoryStream.Create;

 fIVSHMEMSharedMemorySize:=TPasRISCV.TIVSHMEMDevice.IVSHMEM_DEFAULT_SHM_SIZE;

 fAIA:=false;

 fVirtIOBlockEnabled:=false;

 fVirtIOBlockMQ:=false;

 fNVMeEnabled:=false;

 fDisplayMode:=TDisplayMode.SimpleFB;

 fSoundMode:=TSoundMode.VirtIO;

 fLRSCMaximumCycles:=1000; // Default maximum LR/SC loop cycles, based on public knowledge about common real RISC-V SoC implementations

end;

destructor TPasRISCV.TConfiguration.Destroy;
begin
 FreeAndNil(fINITRD);
 FreeAndNil(fKernel);
 FreeAndNil(fBIOS);
 inherited Destroy;
end;

procedure TPasRISCV.TConfiguration.Assign(const aConfiguration:TConfiguration);
begin

 fDebugger:=aConfiguration.fDebugger;
 fDebuggerLocal:=aConfiguration.fDebuggerLocal;
 fDebuggerPort:=aConfiguration.fDebuggerPort;

 fCountHARTs:=aConfiguration.fCountHARTs;

 fBootArguments:=aConfiguration.fBootArguments;

 fBootMemoryBase:=aConfiguration.fBootMemoryBase;
 fBootMemorySize:=aConfiguration.fBootMemorySize;

 fMemoryBase:=aConfiguration.fMemoryBase;
 fMemorySize:=aConfiguration.fMemorySize;

 fCLINTBase:=aConfiguration.fCLINTBase;
 fCLINTSize:=aConfiguration.fCLINTSize;

 fIMSICMachineBase:=aConfiguration.fIMSICMachineBase;
 fIMSICMachineSizePerHART:=aConfiguration.fIMSICMachineSizePerHART;

 fIMSICSupervisorBase:=aConfiguration.fIMSICSupervisorBase;
 fIMSICSupervisorSizePerHART:=aConfiguration.fIMSICSupervisorSizePerHART;

 fAPLICMachineBase:=aConfiguration.fAPLICMachineBase;
 fAPLICMachineSize:=aConfiguration.fAPLICMachineSize;

 fAPLICSupervisorBase:=aConfiguration.fAPLICSupervisorBase;
 fAPLICSupervisorSize:=aConfiguration.fAPLICSupervisorSize;

 fPLICBase:=aConfiguration.fPLICBase;
 fPLICSize:=aConfiguration.fPLICSize;

 fSYSCONBase:=aConfiguration.fSYSCONBase;
 fSYSCONSize:=aConfiguration.fSYSCONSize;

 fUARTBase:=aConfiguration.fUARTBase;
 fUARTSize:=aConfiguration.fUARTSize;
 fUARTIRQ:=aConfiguration.fUARTIRQ;

 fVirtIOBlockBase:=aConfiguration.fVirtIOBlockBase;
 fVirtIOBlockSize:=aConfiguration.fVirtIOBlockSize;
 fVirtIOBlockIRQ:=aConfiguration.fVirtIOBlockIRQ;

 fDS1742Base:=aConfiguration.fDS1742Base;
 fDS1742Size:=aConfiguration.fDS1742Size;

 fGoldfishRTCBase:=aConfiguration.fGoldfishRTCBase;
 fGoldfishRTCSize:=aConfiguration.fGoldfishRTCSize;
 fGoldfishRTCIRQ:=aConfiguration.fGoldfishRTCIRQ;

 fRTCMode:=aConfiguration.fRTCMode;

 fFrameBufferBase:=aConfiguration.fFrameBufferBase;
 fFrameBufferWidth:=aConfiguration.fFrameBufferWidth;
 fFrameBufferHeight:=aConfiguration.fFrameBufferHeight;
 fFrameBufferBytesPerPixel:=aConfiguration.fFrameBufferBytesPerPixel;
 fFrameBufferStride:=aConfiguration.fFrameBufferStride;
 fFrameBufferSize:=aConfiguration.fFrameBufferSize;
 fFrameBufferFormat:=aConfiguration.fFrameBufferFormat;

 fSharedMemoryBase:=aConfiguration.fSharedMemoryBase;
 fSharedMemorySize:=aConfiguration.fSharedMemorySize;
 fSharedMemoryIRQ:=aConfiguration.fSharedMemoryIRQ;

 fRawKeyboardBase:=aConfiguration.fRawKeyboardBase;
 fRawKeyboardSize:=aConfiguration.fRawKeyboardSize;

 fI2CMode:=aConfiguration.fI2CMode;

 fOpenCoresI2CBase:=aConfiguration.fOpenCoresI2CBase;
 fOpenCoresI2CSize:=aConfiguration.fOpenCoresI2CSize;

 fDesignWareI2CBase:=aConfiguration.fDesignWareI2CBase;
 fDesignWareI2CSize:=aConfiguration.fDesignWareI2CSize;

 fPS2KeyboardBase:=aConfiguration.fPS2KeyboardBase;
 fPS2KeyboardSize:=aConfiguration.fPS2KeyboardSize;
 fPS2KeyboardIRQ:=aConfiguration.fPS2KeyboardIRQ;

 fPS2MouseBase:=aConfiguration.fPS2MouseBase;
 fPS2MouseSize:=aConfiguration.fPS2MouseSize;
 fPS2MouseIRQ:=aConfiguration.fPS2MouseIRQ;

 fVirtIOInputKeyboardBase:=aConfiguration.fVirtIOInputKeyboardBase;
 fVirtIOInputKeyboardSize:=aConfiguration.fVirtIOInputKeyboardSize;
 fVirtIOInputKeyboardIRQ:=aConfiguration.fVirtIOInputKeyboardIRQ;

 fVirtIOInputMouseBase:=aConfiguration.fVirtIOInputMouseBase;
 fVirtIOInputMouseSize:=aConfiguration.fVirtIOInputMouseSize;
 fVirtIOInputMouseIRQ:=aConfiguration.fVirtIOInputMouseIRQ;

 fVirtIOSoundBase:=aConfiguration.fVirtIOSoundBase;
 fVirtIOSoundSize:=aConfiguration.fVirtIOSoundSize;
 fVirtIOSoundIRQ:=aConfiguration.fVirtIOSoundIRQ;

 fVirtIO9PBase:=aConfiguration.fVirtIO9PBase;
 fVirtIO9PSize:=aConfiguration.fVirtIO9PSize;
 fVirtIO9PIRQ:=aConfiguration.fVirtIO9PIRQ;

 fVirtIONetBase:=aConfiguration.fVirtIONetBase;
 fVirtIONetSize:=aConfiguration.fVirtIONetSize;
 fVirtIONetIRQ:=aConfiguration.fVirtIONetIRQ;

 fVirtIORandomGeneratorBase:=aConfiguration.fVirtIORandomGeneratorBase;
 fVirtIORandomGeneratorSize:=aConfiguration.fVirtIORandomGeneratorSize;
 fVirtIORandomGeneratorIRQ:=aConfiguration.fVirtIORandomGeneratorIRQ;

 fVirtIOGPUBase:=aConfiguration.fVirtIOGPUBase;
 fVirtIOGPUSize:=aConfiguration.fVirtIOGPUSize;
 fVirtIOGPUIRQ:=aConfiguration.fVirtIOGPUIRQ;

 fVirtIOVSockBase:=aConfiguration.fVirtIOVSockBase;
 fVirtIOVSockSize:=aConfiguration.fVirtIOVSockSize;
 fVirtIOVSockIRQ:=aConfiguration.fVirtIOVSockIRQ;
 fVirtIOVSockGuestCID:=aConfiguration.fVirtIOVSockGuestCID;

 fVirtIORTCBase:=aConfiguration.fVirtIORTCBase;
 fVirtIORTCSize:=aConfiguration.fVirtIORTCSize;
 fVirtIORTCIRQ:=aConfiguration.fVirtIORTCIRQ;

 fIVSHMEMSharedMemorySize:=aConfiguration.fIVSHMEMSharedMemorySize;

 fAIA:=aConfiguration.fAIA;

 fVirtIOBlockEnabled:=aConfiguration.fVirtIOBlockEnabled;

 fVirtIOBlockMQ:=aConfiguration.fVirtIOBlockMQ;

 fNVMeEnabled:=aConfiguration.fNVMeEnabled;

 fLRSCMaximumCycles:=aConfiguration.fLRSCMaximumCycles;

 fBIOS.Clear;
 if aConfiguration.fBIOS.Size>0 then begin
  aConfiguration.fBIOS.Seek(0,soBeginning);
  fBIOS.CopyFrom(aConfiguration.fBIOS,aConfiguration.fBIOS.Size);
 end;

 fKernel.Clear;
 if aConfiguration.fKernel.Size>0 then begin
  aConfiguration.fKernel.Seek(0,soBeginning);
  fKernel.CopyFrom(aConfiguration.fKernel,aConfiguration.fKernel.Size);
 end;

 fINITRD.Clear;
 if aConfiguration.fINITRD.Size>0 then begin
  aConfiguration.fINITRD.Seek(0,soBeginning);
  fINITRD.CopyFrom(aConfiguration.fINITRD,aConfiguration.fINITRD.Size);
 end;

 fDisplayMode:=aConfiguration.fDisplayMode;

 fSoundMode:=aConfiguration.fSoundMode;

end;

procedure TPasRISCV.TConfiguration.LoadBIOSFromFile(const aFileName:TPasRISCVUTF8String);
begin
 fBIOS.Clear;
 fBIOS.LoadFromFile(aFileName);
end;

procedure TPasRISCV.TConfiguration.LoadBIOSFromStream(const aStream:TStream);
begin
 fBIOS.Clear;
 if aStream.Size>0 then begin
  aStream.Seek(0,soBeginning);
  fBIOS.CopyFrom(aStream,aStream.Size);
 end;
end;

procedure TPasRISCV.TConfiguration.LoadBIOSFromMemory(const aMemory:pointer;const aSize:TPasRISCVSizeInt);
begin
 fBIOS.Clear;
 if aSize>0 then begin
  fBIOS.WriteBuffer(aMemory^,aSize);
 end;
end;

procedure TPasRISCV.TConfiguration.LoadKernelFromFile(const aFileName:TPasRISCVUTF8String);
begin
 fKernel.Clear;
 fKernel.LoadFromFile(aFileName);
end;

procedure TPasRISCV.TConfiguration.LoadKernelFromStream(const aStream:TStream);
begin
 fKernel.Clear;
 if aStream.Size>0 then begin
  aStream.Seek(0,soBeginning);
  fKernel.CopyFrom(aStream,aStream.Size);
 end;
end;

procedure TPasRISCV.TConfiguration.LoadKernelFromMemory(const aMemory:pointer;const aSize:TPasRISCVSizeInt);
begin
 fKernel.Clear;
 if aSize>0 then begin
  fKernel.WriteBuffer(aMemory^,aSize);
 end;
end;

procedure TPasRISCV.TConfiguration.LoadINITRDFromFile(const aFileName:TPasRISCVUTF8String);
begin
 fINITRD.Clear;
 fINITRD.LoadFromFile(aFileName);
end;

procedure TPasRISCV.TConfiguration.LoadINITRDFromStream(const aStream:TStream);
begin
 fINITRD.Clear;
 if aStream.Size>0 then begin
  aStream.Seek(0,soBeginning);
  fINITRD.CopyFrom(aStream,aStream.Size);
 end;
end;

procedure TPasRISCV.TConfiguration.LoadINITRDFromMemory(const aMemory:pointer;const aSize:TPasRISCVSizeInt);
begin
 fINITRD.Clear;
 if aSize>0 then begin
  fINITRD.WriteBuffer(aMemory^,aSize);
 end;
end;

{ TPasRISCV }

constructor TPasRISCV.Create(const aConfiguration:TConfiguration);
var Index:TPasRISCVSizeInt;
    HART:THART;
    DebuggerOptions:TPasRISCV.TDebugger.TOptions;
begin
 inherited Create;

 fRandomGeneratorLock:=TPasMPSlimReaderWriterLock.Create;

 fRandomGenerator:=TRNLRandomGenerator.Create;

 fPCG32Lock:=TPasMPSlimReaderWriterLock.Create;

 fPCG32.Init(GetCurrentTime xor fRandomGenerator.GetUInt64);

 fPHandleCounter:=0;

 fInterrupts:=TInterrupts.Create(self);

 fFDT:=TFDT.Create;

 fFDTStream:=TMemoryStream.Create;

 fConfiguration:=TConfiguration.Create;
 if assigned(aConfiguration) then begin
  fConfiguration.Assign(aConfiguration);
 end;

 fCountHARTs:=fConfiguration.fCountHARTs;
 if fCountHARTs<1 then begin
  fCountHARTs:=1;
 end else if fCountHARTs>16 then begin
  fCountHARTs:=16;
 end;

 InitializeFDT;

 fRunState:=RUNSTATE_RUNNING;

{$ifdef PasRISCVSingleStepCounter}
 fSingleStepCounter:=0;
{$endif}

 fFlushTLBHARTMask:=0;

 fHARTActiveMask:=0;

 fHARTRunningMask:=0;

 fAllHARTMask:=0;

 fLRSCMaximumCycles:=fConfiguration.fLRSCMaximumCycles;

 fHARTWakeUpConditionVariableLock:=TPasMPConditionVariableLock.Create;
 fHARTWakeUpConditionVariable:=TPasMPConditionVariable.Create;

 fHARTStatusChangeConditionVariableLock:=TPasMPConditionVariableLock.Create;
 fHARTStatusChangeConditionVariable:=TPasMPConditionVariable.Create;

 fOnReboot:=nil;

 fOnNewFrame:=nil;

 fOnCPUException:=nil;

 fWakeUpConditionVariableLock:=TPasMPConditionVariableLock.Create;

 fWakeUpConditionVariable:=TPasMPConditionVariable.Create;

 fAtomicCriticalSection:=TCriticalSection.Create;

 fJobManager:=TJobManager.Create(4);

 fBootMemoryDevice:=TMemoryDevice.Create(self,fConfiguration.fBootMemoryBase,fConfiguration.fBootMemorySize);

 fMemoryDevice:=TMemoryDevice.Create(self,fConfiguration.fMemoryBase,fConfiguration.fMemorySize);

 fACLINTDevice:=TACLINTDevice.Create(self);

 if fConfiguration.fAIA then begin

  fIMSICMachineDevice:=TIMSICDevice.Create(self,fConfiguration.fIMSICMachineBase,fConfiguration.fIMSICMachineSizePerHART*fConfiguration.CountHARTs,TPasRISCV.TAIARegFileMode.Machine);

  fIMSICSupervisorDevice:=TIMSICDevice.Create(self,fConfiguration.fIMSICSupervisorBase,fConfiguration.fIMSICSupervisorSizePerHART*fConfiguration.CountHARTs,TPasRISCV.TAIARegFileMode.Supervisor);

  fAPLICDevice:=TAPLICDevice.Create(self);

  fPLICDevice:=nil;

  fINTCDevice:=fAPLICDevice;

 end else begin

  fIMSICMachineDevice:=nil;

  fIMSICSupervisorDevice:=nil;

  fPLICDevice:=TPLICDevice.Create(self);

  fINTCDevice:=fPLICDevice;

 end;

 fSYSCONDevice:=TSYSCONDevice.Create(self);

 if fConfiguration.fVirtIOBlockEnabled then begin
  fVirtIOBlockDevice:=TVirtIOBlockDevice.Create(self);
 end else begin
  fVirtIOBlockDevice:=nil;
 end;

 fUARTDevice:=TUARTDevice.Create(self);

 case fConfiguration.fRTCMode of
  TRTCMode.DS1742:begin
   fDS1742Device:=TDS1742Device.Create(self);
   fGoldfishRTCDevice:=nil;
   fDS1307Device:=nil;
  end;
  TRTCMode.Goldfish:begin
   fDS1742Device:=nil;
   fGoldfishRTCDevice:=TGoldfishRTCDevice.Create(self);
   fDS1307Device:=nil;
  end;
  TRTCMode.DS1307:begin
   fDS1742Device:=nil;
   fGoldfishRTCDevice:=nil;
   // DS1307 is an I2C device — created later when I2C bus is set up
   fDS1307Device:=nil;
  end;
  else begin
   fDS1742Device:=TDS1742Device.Create(self);
   fGoldfishRTCDevice:=nil;
   fDS1307Device:=nil;
  end;
 end;
 
 fSoundIO:=TSoundIO.Create(self);

 fPCIBusDevice:=TPCIBusDevice.Create(self);

 if TPCI.PCI_IO_DEFAULT_SIZE<>0 then begin
  fPCIIODevice:=TPCIIODevice.Create(self,TPCI.PCI_IO_DEFAULT_ADDR,TPCI.PCI_IO_DEFAULT_SIZE);
 end else begin
  fPCIIODevice:=nil;
 end;

 fFrameBufferDevice:=TFrameBufferDevice.Create(self);

 case fConfiguration.fDisplayMode of
  TDisplayMode.SimpleFB:begin
   fSimpleFBDevice:=TSimpleFBDevice.Create(self);
  end;
  else begin
   fSimpleFBDevice:=nil;
  end;
 end;

 fSharedMemoryDevice:=TSharedMemoryDevice.Create(self);

 fRawKeyboardDevice:=TRawKeyboardDevice.Create(self);

 if fConfiguration.fRTCMode=TRTCMode.DS1307 then begin
  case fConfiguration.fI2CMode of
   TI2CMode.OpenCores:begin
    fI2CDevice:=TOpenCoresI2CDevice.Create(self);
   end;
   else begin
    fI2CDevice:=TDesignWareI2CDevice.Create(self);
   end;
  end;
  fDS1307Device:=TDS1307I2CBusDevice.Create(fI2CDevice);
  fI2CDevice.AttachBusDevice(fDS1307Device);
 end else begin
  fI2CDevice:=nil;
 end;

{fI2CDevice:=TI2CDevice.Create(self);

 fI2CHIDKeyboardBusDevice:=TI2CHIDKeyboardBusDevice.Create(fI2CDevice);
 fI2CDevice.AttachBusDevice(fI2CHIDKeyboardBusDevice);//\}

 fPS2KeyboardDevice:=TPS2KeyboardDevice.Create(self);

 fPS2MouseDevice:=TPS2MouseDevice.Create(self);

 case fConfiguration.fSoundMode of
  TSoundMode.VirtIO:begin
   fVirtIOSoundDevice:=TVirtIOSoundDevice.Create(self,fSoundIO);
   fFM801Device:=nil;
  end;
  TSoundMode.FM801:begin
   fVirtIOSoundDevice:=nil;
   // FM801 is created later after fPCIBusDevice
   fFM801Device:=nil;
  end;
 end;

 fVirtIOInputKeyboardDevice:=TVirtIOInputKeyboardDevice.Create(self);

 fVirtIOInputMouseDevice:=TVirtIOInputMouseDevice.Create(self);

 fVirtIO9PDevice:=TVirtIO9PDevice.Create(self);

 fVirtIONetDevice:=TVirtIONetDevice.Create(self);

 fVirtIORandomGeneratorDevice:=TVirtIORandomGeneratorDevice.Create(self);

 case fConfiguration.fDisplayMode of
  TDisplayMode.VirtIOGPU:begin
   fVirtIOGPUDevice:=TVirtIOGPUDevice.Create(self);
  end;
  else begin
   fVirtIOGPUDevice:=nil;
  end;
 end;

 fVirtIOVSockDevice:=TVirtIOVSockDevice.Create(self);

 if fConfiguration.fRTCMode=TRTCMode.VirtIO then begin
  fVirtIORTCDevice:=TVirtIORTCDevice.Create(self);
 end else begin
  fVirtIORTCDevice:=nil;
 end;

 fBus:=TBus.Create(self);
 fBus.AddBusDevice(fBootMemoryDevice);
 fBus.AddBusDevice(fMemoryDevice);
 fBus.AddBusDevice(fACLINTDevice);
 if assigned(fIMSICMachineDevice) then begin
  fBus.AddBusDevice(fIMSICMachineDevice);
 end;
 if assigned(fIMSICSupervisorDevice) then begin
  fBus.AddBusDevice(fIMSICSupervisorDevice);
 end;
 if assigned(fAPLICDevice) then begin
  fBus.AddBusDevice(fAPLICDevice);
 end;
 if assigned(fPLICDevice) then begin
  fBus.AddBusDevice(fPLICDevice);
 end;
 fBus.AddBusDevice(fSYSCONDevice);
 if assigned(fVirtIOBlockDevice) then begin
  fBus.AddBusDevice(fVirtIOBlockDevice);
 end;
 fBus.AddBusDevice(fUARTDevice);
 if assigned(fDS1742Device) then begin
  fBus.AddBusDevice(fDS1742Device);
 end;
 if assigned(fGoldfishRTCDevice) then begin
  fBus.AddBusDevice(fGoldfishRTCDevice);
 end;
//fBus.AddBusDevice(fDS1742Device);
 fBus.AddBusDevice(fPCIBusDevice);
 if assigned(fPCIIODevice) then begin
  fBus.AddBusDevice(fPCIIODevice);
 end;
 if assigned(fSimpleFBDevice) then begin
  fBus.AddBusDevice(fSimpleFBDevice);
 end;
 fBus.AddBusDevice(fSharedMemoryDevice);
 fBus.AddBusDevice(fRawKeyboardDevice);
 if assigned(fI2CDevice) then begin
  fBus.AddBusDevice(fI2CDevice);
 end;
//fBus.AddBusDevice(fI2CDevice);
 fBus.AddBusDevice(fPS2KeyboardDevice);
 fBus.AddBusDevice(fPS2MouseDevice);
 fBus.AddBusDevice(fVirtIOInputKeyboardDevice);
 fBus.AddBusDevice(fVirtIOInputMouseDevice);
 if assigned(fVirtIOSoundDevice) then begin
  fBus.AddBusDevice(fVirtIOSoundDevice);
 end;
 fBus.AddBusDevice(fVirtIO9PDevice);
 fBus.AddBusDevice(fVirtIONetDevice);
 fBus.AddBusDevice(fVirtIORandomGeneratorDevice);
 if assigned(fVirtIOGPUDevice) then begin
  fBus.AddBusDevice(fVirtIOGPUDevice);
 end;
 fBus.AddBusDevice(fVirtIOVSockDevice);

 if assigned(fVirtIORTCDevice) then begin
  fBus.AddBusDevice(fVirtIORTCDevice);
 end;

 if fConfiguration.fNVMeEnabled then begin
  fNVMeDevice:=TNVMeDevice.Create(fPCIBusDevice);
  fPCIBusDevice.AddBusDevice(fNVMeDevice);
 end else begin
  fNVMeDevice:=nil;
 end;

 fIVSHMEMDevice:=TIVSHMEMDevice.Create(fPCIBusDevice,fConfiguration.fIVSHMEMSharedMemorySize);
 fPCIBusDevice.AddBusDevice(fIVSHMEMDevice);

 case fConfiguration.fDisplayMode of
  TDisplayMode.BochsVBE:begin
   fBochsVBEDevice:=TBochsVBEDevice.Create(fPCIBusDevice,fFrameBufferDevice);
   fPCIBusDevice.AddBusDevice(fBochsVBEDevice);
  end;
  else begin
   fBochsVBEDevice:=nil;
  end;
 end;

 case fConfiguration.fDisplayMode of
  TDisplayMode.Cirrus:begin
   fCirrusDevice:=TCirrusDevice.Create(fPCIBusDevice,fFrameBufferDevice);
   fPCIBusDevice.AddBusDevice(fCirrusDevice);
  end;
  else begin
   fCirrusDevice:=nil;
  end;
 end;

 if fConfiguration.fSoundMode=TSoundMode.FM801 then begin
  fFM801Device:=TFM801Device.Create(fPCIBusDevice,fSoundIO);
  fPCIBusDevice.AddBusDevice(fFM801Device);
 end;

 fHARTs:=nil;
 SetLength(fHARTs,fCountHARTs);
 for Index:=0 to length(fHARTs)-1 do begin
  HART:=THART.Create(self,Index);
  try
  finally
   fHARTs[Index]:=HART;
  end;
 end;

 fHART:=fHARTs[0];

 if fConfiguration.fDebugger then begin

  DebuggerOptions:=[];
  if fConfiguration.fDebuggerLocal then begin
   DebuggerOptions:=DebuggerOptions+[TPasRISCV.TDebugger.TOption.LocalDebugger,
                                     TPasRISCV.TDebugger.TOption.LocalCLI, 
                                     TPasRISCV.TDebugger.TOption.LocalThreaded,
                                     TPasRISCV.TDebugger.TOption.LocalInputPolling];
  end;
  if fConfiguration.fDebuggerPort>0 then begin
   Include(DebuggerOptions,TPasRISCV.TDebugger.TOption.GDBServer);
  end;

  fDebugger:=TDebugger.Create(self,fConfiguration.fDebuggerPort,DebuggerOptions);
 
  fDebugger.Start;

 end else begin

  fDebugger:=nil;

 end;

end;

destructor TPasRISCV.Destroy;
var Index:TPasRISCVSizeInt;
//  HART:THART;
begin

 if assigned(fDebugger) then begin
  try
   fDebugger.Stop;
  finally
   FreeAndNil(fDebugger);
  end;
 end;

 ShutdownCPUs;

 fJobManager.Shutdown;

 for Index:=0 to length(fHARTs)-1 do begin
  FreeAndNil(fHARTs[Index]);
 end;

 fHARTs:=nil;
 fHART:=nil;

 if assigned(fBochsVBEDevice) then begin
  fPCIBusDevice.RemoveBusDevice(fBochsVBEDevice);
  FreeAndNil(fBochsVBEDevice);
 end;

 if assigned(fCirrusDevice) then begin
  fPCIBusDevice.RemoveBusDevice(fCirrusDevice);
  FreeAndNil(fCirrusDevice);
 end;

 if assigned(fFM801Device) then begin
  fPCIBusDevice.RemoveBusDevice(fFM801Device);
  FreeAndNil(fFM801Device);
 end;

 fPCIBusDevice.RemoveBusDevice(fIVSHMEMDevice);
 FreeAndNil(fIVSHMEMDevice);

 fPCIBusDevice.RemoveBusDevice(fNVMeDevice);

 FreeAndNil(fNVMeDevice);

 FreeAndNil(fMemoryDevice);

 FreeAndNil(fSYSCONDevice);

 FreeAndNil(fPLICDevice);

 FreeAndNil(fIMSICSupervisorDevice);

 FreeAndNil(fIMSICMachineDevice);

 FreeAndNil(fACLINTDevice);

 FreeAndNil(fVirtIOBlockDevice);

 FreeAndNil(fUARTDevice);

 FreeAndNil(fDS1742Device);

 FreeAndNil(fGoldfishRTCDevice);

 FreeAndNil(fDS1307Device);

 FreeAndNil(fPCIIODevice);

 FreeAndNil(fPCIBusDevice);

 FreeAndNil(fSimpleFBDevice);

 FreeAndNil(fFrameBufferDevice);

 FreeAndNil(fSharedMemoryDevice);

 FreeAndNil(fRawKeyboardDevice);

 FreeAndNil(fI2CHIDKeyboardBusDevice);
 FreeAndNil(fI2CDevice);

 FreeAndNil(fPS2KeyboardDevice);
 FreeAndNil(fPS2MouseDevice);

 FreeAndNil(fVirtIOInputKeyboardDevice);
 FreeAndNil(fVirtIOInputMouseDevice);
 FreeAndNil(fVirtIOSoundDevice);
 FreeAndNil(fVirtIO9PDevice);
 FreeAndNil(fVirtIONetDevice);
 FreeAndNil(fVirtIORandomGeneratorDevice);
 FreeAndNil(fVirtIOGPUDevice);
 FreeAndNil(fVirtIOVSockDevice);
 FreeAndNil(fVirtIORTCDevice);

 FreeAndNil(fBus);

 FreeAndNil(fSoundIO);

 FreeAndNil(fAtomicCriticalSection);

 FreeAndNil(fInterrupts);

 FreeAndNil(fJobManager);

 FreeAndNil(fConfiguration);

 FreeAndNil(fFDTStream);
 FreeAndNil(fFDT);

 FreeAndNil(fPCG32Lock);

 FreeAndNil(fRandomGenerator);

 FreeAndNil(fRandomGeneratorLock);

 FreeAndNil(fHARTWakeUpConditionVariable);
 FreeAndNil(fHARTWakeUpConditionVariableLock);

 FreeAndNil(fHARTStatusChangeConditionVariable);
 FreeAndNil(fHARTStatusChangeConditionVariableLock);

 FreeAndNil(fWakeUpConditionVariable);
 FreeAndNil(fWakeUpConditionVariableLock);

 inherited Destroy;

end;

procedure TPasRISCV.ShutdownCPUs;
var Index:TPasRISCVSizeInt;
    HART:THART;
begin

 for Index:=0 to length(fHARTs)-1 do begin
  HART:=fHARTs[Index];
  if not HART.fExecutionThread.Finished then begin
   HART.fExecutionThread.Terminate;
  end;
 end;

 fHARTWakeUpConditionVariableLock.Acquire;
 try
  TPasMPInterlocked.BitwiseOr(TPasMPUInt32(fRunState),RUNSTATE_POWEROFF);
  TPasMPInterlocked.BitwiseAnd(TPasMPUInt32(fRunState),not TPasMPUInt32(RUNSTATE_RUNNING));
  fHARTWakeUpConditionVariable.Broadcast;
 finally
  fHARTWakeUpConditionVariableLock.Release;
 end;

 fHARTStatusChangeConditionVariableLock.Acquire;
 try
  while TPasMPInterlocked.Read(fHARTRunningMask)<>0 do begin
   fHARTStatusChangeConditionVariable.Wait(fHARTStatusChangeConditionVariableLock);
  end;
 finally
  fHARTStatusChangeConditionVariableLock.Release;
 end;

 for Index:=0 to length(fHARTs)-1 do begin
  HART:=fHARTs[Index];
  if not HART.fExecutionThread.Finished then begin
   HART.fExecutionThread.WaitFor;
  end;
 end;

end;

function TPasRISCV.AllocatePHandle:TPasRISCVUInt32;
begin
 result:=TPasMPInterlocked.Increment(fPHandleCounter);
end;

procedure TPasRISCV.InitializeFDT;
var Index,DeviceID,IRQPin:TPasRISCVSizeInt;
    ChosenNode,CPUNode,CPUInterruptControllerNode,CPUsNode,CPUMap,CPUClusterNode,CoreNode,
    MemoryNode,SysConNode,PowerOffNode,RebootNode,
    SoCNode,IMSIC0,IMSICM0,IMSICS0,APLIC0,APLICM0,APLICS0,PLIC0,ACLINTNode,UART0,RTCNode,
    INTC0,PCIBusNode,
    I2CClockNode,I2CNode,I2CHIDKeyboardNode,I2CDS1307Node,
    PS2KeyboardNode,PS2MouseNode,
    VirtIOBlockNode,
    VirtIOInputKeyboardNode,VirtIOInputMouseNode,VirtIOSoundNode,VirtIO9PNode,VirtIONetNode,
    VirtIORandomGeneratorNode,
    VirtIOGPUNode,
    VirtIOVSockNode,
    VirtIORTCNode,
    SimpleFrameBufferNode,
    ReservedMemoryNode,SharedMemoryNode:TPasRISCV.TFDT.TFDTNode;
    AIARegFileMode:TPasRISCV.TAIARegFileMode;
    CPUInterruptControllerNodes:array[0..15] of TPasRISCV.TFDT.TFDTNode;
    CPUNodes:array of TPasRISCV.TFDT.TFDTNode;
    InterruptControllerHandle:TPasRISCVUInt32;
    RandomBuffer:array[0..15] of TPasRISCVUInt32;
    Cells:array[0..3] of TPasRISCVUInt32;
    Ranges:array[0..20] of TPasRISCVUInt32;
    InterruptExtCells:array[0..(4*16)-1] of TPasRISCVUInt32;
    InterruptMap:TPasRISCVUInt32DynamicArray;
    InterrurtMask:array[0..3] of TPasRISCVUInt32;
    BootArguments:TPasRISCVRawByteString;
    FileStream:TFileStream;
    IRQExt:TPasRISCVUInt32DynamicArray;
    ISA,ISAExtensions:TPasRISCVRawByteString;
 procedure AddISAExtension(const aExtension:TPasRISCVRawByteString);
 begin
  ISA:=ISA+'_'+aExtension;
  ISAExtensions:=ISAExtensions+#0+aExtension;
 end;
begin

 FreeAndNil(fFDT);

 CPUNodes:=nil;
 try

  fFDT:=TFDT.Create;

  fFDT.fRoot.AddPropertyU32('#address-cells',2);
  fFDT.fRoot.AddPropertyU32('#size-cells',2);

  fFDT.fRoot.AddPropertyString('model','riscv-virtio,qemu,pasriscv');
  fFDT.fRoot.AddPropertyString('compatible','riscv-virtio'#0'pasriscv'#0);

  ISA:='rv64imafdcb';
  ISAExtensions:='i'#0'm'#0'a'#0'f'#0'd'#0'c'#0'b';

  (*
   * Here are the ordering rules of extension naming defined by RISC-V
   * specification :
   * 1. All extensions should be separated from other multi-letter extensions
   *    by an underscore.
   * 2. The first letter following the 'Z' conventionally indicates the most
   *    closely related alphabetical extension category, IMAFDQLCBKJTPVH.
   *    If multiple 'Z' extensions are named, they should be ordered first
   *    by category, then alphabetically within a category.
   * 3. Standard supervisor-level extensions (starts with 'S') should be
   *    listed after standard unprivileged extensions.  If multiple
   *    supervisor-level extensions are listed, they should be ordered
   *    alphabetically.
   * 4. Non-standard extensions (starts with 'X') must be listed after all
   *    standard extensions. They must be separated from other multi-letter
   *    extensions by an underscore.
   *
   * Not yet implemented and non-implemented ones are commented out
   *
   *)
  AddISAExtension('zic64b');
  AddISAExtension('zicbom');
  AddISAExtension('zicbop');
  AddISAExtension('zicboz');
  AddISAExtension('ziccamoa');
  AddISAExtension('ziccif');
  AddISAExtension('zicclsm');
  AddISAExtension('ziccrse');
//AddISAExtension('zicfilp');
//AddISAExtension('zicfiss');
  AddISAExtension('zicond');
  AddISAExtension('zicntr');
  AddISAExtension('zicsr');
  AddISAExtension('zifencei');
  AddISAExtension('zihintntl');
  AddISAExtension('zihintpause');
  AddISAExtension('zihpm');
  AddISAExtension('zimop');
//AddISAExtension('zmmul');
  AddISAExtension('za64rs');
  AddISAExtension('zaamo');
  AddISAExtension('zabha');
  AddISAExtension('zacas');
  AddISAExtension('zalrsc');
//AddISAExtension('zama16b');
  AddISAExtension('zawrs');
  AddISAExtension('zfa');
  AddISAExtension('zfbfmin');
  AddISAExtension('zfh');
  AddISAExtension('zfhmin');
//AddISAExtension('zfinx');
//AddISAExtension('zdinx');
  AddISAExtension('zca');
  AddISAExtension('zcb');
//AddISAExtension('zcf');
//AddISAExtension('zcd');
//AddISAExtension('zce');
  AddISAExtension('zcmop');
//AddISAExtension('zcmp');
//AddISAExtension('zcmt');
  AddISAExtension('zba');
  AddISAExtension('zbb');
  AddISAExtension('zbc');
//AddISAExtension('zbkb');
//AddISAExtension('zbkc');
//AddISAExtension('zbkx');
  AddISAExtension('zbs');
//AddISAExtension('zk');
//AddISAExtension('zkn');
//AddISAExtension('zknd');
//AddISAExtension('zkne');
//AddISAExtension('zknh');
  AddISAExtension('zkr');
//AddISAExtension('zks');
//AddISAExtension('zksed');
//AddISAExtension('zksh');
  AddISAExtension('zkt');
//AddISAExtension('ztso');
//AddISAExtension('zvbb');
//AddISAExtension('zvbc');
//AddISAExtension('zve32f');
//AddISAExtension('zve32x');
//AddISAExtension('zve64f');
//AddISAExtension('zve64d');
//AddISAExtension('zve64x');
//AddISAExtension('zvfbfmin');
//AddISAExtension('zvfbfwma');
//AddISAExtension('zvfh');
//AddISAExtension('zvfhmin');
//AddISAExtension('zvkb');
//AddISAExtension('zvkg');
//AddISAExtension('zvkn');
//AddISAExtension('zvknc');
//AddISAExtension('zvkned');
//AddISAExtension('zvkng');
//AddISAExtension('zvknha');
//AddISAExtension('zvknhb');
//AddISAExtension('zvks');
//AddISAExtension('zvksc');
//AddISAExtension('zvksed');
//AddISAExtension('zvksg');
//AddISAExtension('zvksh');
//AddISAExtension('zvkt');
//AddISAExtension('zhinx');
//AddISAExtension('zhinxmin');
//AddISAExtension('sdtrig');
  AddISAExtension('shcounterenw');
  AddISAExtension('sha');
  AddISAExtension('shgatpa');
  AddISAExtension('shtvala');
  AddISAExtension('shvsatpa');
  AddISAExtension('shvstvala');
  AddISAExtension('shvstvecd');
 if fConfiguration.fAIA then begin
  AddISAExtension('smaia');
 end;
//AddISAExtension('smcdeleg');
//AddISAExtension('smcntrpmf');
//AddISAExtension('smcsrind');
//AddISAExtension('smdbltrp');
//AddISAExtension('smepmp');
//AddISAExtension('smrnmi');
//AddISAExtension('smmpm');
//AddISAExtension('smnpm');
//AddISAExtension('smstateen');
  if fConfiguration.fAIA then begin
   AddISAExtension('ssaia');
  end;
//AddISAExtension('ssccfg');
  AddISAExtension('ssccptr');
  AddISAExtension('sscofpmf');
  AddISAExtension('sscounterenw');
//AddISAExtension('sscsrind');
//AddISAExtension('ssdbltrp');
  AddISAExtension('ssnpm');
//AddISAExtension('sspm');
  AddISAExtension('ssstateen');
//AddISAExtension('ssstrict');
  AddISAExtension('sstc');
  AddISAExtension('sstvala');
  AddISAExtension('sstvecd');
  AddISAExtension('ssu64xl');
  AddISAExtension('svbare');
  AddISAExtension('ss1p13');
  AddISAExtension('sm1p13');
  AddISAExtension('supm');
  AddISAExtension('svade');
//AddISAExtension('smctr');
//AddISAExtension('ssctr');
  AddISAExtension('svadu');
  AddISAExtension('svinval');
  AddISAExtension('svnapot');
  AddISAExtension('svpbmt');
//AddISAExtension('svrsw60t59b');
//AddISAExtension('svukte');
//AddISAExtension('svvptc');
//AddISAExtension('xtheadba');
//AddISAExtension('xtheadbb');
//AddISAExtension('xtheadbs');
//AddISAExtension('xtheadcmo');
//AddISAExtension('xtheadcondmov');
//AddISAExtension('xtheadfmemidx');
//AddISAExtension('xtheadfmv');
//AddISAExtension('xtheadmac');
//AddISAExtension('xtheadmemidx');
//AddISAExtension('xtheadmempair');
//AddISAExtension('xtheadsync');
//AddISAExtension('xventanacondops');

{ ISA:='rv64imafdcb_zicsr_zifencei_zkr_zicboz_zicbom_svadu_sstc_svnapot';
//ISA:=ISA+'_svpbmt';
  ISAExtensions:='i'#0'm'#0'a'#0'f'#0'd'#0'c'#0'b'#0'zicsr'#0'zifencei'#0'zkr'#0+
                  'zicboz'#0'zicbom'#0'svadu'#0'sstc'#0'svnapot';
  if fConfiguration.fAIA then begin
   ISA:=ISA+'_smaia_ssaia';
   ISAExtensions:=ISAExtensions+#0'smaia'#0'ssaia';
  end;}

  ChosenNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'chosen');
  try
   BootArguments:=fConfiguration.fBootArguments;
   BootArguments:=StringReplace(BootArguments,'$LINUXUART$','uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase),[rfReplaceAll,rfIgnoreCase]);
   ChosenNode.AddPropertyString('bootargs',BootArguments);
 //ChosenNode.AddPropertyString('bootargs','console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/mem rw earlyprintk console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','rw earlyprintk debug console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/mem rw earlyprintk debug console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/mem rw earlyprintk debug console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/vda1 rw earlyprintk debug console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/vda4 rw earlyprintk console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/vda4 rw earlyprintk console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/mem rw earlyprintk console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' console=tty0 earlycon=sbi');
 // ChosenNode.AddPropertyString('bootargs','root=/dev/vda rw console=ttyS earlycon=sbi earlyprintk');
 //  ChosenNode.AddPropertyString('bootargs','root=/dev/vda rw console=ttyS console=tty0 earlycon=sbi earlyprintk');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/nvme0 rootflags=discard rw earlyprintk debug console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' rootwait earlycon=sbi');
 //  ChosenNode.AddPropertyString('bootargs','root=/dev/vda rootflags=discard rw earlyprintk debug console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' rootwait earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/nvme0n1 rootflags=discard rw earlyprintk debug console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' rootwait earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','earlyprintk debug console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' rootwait earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','earlyprintk debug root=/dev/vda1 console=uart,mmio,0x'+FDTHex64(fConfiguration.fUARTBase)+' rootwait earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/vda rw console=ttyS console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','rw console=ttyS console=tty0 earlycon=sbi');
 //ChosenNode.AddPropertyString('bootargs','root=/dev/vda rw console=ttyS console=tty0 earlycon=sbi');
   ChosenNode.AddPropertyString('stdout-path','/soc/uart@'+FDTHex64(fConfiguration.fUARTBase));
   if fKernelSize>0 then begin
    ChosenNode.AddPropertyU64('riscv,kernel-start',fConfiguration.fMemoryBase+fKernelOffset);
    ChosenNode.AddPropertyU64('riscv,kernel-end',fConfiguration.fMemoryBase+fKernelOffset+fKernelSize);
   end;
   if fINITRDSize>0 then begin
    ChosenNode.AddPropertyU64('linux,initrd-start',fConfiguration.fMemoryBase+fINITRDOffset);
    ChosenNode.AddPropertyU64('linux,initrd-end',fConfiguration.fMemoryBase+fINITRDOffset+fINITRDSize);
   end;
   fRandomGeneratorLock.Acquire;
   try
    for Index:=0 to 15 do begin
     RandomBuffer[Index]:=fRandomGenerator.GetUInt32;
    end;
   finally
    fRandomGeneratorLock.Release;
   end;
   ChosenNode.AddProperty('rng-seed',RandomBuffer,SizeOf(RandomBuffer));
  finally
   fFDT.fRoot.AddChild(ChosenNode);
  end;

  CPUsNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'cpus');
  try

   CPUsNode.AddPropertyU32('#address-cells',1);
   CPUsNode.AddPropertyU32('#size-cells',0);
   CPUsNode.AddPropertyU32('timebase-frequency',CLOCK_FREQUENCY);

   CPUMap:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'cpus-map');
   try

    CPUClusterNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'cluster0');
    try

     SetLength(CPUNodes,length(fHARTs));
     for Index:=0 to length(fHARTs)-1 do begin

      CPUNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'cpu@'+IntToStr(Index));
      try

       CPUNode.GetPHandle;

       CPUNode.AddPropertyString('device_type','cpu');
       CPUNode.AddPropertyU32('reg',Index);
       CPUNode.AddPropertyString('status','okay');
       CPUNode.AddPropertyString('compatible','riscv');
       CPUNode.AddPropertyU32('riscv,cbop-block-size',64);
       CPUNode.AddPropertyU32('riscv,cboz-block-size',64);
       CPUNode.AddPropertyU32('riscv,cbom-block-size',64);
       CPUNode.AddPropertyString('riscv,isa',ISA);
       CPUNode.AddPropertyString('riscv,isa-base','rv64i');
       CPUNode.AddPropertyString('riscv,isa-extensions',ISAExtensions);
       CPUNode.AddPropertyString('mmu-type','riscv,sv39');
       CPUNode.AddPropertyU32('clock-frequency',3000000000);

       CPUInterruptControllerNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'cpu'+IntToStr(Index)+'-intc');
       try
        CPUInterruptControllerNode.GetPHandle;
        CPUInterruptControllerNode.AddPropertyU32('#interrupt-cells',1);
        CPUInterruptControllerNode.AddPropertyCells('interrupt-controller',nil,0);
        CPUInterruptControllerNode.AddPropertyString('compatible','riscv,cpu-intc');
       finally
        CPUNode.AddChild(CPUInterruptControllerNode);
        CPUInterruptControllerNodes[Index]:=CPUInterruptControllerNode;
       end;

       CoreNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'core'+IntToStr(Index));
       try

        CoreNode.AddPropertyU32('cpu',CPUNode.GetPHandle);

       finally
        CPUClusterNode.AddChild(CoreNode);
       end;

      finally
       CPUsNode.AddChild(CPUNode);
       CPUNodes[Index]:=CPUNode;
      end;

     end;

    finally
     CPUMap.AddChild(CPUClusterNode);
    end;

   finally
    CPUsNode.AddChild(CPUMap);
   end;

  finally
   fFDT.fRoot.AddChild(CPUsNode);
  end;

  MemoryNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'memory',fConfiguration.fMemoryBase);
  try
   MemoryNode.AddPropertyString('device_type','memory');
   Cells[0]:=0;
   Cells[1]:=fConfiguration.fMemoryBase;
   Cells[2]:=0;
   Cells[3]:=fConfiguration.fMemorySize;
   MemoryNode.AddPropertyCells('reg',@Cells,4);
  finally
   fFDT.fRoot.AddChild(MemoryNode);
  end;

  SysConNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'syscon',fConfiguration.fSYSCONBase);
  try
   SysConNode.GetPHandle;
   Cells[0]:=0;
   Cells[1]:=fConfiguration.fSYSCONBase;
   Cells[2]:=0;
   Cells[3]:=fConfiguration.fSYSCONSize;
   SysConNode.AddPropertyCells('reg',@Cells,4);
   SysConNode.AddPropertyString('compatible','sifive,test1'#0'sifive,test0'#0'syscon'#0);
  finally
   fFDT.fRoot.AddChild(SysConNode);
  end;

  PowerOffNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'poweroff');
  try
   PowerOffNode.AddPropertyU32('value',$5555);
   PowerOffNode.AddPropertyU32('offset',0);
   PowerOffNode.AddPropertyU32('regmap',SysConNode.GetPHandle);
   PowerOffNode.AddPropertyString('compatible','syscon-poweroff');
  finally
   fFDT.fRoot.AddChild(PowerOffNode);
  end;

  RebootNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'reboot');
  try
   RebootNode.AddPropertyU32('value',$7777);
   RebootNode.AddPropertyU32('offset',0);
   RebootNode.AddPropertyU32('regmap',SysConNode.GetPHandle);
   RebootNode.AddPropertyString('compatible','syscon-reboot');
  finally
   fFDT.fRoot.AddChild(RebootNode);
  end;

  SoCNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'soc');
  try

   SoCNode.AddPropertyU32('#address-cells',2);
   SoCNode.AddPropertyU32('#size-cells',2);
   SoCNode.AddPropertyString('compatible','simple-bus');
   SoCNode.AddPropertyCells('ranges',nil,0);

   if fConfiguration.fAIA then begin

    INTC0:=nil;

    for AIARegFileMode:=Low(TPasRISCV.TAIARegFileMode) to High(TPasRISCV.TAIARegFileMode) do begin

     case AIARegFileMode of
      TPasRISCV.TAIARegFileMode.Machine:begin
       IMSIC0:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'imsics_m',fConfiguration.fIMSICMachineBase);
       APLIC0:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'aplics_m',fConfiguration.fAPLICMachineBase);
      end;
      TPasRISCV.TAIARegFileMode.Supervisor:begin
       IMSIC0:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'imsics_s',fConfiguration.fIMSICSupervisorBase);
       APLIC0:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'aplics_s',fConfiguration.fAPLICSupervisorBase);
      end;
      else begin
      end;
     end;
     try

      ///////////
      // IMSIC //
      ///////////

      IMSIC0.GetPHandle;

      Cells[0]:=0;
      Cells[1]:=fConfiguration.fIMSICMachineBase;
      Cells[2]:=0;
      Cells[3]:=fConfiguration.fIMSICMachineSizePerHART*fConfiguration.fCountHARTs;
      IMSIC0.AddPropertyCells('reg',@Cells,4);

      IMSIC0.AddPropertyString('compatible','riscv,imsics');
      IMSIC0.AddPropertyCells('interrupt-controller',nil,0);
      IMSIC0.AddPropertyU32('#interrupt-cells',0);
      IMSIC0.AddPropertyCells('msi-controller',nil,0);
      IMSIC0.AddPropertyU32('#msi-cells',0);
      IMSIC0.AddPropertyU32('riscv,num-ids',TPasRISCV.THART.TAIARegFile.IRQ_LIMIT-1);

      IRQExt:=nil;
      try
       SetLength(IRQExt,length(CPUNodes)*2);
       for Index:=0 to length(CPUNodes)-1 do begin
        CPUNode:=CPUNodes[Index];
        if assigned(CPUNode) then begin
         CPUInterruptControllerNode:=CPUInterruptControllerNodes[Index];
         if assigned(CPUInterruptControllerNode) then begin
          IRQExt[(Index shl 1) or 0]:=CPUInterruptControllerNode.GetPHandle;
          case AIARegFileMode of
           TPasRISCV.TAIARegFileMode.Machine:begin
            IRQExt[(Index shl 1) or 1]:=TPasRISCVUInt32(TPasRISCV.THART.TInterruptValue.MachineExternal);
           end;
           TPasRISCV.TAIARegFileMode.Supervisor:begin
            IRQExt[(Index shl 1) or 1]:=TPasRISCVUInt32(TPasRISCV.THART.TInterruptValue.SupervisorExternal);
           end;
           else begin
           end;
          end;
         end;
        end;
       end;
       IMSIC0.AddPropertyCells('interrupts-extended',@IRQExt[0],length(IRQExt));
      finally
       IRQExt:=nil;
      end;

      ///////////
      // APLIC //
      ///////////

      APLIC0.GetPHandle;

      Cells[0]:=0;
      Cells[2]:=0;
      case AIARegFileMode of
       TPasRISCV.TAIARegFileMode.Machine:begin
        Cells[1]:=fConfiguration.fAPLICMachineBase;
        Cells[3]:=fConfiguration.fAPLICMachineSize;
       end;
       TPasRISCV.TAIARegFileMode.Supervisor:begin
        Cells[1]:=fConfiguration.fAPLICSupervisorBase;
        Cells[3]:=fConfiguration.fAPLICSupervisorSize;
       end;
       else begin
        Cells[1]:=0;
        Cells[3]:=0;
       end;
      end;
      APLIC0.AddPropertyCells('reg',@Cells,4);

      APLIC0.AddPropertyString('compatible','riscv,aplic');
      APLIC0.AddPropertyU32('msi-parent',IMSIC0.GetPHandle);
      APLIC0.AddPropertyCells('interrupt-controller',nil,0);
      APLIC0.AddPropertyU32('#interrupt-cells',2);
      APLIC0.AddPropertyU32('#address-cells',0);
      APLIC0.AddPropertyU32('riscv,num-sources',TPasRISCV.TAPLICDevice.APLIC_SRC_LIMIT-1);

     finally
      SoCNode.AddChild(IMSIC0);
      SoCNode.AddChild(APLIC0);
      case AIARegFileMode of
       TPasRISCV.TAIARegFileMode.Machine:begin
        IMSICM0:=IMSIC0;
        APLICM0:=APLIC0;
       end;
       TPasRISCV.TAIARegFileMode.Supervisor:begin
        IMSICS0:=IMSIC0;
        APLICS0:=APLIC0;
       end;
       else begin
       end;
      end;
     end;

    end;

    Cells[0]:=APLICS0.GetPHandle;
    Cells[1]:=1;
    Cells[2]:=TPasRISCV.TAPLICDevice.APLIC_SRC_LIMIT-1;
    Cells[3]:=0;
    APLICM0.AddPropertyU32('riscv,children',APLICS0.GetPHandle);
    APLICM0.AddPropertyCells('riscv,delegate',@Cells,3);
    APLICM0.AddPropertyCells('riscv,delegation',@Cells,3);

    PLIC0:=nil;

    // APLIC as interrupt controller for devices
    INTC0:=APLICS0;

   end else begin

    IMSICM0:=nil;

    IMSICS0:=nil;

    APLICM0:=nil;

    APLICS0:=nil;

    PLIC0:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'interrupt-controller',fConfiguration.fPLICBase);
    try

     PLIC0.GetPHandle;
     PLIC0.AddPropertyU32('riscv,ndev',$35);

     Cells[0]:=0;
     Cells[1]:=fConfiguration.fPLICBase;
     Cells[2]:=0;
     Cells[3]:=fConfiguration.fPLICSize;
     PLIC0.AddPropertyCells('reg',@Cells,4);

     for Index:=0 to length(fHARTs)-1 do begin
      InterruptExtCells[(Index shl 2) or 0]:=CPUInterruptControllerNodes[Index].GetPHandle;
      InterruptExtCells[(Index shl 2) or 1]:=TPasRISCVUInt32(THART.TInterruptValue.MachineExternal);
      InterruptExtCells[(Index shl 2) or 2]:=CPUInterruptControllerNodes[Index].GetPHandle;
      InterruptExtCells[(Index shl 2) or 3]:=TPasRISCVUInt32(THART.TInterruptValue.SupervisorExternal);
     end;
     PLIC0.AddPropertyCells('interrupts-extended',@InterruptExtCells[0],length(fHARTs)*4);

     PLIC0.AddPropertyCells('interrupt-controller',nil,0);
  // PLIC0.AddPropertyString('compatible','riscv,plic0');
     PLIC0.AddPropertyString('compatible','sifive,plic-1.0.0');
     PLIC0.AddPropertyU32('#interrupt-cells',1);
     PLIC0.AddPropertyU32('#address-cells',0);

    finally
     SoCNode.AddChild(PLIC0);
    end;

    // PLIC as interrupt controller for devices
    INTC0:=PLIC0;

   end;

   ACLINTNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'clint',fConfiguration.fCLINTBase);
   try

    Cells[0]:=0;
    Cells[1]:=fConfiguration.fCLINTBase;
    Cells[2]:=0;
    Cells[3]:=fConfiguration.fCLINTSize;
    ACLINTNode.AddPropertyCells('reg',@Cells,4);

    for Index:=0 to length(fHARTs)-1 do begin
     InterruptExtCells[(Index shl 2) or 0]:=CPUInterruptControllerNodes[Index].GetPHandle;
     InterruptExtCells[(Index shl 2) or 1]:=TPasRISCVUInt32(THART.TInterruptValue.MachineSoftware);
     InterruptExtCells[(Index shl 2) or 2]:=CPUInterruptControllerNodes[Index].GetPHandle;
     InterruptExtCells[(Index shl 2) or 3]:=TPasRISCVUInt32(THART.TInterruptValue.MachineTimer);
    end;
    ACLINTNode.AddPropertyCells('interrupts-extended',@InterruptExtCells[0],length(fHARTs)*4);

    ACLINTNode.AddPropertyString('compatible','sifive,clint0'#0'riscv,clint0'#0);

   finally
    SoCNode.AddChild(ACLINTNode);
   end;

   UART0:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'uart',fConfiguration.fUARTBase);
   try

    if fConfiguration.fAIA then begin
     // APLIC: #interrupt-cells=2, need IRQ number + trigger type (4 = level high)
     Cells[0]:=fConfiguration.fUARTIRQ;
     Cells[1]:=4; // IRQ_TYPE_LEVEL_HIGH
     UART0.AddPropertyCells('interrupts',@Cells,2);
    end else begin
     // PLIC: #interrupt-cells=1
     UART0.AddPropertyU32('interrupts',fConfiguration.fUARTIRQ);
    end;
    UART0.AddPropertyU32('interrupt-parent',INTC0.GetPHandle);
    UART0.AddPropertyU32('clock-frequency',$384000);

    Cells[0]:=0;
    Cells[1]:=fConfiguration.fUARTBase;
    Cells[2]:=0;
    Cells[3]:=fConfiguration.fUARTSize;
    UART0.AddPropertyCells('reg',@Cells,4);

    UART0.AddPropertyString('compatible','ns16550a');

   finally
    SoCNode.AddChild(UART0);
   end;

   case fConfiguration.fRTCMode of
    TRTCMode.DS1742:begin
     RTCNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'rtc',fConfiguration.fDS1742Base);
     try
      RTCNode.AddPropertyReg('reg',fConfiguration.fDS1742Base,fConfiguration.fDS1742Size);
      RTCNode.AddPropertyString('compatible','maxim,ds1742');
     finally
      SoCNode.AddChild(RTCNode);
     end;
    end;
    TRTCMode.Goldfish:begin
     RTCNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'rtc',fConfiguration.fGoldfishRTCBase);
     try
      RTCNode.AddPropertyReg('reg',fConfiguration.fGoldfishRTCBase,fConfiguration.fGoldfishRTCSize);
      if fConfiguration.fAIA then begin
       Cells[0]:=fConfiguration.fGoldfishRTCIRQ;
       Cells[1]:=4; // IRQ_TYPE_LEVEL_HIGH
       RTCNode.AddPropertyCells('interrupts',@Cells,2);
      end else begin
       RTCNode.AddPropertyU32('interrupts',fConfiguration.fGoldfishRTCIRQ);
      end;
      RTCNode.AddPropertyU32('interrupt-parent',INTC0.GetPHandle);
      RTCNode.AddPropertyString('compatible','google,goldfish-rtc');
     finally
      SoCNode.AddChild(RTCNode);
     end;
    end;
    TRTCMode.DS1307:begin
     // DS1307 is declared as part of the I2C bus node, not as a standalone SoC node
    end;
    TRTCMode.VirtIO:begin
     // VirtIO RTC is declared as a VirtIO MMIO node (via requestq virtqueue protocol)
    end;
   end;

   begin

    PCIBusNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'pci',TPCI.PCI_BASE_DEFAULT_MMIO);
    try

     PCIBusNode.AddPropertyU32('#address-cells',3);

     PCIBusNode.AddPropertyU32('#size-cells',2);

     PCIBusNode.AddPropertyU32('#interrupt-cells',1);

     PCIBusNode.AddPropertyString('device_type','pci');

     Cells[0]:=0;
     Cells[1]:=TPCI.PCI_BASE_DEFAULT_MMIO;
     Cells[2]:=0;
     Cells[3]:=256 shl 20;//TPCI.PCI_SIZE;
     PCIBusNode.AddPropertyCells('reg',@Cells,4);

     PCIBusNode.AddPropertyString('compatible','pci-host-ecam-generic');

     PCIBusNode.AddPropertyString('dma-coherent','');

     Cells[0]:=0;
     Cells[1]:=255;//TPCI.PCI_BUS_COUNT-1;
     PCIBusNode.AddPropertyCells('bus-range',@Cells,2);

     Ranges[0]:=$1000000;
     Ranges[1]:=0;
     Ranges[2]:=0;
     Ranges[3]:=TPCI.PCI_IO_DEFAULT_ADDR shr 32;
     Ranges[4]:=TPCI.PCI_IO_DEFAULT_ADDR and TPasRISCVUInt64($ffffffff);
     Ranges[5]:=TPCI.PCI_IO_DEFAULT_SIZE shr 32;
     Ranges[6]:=TPCI.PCI_IO_DEFAULT_SIZE and TPasRISCVUInt64($ffffffff);

     Ranges[7]:=$2000000;
     Ranges[8]:=TPCI.PCI_MEM32_DEFAULT_MMIO shr 32;
     Ranges[9]:=TPCI.PCI_MEM32_DEFAULT_MMIO and TPasRISCVUInt64($ffffffff);
     Ranges[10]:=TPCI.PCI_MEM32_DEFAULT_MMIO shr 32;
     Ranges[11]:=TPCI.PCI_MEM32_DEFAULT_MMIO and TPasRISCVUInt64($ffffffff);
     Ranges[12]:=TPCI.PCI_MEM32_DEFAULT_SIZE shr 32;
     Ranges[13]:=TPCI.PCI_MEM32_DEFAULT_SIZE and TPasRISCVUInt64($ffffffff);

 {   Ranges[14]:=$43000000;
     Ranges[15]:=TPCI.PCI_MEM64_DEFAULT_MMIO shr 32;
     Ranges[16]:=TPCI.PCI_MEM64_DEFAULT_MMIO and TPasRISCVUInt64($ffffffff);
     Ranges[17]:=TPCI.PCI_MEM64_DEFAULT_MMIO shr 32;
     Ranges[18]:=TPCI.PCI_MEM64_DEFAULT_MMIO and TPasRISCVUInt64($ffffffff);
     Ranges[19]:=TPCI.PCI_MEM64_DEFAULT_SIZE shr 32;
     Ranges[20]:=TPCI.PCI_MEM64_DEFAULT_SIZE and TPasRISCVUInt64($ffffffff);}

     if TPCI.PCI_IO_DEFAULT_SIZE<>0 then begin
      PCIBusNode.AddPropertyCells('ranges',@Ranges[0],14{21});
     end else begin
      PCIBusNode.AddPropertyCells('ranges',@Ranges[7],7);
     end;

     // Crossing-style IRQ routing for IRQ balancing
     InterruptControllerHandle:=INTC0.GetPHandle;

     InterruptMap:=nil;
     try
      SetLength(InterruptMap,TPCI.PCI_BUS_IRQS*TPCI.PCI_BUS_IRQS*6);
      Index:=0;
      for DeviceID:=0 to TPCI.PCI_BUS_IRQS-1 do begin
       for IRQPin:=1 to TPCI.PCI_BUS_IRQS do begin

        // PCIe address
        InterruptMap[Index+0]:=DeviceID shl 11;
        InterruptMap[Index+1]:=0;
        InterruptMap[Index+2]:=0;

        // PCIe irq pin
        InterruptMap[Index+3]:=IRQPin;

        // Interrupt controller handle
        InterruptMap[Index+4]:=InterruptControllerHandle;

        // Interrupt cell(s)
        InterruptMap[Index+5]:=TPCI.PCI_IRQs[TPasRISCV.TPCIBusDevice.GetIRQID(DeviceID,IRQPin)];

        inc(Index,6);
       end;
      end;

      PCIBusNode.AddPropertyCells('interrupt-map',@InterruptMap[0],length(InterruptMap));

     finally
      InterruptMap:=nil;
     end;

{    InterruptMap:=nil;
     try
      SetLength(InterruptMap,96);
      InterruptMap[0]:=$0000;  InterruptMap[1]:=0;  InterruptMap[2]:=0;  InterruptMap[3]:=1;  InterruptMap[4]:=InterruptControllerHandle;  InterruptMap[5]:=TPCI.PCI_IRQs[0];
      InterruptMap[6]:=$0000;  InterruptMap[7]:=0;  InterruptMap[8]:=0;  InterruptMap[9]:=2;  InterruptMap[10]:=InterruptControllerHandle; InterruptMap[11]:=TPCI.PCI_IRQs[1];
      InterruptMap[12]:=$0000; InterruptMap[13]:=0; InterruptMap[14]:=0; InterruptMap[15]:=3; InterruptMap[16]:=InterruptControllerHandle; InterruptMap[17]:=TPCI.PCI_IRQs[2];
      InterruptMap[18]:=$0000; InterruptMap[19]:=0; InterruptMap[20]:=0; InterruptMap[21]:=4; InterruptMap[22]:=InterruptControllerHandle; InterruptMap[23]:=TPCI.PCI_IRQs[3];
      InterruptMap[24]:=$0800; InterruptMap[25]:=0; InterruptMap[26]:=0; InterruptMap[27]:=1; InterruptMap[28]:=InterruptControllerHandle; InterruptMap[29]:=TPCI.PCI_IRQs[1];
      InterruptMap[30]:=$0800; InterruptMap[31]:=0; InterruptMap[32]:=0; InterruptMap[33]:=2; InterruptMap[34]:=InterruptControllerHandle; InterruptMap[35]:=TPCI.PCI_IRQs[2];
      InterruptMap[36]:=$0800; InterruptMap[37]:=0; InterruptMap[38]:=0; InterruptMap[39]:=3; InterruptMap[40]:=InterruptControllerHandle; InterruptMap[41]:=TPCI.PCI_IRQs[3];
      InterruptMap[42]:=$0800; InterruptMap[43]:=0; InterruptMap[44]:=0; InterruptMap[45]:=4; InterruptMap[46]:=InterruptControllerHandle; InterruptMap[47]:=TPCI.PCI_IRQs[0];
      InterruptMap[48]:=$1000; InterruptMap[49]:=0; InterruptMap[50]:=0; InterruptMap[51]:=1; InterruptMap[52]:=InterruptControllerHandle; InterruptMap[53]:=TPCI.PCI_IRQs[2];
      InterruptMap[54]:=$1000; InterruptMap[55]:=0; InterruptMap[56]:=0; InterruptMap[57]:=2; InterruptMap[58]:=InterruptControllerHandle; InterruptMap[59]:=TPCI.PCI_IRQs[3];
      InterruptMap[60]:=$1000; InterruptMap[61]:=0; InterruptMap[62]:=0; InterruptMap[63]:=3; InterruptMap[64]:=InterruptControllerHandle; InterruptMap[65]:=TPCI.PCI_IRQs[0];
      InterruptMap[66]:=$1000; InterruptMap[67]:=0; InterruptMap[68]:=0; InterruptMap[69]:=4; InterruptMap[70]:=InterruptControllerHandle; InterruptMap[71]:=TPCI.PCI_IRQs[1];
      InterruptMap[72]:=$1800; InterruptMap[73]:=0; InterruptMap[74]:=0; InterruptMap[75]:=1; InterruptMap[76]:=InterruptControllerHandle; InterruptMap[77]:=TPCI.PCI_IRQs[3];
      InterruptMap[78]:=$1800; InterruptMap[79]:=0; InterruptMap[80]:=0; InterruptMap[81]:=2; InterruptMap[82]:=InterruptControllerHandle; InterruptMap[83]:=TPCI.PCI_IRQs[0];
      InterruptMap[84]:=$1800; InterruptMap[85]:=0; InterruptMap[86]:=0; InterruptMap[87]:=3; InterruptMap[88]:=InterruptControllerHandle; InterruptMap[89]:=TPCI.PCI_IRQs[2];
      InterruptMap[90]:=$1800; InterruptMap[91]:=0; InterruptMap[92]:=0; InterruptMap[93]:=4; InterruptMap[94]:=InterruptControllerHandle; InterruptMap[95]:=TPCI.PCI_IRQs[1];
      PCIBusNode.AddPropertyCells('interrupt-map',@InterruptMap[0],96);
     finally
      InterruptMap:=nil;
     end;}

     InterrurtMask[0]:=$1800;
     InterrurtMask[1]:=0;
     InterrurtMask[2]:=0;
     InterrurtMask[3]:=7;
     PCIBusNode.AddPropertyCells('interrupt-map-mask',@InterrurtMask,4);

    finally
     SoCNode.AddChild(PCIBusNode);
    end;

   end;

   if fConfiguration.fDisplayMode=TDisplayMode.SimpleFB then begin

    SimpleFrameBufferNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'framebuffer',fConfiguration.fFrameBufferBase+TSimpleFBDevice.FrameBufferAddress);
    try
     Cells[0]:=0;
     Cells[1]:=fConfiguration.fFrameBufferBase+TSimpleFBDevice.FrameBufferAddress;
     Cells[2]:=0;
     Cells[3]:=fConfiguration.fFrameBufferSize;
     SimpleFrameBufferNode.AddPropertyCells('reg',@Cells,4);
     SimpleFrameBufferNode.AddPropertyString('compatible','simple-framebuffer');
     SimpleFrameBufferNode.AddPropertyString('format','a8b8g8r8');
     SimpleFrameBufferNode.AddPropertyU32('width',fConfiguration.fFrameBufferWidth);
     SimpleFrameBufferNode.AddPropertyU32('height',fConfiguration.fFrameBufferHeight);
     SimpleFrameBufferNode.AddPropertyU32('stride',fConfiguration.fFrameBufferStride);
    finally
     SoCNode.AddChild(SimpleFrameBufferNode);
    end;

   end;

   if true then begin

    if true then begin

     PS2KeyboardNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'ps2',fConfiguration.fPS2KeyboardBase);
     try
      Cells[0]:=0;
      Cells[1]:=fConfiguration.fPS2KeyboardBase;
      Cells[2]:=0;
      Cells[3]:=TPasRISCVUInt32(TPasRISCV.TPS2KeyboardDevice.DefaultSize);
      PS2KeyboardNode.AddPropertyCells('reg',@Cells,4);
      PS2KeyboardNode.AddPropertyString('compatible','altr,ps2-1.0');
      PS2KeyboardNode.AddPropertyU32('interrupt-parent',INTC0.GetPHandle);
      if fConfiguration.fAIA then begin
       Cells[0]:=fConfiguration.fPS2KeyboardIRQ;
       Cells[1]:=4; // IRQ_TYPE_LEVEL_HIGH
       PS2KeyboardNode.AddPropertyCells('interrupts',@Cells,2);
      end else begin
       PS2KeyboardNode.AddPropertyU32('interrupts',fConfiguration.fPS2KeyboardIRQ);
      end;
     finally
      SoCNode.AddChild(PS2KeyboardNode);
     end;

     PS2MouseNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'ps2',fConfiguration.fPS2MouseBase);
     try
      Cells[0]:=0;
      Cells[1]:=fConfiguration.fPS2MouseBase;
      Cells[2]:=0;
      Cells[3]:=TPasRISCVUInt32(TPasRISCV.TPS2MouseDevice.DefaultSize);
      PS2MouseNode.AddPropertyCells('reg',@Cells,4);
      PS2MouseNode.AddPropertyString('compatible','altr,ps2-1.0');
      PS2MouseNode.AddPropertyU32('interrupt-parent',INTC0.GetPHandle);
      if fConfiguration.fAIA then begin
       Cells[0]:=fConfiguration.fPS2MouseIRQ;
       Cells[1]:=4; // IRQ_TYPE_LEVEL_HIGH
       PS2MouseNode.AddPropertyCells('interrupts',@Cells,2);
      end else begin
       PS2MouseNode.AddPropertyU32('interrupts',fConfiguration.fPS2MouseIRQ);
      end;
     finally
      SoCNode.AddChild(PS2MouseNode);
     end;

    end;

    if true then begin

     VirtIOInputKeyboardNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'virtio',fConfiguration.fVirtIOInputKeyboardBase);
     try
      VirtIOInputKeyboardNode.AddPropertyString('compatible','virtio,mmio');
      Cells[0]:=0;
      Cells[1]:=fConfiguration.fVirtIOInputKeyboardBase;
      Cells[2]:=0;
      Cells[3]:=fConfiguration.fVirtIOInputKeyboardSize;
      VirtIOInputKeyboardNode.AddPropertyCells('reg',@Cells,4);
      Cells[0]:=INTC0.GetPHandle;
      Cells[1]:=TPasRISCVUInt32(fConfiguration.fVirtIOInputKeyboardIRQ);
      VirtIOInputKeyboardNode.AddPropertyCells('interrupts-extended',@Cells,2);
     finally
      SoCNode.AddChild(VirtIOInputKeyboardNode);
     end;

     VirtIOInputMouseNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'virtio',fConfiguration.fVirtIOInputMouseBase);
     try
      VirtIOInputMouseNode.AddPropertyString('compatible','virtio,mmio');
      Cells[0]:=0;
      Cells[1]:=fConfiguration.fVirtIOInputMouseBase;
      Cells[2]:=0;
      Cells[3]:=fConfiguration.fVirtIOInputMouseSize;
      VirtIOInputMouseNode.AddPropertyCells('reg',@Cells,4);
      Cells[0]:=INTC0.GetPHandle;
      Cells[1]:=TPasRISCVUInt32(fConfiguration.fVirtIOInputMouseIRQ);
      VirtIOInputMouseNode.AddPropertyCells('interrupts-extended',@Cells,2);
     finally
      SoCNode.AddChild(VirtIOInputMouseNode);
     end;

     if fConfiguration.fSoundMode=TSoundMode.VirtIO then begin
      VirtIOSoundNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'virtio',fConfiguration.fVirtIOSoundBase);
      try
       VirtIOSoundNode.AddPropertyString('compatible','virtio,mmio');
       Cells[0]:=0;
       Cells[1]:=fConfiguration.fVirtIOSoundBase;
       Cells[2]:=0;
       Cells[3]:=fConfiguration.fVirtIOSoundSize;
       VirtIOSoundNode.AddPropertyCells('reg',@Cells,4);
       Cells[0]:=INTC0.GetPHandle;
       Cells[1]:=TPasRISCVUInt32(fConfiguration.fVirtIOSoundIRQ);
       VirtIOSoundNode.AddPropertyCells('interrupts-extended',@Cells,2);
      finally
       SoCNode.AddChild(VirtIOSoundNode);
      end;
     end;
     // FM801 is a PCI device - discovered via PCI enumeration, no FDT node needed

     VirtIO9PNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'virtio',fConfiguration.fVirtIO9PBase);
     try
      VirtIO9PNode.AddPropertyString('compatible','virtio,mmio');
      Cells[0]:=0;
      Cells[1]:=fConfiguration.fVirtIO9PBase;
      Cells[2]:=0;
      Cells[3]:=fConfiguration.fVirtIO9PSize;
      VirtIO9PNode.AddPropertyCells('reg',@Cells,4);
      Cells[0]:=INTC0.GetPHandle;
      Cells[1]:=TPasRISCVUInt32(fConfiguration.fVirtIO9PIRQ);
      VirtIO9PNode.AddPropertyCells('interrupts-extended',@Cells,2);
     finally
      SoCNode.AddChild(VirtIO9PNode);
     end;

     VirtIONetNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'virtio',fConfiguration.fVirtIONetBase);
     try
      VirtIONetNode.AddPropertyString('compatible','virtio,mmio');
      Cells[0]:=0;
      Cells[1]:=fConfiguration.fVirtIONetBase;
      Cells[2]:=0;
      Cells[3]:=fConfiguration.fVirtIONetSize;
      VirtIONetNode.AddPropertyCells('reg',@Cells,4);
      Cells[0]:=INTC0.GetPHandle;
      Cells[1]:=TPasRISCVUInt32(fConfiguration.fVirtIONetIRQ);
      VirtIONetNode.AddPropertyCells('interrupts-extended',@Cells,2);
     finally
      SoCNode.AddChild(VirtIONetNode);
     end;

     VirtIORandomGeneratorNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'virtio',fConfiguration.fVirtIORandomGeneratorBase);
     try
      VirtIORandomGeneratorNode.AddPropertyString('compatible','virtio,mmio');
      Cells[0]:=0;
      Cells[1]:=fConfiguration.fVirtIORandomGeneratorBase;
      Cells[2]:=0;
      Cells[3]:=fConfiguration.fVirtIORandomGeneratorSize;
      VirtIORandomGeneratorNode.AddPropertyCells('reg',@Cells,4);
      Cells[0]:=INTC0.GetPHandle;
      Cells[1]:=TPasRISCVUInt32(fConfiguration.fVirtIORandomGeneratorIRQ);
      VirtIORandomGeneratorNode.AddPropertyCells('interrupts-extended',@Cells,2);
     finally
      SoCNode.AddChild(VirtIORandomGeneratorNode);
     end;

     if fConfiguration.fDisplayMode=TDisplayMode.VirtIOGPU then begin
      VirtIOGPUNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'virtio',fConfiguration.fVirtIOGPUBase);
      try
       VirtIOGPUNode.AddPropertyString('compatible','virtio,mmio');
       Cells[0]:=0;
       Cells[1]:=fConfiguration.fVirtIOGPUBase;
       Cells[2]:=0;
       Cells[3]:=fConfiguration.fVirtIOGPUSize;
       VirtIOGPUNode.AddPropertyCells('reg',@Cells,4);
       Cells[0]:=INTC0.GetPHandle;
       Cells[1]:=TPasRISCVUInt32(fConfiguration.fVirtIOGPUIRQ);
       VirtIOGPUNode.AddPropertyCells('interrupts-extended',@Cells,2);
      finally
       SoCNode.AddChild(VirtIOGPUNode);
      end;
     end;

     VirtIOVSockNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'virtio',fConfiguration.fVirtIOVSockBase);
     try
      VirtIOVSockNode.AddPropertyString('compatible','virtio,mmio');
      Cells[0]:=0;
      Cells[1]:=fConfiguration.fVirtIOVSockBase;
      Cells[2]:=0;
      Cells[3]:=fConfiguration.fVirtIOVSockSize;
      VirtIOVSockNode.AddPropertyCells('reg',@Cells,4);
      Cells[0]:=INTC0.GetPHandle;
      Cells[1]:=TPasRISCVUInt32(fConfiguration.fVirtIOVSockIRQ);
      VirtIOVSockNode.AddPropertyCells('interrupts-extended',@Cells,2);
     finally
      SoCNode.AddChild(VirtIOVSockNode);
     end;

     if fConfiguration.fRTCMode=TRTCMode.VirtIO then begin
      VirtIORTCNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'virtio',fConfiguration.fVirtIORTCBase);
      try
       VirtIORTCNode.AddPropertyString('compatible','virtio,mmio');
       Cells[0]:=0;
       Cells[1]:=fConfiguration.fVirtIORTCBase;
       Cells[2]:=0;
       Cells[3]:=fConfiguration.fVirtIORTCSize;
       VirtIORTCNode.AddPropertyCells('reg',@Cells,4);
       Cells[0]:=INTC0.GetPHandle;
       Cells[1]:=TPasRISCVUInt32(fConfiguration.fVirtIORTCIRQ);
       VirtIORTCNode.AddPropertyCells('interrupts-extended',@Cells,2);
      finally
       SoCNode.AddChild(VirtIORTCNode);
      end;
     end;

    end;

   end;

   if fConfiguration.fRTCMode=TRTCMode.DS1307 then begin

    I2CClockNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'i2c_clk');
    try
     I2CClockNode.AddPropertyString('compatible','fixed-clock');
     I2CClockNode.AddPropertyU32('#clock-cells',0);
     I2CClockNode.AddPropertyU32('clock-frequency',20000000);
     I2CClockNode.AddPropertyString('clock-output-names','clk');
    finally
     SoCNode.AddChild(I2CClockNode);
    end;

    case fConfiguration.fI2CMode of
     TI2CMode.OpenCores:begin
      I2CNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'i2c',fConfiguration.fOpenCoresI2CBase);
     end;
     else begin
      I2CNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'i2c',fConfiguration.fDesignWareI2CBase);
     end;
    end;
    try
     case fConfiguration.fI2CMode of
      TI2CMode.OpenCores:begin
       Cells[0]:=0;
       Cells[1]:=fConfiguration.fOpenCoresI2CBase;
       Cells[2]:=0;
       Cells[3]:=fConfiguration.fOpenCoresI2CSize;
       I2CNode.AddPropertyCells('reg',@Cells,4);
       I2CNode.AddPropertyString('compatible','opencores,i2c-ocores');
       I2CNode.AddPropertyU32('reg-shift',2);
       I2CNode.AddPropertyU32('reg-io-width',1);
       I2CNode.AddPropertyU32('opencores,ip-clock-frequency',20000000);
      end;
      else begin
       Cells[0]:=0;
       Cells[1]:=fConfiguration.fDesignWareI2CBase;
       Cells[2]:=0;
       Cells[3]:=fConfiguration.fDesignWareI2CSize;
       I2CNode.AddPropertyCells('reg',@Cells,4);
       I2CNode.AddPropertyString('compatible','snps,designware-i2c');
      end;
     end;
     I2CNode.AddPropertyU32('interrupt-parent',INTC0.GetPHandle);
     if fConfiguration.fAIA then begin
      // APLIC: #interrupt-cells=2, need IRQ number + trigger type (4 = level high)
      Cells[0]:=TI2CDevice.IRQ;
      Cells[1]:=4; // IRQ_TYPE_LEVEL_HIGH
      I2CNode.AddPropertyCells('interrupts',@Cells,2);
     end else begin
      // PLIC: #interrupt-cells=1, just IRQ number
      I2CNode.AddPropertyU32('interrupts',TI2CDevice.IRQ);
     end;
     I2CNode.AddPropertyU32('clocks',I2CClockNode.GetPHandle);
     I2CNode.AddPropertyString('clock-names','clk');
     I2CNode.AddPropertyU32('clock-frequency',100000);
     I2CNode.AddPropertyU32('#address-cells',1);
     I2CNode.AddPropertyU32('#size-cells',0);
     I2CNode.AddPropertyString('status','okay');

     I2CDS1307Node:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'rtc',TDS1307I2CBusDevice.DS1307_ADDRESS);
     try
      I2CDS1307Node.AddPropertyString('compatible','dallas,ds1307');
      I2CDS1307Node.AddPropertyU32('reg',TDS1307I2CBusDevice.DS1307_ADDRESS);
      I2CDS1307Node.AddPropertyString('status','okay');
     finally
      I2CNode.AddChild(I2CDS1307Node);
     end;

{    I2CHIDKeyboardNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'i2c',TI2CHIDKeyboardBusDevice.Address);
     try
      I2CHIDKeyboardNode.AddPropertyString('compatible','hid-over-i2c');
      I2CHIDKeyboardNode.AddPropertyU32('reg',TI2CHIDKeyboardBusDevice.Address);
      I2CHIDKeyboardNode.AddPropertyU32('hid-descr-addr',TI2CHIDKeyboardBusDevice.DESC_REG);
      I2CHIDKeyboardNode.AddPropertyU32('interrupt-parent',INTC0.GetPHandle);
      I2CHIDKeyboardNode.AddPropertyU32('interrupts',TI2CHIDKeyboardBusDevice.IRQ);
     finally
      I2CNode.AddChild(I2CHIDKeyboardNode);
     end;//\}

    finally
     SoCNode.AddChild(I2CNode);
    end;

   end;

   if assigned(fVirtIOBlockDevice) then begin

    VirtIOBlockNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'virtio',fConfiguration.fVirtIOBlockBase);
    try
     VirtIOBlockNode.AddPropertyString('compatible','virtio,mmio');
     Cells[0]:=0;
     Cells[1]:=fConfiguration.fVirtIOBlockBase;
     Cells[2]:=0;
     Cells[3]:=fConfiguration.fVirtIOBlockSize;
     VirtIOBlockNode.AddPropertyCells('reg',@Cells,4);
     Cells[0]:=INTC0.GetPHandle;
     Cells[1]:=TPasRISCVUInt32(fConfiguration.fVirtIOBlockIRQ);
     VirtIOBlockNode.AddPropertyCells('interrupts-extended',@Cells,2);
    finally
     SoCNode.AddChild(VirtIOBlockNode);
    end;

   end;

  finally
   fFDT.fRoot.AddChild(SoCNode);
  end;

  ReservedMemoryNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'reserved-memory');
  try
   ReservedMemoryNode.AddPropertyU32('#address-cells',2);
   ReservedMemoryNode.AddPropertyU32('#size-cells',2);
   ReservedMemoryNode.AddProperty('ranges',Cells,0);
   SharedMemoryNode:=TPasRISCV.TFDT.TFDTNode.Create(fFDT,'shared-memory',fConfiguration.fSharedMemoryBase);
   try
    SharedMemoryNode.AddPropertyString('compatible','pasriscv,shared-memory');
    Cells[0]:=0;
    Cells[1]:=fConfiguration.fSharedMemoryBase;
    Cells[2]:=0;
    Cells[3]:=fConfiguration.fSharedMemorySize;
    SharedMemoryNode.AddPropertyCells('reg',@Cells,4);
    SharedMemoryNode.AddProperty('no-map',Cells,0);
    Cells[0]:=INTC0.GetPHandle;
    Cells[1]:=TPasRISCVUInt32(fConfiguration.fSharedMemoryIRQ);
    SharedMemoryNode.AddPropertyCells('interrupts-extended',@Cells,2);
   finally
    ReservedMemoryNode.AddChild(SharedMemoryNode);
   end;
  finally
   fFDT.fRoot.AddChild(ReservedMemoryNode);
  end;

 {FileStream:=TFileStream.Create('fdt.dtb',fmCreate);
  try
   fFDT.SerializeToStream(FileStream);
  finally
   FreeAndNil(FileStream);
  end;//}

  fFDTStream.Clear;
  fFDT.SerializeToStream(fFDTStream);

 finally
  CPUNodes:=nil;
 end;

end;

function TPasRISCV.LoadELFIntoMemory(const aBinary:TMemoryStream;const aOffset:TPasRISCVUInt64;out aSize:TPasRISCVUInt64;const aObjCopy:Boolean):Boolean;
const ELF_ET_NONE=$0;
      ELF_ET_REL=$1;
      ELF_ET_EXEC=$2;
      ELF_ET_DYN=$3;
      ELF_PT_NULL=$0;
      ELF_PT_LOAD=$1;
      ELF_PT_DYNAMIC=$2;
      ELF_PT_INTERP=$3;
      ELF_PT_NOTE=$4;
      ELF_PT_SHLIB=$5;
      ELF_PT_PHDR=$6;
      ELF_PT_TLS=$7;
      ELF_PF_X=$1;
      ELF_PF_W=$2;
      ELF_PF_R=$4;
      ELF_PN_XNUM=$ffff;
var Tmp:array[0..63] of TPasRISCVUInt8;
    ObjCopy,Class64:Boolean;
    ELFType:TPasRISCVUInt16;
    ELFEntry:TPasRISCVUInt64;
    ELFPHOffset,ELFPHSize,ELFPHNum,ELFLoAddr,ELFHiAddr,ELFPHEntryOffset,
    PType,PVAddr,PMemSize,POffset,PFSize,PHDR,BufferSize,Base:TPasRISCVUInt64;
    Index:TPasRISCVSizeInt;
 function ReadUInt16LE(const aData:pointer):TPasRISCVUInt16;
 begin
{$ifdef LITTLE_ENDIAN}
  result:=PPasRISCVUInt16(aData)^;
{$else}
  result:=TPasRISCVUInt16(PPasRISCVUInt8(aData)^) or
         (TPasRISCVUInt16(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+1)))^) shl 8);
{$endif}
 end;
 function ReadUInt32LE(const aData:pointer):TPasRISCVUInt32;
 begin
 {$ifdef LITTLE_ENDIAN}
  result:=PPasRISCVUInt32(aData)^;
{$else}
  result:=TPasRISCVUInt32(PPasRISCVUInt8(aData)^) or
         (TPasRISCVUInt32(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+1)))^) shl 8) or
         (TPasRISCVUInt32(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+2)))^) shl 16) or
         (TPasRISCVUInt32(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+3)))^) shl 24);
{$endif}
 end;
 function ReadUInt64LE(const aData:pointer):TPasRISCVUInt64;
 begin
 {$ifdef LITTLE_ENDIAN}
  result:=PPasRISCVUInt64(aData)^;
{$else}
  result:=TPasRISCVUInt64(PPasRISCVUInt8(aData)^) or
         (TPasRISCVUInt64(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+1)))^) shl 8) or
         (TPasRISCVUInt64(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+2)))^) shl 16) or
         (TPasRISCVUInt64(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+3)))^) shl 24) or
         (TPasRISCVUInt64(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+4)))^) shl 32) or
         (TPasRISCVUInt64(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+5)))^) shl 40) or
         (TPasRISCVUInt64(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+6)))^) shl 48) or
         (TPasRISCVUInt64(PPasRISCVUInt8(Pointer(TPasRISCVPtrUInt(TPasRISCVPtrUInt(aData)+7)))^) shl 56);
{$endif}
 end;
begin

 result:=false;

 if assigned(aBinary) and (aBinary.Size>=64) then begin

  aBinary.Seek(0,soBeginning);
  aBinary.ReadBuffer(Tmp[0],64);

  if (TPasRISCVUInt32((TPasRISCVUInt32(Tmp[0]) shl 0) or
                      (TPasRISCVUInt32(Tmp[1]) shl 8) or
                      (TPasRISCVUInt32(Tmp[2]) shl 16) or
                      (TPasRISCVUInt32(Tmp[3]) shl 24))=$464c457f) and // ELF magic
     ((TPasRISCVUInt8(Tmp[4])=1) or // 32-bit
      (TPasRISCVUInt8(Tmp[4])=2)) and // 64-bit
     (TPasRISCVUInt8(Tmp[5])=1) then begin // Little endian

   Base:=aOffset;

   ObjCopy:=aObjCopy;

   Class64:=TPasRISCVUInt8(Tmp[4])=2;

   ELFType:=ReadUInt16LE(@Tmp[16]);

   if Class64 then begin
    ELFEntry:=ReadUInt64LE(@Tmp[24]);
    ELFPHOffset:=ReadUInt64LE(@Tmp[32]);
    ELFPHSize:=56;
    ELFPHNum:=ReadUInt16LE(@Tmp[56]);
   end else begin
    ELFEntry:=ReadUInt32LE(@Tmp[24]);
    ELFPHOffset:=ReadUInt32LE(@Tmp[28]);
    ELFPHSize:=32;
    ELFPHNum:=ReadUInt16LE(@Tmp[44]);
   end;

   ELFLoAddr:=TPasRISCVUInt64($ffffffffffffffff);
   ELFHiAddr:=0;

   PHDR:=0;

   for Index:=0 to TPasRISCVSizeInt(ELFPHNum)-1 do begin

    ELFPHEntryOffset:=ELFPHOffset+(Index*ELFPHSize);

    aBinary.Seek(ELFPHEntryOffset,soBeginning);
    aBinary.ReadBuffer(Tmp[0],ELFPHSize);

    PType:=ReadUInt32LE(@Tmp[0]);
    if Class64 then begin
     PVAddr:=ReadUInt64LE(@Tmp[16]);
     PMemSize:=ReadUInt64LE(@Tmp[40]);
    end else begin
     PVAddr:=ReadUInt32LE(@Tmp[8]);
     PMemSize:=ReadUInt32LE(@Tmp[20]);
    end;
    case PType of
     ELF_PT_LOAD,ELF_PT_PHDR:begin
      if PVAddr<ELFLoAddr then begin
       ELFLoAddr:=PVAddr;
      end;
      if (PVAddr+PMemSize)>ELFHiAddr then begin
       ELFHiAddr:=PVAddr+PMemSize;
      end;
      if PType=ELF_PT_PHDR then begin
       PHDR:=PVAddr;
      end;
     end;
     else begin
     end;
    end;

   end;

   if ELFLoAddr=TPasRISCVUInt64($ffffffffffffffff) then begin
    ELFLoAddr:=0; // No loadable segments
   end;

   if ObjCopy then begin
    if ELFEntry<>0 then begin
     dec(ELFEntry,ELFLoAddr);
    end;
    if PHDR<>0 then begin
     dec(PHDR,ELFLoAddr);
    end;
    BufferSize:=fMemoryDevice.fSize-aOffset;
   end else begin
    BufferSize:=ELFHiAddr-ELFLoAddr;
    if ELFType=ELF_ET_DYN then begin
    end;
    if ELFEntry<>0 then begin
     inc(ELFEntry,Base);
    end;
    if PHDR<>0 then begin
     inc(PHDR,Base);
    end;
   end;

   for Index:=0 to TPasRISCVSizeInt(ELFPHNum)-1 do begin

    ELFPHEntryOffset:=ELFPHOffset+(Index*ELFPHSize);

    aBinary.Seek(ELFPHEntryOffset,soBeginning);
    aBinary.ReadBuffer(Tmp[0],ELFPHSize);

    PType:=ReadUInt32LE(@Tmp[0]);
    if Class64 then begin
     POffset:=ReadUInt64LE(@Tmp[8]);
     PVAddr:=ReadUInt64LE(@Tmp[16]);
     PFSize:=ReadUInt64LE(@Tmp[32]);
     PMemSize:=ReadUInt64LE(@Tmp[40]);
    end else begin
     POffset:=ReadUInt32LE(@Tmp[4]);
     PVAddr:=ReadUInt32LE(@Tmp[8]);
     PFSize:=ReadUInt32LE(@Tmp[16]);
     PMemSize:=ReadUInt32LE(@Tmp[20]);
    end;

    case PType of
     ELF_PT_LOAD,ELF_PT_PHDR:begin
      if OBJCopy then begin
       dec(PVAddr,ELFLoAddr);
       if (PVAddr+PMemSize)>BufferSize then begin
        exit; // Too large
       end;
      end;
      aBinary.Seek(POffset,soBeginning);
      aBinary.ReadBuffer(PPasRISCVUInt8Array(fMemoryDevice.fData)^[PVAddr+Base],PFSize);
     end;
     ELF_PT_INTERP:begin
      // Ignore for now
     end;
     else begin
     end;
    end;

   end;

   result:=true;

  end;

 end;

end;


function TPasRISCV.LoadBinaryIntoMemory(const aBinary: TMemoryStream;
 const aOffset: TPasRISCVUInt64; out aSize: TPasRISCVUInt64;
 const aCanELF: Boolean; const aObjCopy: Boolean): Boolean;
begin

 result:=false;

 if assigned(aBinary) then begin

  if aBinary.Size>0 then begin

   aBinary.Seek(0,soBeginning);

   aSize:=aBinary.Size;

   if aSize>0 then begin

    if aCanELF and LoadELFIntoMemory(aBinary,aOffset,aSize,aObjCopy) then begin

     result:=true;

    end else begin

     if (aOffset+aSize)<=fMemoryDevice.fSize then begin
      aBinary.Seek(0,soBeginning);
      aBinary.ReadBuffer(PPasRISCVUInt8Array(fMemoryDevice.fData)^[aOffset],aSize);
      result:=true;
     end else begin
      raise EPasRISCV.Create('Binary does not fit into memory, at least '+IntToStr(aSize)+' bytes at offset '+IntToStr(aOffset)+' are required');
     end;
    end;

   end;

  end;

 end;

end;

function TPasRISCV.LoadINITRDIntoMemory(const aBinary:TMemoryStream;const aOffset:TPasRISCVUInt64;out aSize:TPasRISCVUInt64):Boolean;
const CompressionNone=0;
      CompressionDeflate=1;
      CompressionGZIP=2;
var CompressionMethod:TPasRISCVUInt32;
    Tmp:array[0..1] of TPasRISCVUInt8;
    CompressedSize,UncompressedSize:TPasRISCVSizeUInt;
    CompressedData,UncompressedData:pointer;
begin

 result:=false;

 if assigned(aBinary) and (aBinary.Size>4) then begin

  aBinary.Seek(0,soBeginning);
  aBinary.ReadBuffer(Tmp[0],2);
  if Tmp[0]=$1f then begin
   case Tmp[1] of
    $08:begin
     CompressionMethod:=CompressionDeflate;
    end;
    $8b:begin
     CompressionMethod:=CompressionGZIP;
    end;
    else begin
     CompressionMethod:=CompressionNone;
    end;
   end;
  end else begin
   CompressionMethod:=CompressionNone;
  end;

  aBinary.Seek(0,soBeginning);

  case CompressionMethod of
   CompressionDeflate,
   CompressionGZIP:begin

    CompressedSize:=aBinary.Size;

    GetMem(CompressedData,CompressedSize);
    try

     aBinary.Seek(0,soBeginning);
     aBinary.ReadBuffer(CompressedData^,CompressedSize);

     UncompressedData:=nil;
     try

      if DoInflate(CompressedData,CompressedSize,UncompressedData,UncompressedSize,true) then begin

       aSize:=UncompressedSize;

       if (aOffset+aSize)<=fMemoryDevice.Size then begin
        Move(UncompressedData^,PPasRISCVUInt8Array(fMemoryDevice.fData)^[aOffset],aSize);
        result:=true;
       end else begin
        raise EPasRISCV.Create('INITRD does not fit into memory, at least '+IntToStr(aSize)+' bytes at offset '+IntToStr(aOffset)+' are required');
       end;

      end else begin

       // Decompression failed, try to load as is, so that the kernel can handle it itself, since it is just a performance optimization to decompress it here beforehands

       aSize:=CompressedSize;

       if (aOffset+aSize)<=fMemoryDevice.fSize then begin
        Move(CompressedData^,PPasRISCVUInt8Array(fMemoryDevice.fData)^[aOffset],aSize);
        result:=true;
       end else begin
        raise EPasRISCV.Create('INITRD does not fit into memory, at least '+IntToStr(aSize)+' bytes at offset '+IntToStr(aOffset)+' are required');
       end;

      end;

     finally
      if assigned(UncompressedData) then begin
       FreeMem(UncompressedData);
      end;
     end;

    finally
     FreeMem(CompressedData);
    end;

   end;
   else begin

    aSize:=aBinary.Size;

    if (aOffset+aSize)<=fMemoryDevice.fSize then begin
     aBinary.Seek(0,soBeginning);
     aBinary.ReadBuffer(PPasRISCVUInt8Array(fMemoryDevice.fData)^[aOffset],aSize);
     result:=true;
    end else begin
     raise EPasRISCV.Create('INITRD does not fit into memory, at least '+IntToStr(aSize)+' bytes at offset '+IntToStr(aOffset)+' are required');
    end;

   end;
  end;

 end;

end;

procedure TPasRISCV.Reset;
var Index:TPasRISCVSizeInt;
    BIOSOffset,BIOSSize:TPasRISCVUInt64;
    FDTOffset,FDTSize:TPasRISCVUInt64;
    HasBIOS,HasKernel,HasINITRD:Boolean;
    StartCode:PPasRISCVUInt32Array;
begin

 BIOSOffset:=0; // Hardwired to 0
 BIOSSize:=0;
 HasBIOS:=LoadBinaryIntoMemory(fConfiguration.fBIOS,BIOSOffset,BIOSSize,true,true);

{if BIOSSize>KERNEL_OFFSET then begin
  raise EPasRISCV.Create('BIOS size is too large');
 end;}

 fKernelOffset:=KERNEL_OFFSET;
 fKernelSize:=0;
 HasKernel:=LoadBinaryIntoMemory(fConfiguration.fKernel,fKernelOffset,fKernelSize,true,true);

 if HasBIOS or HasKernel then begin

  if HasKernel then begin
   fINITRDOffset:=fKernelOffset+fKernelSize;
  end else begin
   fINITRDOffset:=BIOSOffset+BIOSSize;
  end;
  if (fINITRDOffset and $fff)<>0 then begin
   inc(fINITRDOffset,$1000-(fINITRDOffset and $fff));
  end;
  fINITRDSize:=0;
  HasINITRD:=LoadINITRDIntoMemory(fConfiguration.fINITRD,fINITRDOffset,fINITRDSize);

 end;

 InitializeFDT;

 FDTOffset:=$1000+(8*8);
 FDTSize:=fFDTStream.Size;
 Move(fFDTStream.Memory^,PPasRISCVUInt8Array(fBootMemoryDevice.fData)^[FDTOffset-fBootMemoryDevice.fBase],FDTSize);
 fFDTMemoryOffset:=fConfiguration.fBootMemoryBase+FDTOffset;

 StartCode:=Pointer(@PPasRISCVUInt8Array(fBootMemoryDevice.fData)^[$1000]);
 StartCode^[0]:=$00000297+($80000000-$1000);                     // auipc t0, jump_addr
 StartCode^[1]:=$00000597;                                       // auipc a1, dtb
 StartCode^[2]:=$00058593+(TPasRISCVUInt32(FDTOffset-4) shl 20); // addi a1, a1, dtb
 StartCode^[3]:=$f1402573;                                       // csrr a0, mhartid
 StartCode^[4]:=$00028067;                                       // jalr zero, t0, jump_addr

 fStartStackPointer:=fConfiguration.fMemoryBase+fConfiguration.fMemorySize; // Initial startup stack starts below FDT at the end of the memory

 fACLINTDevice.Reset;
 if assigned(fIMSICMachineDevice) then begin
  fIMSICMachineDevice.Reset;
 end;
 if assigned(fIMSICSupervisorDevice) then begin
  fIMSICSupervisorDevice.Reset;
 end;
 if assigned(fPLICDevice) then begin
  fPLICDevice.Reset;
 end;
 fSYSCONDevice.Reset;
 if assigned(fVirtIOBlockDevice) then begin
  fVirtIOBlockDevice.Reset;
 end;
 fUARTDevice.Reset;
 if assigned(fDS1742Device) then begin
  fDS1742Device.Reset;
 end;
 fPCIBusDevice.Reset;
 if assigned(fSimpleFBDevice) then begin
  fSimpleFBDevice.Reset;
 end;
 fRawKeyboardDevice.Reset;
//fI2CDevice.Reset;
 fPS2KeyboardDevice.Reset;
 fPS2MouseDevice.Reset;
 fVirtIOInputKeyboardDevice.Reset;
 fVirtIOInputMouseDevice.Reset;
 if assigned(fVirtIOSoundDevice) then begin
  fVirtIOSoundDevice.Reset;
 end;
 fVirtIO9PDevice.Reset;
 fVirtIONetDevice.Reset;
 fVirtIORandomGeneratorDevice.Reset;
 if assigned(fVirtIOGPUDevice) then begin
  fVirtIOGPUDevice.Reset;
 end;

 if assigned(fNVMeDevice) then begin
  fNVMeDevice.Reset;
 end;

 if assigned(fBochsVBEDevice) then begin
  fBochsVBEDevice.Reset;
 end;

 if assigned(fCirrusDevice) then begin
  fCirrusDevice.Reset;
 end;

 for Index:=0 to length(fHARTs)-1 do begin
  fHARTs[Index].Init;
 end;

end;

function TPasRISCV.GetRunning:Boolean;
begin
 result:=(fRunState and RUNSTATE_POWEROFF)=0;
end;

procedure TPasRISCV.Execute(const aSingleStep:Boolean);
var Index:TPasRISCVSizeInt;
    RunStateUntilMask:TPasRISCVUInt32;
    SingleStepExecuted:Boolean;
{$ifdef PasRISCVStepDebugOutput}
    DebugActive:Boolean;
    RunStateValue,RunningMaskValue:TPasRISCVUInt32;
{$endif}
begin

 RunStateUntilMask:=RUNSTATE_POWEROFF;

 if aSingleStep then begin
  TPasMPInterlocked.BitwiseOr(fRunState,RUNSTATE_SINGLESTEP);
  RunStateUntilMask:=RunStateUntilMask or RUNSTATE_SINGLESTEP;
 end else begin
  TPasMPInterlocked.BitwiseAnd(fRunState,TPasMPUInt32(not TPasMPUInt32(RUNSTATE_SINGLESTEP)));
 end;

 if (fRunState and RUNSTATE_POWEROFF)=0 then begin

  repeat

   if (fRunState and RUNSTATE_PAUSING)=RUNSTATE_PAUSING then begin

    TPasMPInterlocked.ExchangeBitwiseAndOr(fRunState,TPasMPUInt32(not TPasMPUInt32(RUNSTATE_PAUSING)),TPasMPUInt32(RUNSTATE_PAUSED));

{$if defined(PasRISCVSingleStepRunStateWait)}
    fHARTStatusChangeConditionVariableLock.Acquire;
    try
     fHARTStatusChangeConditionVariable.Broadcast;
    finally
     fHARTStatusChangeConditionVariableLock.Release;
    end;
{$ifend}

{$ifdef PasRISCVStepDebugOutput}
    RunStateValue:=TPasMPInterlocked.Read(fRunState);
    DebugActive:=(RunStateValue and (RUNSTATE_SINGLESTEP or RUNSTATE_PAUSED or RUNSTATE_PAUSING))<>0;
    if DebugActive then begin
     RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
     WriteLn('DBG Execute pausing->paused runstate=0x'+LowerCase(IntToHex(RunStateValue,8))+
             ' running=0x'+LowerCase(IntToHex(RunningMaskValue,8)));
    end;
{$endif}
    
    if assigned(fDebugger) then begin
     fDebugger.NotifyPaused;
    end;

   end;

   if (fRunState and (RUNSTATE_RUNNING or RUNSTATE_PAUSED or RUNSTATE_POWEROFF))=(RUNSTATE_RUNNING or RUNSTATE_PAUSED) then begin

{$ifdef PasRISCVStepDebugOutput}
    RunStateValue:=TPasMPInterlocked.Read(fRunState);
    DebugActive:=(RunStateValue and (RUNSTATE_SINGLESTEP or RUNSTATE_PAUSED or RUNSTATE_PAUSING))<>0;
    if DebugActive then begin
     RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
     WriteLn('DBG Execute pause wait start runstate=0x'+LowerCase(IntToHex(RunStateValue,8))+
             ' running=0x'+LowerCase(IntToHex(RunningMaskValue,8)));
    end;
{$endif}

    fWakeUpConditionVariableLock.Acquire;
    try
     while (fRunState and (RUNSTATE_RUNNING or RUNSTATE_PAUSED or RUNSTATE_POWEROFF))=(RUNSTATE_RUNNING or RUNSTATE_PAUSED) do begin
      fWakeUpConditionVariable.Wait(fWakeUpConditionVariableLock,100);
     end;
    finally
     fWakeUpConditionVariableLock.Release;
    end;

{$ifdef PasRISCVStepDebugOutput}
    RunStateValue:=TPasMPInterlocked.Read(fRunState);
    DebugActive:=(RunStateValue and (RUNSTATE_SINGLESTEP or RUNSTATE_PAUSED or RUNSTATE_PAUSING))<>0;
    if DebugActive then begin
     RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
     WriteLn('DBG Execute pause wait done runstate=0x'+LowerCase(IntToHex(RunStateValue,8))+
             ' running=0x'+LowerCase(IntToHex(RunningMaskValue,8)));
    end;
{$endif}

    if (fRunState and RUNSTATE_POWEROFF)<>0 then begin
     break;
    end;

   end;

   if (fRunState and RUNSTATE_REBOOT)<>0 then begin
    Reset;
    if assigned(fOnReboot) then begin
     fOnReboot;
    end;
    TPasMPInterlocked.BitwiseAnd(fRunState,TPasMPUInt32(not TPasMPUInt32(RUNSTATE_REBOOT)));
   end;

   if aSingleStep and ((fRunState and RUNSTATE_SINGLESTEP)<>0) then begin

    for Index:=0 to length(fHARTs)-1 do begin
     fHARTs[Index].Execute;
    end;

    SingleStepExecuted:=true;

   end else begin

    SingleStepExecuted:=(fRunState and RUNSTATE_SINGLESTEP)<>0;

{$ifdef PasRISCVStepDebugOutput}
    RunStateValue:=TPasMPInterlocked.Read(fRunState);
    DebugActive:=(RunStateValue and (RUNSTATE_SINGLESTEP or RUNSTATE_PAUSED or RUNSTATE_PAUSING))<>0;
    if DebugActive then begin
     RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
     WriteLn('DBG Execute activate harts runstate=0x'+LowerCase(IntToHex(RunStateValue,8))+
             ' running=0x'+LowerCase(IntToHex(RunningMaskValue,8)));
    end;
{$endif}

    fHARTWakeUpConditionVariableLock.Acquire;
    try
     TPasMPInterlocked.BitwiseOr(fHARTActiveMask,fAllHARTMask);
     fHARTWakeUpConditionVariable.Broadcast;
    finally
     fHARTWakeUpConditionVariableLock.Release;
    end;

    fHARTStatusChangeConditionVariableLock.Acquire;
    try
     while TPasMPInterlocked.Read(fHARTRunningMask)<>0 do begin
      fHARTStatusChangeConditionVariable.Wait(fHARTStatusChangeConditionVariableLock);
     end;
    finally
     fHARTStatusChangeConditionVariableLock.Release;
    end;

{$ifdef PasRISCVStepDebugOutput}
    RunStateValue:=TPasMPInterlocked.Read(fRunState);
    DebugActive:=(RunStateValue and (RUNSTATE_SINGLESTEP or RUNSTATE_PAUSED or RUNSTATE_PAUSING))<>0;
    if DebugActive then begin
     RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
     WriteLn('DBG Execute harts done runstate=0x'+LowerCase(IntToHex(RunStateValue,8))+
             ' running=0x'+LowerCase(IntToHex(RunningMaskValue,8)));
    end;
{$endif}

   end;

   if SingleStepExecuted and ((fRunState and RUNSTATE_SINGLESTEP)<>0) and not aSingleStep then begin
    
    SingleStepExecuted:=false;

{$ifdef PasRISCVStepDebugOutput}
    RunStateValue:=TPasMPInterlocked.Read(fRunState);
    DebugActive:=(RunStateValue and (RUNSTATE_SINGLESTEP or RUNSTATE_PAUSED or RUNSTATE_PAUSING))<>0;
    if DebugActive then begin
     RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
     WriteLn('DBG Execute step done->pausing runstate=0x'+LowerCase(IntToHex(RunStateValue,8))+
             ' running=0x'+LowerCase(IntToHex(RunningMaskValue,8)));
    end;
{$endif}

{$ifdef PasRISCVSingleStepCounter}
    fHARTStatusChangeConditionVariableLock.Acquire;
    try
     TPasMPInterlocked.Increment(fSingleStepCounter);
     fHARTStatusChangeConditionVariable.Broadcast;
    finally
     fHARTStatusChangeConditionVariableLock.Release;
    end;
{$endif}

    TPasMPInterlocked.ExchangeBitwiseAndOr(fRunState,TPasMPUInt32(not TPasMPUInt32(RUNSTATE_SINGLESTEP)),TPasMPUInt32(RUNSTATE_PAUSING));

{$if defined(PasRISCVSingleStepRunStateWait)}
    fHARTStatusChangeConditionVariableLock.Acquire;
    try
     fHARTStatusChangeConditionVariable.Broadcast;
    finally
     fHARTStatusChangeConditionVariableLock.Release;
    end;
{$ifend}

   end;

  until (fRunState and RunStateUntilMask)<>0;

 end;

end;

procedure TPasRISCV.Step;
begin
 Execute(true);
end;

procedure TPasRISCV.Run;
begin
 Execute(false);
end;

procedure TPasRISCV.Reboot;
begin
 TPasMPInterlocked.BitwiseOr(fRunState,RUNSTATE_REBOOT);
end;

procedure TPasRISCV.PowerOff;
begin
 TPasMPInterlocked.BitwiseOr(fRunState,RUNSTATE_POWEROFF);
end;

procedure TPasRISCV.FlushTLB;
begin
 TPasMPInterlocked.BitwiseOr(fFlushTLBHARTMask,fAllHARTMask);
 TPasMPInterlocked.BitwiseOr(fRunState,fAllHARTMask);
end;

procedure TPasRISCV.Interrupt;
begin
 TPasMPInterlocked.BitwiseOr(fRunState,fAllHARTMask);
end;

procedure TPasRISCV.WakeUp;
begin
 fWakeUpConditionVariable.Broadcast;
end;

procedure TPasRISCV.InterruptAndWakeUp;
begin
 fWakeUpConditionVariableLock.Acquire;
 try
  TPasMPInterlocked.BitwiseOr(fRunState,fAllHARTMask);
  fWakeUpConditionVariable.Broadcast;
 finally
  fWakeUpConditionVariableLock.Release;
 end;
end;

function TPasRISCV.QueuePause(const aWaitUntilHalted:Boolean):Boolean;
{$ifdef PasRISCVStepDebugOutput}
var RunStateValue,RunningMaskValue:TPasRISCVUInt32;
{$endif}
begin

{$ifdef PasRISCVStepDebugOutput}
 RunStateValue:=TPasMPInterlocked.Read(fRunState);
 RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
 WriteLn('DBG QueuePause enter runstate=0x'+LowerCase(IntToHex(RunStateValue,8))+
         ' running=0x'+LowerCase(IntToHex(RunningMaskValue,8))+
         ' wait='+IntToStr(Ord(aWaitUntilHalted)));
{$endif}

 if (TPasMPInterlocked.Read(fRunState) and (RUNSTATE_PAUSING or RUNSTATE_PAUSED))=0 then begin

  result:=(TPasMPInterlocked.ExchangeBitwiseOr(fRunState,TPasMPUInt32(RUNSTATE_PAUSING)) and RUNSTATE_PAUSING)=0;

  if result then begin

{$ifdef PasRISCVStepDebugOutput}
   WriteLn('DBG QueuePause pausing set');
{$endif}

   Interrupt;
   WakeUp;

   if aWaitUntilHalted then begin
    fHARTStatusChangeConditionVariableLock.Acquire;
    try

{$ifdef PasRISCVStepDebugOutput}
     RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
     WriteLn('DBG QueuePause wait start running=0x'+LowerCase(IntToHex(RunningMaskValue,8)));
{$endif}

     while TPasMPInterlocked.Read(fHARTRunningMask)<>0 do begin
      fHARTStatusChangeConditionVariable.Wait(fHARTStatusChangeConditionVariableLock);
     end;

{$ifdef PasRISCVStepDebugOutput}
     RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
     WriteLn('DBG QueuePause wait done running=0x'+LowerCase(IntToHex(RunningMaskValue,8)));     
{$endif}

    finally
     fHARTStatusChangeConditionVariableLock.Release;
    end;

   end;

  end;

 end else begin

  result:=false;

 end;

{$ifdef PasRISCVStepDebugOutput}
 RunStateValue:=TPasMPInterlocked.Read(fRunState);
 RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
 WriteLn('DBG QueuePause exit runstate=0x'+LowerCase(IntToHex(RunStateValue,8))+
         ' running=0x'+LowerCase(IntToHex(RunningMaskValue,8))+
         ' result='+IntToStr(Ord(result)));
{$endif}

end;

procedure TPasRISCV.Pause(const aWaitUntilHalted:Boolean);
{$ifdef PasRISCVStepDebugOutput}
var RunStateValue,RunningMaskValue:TPasRISCVUInt32;
{$endif}
begin

{$ifdef PasRISCVStepDebugOutput}
 RunStateValue:=TPasMPInterlocked.Read(fRunState);
 RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
 WriteLn('DBG Pause enter runstate=0x'+LowerCase(IntToHex(RunStateValue,8))+
         ' running=0x'+LowerCase(IntToHex(RunningMaskValue,8))+
         ' wait='+IntToStr(Ord(aWaitUntilHalted)));
{$endif}

 if (TPasMPInterlocked.ExchangeBitwiseOr(fRunState,TPasMPUInt32(RUNSTATE_PAUSED)) and RUNSTATE_PAUSED)=0 then begin

  Interrupt;
  WakeUp;

  if aWaitUntilHalted then begin
   
   fHARTStatusChangeConditionVariableLock.Acquire;
   try

{$ifdef PasRISCVStepDebugOutput}
    RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
    WriteLn('DBG Pause wait start running=0x'+LowerCase(IntToHex(RunningMaskValue,8)));
{$endif}

    while TPasMPInterlocked.Read(fHARTRunningMask)<>0 do begin
     fHARTStatusChangeConditionVariable.Wait(fHARTStatusChangeConditionVariableLock);
    end;

{$ifdef PasRISCVStepDebugOutput}
    RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
    WriteLn('DBG Pause wait done running=0x'+LowerCase(IntToHex(RunningMaskValue,8)));
{$endif}

   finally
    fHARTStatusChangeConditionVariableLock.Release;
   end;

  end;

 end;

{$ifdef PasRISCVStepDebugOutput}
 RunStateValue:=TPasMPInterlocked.Read(fRunState);
 RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
 WriteLn('DBG Pause exit runstate=0x'+LowerCase(IntToHex(RunStateValue,8))+
         ' running=0x'+LowerCase(IntToHex(RunningMaskValue,8)));
{$endif}

end;

procedure TPasRISCV.Resume(const aWaitUntilRunning:Boolean);
{$ifdef PasRISCVStepDebugOutput}
var RunStateValue,RunningMaskValue,AllMaskValue:TPasRISCVUInt32;
{$endif}
begin

{$ifdef PasRISCVStepDebugOutput}
 RunStateValue:=TPasMPInterlocked.Read(fRunState);
 RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
 AllMaskValue:=fAllHARTMask;
 WriteLn('DBG Resume enter runstate=0x'+LowerCase(IntToHex(RunStateValue,8))+
         ' running=0x'+LowerCase(IntToHex(RunningMaskValue,8))+
         ' all=0x'+LowerCase(IntToHex(AllMaskValue,8))+
         ' wait='+IntToStr(Ord(aWaitUntilRunning)));
{$endif}

 if (TPasMPInterlocked.ExchangeBitwiseAnd(fRunState,not TPasMPUInt32(RUNSTATE_PAUSED)) and RUNSTATE_PAUSED)<>0 then begin

  Interrupt;
  WakeUp;

  if aWaitUntilRunning {$if defined(PasRISCVSingleStepRunStateWait)}and ((TPasMPInterlocked.Read(fRunState) and RUNSTATE_SINGLESTEP)=0){$ifend} then begin

   fHARTStatusChangeConditionVariableLock.Acquire;
   try

{$ifdef PasRISCVStepDebugOutput}
    RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
    AllMaskValue:=fAllHARTMask;
    WriteLn('DBG Resume wait start running=0x'+LowerCase(IntToHex(RunningMaskValue,8))+
            ' all=0x'+LowerCase(IntToHex(AllMaskValue,8)));
{$endif}

    while (TPasMPInterlocked.Read(fHARTRunningMask) and fAllHARTMask)<>fAllHARTMask do begin
     fHARTStatusChangeConditionVariable.Wait(fHARTStatusChangeConditionVariableLock);
    end;

{$ifdef PasRISCVStepDebugOutput}
    RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
    WriteLn('DBG Resume wait done running=0x'+LowerCase(IntToHex(RunningMaskValue,8)));
{$endif}

   finally
    fHARTStatusChangeConditionVariableLock.Release;
   end;

  end;

 end;

{$ifdef PasRISCVStepDebugOutput}
 RunStateValue:=TPasMPInterlocked.Read(fRunState);
 RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
 WriteLn('DBG Resume exit runstate=0x'+LowerCase(IntToHex(RunStateValue,8))+
         ' running=0x'+LowerCase(IntToHex(RunningMaskValue,8)));
{$endif}

end;

procedure TPasRISCV.SingleStep(const aWaitUntilDone:Boolean);
{$ifdef PasRISCVSingleStepCounter}
var StepCounter:TPasRISCVUInt32;
{$endif}
{$ifdef PasRISCVStepDebugOutput}
var RunStateValue,RunningMaskValue:TPasRISCVUInt32;
{$endif}
begin

{$ifdef PasRISCVStepDebugOutput}
 RunStateValue:=TPasMPInterlocked.Read(fRunState);
 RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
 WriteLn('DBG SingleStep enter runstate=0x'+LowerCase(IntToHex(RunStateValue,8))+
         ' running=0x'+LowerCase(IntToHex(RunningMaskValue,8))+
         ' wait='+IntToStr(Ord(aWaitUntilDone)));
{$endif}

{$ifdef PasRISCVSingleStepCounter}
 StepCounter:=TPasMPInterlocked.Read(fSingleStepCounter);
{$endif}

 if (TPasMPInterlocked.ExchangeBitwiseOr(fRunState,TPasMPUInt32(RUNSTATE_SINGLESTEP)) and RUNSTATE_SINGLESTEP)=0 then begin

{$ifdef PasRISCVSingleStepCounter}

  Resume(false);

  if aWaitUntilDone then begin
   fHARTStatusChangeConditionVariableLock.Acquire;
   try
    while TPasMPInterlocked.Read(fSingleStepCounter)=StepCounter do begin
     fHARTStatusChangeConditionVariable.Wait(fHARTStatusChangeConditionVariableLock,100);
    end;
   finally
    fHARTStatusChangeConditionVariableLock.Release;
   end;
  end;

{$else}
  
  Resume(aWaitUntilDone);

  if aWaitUntilDone then begin

   fHARTStatusChangeConditionVariableLock.Acquire;
   try

{$if defined(PasRISCVSingleStepRunStateWait)}

{$ifdef PasRISCVStepDebugOutput}
    RunStateValue:=TPasMPInterlocked.Read(fRunState);
    WriteLn('DBG SingleStep wait start runstate=0x'+LowerCase(IntToHex(RunStateValue,8)));
{$endif}
    while (TPasMPInterlocked.Read(fRunState) and (RUNSTATE_SINGLESTEP or RUNSTATE_PAUSED))=RUNSTATE_SINGLESTEP do begin
     fHARTStatusChangeConditionVariable.Wait(fHARTStatusChangeConditionVariableLock,100);
    end;
{$ifdef PasRISCVStepDebugOutput}
    RunStateValue:=TPasMPInterlocked.Read(fRunState);
    WriteLn('DBG SingleStep wait done runstate=0x'+LowerCase(IntToHex(RunStateValue,8)));
{$endif}

{$else}

{$ifdef PasRISCVStepDebugOutput}
    RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
    WriteLn('DBG SingleStep wait start running=0x'+LowerCase(IntToHex(RunningMaskValue,8)));
{$endif}
    while TPasMPInterlocked.Read(fHARTRunningMask)<>0 do begin
     fHARTStatusChangeConditionVariable.Wait(fHARTStatusChangeConditionVariableLock);
    end;
{$ifdef PasRISCVStepDebugOutput}
    RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
    WriteLn('DBG SingleStep wait done running=0x'+LowerCase(IntToHex(RunningMaskValue,8)));
{$endif}

{$ifend}

   finally
    fHARTStatusChangeConditionVariableLock.Release;
   end;
  end;

{$endif}

 end;

{$ifdef PasRISCVStepDebugOutput}
 RunStateValue:=TPasMPInterlocked.Read(fRunState);
 RunningMaskValue:=TPasMPInterlocked.Read(fHARTRunningMask);
 WriteLn('DBG SingleStep exit runstate=0x'+LowerCase(IntToHex(RunStateValue,8))+
         ' running=0x'+LowerCase(IntToHex(RunningMaskValue,8)));
{$endif}

end;

procedure GenerateHalfFloatLookUpTables;
var i,e:TPasRISCVInt32;
    Mantissa,Exponent:TPasRISCVUInt32;
begin
 for i:=0 to 255 do begin
  e:=i-127;
  case e of
   -127..-25:begin
    // Very small numbers maps to zero
    FloatToHalfFloatBaseTable[i or $000]:=$0000;
    FloatToHalfFloatBaseTable[i or $100]:=$8000;
    FloatToHalfFloatShiftTable[i or $000]:=24;
    FloatToHalfFloatShiftTable[i or $100]:=24;
   end;
   -24..-15:begin
    // Small numbers maps to denormals
    FloatToHalfFloatBaseTable[i or $000]:=($0400 shr ((-e)-14)) or $0000;
    FloatToHalfFloatBaseTable[i or $100]:=($0400 shr ((-e)-14)) or $8000;
    FloatToHalfFloatShiftTable[i or $000]:=(-e)-1;
    FloatToHalfFloatShiftTable[i or $100]:=(-e)-1;
   end;
   -14..15:begin
    // Normal numbers just loses precision
    FloatToHalfFloatBaseTable[i or $000]:=((e+15) shl 10) or $0000;
    FloatToHalfFloatBaseTable[i or $100]:=((e+15) shl 10) or $8000;
    FloatToHalfFloatShiftTable[i or $000]:=13;
    FloatToHalfFloatShiftTable[i or $100]:=13;
   end;
   16..127:begin
    // Large numbers maps to infinity
    FloatToHalfFloatBaseTable[i or $000]:=$7c00;
    FloatToHalfFloatBaseTable[i or $100]:=$fc00;
    FloatToHalfFloatShiftTable[i or $000]:=24;
    FloatToHalfFloatShiftTable[i or $100]:=24;
   end;
   else begin
    // Infinity and NaN's stay infinity and NaN's
    FloatToHalfFloatBaseTable[i or $000]:=$7c00;
    FloatToHalfFloatBaseTable[i or $100]:=$fc00;
    FloatToHalfFloatShiftTable[i or $000]:=13;
    FloatToHalfFloatShiftTable[i or $100]:=13;
   end;
  end;
 end;
 begin
  begin
   HalfFloatToFloatMantissaTable[0]:=0;
   for i:=1 to 1023 do begin
    Mantissa:=i shl 13;
    Exponent:=0;
    while (Mantissa and $00800000)=0 do begin // While not normalized
     dec(Exponent,$00800000);                 // Decrement exponent by 1 shl 23
     Mantissa:=Mantissa shl 1;                // Shift mantissa
    end;
    Mantissa:=Mantissa and not $00800000;     // Clear leading 1 bit
    inc(Exponent,$38800000);                  // Adjust bias by (127-14) shl 23
    HalfFloatToFloatMantissaTable[i]:=Mantissa or Exponent;
   end;
   for i:=1024 to 2047 do begin
    HalfFloatToFloatMantissaTable[i]:=TPasRISCVUInt32($38000000)+TPasRISCVUInt32(TPasRISCVUInt32(i-1024) shl 13);
   end;
  end;
  begin
   HalfFloatToFloatExponentTable[0]:=0;
   for i:=1 to 30 do begin
    HalfFloatToFloatExponentTable[i]:=i shl 23;
   end;
   HalfFloatToFloatExponentTable[31]:=$47800000;
   HalfFloatToFloatExponentTable[32]:=0;
   for i:=33 to 62 do begin
    HalfFloatToFloatExponentTable[i]:=TPasRISCVUInt32(TPasRISCVUInt32(i-32) shl 23) or TPasRISCVUInt32($80000000);
   end;
   HalfFloatToFloatExponentTable[63]:=$c7800000;
  end;
  begin
   HalfFloatToFloatOffsetTable[0]:=0;
   for i:=1 to 31 do begin
    HalfFloatToFloatOffsetTable[i]:=1024;
   end;
   HalfFloatToFloatOffsetTable[32]:=0;
   for i:=33 to 63 do begin
    HalfFloatToFloatOffsetTable[i]:=1024;
   end;
  end;
 end;
end;

var CPUChecked:TPasMPBool32=false;

{$if defined(cpu386) or defined(cpuamd64) or defined(cpux86_64) or defined(cpux64)}
type TCPUIDData=record
      case TPasRISCVUInt32 of
       0:(
        Data:array[0..3] of TPasRISCVUInt32;
       );
       1:(
        EAX,EBX,EDX,ECX:TPasRISCVUInt32;
       );
       2:(
        String_:array[0..15] of AnsiChar;
       );
      end;

      PCPUIDData=^TCPUIDData;

procedure GetCPUID(Value:TPasRISCVUInt32;out Data:TCPUIDData); assembler;
asm
{$if defined(cpuamd64) or defined(cpux86_64) or defined(cpux64)}
 push rbx
{$if defined(Windows) or defined(Win32) or defined(Win64)}
 // Win64 ABI (rcx, rdx, ...)
 mov eax,ecx
 mov r8,rdx
{$else}
 // SysV x64 ABI (rdi, rsi, ...)
 mov eax,edi
 mov r8,rsi
{$ifend}
{$else}
 // register (eax, edx, ...)
 push ebx
 push edi
 mov edi,edx
{$ifend}
 cpuid
{$if defined(cpuamd64) or defined(cpux86_64) or defined(cpux64)}
 mov dword ptr [r8+0],eax
 mov dword ptr [r8+4],ebx
 mov dword ptr [r8+8],edx
 mov dword ptr [r8+12],ecx
 pop rbx
{$else}
 mov dword ptr [edi+0],eax
 mov dword ptr [edi+4],ebx
 mov dword ptr [edi+8],edx
 mov dword ptr [edi+12],ecx
 pop edi
 pop ebx
{$ifend}
end;
{$ifend}

procedure DoCheckCPU;
{$if defined(cpu386) or defined(cpuamd64) or defined(cpux86_64) or defined(cpux64)}
var CPUIDData:TCPUIDData;
begin
 CPUFeatures:=0;
 begin
  GetCPUID(0,CPUIDData);
 end;
 begin
  GetCPUID(1,CPUIDData);
  if (CPUIDData.ECX and (TPasRISCVUInt32(1) shl 1))<>0 then begin
   CPUFeatures:=CPUFeatures or CPUFeatures_X86_PCLMUL_Mask;
  end;
  if (CPUIDData.ECX and (TPasRISCVUInt32(1) shl 20))<>0 then begin
   CPUFeatures:=CPUFeatures or CPUFeatures_X86_SSE42_Mask;
  end;
  if (CPUIDData.ECX and (TPasRISCVUInt32(1) shl 29))<>0 then begin
   CPUFeatures:=CPUFeatures or CPUFeatures_X86_F16C_Mask;
  end;
 end;
end;
{$else}
begin
end;
{$ifend}

procedure CheckCPU;
begin
 if (not CPUChecked) and
    (not TPasMPInterlocked.CompareExchange(CPUChecked,TPasMPBool32(true),TPasMPBool32(false))) then begin
  DoCheckCPU;
 end;
end;

initialization
{$ifdef windows}
 KERNEL32LibHandle:=LoadLibrary('kernel32.dll');
 if KERNEL32LibHandle<>HMODULE(0) then begin
  @CreateWaitableTimerExW:=GetProcAddress(KERNEL32LibHandle,'CreateWaitableTimerExW');
 end;
 NTDLLLibHandle:=LoadLibrary('ntdll.dll');
 if NTDLLLibHandle<>HMODULE(0) then begin
  @NtDelayExecution:=GetProcAddress(NTDLLLibHandle,'NtDelayExecution');
  @NtQueryTimerResolution:=GetProcAddress(NTDLLLibHandle,'NtQueryTimerResolution');
  @NtSetTimerResolution:=GetProcAddress(NTDLLLibHandle,'NtSetTimerResolution');
 end;
 timeBeginPeriod(1);
 if assigned(NtDelayExecution) and
    assigned(NtQueryTimerResolution) and
    assigned(NtSetTimerResolution) then begin
  if NtQueryTimerResolution(MinimumResolution,MaximumResolution,CurrentResolution)=0 then begin
   GlobalSleepGranularity:=CurrentResolution;
   if NtSetTimerResolution(MaximumResolution,true,CurrentResolution)=0 then begin
    GlobalSleepGranularity:=MaximumResolution;
   end;
  end else begin
   GlobalSleepGranularity:=10000; // 1ms in 100-ns units
  end;
 end else begin
  GlobalSleepGranularity:=10000; // 1ms in 100-ns units
 end;
{$else}
 GlobalSleepGranularity:=5000; // 0.5ms in 100-ns units
{$endif}
 GlobalSleepGranularity:=ConvertScale(GlobalSleepGranularity,10000000,CLOCK_FREQUENCY);
 GlobalSleepThreshold:=GlobalSleepGranularity*4;
 FillChar(ZeroBuffer,SizeOf(TZeroBuffer),#0);
 CheckCPU;
 GenerateHalfFloatLookUpTables;
end.
